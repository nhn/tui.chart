/*!
 * TOAST UI Chart 4th Edition
 * @version 4.3.4 | Tue May 25 2021
 * @author NHN. FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["toastui"] = factory();
	else
		root["toastui"] = root["toastui"] || {}, root["toastui"]["Chart"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3819:
/***/ (function(module) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ 8505:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(5052);

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ 9736:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(95);
var create = __webpack_require__(2391);
var definePropertyModule = __webpack_require__(1787);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 6637:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(966).charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ 7728:
/***/ (function(module) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ 1176:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(5052);

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ 3339:
/***/ (function(module) {

// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';


/***/ }),

/***/ 9918:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(3339);
var DESCRIPTORS = __webpack_require__(7400);
var global = __webpack_require__(9859);
var isObject = __webpack_require__(5052);
var has = __webpack_require__(816);
var classof = __webpack_require__(1589);
var createNonEnumerableProperty = __webpack_require__(5762);
var redefine = __webpack_require__(7487);
var defineProperty = __webpack_require__(1787).f;
var getPrototypeOf = __webpack_require__(7567);
var setPrototypeOf = __webpack_require__(6540);
var wellKnownSymbol = __webpack_require__(95);
var uid = __webpack_require__(1441);

var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || has(TypedArrayConstructorsList, klass)
    || has(BigIntArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return has(TypedArrayConstructorsList, klass)
    || has(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) { /* empty */ }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ 3816:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(9859);
var DESCRIPTORS = __webpack_require__(7400);
var NATIVE_ARRAY_BUFFER = __webpack_require__(3339);
var createNonEnumerableProperty = __webpack_require__(5762);
var redefineAll = __webpack_require__(8787);
var fails = __webpack_require__(4229);
var anInstance = __webpack_require__(7728);
var toInteger = __webpack_require__(6051);
var toLength = __webpack_require__(4237);
var toIndex = __webpack_require__(7331);
var IEEE754 = __webpack_require__(6201);
var getPrototypeOf = __webpack_require__(7567);
var setPrototypeOf = __webpack_require__(6540);
var getOwnPropertyNames = __webpack_require__(8151).f;
var defineProperty = __webpack_require__(1787).f;
var arrayFill = __webpack_require__(7065);
var setToStringTag = __webpack_require__(4555);
var InternalStateModule = __webpack_require__(6407);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError = global.RangeError;

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  /* eslint-disable no-new -- required for testing */
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1);
  }) || fails(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
  /* eslint-enable no-new -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf($DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};


/***/ }),

/***/ 7154:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(2991);
var toAbsoluteIndex = __webpack_require__(3231);
var toLength = __webpack_require__(4237);

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ 7065:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(2991);
var toAbsoluteIndex = __webpack_require__(3231);
var toLength = __webpack_require__(4237);

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ 6570:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__(9996).forEach;
var arrayMethodIsStrict = __webpack_require__(6038);

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ 507:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__(7636);
var toObject = __webpack_require__(2991);
var callWithSafeIterationClosing = __webpack_require__(4960);
var isArrayIteratorMethod = __webpack_require__(1943);
var toLength = __webpack_require__(4237);
var createProperty = __webpack_require__(2324);
var getIteratorMethod = __webpack_require__(8830);

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ 9540:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(905);
var toLength = __webpack_require__(4237);
var toAbsoluteIndex = __webpack_require__(3231);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 9996:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var bind = __webpack_require__(7636);
var IndexedObject = __webpack_require__(9337);
var toObject = __webpack_require__(2991);
var toLength = __webpack_require__(4237);
var arraySpeciesCreate = __webpack_require__(7501);

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_OUT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push.call(target, value); // filterOut
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterOut` method
  // https://github.com/tc39/proposal-array-filtering
  filterOut: createMethod(7)
};


/***/ }),

/***/ 6462:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/* eslint-disable es/no-array-prototype-lastindexof -- safe */
var toIndexedObject = __webpack_require__(905);
var toInteger = __webpack_require__(6051);
var toLength = __webpack_require__(4237);
var arrayMethodIsStrict = __webpack_require__(6038);

var min = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return $lastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf;


/***/ }),

/***/ 1460:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(4229);
var wellKnownSymbol = __webpack_require__(95);
var V8_VERSION = __webpack_require__(6358);

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ 6038:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(4229);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ 3143:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aFunction = __webpack_require__(3819);
var toObject = __webpack_require__(2991);
var IndexedObject = __webpack_require__(9337);
var toLength = __webpack_require__(4237);

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ 7501:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(5052);
var isArray = __webpack_require__(3718);
var wellKnownSymbol = __webpack_require__(95);

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ 4960:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(1176);
var iteratorClose = __webpack_require__(7281);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    iteratorClose(iterator);
    throw error;
  }
};


/***/ }),

/***/ 4575:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(95);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ 7079:
/***/ (function(module) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 1589:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(1601);
var classofRaw = __webpack_require__(7079);
var wellKnownSymbol = __webpack_require__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ 8081:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var defineProperty = __webpack_require__(1787).f;
var create = __webpack_require__(2391);
var redefineAll = __webpack_require__(8787);
var bind = __webpack_require__(7636);
var anInstance = __webpack_require__(7728);
var iterate = __webpack_require__(9003);
var defineIterator = __webpack_require__(7675);
var setSpecies = __webpack_require__(1832);
var DESCRIPTORS = __webpack_require__(7400);
var fastKey = __webpack_require__(5926).fastKey;
var InternalStateModule = __webpack_require__(6407);

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ 9789:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var global = __webpack_require__(9859);
var isForced = __webpack_require__(6541);
var redefine = __webpack_require__(7487);
var InternalMetadataModule = __webpack_require__(5926);
var iterate = __webpack_require__(9003);
var anInstance = __webpack_require__(7728);
var isObject = __webpack_require__(5052);
var fails = __webpack_require__(4229);
var checkCorrectnessOfIteration = __webpack_require__(4575);
var setToStringTag = __webpack_require__(4555);
var inheritIfRequired = __webpack_require__(835);

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ 7081:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(816);
var ownKeys = __webpack_require__(4826);
var getOwnPropertyDescriptorModule = __webpack_require__(7933);
var definePropertyModule = __webpack_require__(1787);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ 8127:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(95);

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ 7528:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(4229);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 1720:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(8885);

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.es/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};


/***/ }),

/***/ 3723:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__(693).IteratorPrototype;
var create = __webpack_require__(2391);
var createPropertyDescriptor = __webpack_require__(5358);
var setToStringTag = __webpack_require__(4555);
var Iterators = __webpack_require__(5495);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 5762:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(7400);
var definePropertyModule = __webpack_require__(1787);
var createPropertyDescriptor = __webpack_require__(5358);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 5358:
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2324:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__(2066);
var definePropertyModule = __webpack_require__(1787);
var createPropertyDescriptor = __webpack_require__(5358);

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ 7675:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var createIteratorConstructor = __webpack_require__(3723);
var getPrototypeOf = __webpack_require__(7567);
var setPrototypeOf = __webpack_require__(6540);
var setToStringTag = __webpack_require__(4555);
var createNonEnumerableProperty = __webpack_require__(5762);
var redefine = __webpack_require__(7487);
var wellKnownSymbol = __webpack_require__(95);
var IS_PURE = __webpack_require__(4231);
var Iterators = __webpack_require__(5495);
var IteratorsCore = __webpack_require__(693);

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ 8423:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var path = __webpack_require__(9276);
var has = __webpack_require__(816);
var wrappedWellKnownSymbolModule = __webpack_require__(5391);
var defineProperty = __webpack_require__(1787).f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ 7400:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(4229);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 2635:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var isObject = __webpack_require__(5052);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 5694:
/***/ (function(module) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 8801:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(7079);
var global = __webpack_require__(9859);

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ 598:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(1333);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 6358:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var userAgent = __webpack_require__(598);

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ 3837:
/***/ (function(module) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 3103:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var getOwnPropertyDescriptor = __webpack_require__(7933).f;
var createNonEnumerableProperty = __webpack_require__(5762);
var redefine = __webpack_require__(7487);
var setGlobal = __webpack_require__(2079);
var copyConstructorProperties = __webpack_require__(7081);
var isForced = __webpack_require__(6541);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 4229:
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 4954:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__(7950);
var redefine = __webpack_require__(7487);
var fails = __webpack_require__(4229);
var wellKnownSymbol = __webpack_require__(95);
var createNonEnumerableProperty = __webpack_require__(5762);

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === RegExp.prototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ 4990:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__(3718);
var toLength = __webpack_require__(4237);
var bind = __webpack_require__(7636);

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ 8476:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(4229);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ 7636:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aFunction = __webpack_require__(3819);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 4128:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(3819);
var isObject = __webpack_require__(5052);

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};


/***/ }),

/***/ 1333:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var path = __webpack_require__(9276);
var global = __webpack_require__(9859);

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 8830:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(1589);
var Iterators = __webpack_require__(5495);
var wellKnownSymbol = __webpack_require__(95);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ 17:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toObject = __webpack_require__(2991);

var floor = Math.floor;
var replace = ''.replace;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace.call(replacement, symbols, function (match, ch) {
    var capture;
    switch (ch.charAt(0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return str.slice(0, position);
      case "'": return str.slice(tailPos);
      case '<':
        capture = namedCaptures[ch.slice(1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ 9859:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 816:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toObject = __webpack_require__(2991);

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function hasOwn(it, key) {
  return hasOwnProperty.call(toObject(it), key);
};


/***/ }),

/***/ 5977:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 3777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(1333);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 4394:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(7400);
var fails = __webpack_require__(4229);
var createElement = __webpack_require__(2635);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 6201:
/***/ (function(module) {

// IEEE754 conversions based on https://github.com/feross/ieee754
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};


/***/ }),

/***/ 9337:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(4229);
var classof = __webpack_require__(7079);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 835:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(5052);
var setPrototypeOf = __webpack_require__(6540);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ 8511:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var store = __webpack_require__(5353);

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 5926:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hiddenKeys = __webpack_require__(5977);
var isObject = __webpack_require__(5052);
var has = __webpack_require__(816);
var defineProperty = __webpack_require__(1787).f;
var uid = __webpack_require__(1441);
var FREEZING = __webpack_require__(8476);

var METADATA = uid('meta');
var id = 0;

// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ 6407:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(8694);
var global = __webpack_require__(9859);
var isObject = __webpack_require__(5052);
var createNonEnumerableProperty = __webpack_require__(5762);
var objectHas = __webpack_require__(816);
var shared = __webpack_require__(5353);
var sharedKey = __webpack_require__(4399);
var hiddenKeys = __webpack_require__(5977);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 1943:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(95);
var Iterators = __webpack_require__(5495);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 3718:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(7079);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ 6541:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(4229);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 5052:
/***/ (function(module) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ 4231:
/***/ (function(module) {

module.exports = false;


/***/ }),

/***/ 8311:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(5052);
var classof = __webpack_require__(7079);
var wellKnownSymbol = __webpack_require__(95);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ 9003:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(1176);
var isArrayIteratorMethod = __webpack_require__(1943);
var toLength = __webpack_require__(4237);
var bind = __webpack_require__(7636);
var getIteratorMethod = __webpack_require__(8830);
var iteratorClose = __webpack_require__(7281);

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};


/***/ }),

/***/ 7281:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(1176);

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};


/***/ }),

/***/ 693:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(4229);
var getPrototypeOf = __webpack_require__(7567);
var createNonEnumerableProperty = __webpack_require__(5762);
var has = __webpack_require__(816);
var wellKnownSymbol = __webpack_require__(95);
var IS_PURE = __webpack_require__(4231);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 5495:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 3839:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_NODE = __webpack_require__(8801);
var V8_VERSION = __webpack_require__(6358);
var fails = __webpack_require__(4229);

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // eslint-disable-next-line es/no-symbol -- required for testing
  return !Symbol.sham &&
    // Chrome 38 Symbol has incorrect toString conversion
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
});


/***/ }),

/***/ 8694:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var inspectSource = __webpack_require__(8511);

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 7272:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isRegExp = __webpack_require__(8311);

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ 2391:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(1176);
var defineProperties = __webpack_require__(219);
var enumBugKeys = __webpack_require__(3837);
var hiddenKeys = __webpack_require__(5977);
var html = __webpack_require__(3777);
var documentCreateElement = __webpack_require__(2635);
var sharedKey = __webpack_require__(4399);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject -- old IE */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ 219:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(7400);
var definePropertyModule = __webpack_require__(1787);
var anObject = __webpack_require__(1176);
var objectKeys = __webpack_require__(5632);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ 1787:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(7400);
var IE8_DOM_DEFINE = __webpack_require__(4394);
var anObject = __webpack_require__(1176);
var toPrimitive = __webpack_require__(2066);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7933:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(7400);
var propertyIsEnumerableModule = __webpack_require__(9195);
var createPropertyDescriptor = __webpack_require__(5358);
var toIndexedObject = __webpack_require__(905);
var toPrimitive = __webpack_require__(2066);
var has = __webpack_require__(816);
var IE8_DOM_DEFINE = __webpack_require__(4394);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ 166:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es/no-object-getownpropertynames -- safe */
var toIndexedObject = __webpack_require__(905);
var $getOwnPropertyNames = __webpack_require__(8151).f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ 8151:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(140);
var enumBugKeys = __webpack_require__(3837);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 894:
/***/ (function(__unused_webpack_module, exports) {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 7567:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(816);
var toObject = __webpack_require__(2991);
var sharedKey = __webpack_require__(4399);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(7528);

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(816);
var toIndexedObject = __webpack_require__(905);
var indexOf = __webpack_require__(9540).indexOf;
var hiddenKeys = __webpack_require__(5977);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 5632:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(140);
var enumBugKeys = __webpack_require__(3837);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 9195:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 6540:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var anObject = __webpack_require__(1176);
var aPossiblePrototype = __webpack_require__(8505);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 7664:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(7400);
var objectKeys = __webpack_require__(5632);
var toIndexedObject = __webpack_require__(905);
var propertyIsEnumerable = __webpack_require__(9195).f;

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ 4059:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(1601);
var classof = __webpack_require__(1589);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 4826:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(1333);
var getOwnPropertyNamesModule = __webpack_require__(8151);
var getOwnPropertySymbolsModule = __webpack_require__(894);
var anObject = __webpack_require__(1176);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 9276:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);

module.exports = global;


/***/ }),

/***/ 8787:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var redefine = __webpack_require__(7487);

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 7487:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var createNonEnumerableProperty = __webpack_require__(5762);
var has = __webpack_require__(816);
var setGlobal = __webpack_require__(2079);
var inspectSource = __webpack_require__(8511);
var InternalStateModule = __webpack_require__(6407);

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ 8115:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(7079);
var regexpExec = __webpack_require__(3466);

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ 3466:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var regexpFlags = __webpack_require__(895);
var stickyHelpers = __webpack_require__(5650);
var shared = __webpack_require__(3036);

var nativeExec = RegExp.prototype.exec;
var nativeReplace = shared('native-string-replace', String.prototype.replace);

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
// eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ 895:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(1176);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 5650:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(4229);

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),

/***/ 8885:
/***/ (function(module) {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 2079:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var createNonEnumerableProperty = __webpack_require__(5762);

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 1832:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(1333);
var definePropertyModule = __webpack_require__(1787);
var wellKnownSymbol = __webpack_require__(95);
var DESCRIPTORS = __webpack_require__(7400);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ 4555:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defineProperty = __webpack_require__(1787).f;
var has = __webpack_require__(816);
var wellKnownSymbol = __webpack_require__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ 4399:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(3036);
var uid = __webpack_require__(1441);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5353:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var setGlobal = __webpack_require__(2079);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 3036:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_PURE = __webpack_require__(4231);
var store = __webpack_require__(5353);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.11.3',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 7942:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(1176);
var aFunction = __webpack_require__(3819);
var wellKnownSymbol = __webpack_require__(95);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ 3689:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(4229);

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};


/***/ }),

/***/ 966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(6051);
var requireObjectCoercible = __webpack_require__(8885);

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 3124:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(6051);
var requireObjectCoercible = __webpack_require__(8885);

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ 1017:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(8885);
var whitespaces = __webpack_require__(1647);

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ 143:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(7079);

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};


/***/ }),

/***/ 3231:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(6051);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 7331:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(6051);
var toLength = __webpack_require__(4237);

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ 905:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(9337);
var requireObjectCoercible = __webpack_require__(8885);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 6051:
/***/ (function(module) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ 4237:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(6051);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 2991:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(8885);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 4262:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toPositiveInteger = __webpack_require__(2002);

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ 2002:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(6051);

module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ 2066:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(5052);

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 1601:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 2574:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var global = __webpack_require__(9859);
var DESCRIPTORS = __webpack_require__(7400);
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(8200);
var ArrayBufferViewCore = __webpack_require__(9918);
var ArrayBufferModule = __webpack_require__(3816);
var anInstance = __webpack_require__(7728);
var createPropertyDescriptor = __webpack_require__(5358);
var createNonEnumerableProperty = __webpack_require__(5762);
var toLength = __webpack_require__(4237);
var toIndex = __webpack_require__(7331);
var toOffset = __webpack_require__(4262);
var toPrimitive = __webpack_require__(2066);
var has = __webpack_require__(816);
var classof = __webpack_require__(1589);
var isObject = __webpack_require__(5052);
var create = __webpack_require__(2391);
var setPrototypeOf = __webpack_require__(6540);
var getOwnPropertyNames = __webpack_require__(8151).f;
var typedArrayFrom = __webpack_require__(5215);
var forEach = __webpack_require__(9996).forEach;
var setSpecies = __webpack_require__(1832);
var definePropertyModule = __webpack_require__(1787);
var getOwnPropertyDescriptorModule = __webpack_require__(7933);
var InternalStateModule = __webpack_require__(6407);
var inheritIfRequired = __webpack_require__(835);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && typeof key != 'symbol'
    && key in target
    && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true))
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
    && isObject(descriptor)
    && has(descriptor, 'value')
    && !has(descriptor, 'get')
    && !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!has(descriptor, 'writable') || descriptor.writable)
    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ 8200:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-new -- required for testing */
var global = __webpack_require__(9859);
var fails = __webpack_require__(4229);
var checkCorrectnessOfIteration = __webpack_require__(4575);
var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(9918).NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ 8874:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aTypedArrayConstructor = __webpack_require__(9918).aTypedArrayConstructor;
var speciesConstructor = __webpack_require__(7942);

module.exports = function (instance, list) {
  var C = speciesConstructor(instance, instance.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};


/***/ }),

/***/ 5215:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toObject = __webpack_require__(2991);
var toLength = __webpack_require__(4237);
var getIteratorMethod = __webpack_require__(8830);
var isArrayIteratorMethod = __webpack_require__(1943);
var bind = __webpack_require__(7636);
var aTypedArrayConstructor = __webpack_require__(9918).aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),

/***/ 1441:
/***/ (function(module) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(3839);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 5391:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(95);

exports.f = wellKnownSymbol;


/***/ }),

/***/ 95:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var shared = __webpack_require__(3036);
var has = __webpack_require__(816);
var uid = __webpack_require__(1441);
var NATIVE_SYMBOL = __webpack_require__(3839);
var USE_SYMBOL_AS_UID = __webpack_require__(6969);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 1647:
/***/ (function(module) {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ 2994:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var fails = __webpack_require__(4229);
var ArrayBufferModule = __webpack_require__(3816);
var anObject = __webpack_require__(1176);
var toAbsoluteIndex = __webpack_require__(3231);
var toLength = __webpack_require__(4237);
var speciesConstructor = __webpack_require__(7942);

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});


/***/ }),

/***/ 8178:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var fails = __webpack_require__(4229);
var isArray = __webpack_require__(3718);
var isObject = __webpack_require__(5052);
var toObject = __webpack_require__(2991);
var toLength = __webpack_require__(4237);
var createProperty = __webpack_require__(2324);
var arraySpeciesCreate = __webpack_require__(7501);
var arrayMethodHasSpeciesSupport = __webpack_require__(1460);
var wellKnownSymbol = __webpack_require__(95);
var V8_VERSION = __webpack_require__(6358);

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ 2656:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var fill = __webpack_require__(7065);
var addToUnscopables = __webpack_require__(9736);

// `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ 5342:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var $filter = __webpack_require__(9996).filter;
var arrayMethodHasSpeciesSupport = __webpack_require__(1460);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 9949:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var $findIndex = __webpack_require__(9996).findIndex;
var addToUnscopables = __webpack_require__(9736);

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),

/***/ 9228:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var $find = __webpack_require__(9996).find;
var addToUnscopables = __webpack_require__(9736);

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ 4870:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var flattenIntoArray = __webpack_require__(4990);
var toObject = __webpack_require__(2991);
var toLength = __webpack_require__(4237);
var aFunction = __webpack_require__(3819);
var arraySpeciesCreate = __webpack_require__(7501);

// `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});


/***/ }),

/***/ 7233:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var from = __webpack_require__(507);
var checkCorrectnessOfIteration = __webpack_require__(4575);

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ 9529:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var $includes = __webpack_require__(9540).includes;
var addToUnscopables = __webpack_require__(9736);

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ 5735:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(905);
var addToUnscopables = __webpack_require__(9736);
var Iterators = __webpack_require__(5495);
var InternalStateModule = __webpack_require__(6407);
var defineIterator = __webpack_require__(7675);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ 6781:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var IndexedObject = __webpack_require__(9337);
var toIndexedObject = __webpack_require__(905);
var arrayMethodIsStrict = __webpack_require__(6038);

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ 3450:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var $map = __webpack_require__(9996).map;
var arrayMethodHasSpeciesSupport = __webpack_require__(1460);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 2501:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var isObject = __webpack_require__(5052);
var isArray = __webpack_require__(3718);
var toAbsoluteIndex = __webpack_require__(3231);
var toLength = __webpack_require__(4237);
var toIndexedObject = __webpack_require__(905);
var createProperty = __webpack_require__(2324);
var wellKnownSymbol = __webpack_require__(95);
var arrayMethodHasSpeciesSupport = __webpack_require__(1460);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ 9805:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var toAbsoluteIndex = __webpack_require__(3231);
var toInteger = __webpack_require__(6051);
var toLength = __webpack_require__(4237);
var toObject = __webpack_require__(2991);
var arraySpeciesCreate = __webpack_require__(7501);
var createProperty = __webpack_require__(2324);
var arrayMethodHasSpeciesSupport = __webpack_require__(1460);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ 3985:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(9736);

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flatMap');


/***/ }),

/***/ 6936:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(7400);
var defineProperty = __webpack_require__(1787).f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ 1245:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(7400);
var global = __webpack_require__(9859);
var isForced = __webpack_require__(6541);
var redefine = __webpack_require__(7487);
var has = __webpack_require__(816);
var classof = __webpack_require__(7079);
var inheritIfRequired = __webpack_require__(835);
var toPrimitive = __webpack_require__(2066);
var fails = __webpack_require__(4229);
var create = __webpack_require__(2391);
var getOwnPropertyNames = __webpack_require__(8151).f;
var getOwnPropertyDescriptor = __webpack_require__(7933).f;
var defineProperty = __webpack_require__(1787).f;
var trim = __webpack_require__(1017).trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ 8143:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);

// `Number.MAX_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.max_safe_integer
$({ target: 'Number', stat: true }, {
  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
});


/***/ }),

/***/ 2023:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);

// `Number.MIN_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.min_safe_integer
$({ target: 'Number', stat: true }, {
  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
});


/***/ }),

/***/ 1321:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var toInteger = __webpack_require__(6051);
var thisNumberValue = __webpack_require__(143);
var repeat = __webpack_require__(3124);
var fails = __webpack_require__(4229);

var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var multiply = function (data, n, c) {
  var index = -1;
  var c2 = c;
  while (++index < 6) {
    c2 += n * data[index];
    data[index] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (data, n) {
  var index = 6;
  var c = 0;
  while (--index >= 0) {
    c += data[index];
    data[index] = floor(c / n);
    c = (c % n) * 1e7;
  }
};

var dataToString = function (data) {
  var index = 6;
  var s = '';
  while (--index >= 0) {
    if (s !== '' || index === 0 || data[index] !== 0) {
      var t = String(data[index]);
      s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
    }
  } return s;
};

var FORCED = nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(data, 0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(data, 1e7, 0);
          j -= 7;
        }
        multiply(data, pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(data, 1 << 23);
          j -= 23;
        }
        divide(data, 1 << j);
        multiply(data, 1, 1);
        divide(data, 2);
        result = dataToString(data);
      } else {
        multiply(data, 0, z);
        multiply(data, 1 << -e, 0);
        result = dataToString(data) + repeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat.call('0', fractDigits - k) + result
        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),

/***/ 2144:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var FREEZING = __webpack_require__(8476);
var fails = __webpack_require__(4229);
var isObject = __webpack_require__(5052);
var onFreeze = __webpack_require__(5926).onFreeze;

// eslint-disable-next-line es/no-object-freeze -- safe
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { $freeze(1); });

// `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ 8625:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var fails = __webpack_require__(4229);
var toIndexedObject = __webpack_require__(905);
var nativeGetOwnPropertyDescriptor = __webpack_require__(7933).f;
var DESCRIPTORS = __webpack_require__(7400);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ 2775:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var DESCRIPTORS = __webpack_require__(7400);
var ownKeys = __webpack_require__(4826);
var toIndexedObject = __webpack_require__(905);
var getOwnPropertyDescriptorModule = __webpack_require__(7933);
var createProperty = __webpack_require__(2324);

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ 6928:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var fails = __webpack_require__(4229);
var toObject = __webpack_require__(2991);
var nativeGetPrototypeOf = __webpack_require__(7567);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(7528);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ 4769:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var toObject = __webpack_require__(2991);
var nativeKeys = __webpack_require__(5632);
var fails = __webpack_require__(4229);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ 2506:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var setPrototypeOf = __webpack_require__(6540);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ 8188:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(1601);
var redefine = __webpack_require__(7487);
var toString = __webpack_require__(4059);

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ 7890:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var $values = __webpack_require__(7664).values;

// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
$({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});


/***/ }),

/***/ 1229:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var getBuiltIn = __webpack_require__(1333);
var aFunction = __webpack_require__(3819);
var anObject = __webpack_require__(1176);
var isObject = __webpack_require__(5052);
var create = __webpack_require__(2391);
var bind = __webpack_require__(4128);
var fails = __webpack_require__(4229);

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ 4565:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(3103);
var isObject = __webpack_require__(5052);
var anObject = __webpack_require__(1176);
var has = __webpack_require__(816);
var getOwnPropertyDescriptorModule = __webpack_require__(7933);
var getPrototypeOf = __webpack_require__(7567);

// `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value')
    ? descriptor.value
    : descriptor.get === undefined
      ? undefined
      : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});


/***/ }),

/***/ 7368:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(7400);
var global = __webpack_require__(9859);
var isForced = __webpack_require__(6541);
var inheritIfRequired = __webpack_require__(835);
var defineProperty = __webpack_require__(1787).f;
var getOwnPropertyNames = __webpack_require__(8151).f;
var isRegExp = __webpack_require__(8311);
var getFlags = __webpack_require__(895);
var stickyHelpers = __webpack_require__(5650);
var redefine = __webpack_require__(7487);
var fails = __webpack_require__(4229);
var enforceInternalState = __webpack_require__(6407).enforce;
var setSpecies = __webpack_require__(1832);
var wellKnownSymbol = __webpack_require__(95);

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

var FORCED = DESCRIPTORS && isForced('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;

    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }

    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = getFlags.call(pattern);
      pattern = pattern.source;
    }

    if (UNSUPPORTED_Y) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    var result = inheritIfRequired(
      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
      thisIsRegExp ? this : RegExpPrototype,
      RegExpWrapper
    );

    if (UNSUPPORTED_Y && sticky) {
      var state = enforceInternalState(result);
      state.sticky = true;
    }

    return result;
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var index = 0;
  while (keys.length > index) proxy(keys[index++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.es/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ 7950:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var exec = __webpack_require__(3466);

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ 8233:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var redefine = __webpack_require__(7487);
var anObject = __webpack_require__(1176);
var fails = __webpack_require__(4229);
var flags = __webpack_require__(895);

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),

/***/ 3244:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__(9789);
var collectionStrong = __webpack_require__(8081);

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
module.exports = collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ 1549:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var createHTML = __webpack_require__(1720);
var forcedStringHTMLMethod = __webpack_require__(3689);

// `String.prototype.anchor` method
// https://tc39.es/ecma262/#sec-string.prototype.anchor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('anchor') }, {
  anchor: function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  }
});


/***/ }),

/***/ 1235:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var notARegExp = __webpack_require__(7272);
var requireObjectCoercible = __webpack_require__(8885);
var correctIsRegExpLogic = __webpack_require__(8127);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 8673:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(966).charAt;
var InternalStateModule = __webpack_require__(6407);
var defineIterator = __webpack_require__(7675);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ 4069:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(4954);
var anObject = __webpack_require__(1176);
var toLength = __webpack_require__(4237);
var requireObjectCoercible = __webpack_require__(8885);
var advanceStringIndex = __webpack_require__(6637);
var regExpExec = __webpack_require__(8115);

// @@match logic
fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ 5940:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(4954);
var anObject = __webpack_require__(1176);
var toLength = __webpack_require__(4237);
var toInteger = __webpack_require__(6051);
var requireObjectCoercible = __webpack_require__(8885);
var advanceStringIndex = __webpack_require__(6637);
var getSubstitution = __webpack_require__(17);
var regExpExec = __webpack_require__(8115);

var max = Math.max;
var min = Math.min;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (
        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
      ) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];
});


/***/ }),

/***/ 8319:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(4954);
var isRegExp = __webpack_require__(8311);
var anObject = __webpack_require__(1176);
var requireObjectCoercible = __webpack_require__(8885);
var speciesConstructor = __webpack_require__(7942);
var advanceStringIndex = __webpack_require__(6637);
var toLength = __webpack_require__(4237);
var callRegExpExec = __webpack_require__(8115);
var regexpExec = __webpack_require__(3466);
var stickyHelpers = __webpack_require__(5650);

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (UNSUPPORTED_Y ? 'g' : 'y');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? S.slice(q) : S);
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, UNSUPPORTED_Y);


/***/ }),

/***/ 634:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(3103);
var DESCRIPTORS = __webpack_require__(7400);
var global = __webpack_require__(9859);
var has = __webpack_require__(816);
var isObject = __webpack_require__(5052);
var defineProperty = __webpack_require__(1787).f;
var copyConstructorProperties = __webpack_require__(7081);

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ 796:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(8423);

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ 4115:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(3103);
var global = __webpack_require__(9859);
var getBuiltIn = __webpack_require__(1333);
var IS_PURE = __webpack_require__(4231);
var DESCRIPTORS = __webpack_require__(7400);
var NATIVE_SYMBOL = __webpack_require__(3839);
var USE_SYMBOL_AS_UID = __webpack_require__(6969);
var fails = __webpack_require__(4229);
var has = __webpack_require__(816);
var isArray = __webpack_require__(3718);
var isObject = __webpack_require__(5052);
var anObject = __webpack_require__(1176);
var toObject = __webpack_require__(2991);
var toIndexedObject = __webpack_require__(905);
var toPrimitive = __webpack_require__(2066);
var createPropertyDescriptor = __webpack_require__(5358);
var nativeObjectCreate = __webpack_require__(2391);
var objectKeys = __webpack_require__(5632);
var getOwnPropertyNamesModule = __webpack_require__(8151);
var getOwnPropertyNamesExternal = __webpack_require__(166);
var getOwnPropertySymbolsModule = __webpack_require__(894);
var getOwnPropertyDescriptorModule = __webpack_require__(7933);
var definePropertyModule = __webpack_require__(1787);
var propertyIsEnumerableModule = __webpack_require__(9195);
var createNonEnumerableProperty = __webpack_require__(5762);
var redefine = __webpack_require__(7487);
var shared = __webpack_require__(3036);
var sharedKey = __webpack_require__(4399);
var hiddenKeys = __webpack_require__(5977);
var uid = __webpack_require__(1441);
var wellKnownSymbol = __webpack_require__(95);
var wrappedWellKnownSymbolModule = __webpack_require__(5391);
var defineWellKnownSymbol = __webpack_require__(8423);
var setToStringTag = __webpack_require__(4555);
var InternalStateModule = __webpack_require__(6407);
var $forEach = __webpack_require__(9996).forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.es/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.es/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ 5825:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $copyWithin = __webpack_require__(7154);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ 7170:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $every = __webpack_require__(9996).every;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 8857:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $fill = __webpack_require__(7065);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
  return $fill.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ 8329:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $filter = __webpack_require__(9996).filter;
var fromSpeciesAndList = __webpack_require__(8874);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSpeciesAndList(this, list);
});


/***/ }),

/***/ 427:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $findIndex = __webpack_require__(9996).findIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 6279:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $find = __webpack_require__(9996).find;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 1159:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $forEach = __webpack_require__(9996).forEach;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 2516:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $includes = __webpack_require__(9540).includes;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 4349:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $indexOf = __webpack_require__(9540).indexOf;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 5273:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(9859);
var ArrayBufferViewCore = __webpack_require__(9918);
var ArrayIterators = __webpack_require__(5735);
var wellKnownSymbol = __webpack_require__(95);

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);


/***/ }),

/***/ 6729:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('join', function join(separator) {
  return $join.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ 1801:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $lastIndexOf = __webpack_require__(6462);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return $lastIndexOf.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ 574:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $map = __webpack_require__(9996).map;
var speciesConstructor = __webpack_require__(7942);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
  });
});


/***/ }),

/***/ 9271:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $reduceRight = __webpack_require__(3143).right;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 5787:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $reduce = __webpack_require__(3143).left;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3160:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ 5688:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var toLength = __webpack_require__(4237);
var toOffset = __webpack_require__(4262);
var toObject = __webpack_require__(2991);
var fails = __webpack_require__(4229);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var FORCED = fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);


/***/ }),

/***/ 3157:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var speciesConstructor = __webpack_require__(7942);
var fails = __webpack_require__(4229);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;

var FORCED = fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ 3333:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var $some = __webpack_require__(9996).some;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 315:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  return $sort.call(aTypedArray(this), comparefn);
});


/***/ }),

/***/ 8314:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(9918);
var toLength = __webpack_require__(4237);
var toAbsoluteIndex = __webpack_require__(3231);
var speciesConstructor = __webpack_require__(7942);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ 556:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(9859);
var ArrayBufferViewCore = __webpack_require__(9918);
var fails = __webpack_require__(4229);

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);


/***/ }),

/***/ 9224:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var exportTypedArrayMethod = __webpack_require__(9918).exportTypedArrayMethod;
var fails = __webpack_require__(4229);
var global = __webpack_require__(9859);

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);


/***/ }),

/***/ 3675:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var createTypedArrayConstructor = __webpack_require__(2574);

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 1939:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var DOMIterables = __webpack_require__(5694);
var forEach = __webpack_require__(6570);
var createNonEnumerableProperty = __webpack_require__(5762);

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),

/***/ 6886:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(9859);
var DOMIterables = __webpack_require__(5694);
var ArrayIteratorMethods = __webpack_require__(5735);
var createNonEnumerableProperty = __webpack_require__(5762);
var wellKnownSymbol = __webpack_require__(95);

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
// extracted by mini-css-extract-plugin

}();
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ src_Chart; }
});

// UNUSED EXPORTS: AreaChart, BarChart, BoxPlotChart, BubbleChart, BulletChart, ColumnChart, ColumnLineChart, GaugeChart, HeatmapChart, LineAreaChart, LineChart, LineScatterChart, NestedPieChart, PieChart, RadarChart, RadialBarChart, ScatterChart, TreemapChart

// NAMESPACE OBJECT: ./src/brushes/label.ts
var label_namespaceObject = {};
__webpack_require__.r(label_namespaceObject);
__webpack_require__.d(label_namespaceObject, {
  "DEFAULT_LABEL_TEXT": function() { return DEFAULT_LABEL_TEXT; },
  "bubbleLabel": function() { return bubbleLabel; },
  "label": function() { return label; },
  "labelStyle": function() { return labelStyle; },
  "strokeLabelStyle": function() { return strokeLabelStyle; }
});

// NAMESPACE OBJECT: ./src/brushes/basic.ts
var basic_namespaceObject = {};
__webpack_require__.r(basic_namespaceObject);
__webpack_require__.d(basic_namespaceObject, {
  "arc": function() { return arc; },
  "circle": function() { return circle; },
  "clipRectArea": function() { return clipRectArea; },
  "line": function() { return line; },
  "pathRect": function() { return pathRect; },
  "rect": function() { return rect; }
});

// NAMESPACE OBJECT: ./src/brushes/axis.ts
var axis_namespaceObject = {};
__webpack_require__.r(axis_namespaceObject);
__webpack_require__.d(axis_namespaceObject, {
  "TICK_SIZE": function() { return TICK_SIZE; },
  "tick": function() { return tick; }
});

// NAMESPACE OBJECT: ./src/brushes/dataLabel.ts
var dataLabel_namespaceObject = {};
__webpack_require__.r(dataLabel_namespaceObject);
__webpack_require__.d(dataLabel_namespaceObject, {
  "dataLabel": function() { return dataLabel; },
  "drawBubbleLabel": function() { return drawBubbleLabel; },
  "getBubbleArrowPoints": function() { return getBubbleArrowPoints; }
});

// NAMESPACE OBJECT: ./src/brushes/spectrumLegend.ts
var spectrumLegend_namespaceObject = {};
__webpack_require__.r(spectrumLegend_namespaceObject);
__webpack_require__.d(spectrumLegend_namespaceObject, {
  "SPECTRUM_LEGEND_LABEL_HEIGHT": function() { return SPECTRUM_LEGEND_LABEL_HEIGHT; },
  "spectrumLegend": function() { return spectrumLegend; },
  "spectrumLegendBar": function() { return spectrumLegendBar; },
  "spectrumLegendTooltip": function() { return spectrumLegendTooltip; },
  "spectrumTooltip": function() { return spectrumTooltip; }
});

// NAMESPACE OBJECT: ./src/brushes/polygon.ts
var polygon_namespaceObject = {};
__webpack_require__.r(polygon_namespaceObject);
__webpack_require__.d(polygon_namespaceObject, {
  "polygon": function() { return polygon; }
});

// NAMESPACE OBJECT: ./src/brushes/scatterSeries.ts
var scatterSeries_namespaceObject = {};
__webpack_require__.r(scatterSeries_namespaceObject);
__webpack_require__.d(scatterSeries_namespaceObject, {
  "scatterSeries": function() { return scatterSeries; }
});

// NAMESPACE OBJECT: ./src/brushes/legend.ts
var legend_namespaceObject = {};
__webpack_require__.r(legend_namespaceObject);
__webpack_require__.d(legend_namespaceObject, {
  "LEGEND_CHECKBOX_SIZE": function() { return LEGEND_CHECKBOX_SIZE; },
  "LEGEND_ICON_SIZE": function() { return LEGEND_ICON_SIZE; },
  "LEGEND_ITEM_MARGIN_X": function() { return LEGEND_ITEM_MARGIN_X; },
  "LEGEND_MARGIN_X": function() { return LEGEND_MARGIN_X; },
  "getLegendItemHeight": function() { return getLegendItemHeight; },
  "legend": function() { return legend; }
});

// NAMESPACE OBJECT: ./src/brushes/lineSeries.ts
var brushes_lineSeries_namespaceObject = {};
__webpack_require__.r(brushes_lineSeries_namespaceObject);
__webpack_require__.d(brushes_lineSeries_namespaceObject, {
  "areaPoints": function() { return areaPoints; },
  "linePoints": function() { return linePoints; }
});

// NAMESPACE OBJECT: ./src/brushes/exportMenu.ts
var brushes_exportMenu_namespaceObject = {};
__webpack_require__.r(brushes_exportMenu_namespaceObject);
__webpack_require__.d(brushes_exportMenu_namespaceObject, {
  "exportMenuButton": function() { return exportMenuButton; }
});

// NAMESPACE OBJECT: ./src/brushes/resetButton.ts
var brushes_resetButton_namespaceObject = {};
__webpack_require__.r(brushes_resetButton_namespaceObject);
__webpack_require__.d(brushes_resetButton_namespaceObject, {
  "backButton": function() { return backButton; },
  "resetButton": function() { return resetButton; }
});

// NAMESPACE OBJECT: ./src/brushes/sector.ts
var brushes_sector_namespaceObject = {};
__webpack_require__.r(brushes_sector_namespaceObject);
__webpack_require__.d(brushes_sector_namespaceObject, {
  "sector": function() { return sector; }
});

// NAMESPACE OBJECT: ./src/brushes/circleLegend.ts
var brushes_circleLegend_namespaceObject = {};
__webpack_require__.r(brushes_circleLegend_namespaceObject);
__webpack_require__.d(brushes_circleLegend_namespaceObject, {
  "circleLegend": function() { return circleLegend; }
});

// NAMESPACE OBJECT: ./src/brushes/boxPlot.ts
var boxPlot_namespaceObject = {};
__webpack_require__.r(boxPlot_namespaceObject);
__webpack_require__.d(boxPlot_namespaceObject, {
  "boxPlot": function() { return boxPlot; }
});

// NAMESPACE OBJECT: ./src/brushes/gauge.ts
var gauge_namespaceObject = {};
__webpack_require__.r(gauge_namespaceObject);
__webpack_require__.d(gauge_namespaceObject, {
  "clockHand": function() { return clockHand; }
});

// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.set-prototype-of.js
var es_object_set_prototype_of = __webpack_require__(2506);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.get-prototype-of.js
var es_object_get_prototype_of = __webpack_require__(6928);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.reflect.construct.js
var es_reflect_construct = __webpack_require__(1229);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.reflect.get.js
var es_reflect_get = __webpack_require__(4565);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js
var es_object_get_own_property_descriptor = __webpack_require__(8625);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__(4769);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__(4115);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__(5342);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__(1939);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.get-own-property-descriptors.js
var es_object_get_own_property_descriptors = __webpack_require__(2775);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__(634);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__(8188);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__(796);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__(5735);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__(8673);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__(6886);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__(3450);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__(8178);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.from.js
var es_array_from = __webpack_require__(7233);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__(2501);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__(6936);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__(7950);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__(8319);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__(9805);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__(9529);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.find-index.js
var es_array_find_index = __webpack_require__(9949);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__(1245);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__(9228);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.number.to-fixed.js
var es_number_to_fixed = __webpack_require__(1321);
;// CONCATENATED MODULE: ./src/helpers/utils.ts
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isExist(value) {
  return !isUndefined(value) && !isNull(value);
}
function isDate(value) {
  return value instanceof Date;
}
function isUndefined(value) {
  return typeof value === 'undefined';
}
function isNull(value) {
  return value === null;
}
function isBoolean(value) {
  return typeof value === 'boolean';
}
function isNumber(value) {
  return typeof value === 'number';
}
function utils_isString(value) {
  return typeof value === 'string';
}
function isInteger(value) {
  return isNumber(value) && isFinite(value) && Math.floor(value) === value;
}
function isObject(obj) {
  return _typeof(obj) === 'object' && obj !== null;
}
function isFunction(value) {
  return typeof value === 'function';
}
function forEach(obj, cb) {
  for (var _key in obj) {
    if (obj.hasOwnProperty(_key)) {
      cb(obj[_key], _key);
    }
  }
}
function forEachArray(arr, iteratee) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  for (var _index = 0, len = arr.length; _index < len; _index += 1) {
    if (iteratee.call(context, arr[_index], _index, arr) === false) {
      break;
    }
  }
}
function range(start, stop, step) {
  if (isUndefined(stop)) {
    stop = start || 0;
    start = 0;
  }

  step = step || 1;
  var arr = [];

  if (stop) {
    var flag = step < 0 ? -1 : 1;
    stop *= flag;

    for (; start * flag < stop; start += step) {
      arr.push(start);
    }
  }

  return arr;
}
function toArray(arrayLike) {
  var arr = [];

  try {
    arr = Array.prototype.slice.call(arrayLike);
  } catch (e) {
    forEachArray(arrayLike, function (value) {
      arr.push(value);
    });
  }

  return arr;
}
function includes(arr, searchItem, searchIndex) {
  if (typeof searchIndex === 'number' && arr[searchIndex] !== searchItem) {
    return false;
  }

  var _iterator = _createForOfIteratorHelper(arr),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _item = _step.value;

      if (_item === searchItem) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
}
function pick(obj) {
  for (var _len = arguments.length, propNames = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
    propNames[_key2 - 1] = arguments[_key2];
  }

  var resultMap = {};
  Object.keys(obj).forEach(function (key) {
    if (includes(propNames, key)) {
      resultMap[key] = obj[key];
    }
  });
  return resultMap;
}
function omit(obj) {
  for (var _len2 = arguments.length, propNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
    propNames[_key3 - 1] = arguments[_key3];
  }

  var resultMap = {};
  Object.keys(obj).forEach(function (key) {
    if (!includes(propNames, key)) {
      resultMap[key] = obj[key];
    }
  });
  return resultMap;
}
function pickProperty(target, keys) {
  var length = keys.length;

  if (length) {
    for (var i = 0; i < length; i += 1) {
      if (isUndefined(target) || isNull(target)) {
        return null;
      }

      target = target[keys[i]];
    }
  }

  return target;
}
function pickPropertyWithMakeup(target, args) {
  var length = args.length;

  if (length) {
    for (var i = 0; i < length; i += 1) {
      if (isUndefined(target[args[i]])) {
        target[args[i]] = {};
      }

      target = target[args[i]];
    }
  }

  return target;
}
function debounce(fn) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var timer;

  function debounced() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
      args[_key4] = arguments[_key4];
    }

    window.clearTimeout(timer);
    timer = window.setTimeout(function () {
      fn.apply(void 0, args);
    }, delay);
  }

  return debounced;
}
function merge(target) {
  target = target || {};

  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  args.forEach(function (obj) {
    if (!obj) {
      return;
    }

    forEach(obj, function (item, key) {
      if (Object.prototype.toString.call(item) === '[object Object]') {
        target[key] = merge(target[key], item);
      } else {
        target[key] = item;
      }
    });
  });
  return target;
}
function throttle(fn) {
  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var base = null;
  var isLeading = true;

  var tick = function tick() {
    fn.apply(void 0, arguments);
    base = null;
  };

  var stamp = 0;
  var debounced = debounce(tick, interval);

  function throttled() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
      args[_key6] = arguments[_key6];
    }

    if (isLeading) {
      tick.apply(void 0, args);
      isLeading = false;
      return;
    }

    stamp = Number(new Date());
    base = base || stamp;
    debounced(args);

    if (stamp - base >= interval) {
      tick(args);
    }
  }

  function reset() {
    // eslint-disable-line require-jsdoc
    isLeading = true;
    base = null;
  }

  throttled.reset = reset;
  return throttled;
}
function deepMergedCopy(targetObj, obj) {
  var resultObj = _objectSpread({}, targetObj);

  Object.keys(obj).forEach(function (prop) {
    if (isObject(resultObj[prop])) {
      if (Array.isArray(obj[prop])) {
        resultObj[prop] = deepCopyArray(obj[prop]);
      } else if (resultObj.hasOwnProperty(prop)) {
        resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);
      } else {
        resultObj[prop] = deepCopy(obj[prop]);
      }
    } else {
      resultObj[prop] = obj[prop];
    }
  });
  return resultObj;
}
function deepCopyArray(items) {
  return items.map(function (item) {
    if (isObject(item)) {
      return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);
    }

    return item;
  });
}
function deepCopy(obj) {
  var resultObj = {};
  var keys = Object.keys(obj);

  if (!keys.length) {
    return obj;
  }

  keys.forEach(function (prop) {
    if (isObject(obj[prop])) {
      resultObj[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);
    } else {
      resultObj[prop] = obj[prop];
    }
  });
  return resultObj;
}
function sortCategories(x, y) {
  return isInteger(x) ? Number(x) - Number(y) : new Date(x).getTime() - new Date(y).getTime();
}
function sortNumber(x, y) {
  return x - y;
}
function first(items) {
  // eslint-disable-next-line no-undefined
  return items.length ? items[0] : undefined;
}
function last(items) {
  // eslint-disable-next-line no-undefined
  return items.length ? items[items.length - 1] : undefined;
}
function hasNegative() {
  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return values.some(function (value) {
    return Number(value) < 0;
  });
}
function sum(items) {
  return items.reduce(function (a, b) {
    return a + b;
  }, 0);
}
function hasPositiveOnly(values) {
  return values.every(function (value) {
    return Number(value) >= 0;
  });
}
function hasNegativeOnly(values) {
  return values.every(function (value) {
    return Number(value) <= 0;
  });
}
function getFirstValidValue(values) {
  return values === null || values === void 0 ? void 0 : values.find(function (value) {
    return value !== null;
  });
}
function utils_getPercentageValue(text) {
  return Number(text.substr(0, text.length - 1));
}
function calculateSizeWithPercentString(size, value) {
  return isNumber(value) ? value : Number((size * utils_getPercentageValue(value) / 100).toFixed(2));
}
function getInitialSize(size) {
  return isNumber(size) ? size : 0;
}
function isAutoValue(value) {
  return value === 'auto';
}
;// CONCATENATED MODULE: ./src/message.ts
var message = {
  SELECT_SERIES_API_SELECTABLE_ERROR: 'It works only when the selectable option is true.',
  SELECT_SERIES_API_INDEX_ERROR: 'The index value is invalid.',
  ALREADY_OBSERVABLE_ERROR: 'Source object is observable already',
  CIRCLE_LEGEND_RENDER_ERROR: 'circleLegend is only possible when bubble series is present',
  noDataError: function noDataError(chartName) {
    return "There's no ".concat(chartName, " data!");
  },
  noBrushError: function noBrushError(brushName) {
    return "Brush don't exist in painter: ".concat(brushName);
  },
  DASH_SEGMENTS_UNAVAILABLE_ERROR: 'DashSegments option is available from IE11 and above.',
  SERIES_INDEX_ERROR: 'The seriesIndex value is invalid',
  AUTO_LAYOUT_CONTAINER_SIZE_ERROR: 'To use auto layout, the width or height of the container must be specified as a value such as "%" or "vh", "vw".'
};
;// CONCATENATED MODULE: ./src/store/reactive.ts
function reactive_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function reactive_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { reactive_typeof = function _typeof(obj) { return typeof obj; }; } else { reactive_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return reactive_typeof(obj); }

















var currentCollectorObserver = null;
var currentRunningObserver = null;
var observerCallCue = [];
var doingInvisibleWork = false;
function reactive_observe(fn) {
  var observer = function observer() {
    if (currentRunningObserver === observer) {
      return;
    } // If there is observer running or doing invisible work


    if (doingInvisibleWork || !isNull(currentRunningObserver)) {
      if (observerCallCue.includes(observer)) {
        observerCallCue.splice(observerCallCue.indexOf(observer), 1);
      } // We use observer call cue because avoid nested observer call.


      observerCallCue.push(observer); // or If there are no observers running. Run the observer and run the next observer in the call queue.
    } else if (isNull(currentRunningObserver)) {
      currentRunningObserver = observer;
      fn();
      currentRunningObserver = null;
      digestObserverCallCue();
    }
  };

  observer.deps = []; // first observer excution for collect dependencies

  currentCollectorObserver = observer;
  currentCollectorObserver();
  currentCollectorObserver = null;
  return function () {
    observer.deps.forEach(function (dep) {
      var index = dep.findIndex(function (ob) {
        return ob === observer;
      });
      dep.splice(index, 1);
    });
    observer.deps = [];
  };
}

function digestObserverCallCue() {
  if (observerCallCue.length) {
    var nextObserver = observerCallCue.shift();

    if (nextObserver) {
      nextObserver();
    }
  }
}

function isObservable(target) {
  return reactive_typeof(target) === 'object' && target.__toastUIChartOb__;
}
function reactive_observable(target) {
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target;

  if (isObservable(source)) {
    throw new Error(message.ALREADY_OBSERVABLE_ERROR);
  }

  if (!isObservable(target)) {
    Object.defineProperty(target, '__toastUIChartOb__', {
      enumerable: false
    });
  }

  var _loop = function _loop(key) {
    if (!source.hasOwnProperty(key)) {
      return "continue";
    }

    var obs = [];
    var value = source[key];
    var descriptor = Object.getOwnPropertyDescriptor(source, key);
    var preGetter = descriptor && descriptor.get;
    var preSetter = descriptor && descriptor.set;
    /* eslint-disable no-loop-func */

    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: true,
      get: function get() {
        // It's some kind a trick to get observable information from closure using getter for notify()
        if (currentCollectorObserver === observableInfo) {
          return {
            target: target,
            key: key,
            value: value,
            obs: obs
          };
        }

        if (!doingInvisibleWork && currentCollectorObserver && !obs.includes(currentCollectorObserver)) {
          // if there is collector observer in running, collect current data as dependency
          obs.push(currentCollectorObserver);
          currentCollectorObserver.deps.push(obs);
        }

        return value;
      },
      set: function set(v) {
        var prevValue = value;

        if (preSetter) {
          preSetter.call(target, v);
          value = preGetter ? preGetter.call(target) : target[key];
        } else {
          value = v;
        }

        if (prevValue !== value) {
          // Run observers
          invokeObs(obs);
        }
      }
    });

    if (reactive_typeof(target[key]) === 'object' && !Array.isArray(target[key])) {
      reactive_observable(target[key]);
    }
    /* eslint-enable no-loop-func */

  };

  for (var key in source) {
    var _ret = _loop(key);

    if (_ret === "continue") continue;
  }

  return target;
}
function setValue(target, key, source) {
  return reactive_observable(target, reactive_defineProperty({}, key, source));
}
function extend(target, source) {
  if (isObservable(source)) {
    throw new Error(message.ALREADY_OBSERVABLE_ERROR);
  }

  return reactive_observable(target, source);
}
function reactive_notify(target, key) {
  var obInfo = observableInfo(target, key);

  if (obInfo) {
    invokeObs(obInfo.obs);
  }
}
function invisibleWork(fn) {
  doingInvisibleWork = true;
  fn();
  doingInvisibleWork = false;
  digestObserverCallCue();
}
function reactive_notifyByPath(holder, namePath) {
  var splited = namePath.split('.');
  var key = splited.splice(splited.length - 1, 1)[0];
  var target = pickProperty(holder, splited);

  if (target) {
    reactive_notify(target, key);
  }
}

function invokeObs(obs) {
  obs.forEach(function (ob) {
    return ob();
  });
}

function observableInfo(target, key) {
  currentCollectorObserver = observableInfo;
  var obInfo = target[key];
  currentCollectorObserver = null;

  if (reactive_typeof(obInfo) === 'object' && obInfo.hasOwnProperty('target') && obInfo.hasOwnProperty('obs')) {
    return obInfo;
  }

  return null;
}

function computed(target, key, fn) {
  var cachedValue;
  var computedBox = {};
  Object.defineProperty(computedBox, key, {
    configurable: true,
    enumerable: true,
    get: function get() {
      return cachedValue;
    }
  });
  extend(target, computedBox);
  reactive_observe(function () {
    var prevValue = cachedValue;
    cachedValue = fn();

    if (prevValue !== cachedValue) {
      target[key] = cachedValue;
    }
  });
}
function watch(holder, path, fn) {
  var splited = path.split('.');
  var key = splited.splice(splited.length - 1, 1)[0];
  var target = pickProperty(holder, splited);

  if (!target) {
    return null;
  }

  var obInfo = observableInfo(target, key);

  if (!obInfo) {
    return null;
  }

  var watcher = function watcher() {
    fn(target[key]);
  };

  obInfo.obs.push(watcher);
  return function () {
    var index = obInfo.obs.findIndex(function (ob) {
      return ob === watcher;
    });

    if (index > -1) {
      obInfo.obs.splice(index, 1);
    }
  };
}
function makeObservableObjectToNormal(obj) {
  return JSON.parse(JSON.stringify(obj));
}
;// CONCATENATED MODULE: ./src/store/store.ts
function store_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { store_typeof = function _typeof(obj) { return typeof obj; }; } else { store_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return store_typeof(obj); }














function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var Store = /*#__PURE__*/function () {
  function Store(initStoreState) {
    _classCallCheck(this, Store);

    store_defineProperty(this, "state", void 0);

    store_defineProperty(this, "initStoreState", void 0);

    store_defineProperty(this, "computed", {});

    store_defineProperty(this, "actions", {});

    this.initStoreState = deepCopy(initStoreState);
    this.setRootState({});
  }

  _createClass(Store, [{
    key: "setRootState",
    value: function setRootState(state) {
      reactive_observable(state);

      this.state = state;
    }
  }, {
    key: "setComputed",
    value: function setComputed(namePath, fn) {
      var holder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.computed;
      var splited = namePath.split('.');
      var key = splited.splice(splited.length - 1, 1)[0];
      var target = pickPropertyWithMakeup(holder, splited);
      computed(target, key, fn.bind(null, this.state, this.computed));
    }
  }, {
    key: "setWatch",
    value: function setWatch(namePath, fn) {
      return watch(this, namePath, fn);
    }
  }, {
    key: "setAction",
    value: function setAction(name, fn) {
      this.actions[name] = fn;
    }
  }, {
    key: "dispatch",
    value: function dispatch(name, payload, isInvisible) {
      var _this = this;

      // observe.setlayout  setLayout    state.layout getter 
      // state.layout  observe.setLayout .  
      //  observe    
      // extend(state.layout, layouts);   layout getter
      // layout   observe   
      if (isInvisible) {
        invisibleWork(function () {
          // console.log('dispatch', name, ...args);
          _this.actions[name].call(_this, _this, payload); // console.log('dispatch end', name);

        });
      } else {
        this.actions[name].call(this, this, payload);
      }
    }
  }, {
    key: "observe",
    value: function observe(fn) {
      return reactive_observe(fn.bind(this, this.state, this.computed));
    }
  }, {
    key: "observable",
    value: function observable(target) {
      return reactive_observable(target);
    }
  }, {
    key: "notifyByPath",
    value: function notifyByPath(namePath) {
      reactive_notifyByPath(this, namePath);
    }
  }, {
    key: "notify",
    value: function notify(target, key) {
      reactive_notify(target, key);
    }
  }, {
    key: "setModule",
    value: function setModule(name, param) {
      var _this2 = this;

      if (!param) {
        param = name;
        name = param.name;
      }

      if (param.state) {
        var moduleState = typeof param.state === 'function' ? param.state(this.initStoreState) : param.state;
        store_extend(this.state, moduleState);
      }

      if (param.computed) {
        forEach(param.computed, function (item, key) {
          _this2.setComputed(key, item);
        });
      }

      if (param.watch) {
        forEach(param.watch, function (item, key) {
          _this2.setWatch(key, item);
        });
      }

      if (param.action) {
        forEach(param.action, function (item, key) {
          _this2.setAction(key, item);
        });
      }

      if (param.observe) {
        forEach(param.observe, function (item) {
          _this2.observe(item);
        });
      }
    }
  }, {
    key: "setValue",
    value: function setValue(target, key, source) {
      store_extend(target, store_defineProperty({}, key, source));
    }
  }]);

  return Store;
}();


function store_extend(target, source) {
  var newItems = {};

  for (var k in source) {
    if (!source.hasOwnProperty(k)) {
      continue;
    }

    if (!isUndefined(target[k])) {
      if (store_typeof(source[k]) === 'object' && !Array.isArray(source[k])) {
        store_extend(target[k], source[k]);
      } else {
        target[k] = source[k];
      }
    } else {
      newItems[k] = source[k];
    }
  }

  if (Object.keys(newItems).length) {
    extend(target, newItems);
  }
}
;// CONCATENATED MODULE: ./src/store/root.ts







function root_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function root_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { root_ownKeys(Object(source), true).forEach(function (key) { root_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { root_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function root_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function initialSize(containerEl, _ref) {
  var width = _ref.width,
      height = _ref.height;
  return {
    width: width === 0 ? containerEl.offsetWidth : width,
    height: height === 0 ? containerEl.offsetHeight : height
  };
}

var root = {
  name: 'root',
  state: function state(_ref2) {
    var _options$chart, _options$chart2, _options$chart3, _options$chart4;

    var options = _ref2.options;
    return {
      chart: root_objectSpread(root_objectSpread({}, options.chart), {}, {
        width: getInitialSize(options === null || options === void 0 ? void 0 : (_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width),
        height: getInitialSize(options === null || options === void 0 ? void 0 : (_options$chart2 = options.chart) === null || _options$chart2 === void 0 ? void 0 : _options$chart2.height)
      }),
      usingContainerSize: {
        width: isAutoValue(options === null || options === void 0 ? void 0 : (_options$chart3 = options.chart) === null || _options$chart3 === void 0 ? void 0 : _options$chart3.width),
        height: isAutoValue(options === null || options === void 0 ? void 0 : (_options$chart4 = options.chart) === null || _options$chart4 === void 0 ? void 0 : _options$chart4.height)
      },
      container: {}
    };
  },
  action: {
    setChartSize: function setChartSize(_ref3, size) {
      var state = _ref3.state;
      state.chart.width = size.width;
      state.chart.height = size.height;
      this.notify(state, 'chart');
    },
    initChartSize: function initChartSize(_ref4, containerEl) {
      var _this = this;

      var state = _ref4.state;
      var _state$chart = state.chart,
          width = _state$chart.width,
          height = _state$chart.height;

      if (width === 0 || height === 0) {
        if (containerEl.parentNode) {
          this.dispatch('setChartSize', initialSize(containerEl, {
            width: width,
            height: height
          }));
        } else {
          setTimeout(function () {
            _this.dispatch('setChartSize', initialSize(containerEl, {
              width: width,
              height: height
            }));
          }, 0);
        }
      }
    },
    setUsingContainerSize: function setUsingContainerSize(_ref5, _ref6) {
      var state = _ref5.state;
      var width = _ref6.width,
          height = _ref6.height;
      state.usingContainerSize.width = width;
      state.usingContainerSize.height = height;
    }
  }
};
/* harmony default export */ var store_root = (root);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.set.js
var es_set = __webpack_require__(3244);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.match.js
var es_string_match = __webpack_require__(4069);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.fill.js
var es_array_fill = __webpack_require__(2656);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__(5940);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__(8233);
;// CONCATENATED MODULE: ./src/helpers/color.ts
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || color_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function color_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return color_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return color_arrayLikeToArray(o, minLen); }

function color_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




















var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
var rgbRX = /rgb\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3})\)/;
var rgbaRX = /rgba\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3}), ?(1|0?\.?\d+)\)/;
/**
 * Color map.
 * http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes
 * http://www.w3schools.com/HTML/html_colornames.asp
 * @ignore
 */

var colorMap = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgrey: '#d3d3d3',
  lightgreen: '#90ee90',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370d8',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#d87093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32'
};

function leadingZero(number, length) {
  if (number.length > length) {
    return number;
  }

  var res = number;
  range(0, length - 1).forEach(function (_) {
    res = '0' + res;
  });
  return res.slice(length * -1);
}

function isValidRGB(str) {
  return hexRX.test(str);
}

function colorNameToHex(colorName) {
  return colorMap[colorName.toLowerCase()] || colorName;
} // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html


function hexToRGB(str) {
  var hexStr = colorNameToHex(str);

  if (!isValidRGB(hexStr)) {
    return false;
  }

  return hexStr.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
    return '#' + r + r + g + g + b + b;
  }).substring(1).match(/.{2}/g).map(function (x) {
    return parseInt(x, 16);
  });
}
function rgbToHEX(r, g, b) {
  var hexPreFix = '#';
  var hexStr = hexPreFix + leadingZero(r.toString(16), 2) + leadingZero(g.toString(16), 2) + leadingZero(b.toString(16), 2);

  if (isValidRGB(hexStr)) {
    return hexStr;
  }

  return false;
}
function getRGBA(str, opacity) {
  var hexStr = colorNameToHex(str);

  if (isValidRGB(hexStr)) {
    var _ref = hexToRGB(hexStr),
        _ref2 = _slicedToArray(_ref, 3),
        r = _ref2[0],
        g = _ref2[1],
        b = _ref2[2];

    return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(opacity, ")");
  }

  if (rgbRX.test(str)) {
    var match = rgbRX.exec(str);
    return "rgba(".concat(match[1], ", ").concat(match[2], ", ").concat(match[3], ", ").concat(opacity, ")");
  }

  if (rgbaRX.test(str)) {
    var _match = rgbaRX.exec(str);

    return "rgba(".concat(_match[1], ", ").concat(_match[2], ", ").concat(_match[3], ", ").concat(opacity, ")");
  }

  return str;
}
function getAlpha(str) {
  if (rgbaRX.test(str)) {
    var match = rgbaRX.exec(str);
    return Number(match[4]);
  }

  return 1;
}
function rgba(color) {
  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var alpha = getAlpha(color) * opacity;
  return getRGBA(color, alpha);
}
;// CONCATENATED MODULE: ./src/helpers/style.ts









function style_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function style_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { style_ownKeys(Object(source), true).forEach(function (key) { style_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { style_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function style_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function makeStyleObj(style, styleSet) {
  return style.reduce(function (acc, curValue) {
    if (utils_isString(curValue)) {
      return style_objectSpread(style_objectSpread({}, acc), styleSet[curValue]);
    }

    return style_objectSpread(style_objectSpread({}, acc), curValue);
  }, {});
}
function getTranslateString(x, y) {
  return "translate(".concat(x, "px,").concat(y, "px)");
}
function getTitleFontString(fontTheme) {
  var fontFamily = fontTheme.fontFamily,
      fontSize = fontTheme.fontSize,
      fontWeight = fontTheme.fontWeight;
  return "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
}
function getFontStyleString(theme) {
  var color = theme.color,
      fontSize = theme.fontSize,
      fontFamily = theme.fontFamily,
      fontWeight = theme.fontWeight;
  return "font-weight: ".concat(fontWeight, "; font-family: ").concat(fontFamily, "; font-size: ").concat(fontSize, "px; color: ").concat(color, ";");
}
function getFont(theme) {
  return getTitleFontString(pick(theme, 'fontFamily', 'fontWeight', 'fontSize'));
}
function setLineDash(ctx, dashSegments) {
  if (ctx.setLineDash) {
    ctx.setLineDash(dashSegments);
  }
}
function getBoxTypeSeriesPadding(tickDistance) {
  return Math.floor(tickDistance * 0.15);
}
function fillStyle(ctx, fillOption) {
  ctx.fillStyle = fillOption;
  ctx.fill();
}
function strokeWithOptions(ctx, style) {
  var lineWidth = style.lineWidth,
      strokeStyle = style.strokeStyle;

  if (strokeStyle) {
    ctx.strokeStyle = strokeStyle;
  }

  if (lineWidth) {
    ctx.lineWidth = lineWidth;
  }

  if (ctx.lineWidth && getAlpha(String(ctx.strokeStyle))) {
    ctx.stroke();
  }
}
;// CONCATENATED MODULE: ./src/brushes/label.ts






var DEFAULT_LABEL_TEXT = 'normal 11px Arial';
var labelStyle = {
  default: {
    font: DEFAULT_LABEL_TEXT,
    fillStyle: '#333333',
    textAlign: 'left',
    textBaseline: 'middle'
  },
  title: {
    textBaseline: 'top'
  },
  axisTitle: {
    textBaseline: 'top'
  },
  rectLabel: {
    font: DEFAULT_LABEL_TEXT,
    fillStyle: 'rgba(0, 0, 0, 0.3)',
    textAlign: 'center',
    textBaseline: 'middle'
  }
};
var strokeLabelStyle = {
  none: {
    lineWidth: 1,
    strokeStyle: 'rgba(255, 255, 255, 0)'
  },
  stroke: {
    lineWidth: 4,
    strokeStyle: 'rgba(255, 255, 255, 0.5)'
  }
};
function label(ctx, labelModel) {
  var x = labelModel.x,
      y = labelModel.y,
      text = labelModel.text,
      style = labelModel.style,
      stroke = labelModel.stroke,
      opacity = labelModel.opacity,
      radian = labelModel.radian,
      rotationPosition = labelModel.rotationPosition;

  if (style) {
    var styleObj = makeStyleObj(style, labelStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = key === 'fillStyle' && isNumber(opacity) ? rgba(styleObj[key], opacity) : styleObj[key];
    });
  }

  ctx.save();

  if (radian) {
    var _rotationPosition$x, _rotationPosition$y, _rotationPosition$x2, _rotationPosition$y2;

    ctx.translate((_rotationPosition$x = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x !== void 0 ? _rotationPosition$x : x, (_rotationPosition$y = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y !== void 0 ? _rotationPosition$y : y);
    ctx.rotate(radian);
    ctx.translate(-((_rotationPosition$x2 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x2 !== void 0 ? _rotationPosition$x2 : x), -((_rotationPosition$y2 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y2 !== void 0 ? _rotationPosition$y2 : y));
  }

  if (stroke) {
    var strokeStyleObj = makeStyleObj(stroke, strokeLabelStyle);
    var strokeStyleKeys = Object.keys(strokeStyleObj);
    strokeStyleKeys.forEach(function (key) {
      ctx[key] = key === 'strokeStyle' && isNumber(opacity) ? rgba(strokeStyleObj[key], opacity) : strokeStyleObj[key];
    });

    if (strokeStyleKeys.length) {
      ctx.strokeText(text, x, y);
    }
  }

  ctx.fillText(text, x, y);
  ctx.restore();
}
var textBubbleStyle = {
  shadow: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetY: 2,
    shadowBlur: 4
  }
};
function bubbleLabel(ctx, model) {
  var _model$radian = model.radian,
      radian = _model$radian === void 0 ? 0 : _model$radian,
      rotationPosition = model.rotationPosition,
      _model$bubble = model.bubble,
      x = _model$bubble.x,
      y = _model$bubble.y,
      width = _model$bubble.width,
      height = _model$bubble.height,
      _model$bubble$radius = _model$bubble.radius,
      radius = _model$bubble$radius === void 0 ? 0 : _model$bubble$radius,
      _model$bubble$lineWid = _model$bubble.lineWidth,
      lineWidth = _model$bubble$lineWid === void 0 ? 1 : _model$bubble$lineWid,
      direction = _model$bubble.direction,
      _model$bubble$points = _model$bubble.points,
      points = _model$bubble$points === void 0 ? [] : _model$bubble$points,
      _model$bubble$fill = _model$bubble.fill,
      fill = _model$bubble$fill === void 0 ? '#fff' : _model$bubble$fill,
      _model$bubble$strokeS = _model$bubble.strokeStyle,
      strokeStyle = _model$bubble$strokeS === void 0 ? 'rgba(0, 0, 0, 0)' : _model$bubble$strokeS,
      _model$bubble$style = _model$bubble.style,
      bubbleStyle = _model$bubble$style === void 0 ? null : _model$bubble$style;

  if (width > 0 && height > 0) {
    var _rotationPosition$x3, _rotationPosition$y3;

    drawBubble(ctx, {
      x: x,
      y: y,
      radius: radius,
      width: width,
      height: height,
      style: bubbleStyle,
      fill: fill,
      strokeStyle: strokeStyle,
      lineWidth: lineWidth,
      direction: direction,
      points: points,
      radian: radian,
      rotationPosition: {
        x: (_rotationPosition$x3 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x3 !== void 0 ? _rotationPosition$x3 : x,
        y: (_rotationPosition$y3 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y3 !== void 0 ? _rotationPosition$y3 : y
      }
    });
  }

  if (model.label.text) {
    var _model$label = model.label,
        labelX = _model$label.x,
        labelY = _model$label.y,
        text = _model$label.text,
        _model$label$strokeSt = _model$label.strokeStyle,
        labelStrokeColor = _model$label$strokeSt === void 0 ? 'rgba(0, 0, 0, 0)' : _model$label$strokeSt,
        style = _model$label.style;
    ctx.shadowColor = 'rgba(0, 0, 0, 0)';
    label(ctx, {
      type: 'label',
      x: labelX,
      y: labelY,
      text: text,
      style: style,
      stroke: [{
        strokeStyle: labelStrokeColor
      }],
      radian: radian,
      rotationPosition: rotationPosition
    });
  }
}

function drawBubbleArrow(ctx, points) {
  if (!points.length) {
    return;
  }

  ctx.lineTo(points[0].x, points[0].y);
  ctx.lineTo(points[1].x, points[1].y);
  ctx.lineTo(points[2].x, points[2].y);
}

function drawBubble(ctx, model) {
  var x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      style = model.style,
      _model$radius = model.radius,
      radius = _model$radius === void 0 ? 0 : _model$radius,
      strokeStyle = model.strokeStyle,
      fill = model.fill,
      _model$lineWidth = model.lineWidth,
      lineWidth = _model$lineWidth === void 0 ? 1 : _model$lineWidth,
      _model$points = model.points,
      points = _model$points === void 0 ? [] : _model$points,
      _model$direction = model.direction,
      direction = _model$direction === void 0 ? '' : _model$direction,
      radian = model.radian,
      rotationPosition = model.rotationPosition;
  var right = x + width;
  var bottom = y + height;
  ctx.beginPath();
  ctx.save();

  if (radian && rotationPosition) {
    ctx.translate(rotationPosition.x, rotationPosition.y);
    ctx.rotate(radian);
    ctx.translate(-rotationPosition.x, -rotationPosition.y);
  }

  ctx.moveTo(x + radius, y);

  if (direction === 'top') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(right - radius, y);
  ctx.quadraticCurveTo(right, y, right, y + radius);

  if (direction === 'right') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(right, y + height - radius);
  ctx.quadraticCurveTo(right, bottom, right - radius, bottom);

  if (direction === 'bottom') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(x + radius, bottom);
  ctx.quadraticCurveTo(x, bottom, x, bottom - radius);

  if (direction === 'left') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);

  if (style) {
    var styleObj = makeStyleObj(style, textBubbleStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (fill) {
    fillStyle(ctx, fill);
  }

  if (strokeStyle) {
    strokeWithOptions(ctx, {
      strokeStyle: strokeStyle,
      lineWidth: lineWidth
    });
  }

  ctx.restore();
}
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.anchor.js
var es_string_anchor = __webpack_require__(1549);
;// CONCATENATED MODULE: ./src/helpers/sector.ts








function sector_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function sector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { sector_ownKeys(Object(source), true).forEach(function (key) { sector_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { sector_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function sector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var DEGREE_180 = 180;
var DEGREE_NEGATIVE_180 = -180;
var DEGREE_360 = 360;
var DEGREE_0 = 0;
var DEGREE_NEGATIVE_90 = -90;
var DEGREE_90 = 90;
var MINIMUM_RADIUS = 10;
function makeAnchorPositionParam(anchor, model) {
  return sector_objectSpread({
    anchor: anchor
  }, pick(model, 'x', 'y', 'radius', 'degree', 'drawingStartAngle'));
}
function calculateDegreeToRadian(degree) {
  var drawingStartAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEGREE_NEGATIVE_90;
  var result = 0;

  if (degree % DEGREE_360 === 0) {
    result = Math.PI / DEGREE_180 * drawingStartAngle;
  } else if (degree >= 0) {
    result = Math.PI / DEGREE_180 * (degree + drawingStartAngle);
  }

  return result;
}
function calculateRadianToDegree(radian) {
  var drawingStartAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEGREE_NEGATIVE_90;
  return (radian * DEGREE_180 / Math.PI - drawingStartAngle + DEGREE_360) % DEGREE_360;
}
function getRadialAnchorPosition(param) {
  var anchor = param.anchor,
      x = param.x,
      y = param.y,
      _param$radius = param.radius,
      inner = _param$radius.inner,
      outer = _param$radius.outer,
      _param$degree = param.degree,
      start = _param$degree.start,
      end = _param$degree.end,
      _param$drawingStartAn = param.drawingStartAngle,
      drawingStartAngle = _param$drawingStartAn === void 0 ? DEGREE_NEGATIVE_90 : _param$drawingStartAn;
  var halfDegree = start + (end - start) / 2;
  var radian = calculateDegreeToRadian(halfDegree, drawingStartAngle);
  var r = anchor === 'outer' ? outer : (outer + inner) / 2;
  return getRadialPosition(x, y, r, radian);
}
function getRadialPosition(x, y, r, radian) {
  return {
    x: Math.round(x + r * Math.cos(radian)),
    y: Math.round(y + r * Math.sin(radian))
  };
}
function withinRadian(clockwise, startDegree, endDegree, currentDegree) {
  return clockwise ? startDegree <= currentDegree && endDegree >= currentDegree : startDegree >= currentDegree && endDegree <= currentDegree;
}
function initSectorOptions(options) {
  var _options$clockwise, _options$angleRange$s, _options$angleRange, _options$angleRange$e, _options$angleRange2;

  var clockwise = (_options$clockwise = options === null || options === void 0 ? void 0 : options.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
  return {
    clockwise: clockwise,
    startAngle: (_options$angleRange$s = options === null || options === void 0 ? void 0 : (_options$angleRange = options.angleRange) === null || _options$angleRange === void 0 ? void 0 : _options$angleRange.start) !== null && _options$angleRange$s !== void 0 ? _options$angleRange$s : clockwise ? DEGREE_0 : DEGREE_360,
    endAngle: (_options$angleRange$e = options === null || options === void 0 ? void 0 : (_options$angleRange2 = options.angleRange) === null || _options$angleRange2 === void 0 ? void 0 : _options$angleRange2.end) !== null && _options$angleRange$e !== void 0 ? _options$angleRange$e : clockwise ? DEGREE_360 : DEGREE_0
  };
}
function getDefaultRadius(_ref) {
  var width = _ref.width,
      height = _ref.height;
  var isSemiCircular = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var maxLabelWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxLabelHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var result;

  if (isSemiCircular) {
    result = Math.min(width / 2, height) - maxLabelHeight;
  } else if (width > height) {
    result = height / 2 - maxLabelHeight;
  } else {
    result = width / 2 - maxLabelWidth;
  }

  return Math.max(result, MINIMUM_RADIUS);
}

function getRadian(startAngle, endAngle, drawingStartAngle, needCalculateByHalf) {
  var degree = needCalculateByHalf ? (endAngle + startAngle) / 2 : startAngle;
  return calculateDegreeToRadian(degree, drawingStartAngle);
}

function getRadialLabelAlign(model, anchor) {
  var needCalculateByHalf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var _model$totalAngle = model.totalAngle,
      totalAngle = _model$totalAngle === void 0 ? DEGREE_360 : _model$totalAngle,
      _model$degree = model.degree,
      start = _model$degree.start,
      end = _model$degree.end,
      _model$drawingStartAn = model.drawingStartAngle,
      drawingStartAngle = _model$drawingStartAn === void 0 ? DEGREE_NEGATIVE_90 : _model$drawingStartAn;
  var textAlign = 'center';

  if (anchor !== 'outer') {
    return textAlign;
  }

  var radian0 = calculateDegreeToRadian(0, drawingStartAngle);
  var halfRadian = calculateDegreeToRadian(totalAngle / 2, drawingStartAngle);
  var radian = getRadian(start, end, drawingStartAngle, needCalculateByHalf);

  if (drawingStartAngle >= DEGREE_NEGATIVE_90 && drawingStartAngle < DEGREE_90) {
    if (radian0 < radian && halfRadian > radian) {
      textAlign = 'left';
    } else if (halfRadian < radian) {
      textAlign = 'right';
    }
  } else if (radian0 < radian && halfRadian > radian) {
    textAlign = 'right';
  } else if (halfRadian < radian) {
    textAlign = 'left';
  }

  return textAlign;
}
function getRadiusRanges(radiusRanges, padding) {
  return radiusRanges.reduce(function (acc, cur, index) {
    if (index) {
      acc.push({
        inner: cur + padding,
        outer: radiusRanges[index - 1] - padding
      });
    }

    if (index === radiusRanges.length - 1) {
      acc.push({
        inner: padding,
        outer: cur - padding
      });
    }

    return acc;
  }, []);
} // Recalculate to an angle between 0 and 360 degrees.

function calculateValidAngle(angle) {
  if (angle < DEGREE_0) {
    return DEGREE_360 + angle % DEGREE_360;
  }

  if (angle > DEGREE_360) {
    return angle % DEGREE_360;
  }

  return angle;
}
;// CONCATENATED MODULE: ./src/brushes/basic.ts





var circleStyle = {
  default: {
    strokeStyle: '#ffffff',
    lineWidth: 2
  },
  plot: {
    lineWidth: 1,
    strokeStyle: 'rgba(0, 0, 0, 0.05)'
  }
};
var rectStyle = {
  shadow: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetX: 2,
    shadowOffsetY: 2,
    shadowBlur: 6
  }
};
function clipRectArea(ctx, clipRectAreaModel) {
  var x = clipRectAreaModel.x,
      y = clipRectAreaModel.y,
      width = clipRectAreaModel.width,
      height = clipRectAreaModel.height;
  ctx.beginPath();
  ctx.rect(x, y, width, height);
  ctx.clip();
}
function pathRect(ctx, pathRectModel) {
  var x = pathRectModel.x,
      y = pathRectModel.y,
      width = pathRectModel.width,
      height = pathRectModel.height,
      _pathRectModel$radius = pathRectModel.radius,
      radius = _pathRectModel$radius === void 0 ? 0 : _pathRectModel$radius,
      _pathRectModel$stroke = pathRectModel.stroke,
      strokeStyle = _pathRectModel$stroke === void 0 ? 'black' : _pathRectModel$stroke,
      _pathRectModel$fill = pathRectModel.fill,
      fill = _pathRectModel$fill === void 0 ? '' : _pathRectModel$fill,
      _pathRectModel$lineWi = pathRectModel.lineWidth,
      lineWidth = _pathRectModel$lineWi === void 0 ? 1 : _pathRectModel$lineWi;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();

  if (fill) {
    fillStyle(ctx, fill);
  }

  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
}
function circle(ctx, circleModel) {
  var x = circleModel.x,
      y = circleModel.y,
      style = circleModel.style,
      radius = circleModel.radius,
      color = circleModel.color,
      _circleModel$angle = circleModel.angle,
      angle = _circleModel$angle === void 0 ? {
    start: 0,
    end: Math.PI * 2
  } : _circleModel$angle,
      lineWidth = circleModel.borderWidth,
      strokeStyle = circleModel.borderColor;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, circleStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  ctx.arc(x, y, radius, angle.start, angle.end, true);
  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  fillStyle(ctx, color);
  ctx.closePath();
}
function line(ctx, lineModel) {
  var x = lineModel.x,
      y = lineModel.y,
      x2 = lineModel.x2,
      y2 = lineModel.y2,
      strokeStyle = lineModel.strokeStyle,
      lineWidth = lineModel.lineWidth,
      dashSegments = lineModel.dashSegments;
  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  ctx.moveTo(x, y);
  ctx.lineTo(x2, y2);
  strokeWithOptions(ctx, {
    strokeStyle: strokeStyle,
    lineWidth: lineWidth
  });
  ctx.closePath();
}
function rect(ctx, model) {
  var x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      style = model.style,
      _model$thickness = model.thickness,
      thickness = _model$thickness === void 0 ? 0 : _model$thickness,
      color = model.color,
      _model$borderColor = model.borderColor,
      borderColor = _model$borderColor === void 0 ? '#ffffff' : _model$borderColor;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, rectStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (thickness) {
    ctx.fillStyle = borderColor;
    ctx.fillRect(x - thickness, y - thickness, width + thickness * 2, height + thickness * 2);
    ctx.shadowColor = 'rgba(0, 0, 0, 0)'; // reset shadow color
  }

  ctx.rect(x, y, width, height);
  fillStyle(ctx, color);
}
function arc(ctx, arcModel) {
  var x = arcModel.x,
      y = arcModel.y,
      _arcModel$angle = arcModel.angle,
      start = _arcModel$angle.start,
      end = _arcModel$angle.end,
      lineWidth = arcModel.borderWidth,
      strokeStyle = arcModel.borderColor,
      drawingStartAngle = arcModel.drawingStartAngle,
      radius = arcModel.radius,
      _arcModel$clockwise = arcModel.clockwise,
      clockwise = _arcModel$clockwise === void 0 ? true : _arcModel$clockwise;
  ctx.beginPath();
  var startRadian = calculateDegreeToRadian(start, drawingStartAngle);
  var endRadian = calculateDegreeToRadian(end, drawingStartAngle);
  ctx.arc(x, y, radius, startRadian, endRadian, !clockwise);
  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
}
;// CONCATENATED MODULE: ./src/brushes/axis.ts

var TICK_SIZE = 5;
function tick(ctx, tickModel) {
  var x = tickModel.x,
      y = tickModel.y,
      isYAxis = tickModel.isYAxis,
      _tickModel$tickSize = tickModel.tickSize,
      tickSize = _tickModel$tickSize === void 0 ? TICK_SIZE : _tickModel$tickSize,
      strokeStyle = tickModel.strokeStyle,
      lineWidth = tickModel.lineWidth;
  var lineModel = {
    type: 'line',
    x: x,
    y: y,
    x2: x,
    y2: y,
    strokeStyle: strokeStyle,
    lineWidth: lineWidth
  };

  if (isYAxis) {
    lineModel.x2 += tickSize;
  } else {
    lineModel.y2 += tickSize;
  }

  line(ctx, lineModel);
}
;// CONCATENATED MODULE: ./src/helpers/calculator.ts
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || calculator_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function calculator_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return calculator_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return calculator_arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return calculator_arrayLikeToArray(arr); }

function calculator_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



















var LINE_HEIGHT_NORMAL = 1.2;
var ctx = document.createElement('canvas').getContext('2d');
function getTextWidth(text) {
  var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LABEL_TEXT;
  ctx.font = font;
  return Math.ceil(ctx.measureText(text).width);
}
/*
 * Calculate height of canvas text
 * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics
 * */

function getTextHeight(text) {
  var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LABEL_TEXT;
  ctx.font = font;

  var _ctx$measureText = ctx.measureText(text),
      actualBoundingBoxAscent = _ctx$measureText.actualBoundingBoxAscent,
      actualBoundingBoxDescent = _ctx$measureText.actualBoundingBoxDescent;

  var validActualBoundingBox = isNumber(actualBoundingBoxAscent) && isNumber(actualBoundingBoxDescent);
  return validActualBoundingBox ? Math.ceil(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent)) + 1 : getFontHeight(font);
}
function getFontHeight() {
  var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_LABEL_TEXT;
  var fontSize = font.match(/\d+(?=px)/);
  return parseInt(String(Number(fontSize) * LINE_HEIGHT_NORMAL), 10);
}
function getAxisLabelAnchorPoint(labelHeight) {
  return crispPixel(TICK_SIZE * 2 + labelHeight / 2);
}

function getDecimalLength(value) {
  var _String$split$1$lengt, _String$split$;

  return (_String$split$1$lengt = (_String$split$ = String(value).split('.')[1]) === null || _String$split$ === void 0 ? void 0 : _String$split$.length) !== null && _String$split$1$lengt !== void 0 ? _String$split$1$lengt : 0;
}

function findMultipleNum() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var underPointLens = args.map(function (value) {
    return getDecimalLength(value);
  });
  var underPointLen = Math.max.apply(Math, _toConsumableArray(underPointLens));
  return Math.pow(10, underPointLen);
}

function add(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return (a * multipleNum + b * multipleNum) / multipleNum;
}
function multiply(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return a * multipleNum * (b * multipleNum) / (multipleNum * multipleNum);
}
function divide(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return a * multipleNum / (b * multipleNum);
}
function calculator_sum(values) {
  var copyArr = values.slice();
  copyArr.unshift(0);
  return copyArr.reduce(function (base, value) {
    return add(parseFloat(String(base)), parseFloat(String(value)));
  });
}
function divisors(value) {
  var result = [];

  for (var a = 2, b; a * a <= value; a += 1) {
    if (value % a === 0) {
      b = value / a;
      result.push(a);

      if (b !== a) {
        result.push(b);
      }
    }
  }

  return result.sort(function (prev, next) {
    return prev - next;
  });
}
function makeLabelsFromLimit(limit, stepSize, isDateType) {
  var multipleNum = findMultipleNum(stepSize);
  var min = Math.round(limit.min * multipleNum);
  var max = Math.round(limit.max * multipleNum);
  var labels = range(min, max + 1, stepSize * multipleNum);
  return labels.map(function (label) {
    return String(isDateType ? new Date(label) : label / multipleNum);
  });
}
function makeTickPixelPositions(size, count) {
  var additionalPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var remainLastBlockIntervalPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var positions = [];

  if (count > 0) {
    positions = range(0, count).map(function (index) {
      var ratio = index === 0 ? 0 : index / (count - 1);
      return ratio * size + additionalPosition;
    });
  }

  if (remainLastBlockIntervalPosition) {
    positions.push(remainLastBlockIntervalPosition);
  }

  return positions;
}
function crispPixel(pixel) {
  var thickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var halfThickness = thickness / 2;
  return thickness % 2 ? (isInteger(pixel) ? pixel : Math.round(pixel - halfThickness)) + halfThickness : Math.round(pixel);
}

function getControlPoints(prev, cur, next) {
  // http://scaledinnovation.com/analytics/splines/aboutSplines.html
  var TENSION = 0.333;
  var x0 = prev.x,
      y0 = prev.y;
  var x1 = cur.x,
      y1 = cur.y;
  var x2 = next.x,
      y2 = next.y;
  var d12 = getDistance(next, cur);
  var d01 = getDistance(cur, prev);
  var fa = TENSION * d01 / (d01 + d12) || 0; // scaling factor for triangle Ta

  var fb = TENSION * d12 / (d01 + d12) || 0; // ditto for Tb, simplifies to fb=t-fa

  return {
    prev: {
      x: x1 - fa * (x2 - x0),
      // x2-x0 is the width of triangle T
      y: y1 - fa * (y2 - y0) // y2-y0 is the height of T

    },
    next: {
      x: x1 + fb * (x2 - x0),
      y: y1 + fb * (y2 - y0)
    }
  };
}

function setSplineControlPoint(points) {
  for (var i = 0, pointsSize = points.length, prev = points[0]; i < pointsSize; i += 1) {
    var point = points[i];

    if (isNull(point)) {
      prev = points[i + 1];
      continue;
    }

    var next = points[Math.min(i + 1, pointsSize - 1) % pointsSize];

    if (prev && next) {
      point.controlPoint = getControlPoints(prev, point, next);
    }

    prev = point;
  }
}
function getValueRatio(value, _ref) {
  var min = _ref.min,
      max = _ref.max;

  if (max === min) {
    return 0;
  }

  return (value - min) / (max - min);
}
function getDistance(point1, point2) {
  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
}
function getMaxLengthLabelWidth(labels) {
  var maxLengthLabel = labels.reduce(function (acc, cur) {
    return acc.length > cur.length ? acc : cur;
  }, '');
  return getTextWidth(maxLengthLabel);
}
function getXPosition(axisData, offsetSize, value, dataIndex) {
  var pointOnColumn = axisData.pointOnColumn,
      tickDistance = axisData.tickDistance,
      labelRange = axisData.labelRange;
  var x;

  if (labelRange) {
    var xValue = utils_isString(value) ? Number(new Date(value)) : Number(value);
    var xValueRatio = getValueRatio(xValue, labelRange);
    x = xValueRatio * offsetSize;
  } else {
    x = tickDistance * dataIndex + (pointOnColumn ? tickDistance / 2 : 0);
  }

  return x;
}
;// CONCATENATED MODULE: ./src/helpers/arrayUtil.ts














function arrayUtil_slicedToArray(arr, i) { return arrayUtil_arrayWithHoles(arr) || arrayUtil_iterableToArrayLimit(arr, i) || arrayUtil_unsupportedIterableToArray(arr, i) || arrayUtil_nonIterableRest(); }

function arrayUtil_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function arrayUtil_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function arrayUtil_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function arrayUtil_toConsumableArray(arr) { return arrayUtil_arrayWithoutHoles(arr) || arrayUtil_iterableToArray(arr) || arrayUtil_unsupportedIterableToArray(arr) || arrayUtil_nonIterableSpread(); }

function arrayUtil_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function arrayUtil_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return arrayUtil_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayUtil_arrayLikeToArray(o, minLen); }

function arrayUtil_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function arrayUtil_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return arrayUtil_arrayLikeToArray(arr); }

function arrayUtil_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function max(arr, condition, context) {
  var result;

  if (!condition) {
    result = Math.max.apply(Math, arrayUtil_toConsumableArray(arr));
  } else {
    var _arr2 = arrayUtil_slicedToArray(arr, 1);

    result = _arr2[0];
    var rest = arr.slice(1);
    var maxValue = condition.call(context, result, 0);
    rest.forEach(function (item, index) {
      var compareValue = condition.call(context, item, index + 1);

      if (compareValue > maxValue) {
        maxValue = compareValue;
        result = item;
      }
    });
  }

  return result;
}
/**
 * Array pivot.
 * @memberOf module:arrayUtil
 * @param {Array.<Array>} arr2d target 2d array
 * @returns {Array.<Array>} pivoted 2d array
 */

function pivot(arr2d) {
  var result = [];
  var len = max(arr2d.map(function (arr) {
    return arr.length;
  }));
  arr2d.forEach(function (arr) {
    for (var index = 0; index < len; index += 1) {
      if (!result[index]) {
        result[index] = [];
      }

      result[index].push(arr[index]);
    }
  });
  return result;
}
function isSameArray(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (var i = 0; i < arr1.length; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}
function pluck(arr, property) {
  return arr.reduce(function (acc, cur) {
    return [].concat(arrayUtil_toConsumableArray(acc), [cur[property]]);
  }, []);
}
;// CONCATENATED MODULE: ./src/component/component.ts
function component_toConsumableArray(arr) { return component_arrayWithoutHoles(arr) || component_iterableToArray(arr) || component_unsupportedIterableToArray(arr) || component_nonIterableSpread(); }

function component_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_arrayLikeToArray(o, minLen); }

function component_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function component_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_arrayLikeToArray(arr); }

function component_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function component_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_ownKeys(Object(source), true).forEach(function (key) { component_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





















function component_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function component_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function component_createClass(Constructor, protoProps, staticProps) { if (protoProps) component_defineProperties(Constructor.prototype, protoProps); if (staticProps) component_defineProperties(Constructor, staticProps); return Constructor; }

function component_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var Component = /*#__PURE__*/function () {
  function Component(_ref) {
    var store = _ref.store,
        eventBus = _ref.eventBus;

    component_classCallCheck(this, Component);

    component_defineProperty(this, "name", 'Component');

    component_defineProperty(this, "type", 'component');

    component_defineProperty(this, "rect", {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    });

    component_defineProperty(this, "isShow", true);

    component_defineProperty(this, "selectable", void 0);

    component_defineProperty(this, "store", void 0);

    component_defineProperty(this, "eventBus", void 0);

    component_defineProperty(this, "models", void 0);

    component_defineProperty(this, "drawModels", void 0);

    component_defineProperty(this, "responders", void 0);

    component_defineProperty(this, "activeSeriesMap", void 0);

    this.store = store;
    this.eventBus = eventBus;
  }

  component_createClass(Component, [{
    key: "update",
    value: function update(delta) {
      var _this = this;

      if (!this.drawModels) {
        return;
      }

      if (Array.isArray(this.models)) {
        this.updateModels(this.drawModels, this.models, delta);
      } else {
        Object.keys(this.models).forEach(function (type) {
          var currentModels = _this.drawModels[type];
          var targetModels = _this.models[type];

          _this.updateModels(currentModels, targetModels, delta);
        });
      }
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.update(delta);
    }
  }, {
    key: "updateModels",
    value: function updateModels(currentModels, targetModels, delta) {
      var _this2 = this;

      currentModels.forEach(function (current, index) {
        var target = targetModels[index];
        Object.keys(current).forEach(function (key) {
          if (!current || !target) {
            return;
          }

          if (key[0] !== '_') {
            if (isNumber(current[key])) {
              current[key] = current[key] + (target[key] - current[key]) * delta;
            } else if (key === 'points') {
              var _this2$store$state$op;

              var matchedModel = _this2.getCurrentModelToMatchTargetModel(current[key], current[key], target[key]);

              var newPoints = matchedModel.map(function (curPoint, idx) {
                var next = target[key][idx];

                if (curPoint && next) {
                  var x = curPoint.x,
                      y = curPoint.y;
                  var nextX = next.x,
                      nextY = next.y;
                  return component_objectSpread(component_objectSpread({}, next), {}, {
                    x: x + (nextX - x) * delta,
                    y: y + (nextY - y) * delta
                  });
                }

                return next;
              });

              if ((_this2$store$state$op = _this2.store.state.options.series) !== null && _this2$store$state$op !== void 0 && _this2$store$state$op.spline) {
                setSplineControlPoint(newPoints);
              }

              current[key] = newPoints;
            } else {
              current[key] = target[key];
            }
          }
        });
      });
    }
  }, {
    key: "sync",
    value: function sync() {
      var _this3 = this;

      if (!this.drawModels) {
        return;
      }

      if (Array.isArray(this.models)) {
        this.syncModels(this.drawModels, this.models);
      } else if (!Object.keys(this.models).length) {
        this.drawModels = this.models;
      } else {
        Object.keys(this.models).forEach(function (type) {
          var currentModels = _this3.drawModels[type];
          var targetModels = _this3.models[type];

          _this3.syncModels(currentModels, targetModels, type);
        });
      }
    }
  }, {
    key: "getCurrentModelToMatchTargetModel",
    value: function getCurrentModelToMatchTargetModel(models, currentModels, targetModels) {
      var _getFirstValidValue;

      if (!models || !currentModels) {
        return component_toConsumableArray(targetModels);
      }

      if ((_getFirstValidValue = getFirstValidValue(targetModels)) !== null && _getFirstValidValue !== void 0 && _getFirstValidValue.name) {
        var modelNames = component_toConsumableArray(new Set(models.map(function (_ref2) {
          var name = _ref2.name;
          return name;
        })));

        var targetNames = component_toConsumableArray(new Set(targetModels.map(function (_ref3) {
          var name = _ref3.name;
          return name;
        })));

        var same = isSameArray(modelNames, targetNames);

        if (!same) {
          return this.getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames);
        }
      }

      var currentLength = currentModels.length;
      var targetLength = targetModels.length;

      if (currentLength < targetLength) {
        return [].concat(component_toConsumableArray(currentModels), component_toConsumableArray(targetModels.slice(currentLength, targetLength)));
      }

      if (currentLength > targetLength) {
        return currentModels.slice(0, targetLength);
      }

      return models;
    }
  }, {
    key: "getCurrentModelWithDifferentModel",
    value: function getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames) {
      var currentLength = currentModels.length;
      var targetLength = targetModels.length;

      if (currentLength > targetLength) {
        var newModels = models.filter(function (_ref4) {
          var name = _ref4.name;
          return includes(targetNames, name);
        });
        return newModels.length !== targetModels.length ? targetModels : newModels;
      }

      if (currentLength < targetLength) {
        var notIncludedModels = targetModels.reduce(function (acc, cur, idx) {
          var notIncluded = !includes(modelNames, cur.name);
          return notIncluded ? {
            models: [].concat(component_toConsumableArray(acc.models), [cur]),
            modelIdx: [].concat(component_toConsumableArray(acc.modelIdx), [idx])
          } : acc;
        }, {
          models: [],
          modelIdx: []
        });

        if (models.length + notIncludedModels.models.length === targetLength) {
          var _newModels = component_toConsumableArray(models);

          notIncludedModels.models.forEach(function (model, idx) {
            _newModels.splice(notIncludedModels.modelIdx[idx], 0, model);
          });
          return _newModels;
        }

        return targetModels;
      }

      return models;
    }
  }, {
    key: "syncModels",
    value: function syncModels(currentModels, targetModels, type) {
      var drawModels = type ? this.drawModels[type] : this.drawModels;
      var model = this.getCurrentModelToMatchTargetModel(drawModels, currentModels, targetModels);

      if (type) {
        this.drawModels[type] = model;
      } else {
        this.drawModels = model;
      }
    }
  }, {
    key: "getSelectableOption",
    value: function getSelectableOption(options) {
      var _options$series$selec, _options$series;

      return (_options$series$selec = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.selectable) !== null && _options$series$selec !== void 0 ? _options$series$selec : false;
    }
  }, {
    key: "renderDataLabels",
    value: function renderDataLabels(data, name) {
      var _this4 = this;

      setTimeout(function () {
        _this4.eventBus.emit('renderDataLabels', {
          data: data,
          name: name !== null && name !== void 0 ? name : _this4.name
        });
      }, 0);
    }
  }, {
    key: "draw",
    value: function draw(painter) {
      var models = this.drawModels ? this.drawModels : this.models;

      if (Array.isArray(models)) {
        painter.paintForEach(models);
      } else if (models) {
        Object.keys(models).forEach(function (item) {
          painter.paintForEach(models[item]);
        });
      }
    }
  }]);

  return Component;
}();


;// CONCATENATED MODULE: ./src/component/axis.ts
function axis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axis_typeof = function _typeof(obj) { return typeof obj; }; } else { axis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axis_typeof(obj); }

function axis_toConsumableArray(arr) { return axis_arrayWithoutHoles(arr) || axis_iterableToArray(arr) || axis_unsupportedIterableToArray(arr) || axis_nonIterableSpread(); }

function axis_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axis_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axis_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axis_arrayLikeToArray(o, minLen); }

function axis_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function axis_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axis_arrayLikeToArray(arr); }

function axis_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axis_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function axis_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axis_ownKeys(Object(source), true).forEach(function (key) { axis_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axis_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






















function axis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axis_createClass(Constructor, protoProps, staticProps) { if (protoProps) axis_defineProperties(Constructor.prototype, protoProps); if (staticProps) axis_defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (axis_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function axis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var AxisType;

(function (AxisType) {
  AxisType["X"] = "xAxis";
  AxisType["Y"] = "yAxis";
  AxisType["SECONDARY_Y"] = "secondaryYAxis";
  AxisType["CIRCULAR"] = "circularAxis";
  AxisType["VERTICAL"] = "verticalAxis";
})(AxisType || (AxisType = {}));

function getOffsetAndAnchorKey(hasBasedYAxis) {
  return {
    offsetKey: hasBasedYAxis ? 'y' : 'x',
    anchorKey: hasBasedYAxis ? 'x' : 'y'
  };
}

var Axis = /*#__PURE__*/function (_Component) {
  _inherits(Axis, _Component);

  var _super = _createSuper(Axis);

  function Axis() {
    var _this;

    axis_classCallCheck(this, Axis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axis_defineProperty(_assertThisInitialized(_this), "models", {
      label: [],
      tick: [],
      axisLine: []
    });

    axis_defineProperty(_assertThisInitialized(_this), "drawModels", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "yAxisComponent", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "theme", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "axisSize", 0);

    return _this;
  }

  axis_createClass(Axis, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axis';
      this.name = name;
      this.yAxisComponent = includes([AxisType.Y, AxisType.SECONDARY_Y], name);
    }
  }, {
    key: "render",
    value: function render(_ref2) {
      var _this2 = this;

      var layout = _ref2.layout,
          axes = _ref2.axes,
          theme = _ref2.theme,
          scale = _ref2.scale;

      if (axes.centerYAxis || !axes[this.name]) {
        return;
      }

      this.theme = getAxisTheme(theme, this.name);
      this.rect = layout[this.name];
      this.axisSize = this.yAxisComponent ? this.rect.height : this.rect.width;
      var viewLabels = axes[this.name].viewLabels;

      var _getOffsetAndAnchorKe = getOffsetAndAnchorKey(this.yAxisComponent),
          offsetKey = _getOffsetAndAnchorKe.offsetKey,
          anchorKey = _getOffsetAndAnchorKe.anchorKey;

      var renderOptions = this.makeRenderOptions(axes[this.name], scale === null || scale === void 0 ? void 0 : scale[this.name]);
      var hasOnlyAxisLine = this.hasOnlyAxisLine();

      if (!hasOnlyAxisLine) {
        this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
        this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
      }

      this.models.axisLine = [this.renderAxisLineModel()];

      if (!this.drawModels) {
        this.drawModels = {
          tick: [],
          label: [],
          axisLine: this.models.axisLine
        };
        ['tick', 'label'].forEach(function (type) {
          _this2.drawModels[type] = _this2.models[type].map(function (m) {
            var drawModel = axis_objectSpread({}, m);

            if (_this2.yAxisComponent) {
              drawModel.y = 0;
            } else {
              drawModel.x = 0;
            }

            return drawModel;
          });
        });
      }
    }
  }, {
    key: "renderAxisLineModel",
    value: function renderAxisLineModel() {
      var zeroPixel = crispPixel(0);
      var lineModel;
      var _this$theme = this.theme,
          strokeStyle = _this$theme.color,
          lineWidth = _this$theme.width;

      if (this.yAxisComponent) {
        var x = this.getYAxisXPoint();
        lineModel = {
          type: 'line',
          x: x,
          y: zeroPixel,
          x2: x,
          y2: crispPixel(this.axisSize),
          strokeStyle: strokeStyle,
          lineWidth: lineWidth
        };
      } else {
        lineModel = {
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: crispPixel(this.axisSize),
          y2: zeroPixel,
          strokeStyle: strokeStyle,
          lineWidth: lineWidth
        };
      }

      return lineModel;
    }
  }, {
    key: "renderTickModels",
    value: function renderTickModels(offsetKey, anchorKey, renderOptions) {
      var _this3 = this;

      var tickAnchorPoint = this.yAxisComponent ? this.getYAxisXPoint() : crispPixel(0);
      var tickInterval = renderOptions.tickInterval,
          relativePositions = renderOptions.relativePositions;
      var tickSize = includes([AxisType.SECONDARY_Y, AxisType.X], this.name) ? TICK_SIZE : -TICK_SIZE;
      return relativePositions.reduce(function (positions, position, index) {
        var _ref3;

        return index % tickInterval ? positions : [].concat(axis_toConsumableArray(positions), [(_ref3 = {
          type: 'tick',
          isYAxis: _this3.yAxisComponent,
          tickSize: tickSize
        }, axis_defineProperty(_ref3, offsetKey, crispPixel(position)), axis_defineProperty(_ref3, anchorKey, tickAnchorPoint), axis_defineProperty(_ref3, "strokeStyle", _this3.theme.color), axis_defineProperty(_ref3, "lineWidth", _this3.theme.width), _ref3)]);
      }, []);
    }
  }, {
    key: "renderLabelModels",
    value: function renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
      var needRotateLabel = renderOptions.needRotateLabel,
          radian = renderOptions.radian,
          offsetY = renderOptions.offsetY;
      var labelTheme = this.theme.label;
      var font = getTitleFontString(labelTheme);
      var textAlign = this.getLabelTextAlign(needRotateLabel);
      var style = ['default', {
        textAlign: textAlign,
        font: font,
        fillStyle: labelTheme.color
      }];
      var labelAnchorPoint = this.yAxisComponent ? this.getYAxisAnchorPoint() : offsetY;
      return labels.map(function (_ref4) {
        var _ref5;

        var text = _ref4.text,
            offsetPos = _ref4.offsetPos;
        return _ref5 = {
          type: 'label',
          text: text,
          style: style,
          radian: radian
        }, axis_defineProperty(_ref5, offsetKey, crispPixel(offsetPos)), axis_defineProperty(_ref5, anchorKey, labelAnchorPoint), _ref5;
      });
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(axisData, scale) {
      var _scale$sizeRatio, _scale$positionRatio;

      var tickCount = axisData.tickCount,
          tickInterval = axisData.tickInterval;
      var sizeRatio = (_scale$sizeRatio = scale === null || scale === void 0 ? void 0 : scale.sizeRatio) !== null && _scale$sizeRatio !== void 0 ? _scale$sizeRatio : 1;
      var positionRatio = (_scale$positionRatio = scale === null || scale === void 0 ? void 0 : scale.positionRatio) !== null && _scale$positionRatio !== void 0 ? _scale$positionRatio : 0;
      var relativePositions = makeTickPixelPositions(this.axisSize * sizeRatio, tickCount, this.axisSize * positionRatio);

      if (this.yAxisComponent) {
        return {
          relativePositions: relativePositions,
          tickInterval: tickInterval
        };
      }

      var needRotateLabel = axisData.needRotateLabel,
          radian = axisData.radian,
          offsetY = axisData.offsetY;
      return {
        relativePositions: relativePositions,
        tickInterval: tickInterval,
        needRotateLabel: needRotateLabel,
        radian: radian,
        offsetY: offsetY
      };
    }
  }, {
    key: "getYAxisAnchorPoint",
    value: function getYAxisAnchorPoint() {
      return this.isRightSide() ? crispPixel(this.rect.width) : crispPixel(0);
    }
  }, {
    key: "getLabelTextAlign",
    value: function getLabelTextAlign(needRotateLabel) {
      var yAxisTextAlign = this.isRightSide() ? 'right' : 'left';
      var xAxisTextAlign = needRotateLabel ? 'left' : 'center';
      return this.yAxisComponent ? yAxisTextAlign : xAxisTextAlign;
    }
  }, {
    key: "isRightSide",
    value: function isRightSide() {
      return this.name === AxisType.SECONDARY_Y;
    }
  }, {
    key: "getYAxisXPoint",
    value: function getYAxisXPoint() {
      return this.isRightSide() ? crispPixel(0) : crispPixel(this.rect.width);
    }
  }, {
    key: "hasOnlyAxisLine",
    value: function hasOnlyAxisLine() {
      return this.yAxisComponent && !this.rect.width || this.name === AxisType.X && !this.rect.height;
    }
  }]);

  return Axis;
}(Component);


;// CONCATENATED MODULE: ./src/helpers/geometric.ts
var RAD = Math.PI / 180;
var ANGLE_90 = 90;
var ANGLE_CANDIDATES = [0, 25, 45, 65, 85, 90];
/**
 * Calculate adjacent.
 *
 *   H : Hypotenuse
 *   A : Adjacent
 *   O : Opposite
 *   D : Degree
 *
 *        /|
 *       / |
 *    H /  | O
 *     /   |
 *    /\ D |
 *    -----
 *       A
 */

function calculateAdjacent(degree, hypotenuse) {
  return Math.cos(degree * RAD) * hypotenuse;
}

function calculateOpposite(degree, hypotenuse) {
  return Math.sin(degree * RAD) * hypotenuse;
}

function calculateRotatedWidth(degree, width, height) {
  var centerHalf = calculateAdjacent(degree, width / 2);
  var sideHalf = calculateAdjacent(ANGLE_90 - degree, height / 2);
  return (centerHalf + sideHalf) * 2;
}
function calculateRotatedHeight(degree, width, height) {
  var centerHalf = calculateOpposite(degree, width / 2);
  var sideHalf = calculateOpposite(ANGLE_90 - degree, height / 2);
  return (centerHalf + sideHalf) * 2;
}
;// CONCATENATED MODULE: ./src/helpers/formatDate.ts



// https://github.com/nhn/tui.code-snippet/blob/master/formatDate/formatDate.js

var DEFAULT_DATE_FORMAT = 'YY-MM-DD hh:mm:ss';
function getDateFormat(date) {
  if (!date) {
    return;
  }

  return isObject(date) ? date.format : DEFAULT_DATE_FORMAT;
}
var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*mm|[\\]*m|[\\]*ss|[\\]*s|[\\]*A/gi;
var MONTH_STR = ['Invalid month', 'January', 'February', 'March', 'April', 'May', 'Jun', 'Jul', 'August', 'September', 'October', 'November', 'December'];
var MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var replaceMap = {
  M: function M(date) {
    return Number(date.month);
  },
  MM: function MM(date) {
    var month = date.month;
    return Number(month) < 10 ? "0".concat(month) : month;
  },
  MMM: function MMM(date) {
    return MONTH_STR[Number(date.month)].substr(0, 3);
  },
  MMMM: function MMMM(date) {
    return MONTH_STR[Number(date.month)];
  },
  D: function D(date) {
    return Number(date.date);
  },
  d: function d(date) {
    return replaceMap.D(date);
  },
  // eslint-disable-line new-cap
  DD: function DD(date) {
    var dayInMonth = date.date;
    return Number(dayInMonth) < 10 ? "0".concat(dayInMonth) : dayInMonth;
  },
  dd: function dd(date) {
    return replaceMap.DD(date);
  },
  // eslint-disable-line new-cap
  YY: function YY(date) {
    return Number(date.year) % 100;
  },
  yy: function yy(date) {
    return replaceMap.YY(date);
  },
  // eslint-disable-line new-cap
  YYYY: function YYYY(date) {
    var prefix = '20';
    var year = date.year;

    if (year > 69 && year < 100) {
      prefix = '19';
    }

    return Number(year) < 100 ? prefix + String(year) : year;
  },
  yyyy: function yyyy(date) {
    return replaceMap.YYYY(date);
  },
  // eslint-disable-line new-cap
  A: function A(date) {
    return date.meridiem;
  },
  a: function a(date) {
    return date.meridiem;
  },
  hh: function hh(date) {
    var hour = date.hour;
    return Number(hour) < 10 ? '0' + hour : hour;
  },
  HH: function HH(date) {
    return replaceMap.hh(date);
  },
  h: function h(date) {
    return String(Number(date.hour));
  },
  H: function H(date) {
    return replaceMap.h(date);
  },
  m: function m(date) {
    return String(Number(date.minute));
  },
  mm: function mm(date) {
    var minute = date.minute;
    return Number(minute) < 10 ? "0".concat(minute) : minute;
  },
  s: function s(date) {
    return String(Number(date.second));
  },
  ss: function ss(date) {
    var second = date.second;
    return Number(second) < 10 ? "0".concat(second) : second;
  }
};

function isLeapYear(month, year) {
  return month === 2 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function isValidDate(y, m, d) {
  var year = Number(y);
  var month = Number(m);
  var date = Number(d);
  var isValidYear = year > -1 && year < 100 || year > 1969 && year < 2070;
  var isValidMonth = month > 0 && month < 13;

  if (!isValidYear || !isValidMonth) {
    return false;
  }

  var lastDayInMonth = isLeapYear(month, year) ? 29 : MONTH_DAYS[month];
  return date > 0 && date <= lastDayInMonth;
}
/*
 * key             | Shorthand
 * --------------- |-----------------------
 * years           | YY / YYYY / yy / yyyy
 * months(n)       | M / MM
 * months(str)     | MMM / MMMM
 * days            | D / DD / d / dd
 * hours           | H / HH / h / hh
 * minutes         | m / mm
 * seconds         | s / ss
 * meridiem(AM,PM) | A / a
 */


function formatDate(form, date, option) {
  var _option$meridiemSet$A;

  var am = (_option$meridiemSet$A = option === null || option === void 0 ? void 0 : option.meridiemSet.AM) !== null && _option$meridiemSet$A !== void 0 ? _option$meridiemSet$A : 'AM';
  var pm = (option === null || option === void 0 ? void 0 : option.meridiemSet.PM) || 'PM';
  var nDate;

  if (isDate(date)) {
    nDate = {
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      date: date.getDate(),
      hour: date.getHours(),
      minute: date.getMinutes(),
      second: date.getSeconds()
    };
  } else {
    var year = date.year,
        month = date.month,
        hour = date.hour,
        minute = date.minute,
        second = date.second;
    nDate = {
      year: year,
      month: month,
      date: date.date,
      hour: hour,
      minute: minute,
      second: second
    };
  }

  if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
    return '';
  }

  nDate.meridiem = '';

  if (/([^\\]|^)[aA]\b/.test(form)) {
    if (nDate.hour > 12) {
      // See the clock system: https://en.wikipedia.org/wiki/12-hour_clock
      nDate.hour %= 12;
    }

    if (nDate.hour === 0) {
      nDate.hour = 12;
    }

    nDate.meridiem = nDate.hour > 11 ? pm : am;
  }

  return form.replace(tokens, function (key) {
    if (key.indexOf('\\') > -1) {
      // escape character
      return key.replace(/\\/, '');
    }

    return replaceMap[key](nDate) || '';
  });
}
;// CONCATENATED MODULE: ./src/helpers/pieSeries.ts








var semiCircleCenterYRatio = {
  COUNTER_CLOCKWISE: 0.1,
  CLOCKWISE: 1
};
function hasClockwiseSemiCircle(clockwise, startAngle, endAngle) {
  return clockwise && (startAngle >= DEGREE_NEGATIVE_90 && endAngle <= DEGREE_90 || startAngle >= DEGREE_90 && endAngle <= DEGREE_180);
}
function hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle) {
  return !clockwise && (startAngle >= DEGREE_NEGATIVE_180 && endAngle <= DEGREE_90 || startAngle <= DEGREE_90 && endAngle >= DEGREE_NEGATIVE_90);
}
function getRadius(defaultRadius, radius) {
  return isString(radius) ? Number((defaultRadius * getPercentageValue(radius) / 100).toFixed(2)) : radius;
}
function getTotalAngle(clockwise, startAngle, endAngle) {
  var diffAngle = endAngle - startAngle;
  var absDiff = Math.abs(diffAngle);
  var needSubstractAngle = diffAngle > DEGREE_0 && absDiff !== DEGREE_360 && !clockwise || diffAngle < DEGREE_0 && absDiff !== DEGREE_360 && clockwise;
  return needSubstractAngle ? DEGREE_360 - absDiff : absDiff;
}
function isSemiCircle(clockwise, startAngle, endAngle) {
  return getTotalAngle(clockwise, startAngle, endAngle) <= DEGREE_180 && (hasClockwiseSemiCircle(clockwise, startAngle, endAngle) || hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle));
}
function getSemiCircleCenterY(rectHeight, clockwise) {
  return clockwise ? rectHeight * semiCircleCenterYRatio.CLOCKWISE : rectHeight * semiCircleCenterYRatio.COUNTER_CLOCKWISE;
}
function makePieTooltipData(seriesRawData) {
  var category = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return seriesRawData.filter(function (_ref) {
    var data = _ref.data;
    return !isNull(data);
  }).map(function (_ref2) {
    var data = _ref2.data,
        name = _ref2.name,
        color = _ref2.color,
        rootParentName = _ref2.rootParentName;
    return {
      label: name,
      color: color,
      value: data,
      category: category,
      rootParentName: rootParentName,
      templateType: 'pie'
    };
  });
}
function hasNestedPieSeries(series) {
  var _series$pie$;

  return !!(series.pie && Array.isArray((_series$pie$ = series.pie[0]) === null || _series$pie$ === void 0 ? void 0 : _series$pie$.data));
}
function getNestedPieChartAliasNames(series) {
  return series.pie.map(function (_ref3) {
    var name = _ref3.name;
    return name;
  });
}
function pieTooltipLabelFormatter(percentValue) {
  var percentageString = percentValue.toFixed(2);
  var percent = parseFloat(percentageString);
  var needSlice = percentageString.length > 5;
  return "".concat(needSlice ? parseFloat(percentageString.substr(0, 4)) : String(percent), "%");
}
function hasOuterDataLabel(options, series) {
  var _options$series, _options$series$dataL;

  return !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : (_options$series$dataL = _options$series.dataLabels) === null || _options$series$dataL === void 0 ? void 0 : _options$series$dataL.anchor) === 'outer';
}
function hasOuterPieSeriesName(options, series) {
  var _options$series2, _options$series2$data, _options$series2$data2;

  return !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : (_options$series2$data2 = _options$series2$data.pieSeriesName) === null || _options$series2$data2 === void 0 ? void 0 : _options$series2$data2.anchor) === 'outer';
}
;// CONCATENATED MODULE: ./src/store/radialAxes.ts





var Y_LABEL_PADDING = 5;
var RADIAL_LABEL_PADDING = 25;
var RadialAxisType;

(function (RadialAxisType) {
  RadialAxisType["CIRCULAR"] = "circularAxis";
  RadialAxisType["VERTICAL"] = "verticalAxis";
})(RadialAxisType || (RadialAxisType = {}));

function getYAxisLabelAlign() {
  var clockwise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var isLabelOnVerticalAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var align = 'center';

  if (isLabelOnVerticalAxis) {
    align = clockwise ? 'right' : 'left';
  }

  return align;
}

function getVerticalAxisData(_ref) {
  var labels = _ref.labels,
      pointOnColumn = _ref.pointOnColumn,
      intervalData = _ref.intervalData,
      isLabelOnVerticalAxis = _ref.isLabelOnVerticalAxis,
      verticalAxisLabelMargin = _ref.verticalAxisLabelMargin,
      verticalAxisLabelFont = _ref.verticalAxisLabelFont,
      defaultAxisData = _ref.defaultAxisData,
      radiusData = _ref.radiusData;
  var clockwise = defaultAxisData.clockwise,
      axisSize = defaultAxisData.axisSize,
      centerX = defaultAxisData.centerX,
      centerY = defaultAxisData.centerY,
      startAngle = defaultAxisData.startAngle,
      endAngle = defaultAxisData.endAngle;
  var radiusRanges = radiusData.radiusRanges,
      innerRadius = radiusData.innerRadius,
      outerRadius = radiusData.outerRadius;
  var labelInterval = intervalData.labelInterval;
  /*
  return {
    labels,
    tickDistance: (outerRadius - innerRadius) / labels.length,
    ...pick(defaultAxisData, 'axisSize', 'centerX', 'centerY', 'startAngle', 'endAngle'),
    pointOnColumn,
    radiusRanges,
    innerRadius,
    outerRadius,
    labelInterval,
    labelMargin: verticalAxisLabelMargin,
    labelAlign: getYAxisLabelAlign(clockwise, isLabelOnVerticalAxis),
    ...getMaxLabelSize(labels, verticalAxisLabelMargin, verticalAxisLabelFont),
  };
  */

  var _getMaxLabelSize = getMaxLabelSize(labels, verticalAxisLabelMargin, verticalAxisLabelFont),
      maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

  return {
    axisSize: axisSize,
    centerX: centerX,
    centerY: centerY,
    label: {
      labels: labels,
      interval: labelInterval,
      margin: verticalAxisLabelMargin,
      maxWidth: maxLabelWidth,
      maxHeight: maxLabelHeight,
      align: getYAxisLabelAlign(clockwise, isLabelOnVerticalAxis)
    },
    radius: {
      inner: innerRadius,
      outer: outerRadius,
      ranges: radiusRanges
    },
    angle: {
      start: startAngle,
      end: endAngle
    },
    tickDistance: (outerRadius - innerRadius) / labels.length,
    pointOnColumn: pointOnColumn
  };
}

function getCircularAxisData(_ref2) {
  var labels = _ref2.labels,
      intervalData = _ref2.intervalData,
      circularAxisLabelMargin = _ref2.circularAxisLabelMargin,
      circularAxisLabelFont = _ref2.circularAxisLabelFont,
      defaultAxisData = _ref2.defaultAxisData,
      radiusData = _ref2.radiusData;

  var _getMaxLabelSize2 = getMaxLabelSize(labels, circularAxisLabelMargin, circularAxisLabelFont),
      maxLabelWidth = _getMaxLabelSize2.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize2.maxLabelHeight;

  var totalAngle = defaultAxisData.totalAngle,
      clockwise = defaultAxisData.clockwise,
      axisSize = defaultAxisData.axisSize,
      centerX = defaultAxisData.centerX,
      centerY = defaultAxisData.centerY,
      startAngle = defaultAxisData.startAngle,
      endAngle = defaultAxisData.endAngle,
      drawingStartAngle = defaultAxisData.drawingStartAngle;
  var tickInterval = intervalData.tickInterval,
      labelInterval = intervalData.labelInterval;
  var innerRadius = radiusData.innerRadius,
      outerRadius = radiusData.outerRadius;
  var centralAngle = totalAngle / (labels.length + (totalAngle < DEGREE_360 ? -1 : DEGREE_0));
  /*
  return {
    labels,
    ...defaultAxisData,
    centralAngle,
    tickInterval,
    labelInterval,
    labelMargin: circularAxisLabelMargin,
    maxLabelWidth,
    maxLabelHeight,
    innerRadius,
    outerRadius,
  };
  */

  return {
    axisSize: axisSize,
    centerX: centerX,
    centerY: centerY,
    label: {
      labels: labels,
      interval: labelInterval,
      margin: circularAxisLabelMargin,
      maxWidth: maxLabelWidth,
      maxHeight: maxLabelHeight
    },
    radius: {
      inner: innerRadius,
      outer: outerRadius
    },
    angle: {
      start: startAngle,
      end: endAngle,
      total: totalAngle,
      central: centralAngle,
      drawingStart: drawingStartAngle
    },
    tickInterval: tickInterval,
    clockwise: clockwise
  };
}

function makeLabels(options, rawLabels, axisName) {
  var _options$axisName$lab, _options$axisName, _options$axisName$lab2;

  var formatter = (_options$axisName$lab = (_options$axisName = options[axisName]) === null || _options$axisName === void 0 ? void 0 : (_options$axisName$lab2 = _options$axisName.label) === null || _options$axisName$lab2 === void 0 ? void 0 : _options$axisName$lab2.formatter) !== null && _options$axisName$lab !== void 0 ? _options$axisName$lab : function (value) {
    return value;
  };
  return rawLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: rawLabels,
      axisName: axisName
    });
  });
}

function getAxisLabels(isLabelOnVerticalAxis, options, categories, scale) {
  var valueAxisName = isLabelOnVerticalAxis ? RadialAxisType.CIRCULAR : RadialAxisType.VERTICAL;
  var _ref3 = scale[valueAxisName],
      limit = _ref3.limit,
      stepSize = _ref3.stepSize;
  var valueLabels = makeLabels(options, makeLabelsFromLimit(limit, stepSize), valueAxisName);
  var categoryLabels = makeLabels(options, categories, isLabelOnVerticalAxis ? RadialAxisType.VERTICAL : RadialAxisType.CIRCULAR);
  return {
    radialAxisLabels: isLabelOnVerticalAxis ? valueLabels : categoryLabels,
    yAxisLabels: isLabelOnVerticalAxis ? categoryLabels : valueLabels
  };
}

function getAxisLabelMargin(isLabelOnVerticalAxis, options) {
  var _verticalAxis$label$m, _verticalAxis, _verticalAxis$label, _options$circularAxis, _options$circularAxis2, _options$circularAxis3;

  return {
    verticalAxisLabelMargin: (_verticalAxis$label$m = options === null || options === void 0 ? void 0 : (_verticalAxis = options.verticalAxis) === null || _verticalAxis === void 0 ? void 0 : (_verticalAxis$label = _verticalAxis.label) === null || _verticalAxis$label === void 0 ? void 0 : _verticalAxis$label.margin) !== null && _verticalAxis$label$m !== void 0 ? _verticalAxis$label$m : isLabelOnVerticalAxis ? Y_LABEL_PADDING : 0,
    circularAxisLabelMargin: (_options$circularAxis = options === null || options === void 0 ? void 0 : (_options$circularAxis2 = options.circularAxis) === null || _options$circularAxis2 === void 0 ? void 0 : (_options$circularAxis3 = _options$circularAxis2.label) === null || _options$circularAxis3 === void 0 ? void 0 : _options$circularAxis3.margin) !== null && _options$circularAxis !== void 0 ? _options$circularAxis : RADIAL_LABEL_PADDING
  };
}

var axes = {
  name: 'radialAxes',
  state: function state() {
    return {
      radialAxes: {}
    };
  },
  action: {
    setRadialAxesData: function setRadialAxesData(_ref4) {
      var _options$series;

      var state = _ref4.state;
      var series = state.series,
          layout = state.layout,
          scale = state.scale;
      var categories = state.categories;
      var plot = layout.plot;
      var isLabelOnVerticalAxis = isLabelAxisOnYAxis({
        series: series,
        categories: categories
      });
      var options = state.options;
      var theme = state.theme;
      var circularAxisLabelFont = getTitleFontString(theme.circularAxis.label);
      var verticalAxisLabelFont = getTitleFontString(theme.verticalAxis.label);

      var _getAxisLabelMargin = getAxisLabelMargin(isLabelOnVerticalAxis, options),
          verticalAxisLabelMargin = _getAxisLabelMargin.verticalAxisLabelMargin,
          circularAxisLabelMargin = _getAxisLabelMargin.circularAxisLabelMargin;

      var _getAxisLabels = getAxisLabels(isLabelOnVerticalAxis, options, categories, scale),
          radialAxisLabels = _getAxisLabels.radialAxisLabels,
          yAxisLabels = _getAxisLabels.yAxisLabels;

      var _getMaxLabelSize3 = getMaxLabelSize(radialAxisLabels, circularAxisLabelMargin, circularAxisLabelFont),
          maxLabelWidth = _getMaxLabelSize3.maxLabelWidth,
          maxLabelHeight = _getMaxLabelSize3.maxLabelHeight;

      var defaultAxisData = getDefaultRadialAxisData(options, plot, maxLabelWidth, maxLabelHeight + circularAxisLabelMargin, isLabelOnVerticalAxis);
      var axisSize = defaultAxisData.axisSize;
      var radiusData = isLabelOnVerticalAxis ? getRadiusInfo(axisSize, options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.radiusRange, yAxisLabels.length + 1) : {
        radiusRanges: makeTickPixelPositions(axisSize, yAxisLabels.length),
        innerRadius: 0,
        outerRadius: axisSize
      };
      var verticalAxisData = getVerticalAxisData({
        labels: yAxisLabels,
        pointOnColumn: isLabelOnVerticalAxis,
        isLabelOnVerticalAxis: isLabelOnVerticalAxis,
        intervalData: getInitAxisIntervalData(isLabelOnVerticalAxis, {
          axis: options.verticalAxis,
          categories: categories,
          layout: layout
        }),
        verticalAxisLabelMargin: verticalAxisLabelMargin,
        verticalAxisLabelFont: verticalAxisLabelFont,
        defaultAxisData: defaultAxisData,
        radiusData: radiusData
      });
      state.radialAxes = {
        circularAxis: getCircularAxisData({
          labels: radialAxisLabels,
          intervalData: getInitAxisIntervalData(true, {
            axis: options.circularAxis,
            categories: categories,
            layout: layout
          }),
          defaultAxisData: defaultAxisData,
          circularAxisLabelMargin: circularAxisLabelMargin,
          circularAxisLabelFont: circularAxisLabelFont,
          radiusData: radiusData
        }),
        verticalAxis: verticalAxisData
      };
    }
  },
  observe: {
    updateRadialAxes: function updateRadialAxes() {
      this.dispatch('setRadialAxesData');
    }
  }
};
/* harmony default export */ var radialAxes = (axes);
;// CONCATENATED MODULE: ./src/helpers/axes.ts
function axes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function axes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axes_ownKeys(Object(source), true).forEach(function (key) { axes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function axes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function axes_toConsumableArray(arr) { return axes_arrayWithoutHoles(arr) || axes_iterableToArray(arr) || axes_unsupportedIterableToArray(arr) || axes_nonIterableSpread(); }

function axes_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axes_arrayLikeToArray(o, minLen); }

function axes_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function axes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axes_arrayLikeToArray(arr); }

function axes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }






























function makeAdjustingIntervalInfo(blockCount, axisWidth, blockSize) {
  var remainBlockCount;
  var newBlockCount = Math.floor(axisWidth / blockSize);
  var intervalInfo = null;
  var interval = newBlockCount ? Math.floor(blockCount / newBlockCount) : blockCount;

  if (interval > 1) {
    // remainBlockCount : remaining block count after filling new blocks
    // | | | | | | | | | | | |  - previous block interval
    // |     |     |     |      - new block interval
    //                   |*|*|  - remaining block
    remainBlockCount = blockCount - interval * newBlockCount;

    if (remainBlockCount >= interval) {
      newBlockCount += Math.floor(remainBlockCount / interval);
      remainBlockCount = remainBlockCount % interval;
    }

    intervalInfo = {
      blockCount: newBlockCount,
      remainBlockCount: remainBlockCount,
      interval: interval
    };
  }

  return intervalInfo;
}

function getAutoAdjustingInterval(count, axisWidth, categories) {
  var autoInterval = {
    MIN_WIDTH: 90,
    MAX_WIDTH: 121,
    STEP_SIZE: 5
  };
  var LABEL_MARGIN = 5;

  if (categories !== null && categories !== void 0 && categories[0]) {
    var categoryMinWidth = getTextWidth(categories[0]);

    if (categoryMinWidth < axisWidth / count - LABEL_MARGIN) {
      return 1;
    }
  }

  var candidates = [];
  divisors(count).forEach(function (interval) {
    var intervalWidth = interval / count * axisWidth;

    if (intervalWidth >= autoInterval.MIN_WIDTH && intervalWidth <= autoInterval.MAX_WIDTH) {
      candidates.push({
        interval: interval,
        blockCount: Math.floor(count / interval),
        remainBlockCount: 0
      });
    }
  });

  if (!candidates.length) {
    var blockSizeRange = range(autoInterval.MIN_WIDTH, autoInterval.MAX_WIDTH, autoInterval.STEP_SIZE);
    candidates = blockSizeRange.reduce(function (acc, blockSize) {
      var candidate = makeAdjustingIntervalInfo(count, axisWidth, blockSize);
      return candidate ? [].concat(axes_toConsumableArray(acc), [candidate]) : acc;
    }, []);
  }

  var tickInterval = 1;

  if (candidates.length) {
    var candidate = candidates.reduce(function (acc, cur) {
      return cur.blockCount > acc.blockCount ? cur : acc;
    }, {
      blockCount: 0,
      interval: 1
    });
    tickInterval = candidate.interval;
  }

  return tickInterval;
}
function isLabelAxisOnYAxis(_ref) {
  var _series;

  var series = _ref.series,
      options = _ref.options,
      categories = _ref.categories;
  return !!series.bar || !!series.radialBar || !!series.gauge && Array.isArray(categories) && !categories.length || !!series.bullet && !(options !== null && options !== void 0 && (_series = options.series) !== null && _series !== void 0 && _series.vertical);
}
function hasBoxTypeSeries(series) {
  return !!series.column || !!series.bar || !!series.boxPlot || !!series.bullet;
}
function isPointOnColumn(series, options) {
  if (hasBoxTypeSeries(series)) {
    return true;
  }

  if (series.line || series.area) {
    var _options$xAxis;

    return Boolean((_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.pointOnColumn);
  }

  return false;
}
function isSeriesUsingRadialAxes(series) {
  return !!series.radar || !!series.radialBar || !!series.gauge;
}

function getAxisNameUsingRadialAxes(labelAxisOnYAxis) {
  return {
    valueAxisName: labelAxisOnYAxis ? 'circularAxis' : 'verticalAxis',
    labelAxisName: labelAxisOnYAxis ? 'verticalAxis' : 'circularAxis'
  };
}

function getAxisName(labelAxisOnYAxis, series) {
  return isSeriesUsingRadialAxes(series) ? getAxisNameUsingRadialAxes(labelAxisOnYAxis) : {
    valueAxisName: labelAxisOnYAxis ? 'xAxis' : 'yAxis',
    labelAxisName: labelAxisOnYAxis ? 'yAxis' : 'xAxis'
  };
}
function getSizeKey(labelAxisOnYAxis) {
  return {
    valueSizeKey: labelAxisOnYAxis ? 'width' : 'height',
    labelSizeKey: labelAxisOnYAxis ? 'height' : 'width'
  };
}
function getLimitOnAxis(labels) {
  var values = labels.map(function (label) {
    return Number(label);
  });
  return {
    min: Math.min.apply(Math, axes_toConsumableArray(values)),
    max: Math.max.apply(Math, axes_toConsumableArray(values))
  };
}
function hasSecondaryYAxis(options) {
  return Array.isArray(options === null || options === void 0 ? void 0 : options.yAxis) && options.yAxis.length === 2;
}
function getYAxisOption(options) {
  var secondaryYAxis = hasSecondaryYAxis(options);
  return {
    yAxis: secondaryYAxis ? options.yAxis[0] : options === null || options === void 0 ? void 0 : options.yAxis,
    secondaryYAxis: secondaryYAxis ? options.yAxis[1] : null
  };
}
function getValueAxisName(options, seriesName, valueAxisName) {
  var _getYAxisOption = getYAxisOption(options),
      secondaryYAxis = _getYAxisOption.secondaryYAxis;

  return (secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.chartType) === seriesName ? 'secondaryYAxis' : valueAxisName;
}
function getValueAxisNames(options, valueAxisName) {
  if (includes([AxisType.X, AxisType.CIRCULAR, AxisType.VERTICAL], valueAxisName)) {
    return [valueAxisName];
  }

  var optionsUsingYAxis = options;

  var _getYAxisOption2 = getYAxisOption(optionsUsingYAxis),
      yAxis = _getYAxisOption2.yAxis,
      secondaryYAxis = _getYAxisOption2.secondaryYAxis;

  return secondaryYAxis ? [yAxis.chartType, secondaryYAxis.chartType].map(function (seriesName, index) {
    return seriesName ? getValueAxisName(optionsUsingYAxis, seriesName, valueAxisName) : ['yAxis', 'secondaryYAxis'][index];
  }) : [valueAxisName];
}
function getAxisTheme(theme, name) {
  var xAxis = theme.xAxis,
      yAxis = theme.yAxis,
      circularAxis = theme.circularAxis;
  var axisTheme;

  if (name === AxisType.X) {
    axisTheme = xAxis;
  } else if (Array.isArray(yAxis)) {
    axisTheme = name === AxisType.Y ? yAxis[0] : yAxis[1];
  } else if (name === RadialAxisType.CIRCULAR) {
    axisTheme = circularAxis;
  } else {
    axisTheme = yAxis;
  }

  return axisTheme;
}

function getRotationDegree(distance, labelWidth, labelHeight) {
  var degree = 0;
  ANGLE_CANDIDATES.every(function (angle) {
    var compareWidth = calculateRotatedWidth(angle, labelWidth, labelHeight);
    degree = angle;
    return compareWidth > distance;
  });
  return distance < labelWidth ? degree : 0;
}

function hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, field) {
  var prevYAxis = previousAxes[field];
  var yAxis = currentAxes[field];

  if (!prevYAxis && !yAxis) {
    return false;
  }

  return (prevYAxis === null || prevYAxis === void 0 ? void 0 : prevYAxis.maxLabelWidth) !== (yAxis === null || yAxis === void 0 ? void 0 : yAxis.maxLabelWidth);
}

function hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) {
  return hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'yAxis') || hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'secondaryYAxis');
}

function hasXAxisSizeChanged(previousAxes, currentAxes) {
  var prevMaxHeight = previousAxes.xAxis.maxHeight;
  var maxHeight = currentAxes.xAxis.maxHeight;
  return prevMaxHeight !== maxHeight;
}

function hasAxesLayoutChanged(previousAxes, currentAxes) {
  return hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) || hasXAxisSizeChanged(previousAxes, currentAxes);
}
function getRotatableOption(options) {
  var _options$xAxis$label$, _options$xAxis2, _options$xAxis2$label;

  return (_options$xAxis$label$ = options === null || options === void 0 ? void 0 : (_options$xAxis2 = options.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : (_options$xAxis2$label = _options$xAxis2.label) === null || _options$xAxis2$label === void 0 ? void 0 : _options$xAxis2$label.rotatable) !== null && _options$xAxis$label$ !== void 0 ? _options$xAxis$label$ : true;
}
function getViewAxisLabels(axisData, axisSize) {
  var labels = axisData.labels,
      pointOnColumn = axisData.pointOnColumn,
      labelDistance = axisData.labelDistance,
      tickDistance = axisData.tickDistance,
      labelInterval = axisData.labelInterval,
      tickInterval = axisData.tickInterval,
      tickCount = axisData.tickCount,
      scale = axisData.scale;
  var axisSizeAppliedRatio = axisSize;
  var additional = 0;
  var labelAdjustment = 0;

  if (scale) {
    var _scale$sizeRatio, _scale$positionRatio;

    var sizeRatio = (_scale$sizeRatio = scale === null || scale === void 0 ? void 0 : scale.sizeRatio) !== null && _scale$sizeRatio !== void 0 ? _scale$sizeRatio : 1;
    var positionRatio = (_scale$positionRatio = scale === null || scale === void 0 ? void 0 : scale.positionRatio) !== null && _scale$positionRatio !== void 0 ? _scale$positionRatio : 0;
    axisSizeAppliedRatio = axisSize * sizeRatio;
    additional = axisSize * positionRatio;
  } else {
    var interval = labelInterval === tickInterval ? labelInterval : 1;
    labelAdjustment = pointOnColumn ? (labelDistance !== null && labelDistance !== void 0 ? labelDistance : tickDistance * interval) / 2 : 0;
  }

  var relativePositions = makeTickPixelPositions(axisSizeAppliedRatio, tickCount, additional);
  return labels.reduce(function (acc, text, index) {
    var offsetPos = relativePositions[index] + labelAdjustment;
    var needRender = !(index % labelInterval) && offsetPos <= axisSize;
    return needRender ? [].concat(axes_toConsumableArray(acc), [{
      offsetPos: offsetPos,
      text: text
    }]) : acc;
  }, []);
}
function makeTitleOption(title) {
  if (isUndefined(title)) {
    return title;
  }

  var defaultOption = {
    text: '',
    offsetX: 0,
    offsetY: 0
  };
  return utils_isString(title) ? axes_objectSpread(axes_objectSpread({}, defaultOption), {}, {
    text: title
  }) : axes_objectSpread(axes_objectSpread({}, defaultOption), title);
}
function getAxisFormatter(options, axisName) {
  var _axisOptions$axisName, _axisOptions$axisName2, _axisOptions$axisName3;

  var axisOptions = axes_objectSpread(axes_objectSpread({}, getYAxisOption(options)), {}, {
    xAxis: options.xAxis
  });

  return (_axisOptions$axisName = (_axisOptions$axisName2 = axisOptions[axisName]) === null || _axisOptions$axisName2 === void 0 ? void 0 : (_axisOptions$axisName3 = _axisOptions$axisName2.label) === null || _axisOptions$axisName3 === void 0 ? void 0 : _axisOptions$axisName3.formatter) !== null && _axisOptions$axisName !== void 0 ? _axisOptions$axisName : function (value) {
    return value;
  };
}
function getLabelsAppliedFormatter(labels, options, dateType, axisName) {
  var _options$axisName;

  var dateFormatter = getDateFormat(options === null || options === void 0 ? void 0 : (_options$axisName = options[axisName]) === null || _options$axisName === void 0 ? void 0 : _options$axisName.date);
  var formattedLabels = dateType && dateFormatter ? labels.map(function (label) {
    return formatDate(dateFormatter, new Date(label));
  }) : labels;
  var formatter = getAxisFormatter(options, axisName);
  return formattedLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: labels,
      axisName: axisName
    });
  });
}
function makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable) {
  var degree = getRotationDegree(distance, maxLabelWidth, maxLabelHeight);

  if (!rotatable || degree === 0) {
    return {
      needRotateLabel: false,
      radian: 0,
      rotationHeight: maxLabelHeight
    };
  }

  return {
    needRotateLabel: degree > 0,
    radian: calculateDegreeToRadian(degree, 0),
    rotationHeight: calculateRotatedHeight(degree, maxLabelWidth, maxLabelHeight)
  };
}
function getMaxLabelSize(labels, xMargin) {
  var font = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_LABEL_TEXT;
  var maxLengthLabel = labels.reduce(function (acc, cur) {
    return acc.length > cur.length ? acc : cur;
  }, '');
  return {
    maxLabelWidth: getTextWidth(maxLengthLabel, font) + xMargin,
    maxLabelHeight: getTextHeight(maxLengthLabel, font)
  };
}
function getLabelXMargin(axisName, options) {
  var _axisOptions$axisName4, _axisOptions$axisName5, _axisOptions$axisName6;

  if (axisName === 'xAxis') {
    return 0;
  }

  var axisOptions = getYAxisOption(options);
  return Math.abs((_axisOptions$axisName4 = axisOptions === null || axisOptions === void 0 ? void 0 : (_axisOptions$axisName5 = axisOptions[axisName]) === null || _axisOptions$axisName5 === void 0 ? void 0 : (_axisOptions$axisName6 = _axisOptions$axisName5.label) === null || _axisOptions$axisName6 === void 0 ? void 0 : _axisOptions$axisName6.margin) !== null && _axisOptions$axisName4 !== void 0 ? _axisOptions$axisName4 : 0);
}
function getInitAxisIntervalData(isLabelAxis, params) {
  var _axis$tick, _axis$label, _axis$scale;

  var axis = params.axis,
      categories = params.categories,
      layout = params.layout,
      isCoordinateTypeChart = params.isCoordinateTypeChart;
  var tickInterval = axis === null || axis === void 0 ? void 0 : (_axis$tick = axis.tick) === null || _axis$tick === void 0 ? void 0 : _axis$tick.interval;
  var labelInterval = axis === null || axis === void 0 ? void 0 : (_axis$label = axis.label) === null || _axis$label === void 0 ? void 0 : _axis$label.interval;
  var existIntervalOptions = isNumber(tickInterval) || isNumber(labelInterval);
  var needAdjustInterval = isLabelAxis && !isNumber(axis === null || axis === void 0 ? void 0 : (_axis$scale = axis.scale) === null || _axis$scale === void 0 ? void 0 : _axis$scale.stepSize) && !params.shift && !existIntervalOptions && !isCoordinateTypeChart;
  var initTickInterval = needAdjustInterval ? getInitTickInterval(categories, layout) : 1;
  var initLabelInterval = needAdjustInterval ? initTickInterval : 1;
  var axisData = {
    tickInterval: tickInterval !== null && tickInterval !== void 0 ? tickInterval : initTickInterval,
    labelInterval: labelInterval !== null && labelInterval !== void 0 ? labelInterval : initLabelInterval
  };
  return axisData;
}

function getInitTickInterval(categories, layout) {
  if (!categories || !layout) {
    return 1;
  }

  var width = layout.xAxis.width;
  var count = categories.length;
  return getAutoAdjustingInterval(count, width, categories);
}

function getDefaultRadialAxisData(options, plot) {
  var maxLabelWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxLabelHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var isLabelOnVerticalAxis = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var centerX = plot.width / 2;

  if (isLabelOnVerticalAxis) {
    var _initSectorOptions = initSectorOptions(options === null || options === void 0 ? void 0 : options.series),
        startAngle = _initSectorOptions.startAngle,
        endAngle = _initSectorOptions.endAngle,
        clockwise = _initSectorOptions.clockwise;

    var isSemiCircular = isSemiCircle(clockwise, startAngle, endAngle);
    return {
      isSemiCircular: isSemiCircular,
      axisSize: getDefaultRadius(plot, isSemiCircular, maxLabelWidth, maxLabelHeight),
      centerX: centerX,
      centerY: isSemiCircular ? getSemiCircleCenterY(plot.height, clockwise) : plot.height / 2,
      totalAngle: getTotalAngle(clockwise, startAngle, endAngle),
      drawingStartAngle: startAngle,
      clockwise: clockwise,
      startAngle: startAngle,
      endAngle: endAngle
    };
  }

  return {
    isSemiCircular: false,
    axisSize: getDefaultRadius(plot, false, maxLabelWidth, maxLabelHeight),
    centerX: centerX,
    centerY: plot.height / 2,
    totalAngle: DEGREE_360,
    drawingStartAngle: DEGREE_0,
    clockwise: true,
    startAngle: DEGREE_0,
    endAngle: DEGREE_360
  };
}
function getRadiusInfo(axisSize, radiusRange) {
  var _radiusRange$inner, _radiusRange$outer;

  var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var innerRadius = calculateSizeWithPercentString(axisSize, (_radiusRange$inner = radiusRange === null || radiusRange === void 0 ? void 0 : radiusRange.inner) !== null && _radiusRange$inner !== void 0 ? _radiusRange$inner : 0);
  var outerRadius = calculateSizeWithPercentString(axisSize, (_radiusRange$outer = radiusRange === null || radiusRange === void 0 ? void 0 : radiusRange.outer) !== null && _radiusRange$outer !== void 0 ? _radiusRange$outer : axisSize);
  return {
    radiusRanges: makeTickPixelPositions(outerRadius - innerRadius, count, innerRadius).splice(innerRadius === 0 ? 1 : 0, count).reverse(),
    innerRadius: innerRadius,
    outerRadius: outerRadius
  };
}
function isDateType(options, axisName) {
  var _options$axisName2;

  return !!((_options$axisName2 = options[axisName]) !== null && _options$axisName2 !== void 0 && _options$axisName2.date);
}
;// CONCATENATED MODULE: ./src/helpers/coordinate.ts



function getCoordinateYValue(datum) {
  if (isNumber(datum)) {
    return datum;
  }

  return Array.isArray(datum) ? datum[1] : datum.y;
}
function getCoordinateXValue(datum) {
  return Array.isArray(datum) ? datum[0] : datum.x;
}
function isValueAfterLastCategory(value, categories) {
  var category = last(categories);

  if (!category) {
    return false;
  }

  return isNumber(value) ? value >= Number(category) : new Date(value) >= new Date(category);
}
function getCoordinateDataIndex(datum, categories, dataIndex, startIndex) {
  if (isNumber(datum)) {
    return dataIndex - startIndex;
  }

  var value = getCoordinateXValue(datum);
  var index = categories.findIndex(function (category) {
    return category === String(value);
  });

  if (index === -1 && isValueAfterLastCategory(value, categories)) {
    index = categories.length;
  }

  return index;
}

function isLineCoordinateSeries(series) {
  var _series$line$;

  if (!series.line) {
    return false;
  }

  var firstData = getFirstValidValue((_series$line$ = series.line[0]) === null || _series$line$ === void 0 ? void 0 : _series$line$.data);
  return firstData && (Array.isArray(firstData) || isObject(firstData));
}

function isCoordinateSeries(series) {
  return isLineCoordinateSeries(series) || !!series.scatter || !!series.bubble;
}
function isModelExistingInRect(rect, point) {
  var height = rect.height,
      width = rect.width;
  var x = point.x,
      y = point.y;
  return x >= 0 && x <= width && y >= 0 && y <= height;
}
function isMouseInRect(rect, mousePosition) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height;
  return mousePosition.x >= x && mousePosition.x <= x + width && mousePosition.y >= y && mousePosition.y <= y + height;
}
;// CONCATENATED MODULE: ./src/store/axes.ts
function store_axes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function store_axes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_axes_ownKeys(Object(source), true).forEach(function (key) { store_axes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_axes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function store_axes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function store_axes_toConsumableArray(arr) { return store_axes_arrayWithoutHoles(arr) || store_axes_iterableToArray(arr) || store_axes_unsupportedIterableToArray(arr) || store_axes_nonIterableSpread(); }

function store_axes_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function store_axes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return store_axes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return store_axes_arrayLikeToArray(o, minLen); }

function store_axes_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function store_axes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return store_axes_arrayLikeToArray(arr); }

function store_axes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

























function isCenterYAxis(options) {
  var _options$yAxis;

  var diverging = !!pickProperty(options, ['series', 'diverging']);
  var alignCenter = (options === null || options === void 0 ? void 0 : (_options$yAxis = options.yAxis) === null || _options$yAxis === void 0 ? void 0 : _options$yAxis.align) === 'center';
  return diverging && alignCenter;
}

function isDivergingBoxSeries(series, options) {
  var _options$series;

  return hasBoxTypeSeries(series) && !!((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.diverging);
}

function getZeroPosition(limit, axisSize, labelAxisOnYAxis, isDivergingSeries) {
  var min = limit.min,
      max = limit.max;
  var hasZeroValue = min <= 0 && max >= 0;

  if (!hasZeroValue || isDivergingSeries) {
    return null;
  }

  var position = (0 - min) / (max - min) * axisSize;
  return labelAxisOnYAxis ? position : axisSize - position;
}

function getLabelAxisData(stateProp) {
  var axisSize = stateProp.axisSize,
      categories = stateProp.categories,
      series = stateProp.series,
      options = stateProp.options,
      theme = stateProp.theme,
      scale = stateProp.scale,
      initialAxisData = stateProp.initialAxisData,
      isCoordinateTypeChart = stateProp.isCoordinateTypeChart,
      axisName = stateProp.axisName;
  var hasLineSeries = !!series.line;
  var pointOnColumn = isPointOnColumn(series, options);
  var dateType = isDateType(options, axisName);
  var labelsBeforeFormatting = isCoordinateTypeChart ? makeLabelsFromLimit(scale.limit, scale.stepSize, dateType) : categories;
  var labels = getLabelsAppliedFormatter(labelsBeforeFormatting, options, dateType, axisName);
  var labelRange;

  if (scale && hasLineSeries) {
    var baseLabels = pointOnColumn ? labelsBeforeFormatting : categories;
    var values = baseLabels.map(function (value) {
      return dateType ? Number(new Date(value)) : Number(value);
    });
    labelRange = {
      min: Math.min.apply(Math, store_axes_toConsumableArray(values)),
      max: Math.max.apply(Math, store_axes_toConsumableArray(values))
    };
  }

  var rectResponderCount = categories.length;
  var tickIntervalCount = rectResponderCount - (pointOnColumn ? 0 : 1);
  var tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
  var labelDistance = axisSize / (labels.length - (pointOnColumn ? 0 : 1));
  var tickCount = labels.length;

  if (pointOnColumn && !isCoordinateTypeChart) {
    tickCount += 1;
  }

  var viewLabels = getViewAxisLabels(store_axes_objectSpread({
    labels: labels,
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount,
    scale: scale
  }, initialAxisData), axisSize);
  var axisLabelMargin = getLabelXMargin(axisName, options);
  return store_axes_objectSpread(store_axes_objectSpread({
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    labelDistance: labelDistance,
    tickDistance: tickDistance,
    tickCount: tickCount,
    labelRange: labelRange,
    rectResponderCount: rectResponderCount,
    isLabelAxis: true
  }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));
}

function getValueAxisData(stateProp) {
  var scale = stateProp.scale,
      axisSize = stateProp.axisSize,
      series = stateProp.series,
      options = stateProp.options,
      centerYAxis = stateProp.centerYAxis,
      initialAxisData = stateProp.initialAxisData,
      theme = stateProp.theme,
      labelOnYAxis = stateProp.labelOnYAxis,
      axisName = stateProp.axisName;
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var size = centerYAxis ? centerYAxis === null || centerYAxis === void 0 ? void 0 : centerYAxis.xAxisHalfSize : axisSize;
  var divergingBoxSeries = isDivergingBoxSeries(series, options);
  var formatter = getAxisFormatter(options, axisName);
  var zeroPosition = getZeroPosition(limit, axisSize, isLabelAxisOnYAxis({
    series: series,
    options: options
  }), divergingBoxSeries);
  var valueLabels = makeLabelsFromLimit(limit, stepSize);

  if (!centerYAxis && divergingBoxSeries) {
    valueLabels = getDivergingValues(valueLabels);
  }

  var labels = valueLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: valueLabels,
      axisName: axisName
    });
  });
  var tickDistance = size / Math.max(valueLabels.length, 1);
  var tickCount = valueLabels.length;
  var pointOnColumn = false;
  var viewLabels = getViewAxisLabels(store_axes_objectSpread({
    labels: labelOnYAxis ? labels : store_axes_toConsumableArray(labels).reverse(),
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount
  }, initialAxisData), size);
  var axisLabelMargin = getLabelXMargin(axisName, options);

  var axisData = store_axes_objectSpread(store_axes_objectSpread({
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    isLabelAxis: false,
    tickCount: tickCount,
    tickDistance: tickDistance
  }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));

  if (isNumber(zeroPosition)) {
    axisData.zeroPosition = zeroPosition;
  }

  return axisData;
}

function getDivergingValues(valueLabels) {
  return hasNegativeOnly(valueLabels) ? valueLabels.reverse().slice(1).concat(valueLabels) : valueLabels.slice(1).reverse().concat(valueLabels);
}

function makeDefaultAxisData(isLabelAxis, params) {
  var _params$axis;

  var axisData = getInitAxisIntervalData(isLabelAxis, params);
  var title = makeTitleOption(params === null || params === void 0 ? void 0 : (_params$axis = params.axis) === null || _params$axis === void 0 ? void 0 : _params$axis.title);

  if (title) {
    axisData.title = title;
  }

  return axisData;
}

function getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart) {
  var _options$series2;

  var _getYAxisOption = getYAxisOption(options),
      yAxis = _getYAxisOption.yAxis,
      secondaryYAxis = _getYAxisOption.secondaryYAxis;

  var shift = options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.shift;
  return {
    xAxis: makeDefaultAxisData(!labelOnYAxis, {
      categories: categories,
      axis: options === null || options === void 0 ? void 0 : options.xAxis,
      layout: layout,
      shift: shift,
      isCoordinateTypeChart: isCoordinateTypeChart
    }),
    yAxis: makeDefaultAxisData(labelOnYAxis, {
      axis: yAxis
    }),
    secondaryYAxis: secondaryYAxis ? makeDefaultAxisData(labelOnYAxis, {
      axis: secondaryYAxis
    }) : null
  };
}

function getSecondaryYAxisData(_ref) {
  var _getYAxisOption$secon, _getYAxisOption$secon2;

  var state = _ref.state,
      labelOnYAxis = _ref.labelOnYAxis,
      valueAxisSize = _ref.valueAxisSize,
      labelAxisSize = _ref.labelAxisSize,
      initialAxisData = _ref.initialAxisData,
      isCoordinateTypeChart = _ref.isCoordinateTypeChart;
  var scale = state.scale,
      options = state.options,
      series = state.series,
      theme = state.theme;
  var categories = state.categories;
  return labelOnYAxis ? getLabelAxisData({
    scale: scale.secondaryYAxis,
    axisSize: labelAxisSize,
    categories: (_getYAxisOption$secon = (_getYAxisOption$secon2 = getYAxisOption(options).secondaryYAxis) === null || _getYAxisOption$secon2 === void 0 ? void 0 : _getYAxisOption$secon2.categories) !== null && _getYAxisOption$secon !== void 0 ? _getYAxisOption$secon : categories,
    options: options,
    series: series,
    theme: getAxisTheme(theme, AxisType.SECONDARY_Y),
    initialAxisData: initialAxisData,
    isCoordinateTypeChart: isCoordinateTypeChart,
    axisName: AxisType.SECONDARY_Y
  }) : getValueAxisData({
    scale: scale.secondaryYAxis,
    axisSize: valueAxisSize,
    options: options,
    series: series,
    theme: getAxisTheme(theme, AxisType.SECONDARY_Y),
    centerYAxis: null,
    initialAxisData: initialAxisData,
    axisName: AxisType.SECONDARY_Y
  });
}

function makeXAxisData(_ref2) {
  var axisData = _ref2.axisData,
      axisSize = _ref2.axisSize,
      centerYAxis = _ref2.centerYAxis,
      rotatable = _ref2.rotatable,
      _ref2$labelMargin = _ref2.labelMargin,
      labelMargin = _ref2$labelMargin === void 0 ? 0 : _ref2$labelMargin;
  var viewLabels = axisData.viewLabels,
      pointOnColumn = axisData.pointOnColumn,
      maxLabelWidth = axisData.maxLabelWidth,
      maxLabelHeight = axisData.maxLabelHeight;
  var offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;
  var size = centerYAxis ? centerYAxis.xAxisHalfSize : axisSize;
  var distance = size / (viewLabels.length - (pointOnColumn ? 0 : 1));
  var rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable);
  var needRotateLabel = rotationData.needRotateLabel,
      rotationHeight = rotationData.rotationHeight;
  var maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
  return store_axes_objectSpread(store_axes_objectSpread(store_axes_objectSpread({}, axisData), rotationData), {}, {
    maxHeight: maxHeight,
    offsetY: offsetY
  });
}

function getAxisInfo(labelOnYAxis, plot, series) {
  var _getAxisName = getAxisName(labelOnYAxis, series),
      valueAxisName = _getAxisName.valueAxisName,
      labelAxisName = _getAxisName.labelAxisName;

  var _getSizeKey = getSizeKey(labelOnYAxis),
      valueSizeKey = _getSizeKey.valueSizeKey,
      labelSizeKey = _getSizeKey.labelSizeKey;

  var valueAxisSize = plot[valueSizeKey];
  var labelAxisSize = plot[labelSizeKey];
  return {
    valueAxisName: valueAxisName,
    valueAxisSize: valueAxisSize,
    labelAxisName: labelAxisName,
    labelAxisSize: labelAxisSize
  };
}

function getCategoriesWithTypes(categories, rawCategories) {
  var _ref3, _ref4;

  return {
    categories: (_ref3 = categories) !== null && _ref3 !== void 0 ? _ref3 : [],
    rawCategories: (_ref4 = rawCategories) !== null && _ref4 !== void 0 ? _ref4 : []
  };
}

var axes_axes = {
  name: 'axes',
  state: function state(_ref5) {
    var series = _ref5.series,
        options = _ref5.options;

    var _getYAxisOption2 = getYAxisOption(options),
        secondaryYAxis = _getYAxisOption2.secondaryYAxis;

    var axesState = {
      xAxis: {},
      yAxis: {}
    };

    if (!!series.bar && isCenterYAxis(options)) {
      axesState.centerYAxis = {};
    }

    if (secondaryYAxis) {
      axesState.secondaryYAxis = {};
    }

    return {
      axes: axesState
    };
  },
  action: {
    setAxesData: function setAxesData(_ref6) {
      var _options$xAxis, _options$xAxis$label;

      var state = _ref6.state,
          initStoreState = _ref6.initStoreState;
      var scale = state.scale,
          options = state.options,
          series = state.series,
          layout = state.layout,
          theme = state.theme;
      var xAxis = layout.xAxis,
          yAxis = layout.yAxis,
          plot = layout.plot;
      var isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);
      var labelOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options
      });

      var _getCategoriesWithTyp = getCategoriesWithTypes(state.categories, state.rawCategories),
          categories = _getCategoriesWithTyp.categories;

      var _getAxisInfo = getAxisInfo(labelOnYAxis, plot, series),
          valueAxisName = _getAxisInfo.valueAxisName,
          valueAxisSize = _getAxisInfo.valueAxisSize,
          labelAxisName = _getAxisInfo.labelAxisName,
          labelAxisSize = _getAxisInfo.labelAxisSize;

      var hasCenterYAxis = state.axes.centerYAxis;
      var initialAxisData = getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart);
      var valueAxisData = getValueAxisData({
        scale: scale[valueAxisName],
        axisSize: valueAxisSize,
        options: options,
        series: series,
        theme: getAxisTheme(theme, valueAxisName),
        centerYAxis: hasCenterYAxis ? {
          xAxisHalfSize: (xAxis.width - yAxis.width) / 2
        } : null,
        initialAxisData: initialAxisData[valueAxisName],
        labelOnYAxis: labelOnYAxis,
        axisName: valueAxisName
      });
      var labelAxisData = getLabelAxisData({
        scale: scale[labelAxisName],
        axisSize: labelAxisSize,
        categories: categories,
        options: options,
        series: series,
        theme: getAxisTheme(theme, labelAxisName),
        initialAxisData: initialAxisData[labelAxisName],
        isCoordinateTypeChart: isCoordinateTypeChart,
        labelOnYAxis: labelOnYAxis,
        axisName: labelAxisName
      });
      var secondaryYAxis, centerYAxis;

      if (state.axes.secondaryYAxis) {
        secondaryYAxis = getSecondaryYAxisData({
          state: state,
          labelOnYAxis: labelOnYAxis,
          valueAxisSize: valueAxisSize,
          labelAxisSize: labelAxisSize,
          labelAxisName: labelAxisName,
          valueAxisName: valueAxisName,
          initialAxisData: initialAxisData.secondaryYAxis,
          isCoordinateTypeChart: isCoordinateTypeChart
        });
      }

      if (hasCenterYAxis) {
        var xAxisHalfSize = (xAxis.width - yAxis.width) / 2;
        centerYAxis = deepMergedCopy(valueAxisData, {
          x: xAxis.x + xAxisHalfSize,
          xAxisHalfSize: xAxisHalfSize,
          secondStartX: (xAxis.width + yAxis.width) / 2,
          yAxisLabelAnchorPoint: yAxis.width / 2,
          yAxisHeight: yAxis.height
        });
      }

      var axesState = {
        xAxis: makeXAxisData({
          axisData: labelOnYAxis ? valueAxisData : labelAxisData,
          axisSize: labelOnYAxis ? valueAxisSize : labelAxisSize,
          centerYAxis: centerYAxis,
          rotatable: getRotatableOption(options),
          labelMargin: (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : (_options$xAxis$label = _options$xAxis.label) === null || _options$xAxis$label === void 0 ? void 0 : _options$xAxis$label.margin
        }),
        yAxis: labelOnYAxis ? labelAxisData : valueAxisData,
        secondaryYAxis: secondaryYAxis,
        centerYAxis: centerYAxis
      };

      if (hasAxesLayoutChanged(state.axes, axesState)) {
        this.notify(state, 'layout');
      }

      state.axes = axesState;
    }
  },
  computed: {},
  observe: {
    updateAxes: function updateAxes() {
      this.dispatch('setAxesData');
    }
  }
};
/* harmony default export */ var store_axes = (axes_axes);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__(6781);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.freeze.js
var es_object_freeze = __webpack_require__(2144);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array-buffer.slice.js
var es_array_buffer_slice = __webpack_require__(2994);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.uint8-array.js
var es_typed_array_uint8_array = __webpack_require__(3675);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.copy-within.js
var es_typed_array_copy_within = __webpack_require__(5825);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.every.js
var es_typed_array_every = __webpack_require__(7170);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.fill.js
var es_typed_array_fill = __webpack_require__(8857);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.filter.js
var es_typed_array_filter = __webpack_require__(8329);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.find.js
var es_typed_array_find = __webpack_require__(6279);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.find-index.js
var es_typed_array_find_index = __webpack_require__(427);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.for-each.js
var es_typed_array_for_each = __webpack_require__(1159);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.includes.js
var es_typed_array_includes = __webpack_require__(2516);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.index-of.js
var es_typed_array_index_of = __webpack_require__(4349);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.iterator.js
var es_typed_array_iterator = __webpack_require__(5273);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.join.js
var es_typed_array_join = __webpack_require__(6729);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.last-index-of.js
var es_typed_array_last_index_of = __webpack_require__(1801);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.map.js
var es_typed_array_map = __webpack_require__(574);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.reduce.js
var es_typed_array_reduce = __webpack_require__(5787);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.reduce-right.js
var es_typed_array_reduce_right = __webpack_require__(9271);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.reverse.js
var es_typed_array_reverse = __webpack_require__(3160);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.set.js
var es_typed_array_set = __webpack_require__(5688);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.slice.js
var es_typed_array_slice = __webpack_require__(3157);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.some.js
var es_typed_array_some = __webpack_require__(3333);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.sort.js
var es_typed_array_sort = __webpack_require__(315);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.subarray.js
var es_typed_array_subarray = __webpack_require__(8314);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.to-locale-string.js
var es_typed_array_to_locale_string = __webpack_require__(556);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.to-string.js
var es_typed_array_to_string = __webpack_require__(9224);
;// CONCATENATED MODULE: ./src/helpers/downloader.ts








var _templateObject;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function downloader_toConsumableArray(arr) { return downloader_arrayWithoutHoles(arr) || downloader_iterableToArray(arr) || downloader_unsupportedIterableToArray(arr) || downloader_nonIterableSpread(); }

function downloader_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function downloader_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return downloader_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return downloader_arrayLikeToArray(o, minLen); }

function downloader_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function downloader_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return downloader_arrayLikeToArray(arr); }

function downloader_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }








































var DATA_URI_HEADERS = {
  xls: 'data:application/vnd.ms-excel;base64,',
  csv: 'data:text/csv;charset=utf-8,%EF%BB%BF'
  /* BOM for utf-8 */

};

function getDownloadMethod() {
  var method;
  var isDownloadAttributeSupported = !isUndefined(document.createElement('a').download);
  var isMSSaveOrOpenBlobSupported = !isUndefined(window.Blob && window.navigator.msSaveOrOpenBlob);

  if (isMSSaveOrOpenBlobSupported) {
    method = downloadWithMSSaveOrOpenBlob;
  } else if (isDownloadAttributeSupported) {
    method = downloadWithAnchorElementDownloadAttribute;
  }

  return method;
}
/**
 * Base64 string to blob
 * original source ref: https://github.com/miguelmota/base64toblob/blob/master/base64toblob.js
 * Licence: MIT Licence
 */


function base64toBlob(base64String) {
  var contentType = base64String.substr(0, base64String.indexOf(';base64,')).substr(base64String.indexOf(':') + 1);
  var sliceSize = 1024;
  var byteCharacters = atob(base64String.substr(base64String.indexOf(',') + 1));
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);
    var byteNumbers = new Array(slice.length);

    for (var i = 0; i < slice.length; i += 1) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    byteArrays.push(new window.Uint8Array(byteNumbers));
  }

  try {
    // for IE 11
    return new Blob(byteArrays, {
      type: contentType
    });
  } catch (e) {
    // for IE 10
    return new Blob(byteArrays.map(function (byteArr) {
      return byteArr.buffer;
    }), {
      type: contentType
    });
  }
}

function isImageExtension(extension) {
  return extension === 'jpeg' || extension === 'png';
}

function downloadWithMSSaveOrOpenBlob(fileName, extension, content, contentType) {
  var blobObject = isImageExtension(extension) ? base64toBlob(content) : new Blob([content], {
    type: contentType
  });
  window.navigator.msSaveOrOpenBlob(blobObject, "".concat(fileName, ".").concat(extension));
}

function downloadWithAnchorElementDownloadAttribute(fileName, extension, content) {
  if (content) {
    var anchorElement = document.createElement('a');
    anchorElement.href = content;
    anchorElement.target = '_blank';
    anchorElement.download = "".concat(fileName, ".").concat(extension);
    document.body.appendChild(anchorElement);
    anchorElement.click();
    anchorElement.remove();
  }
}

function oneLineTrim() {
  var normalTag = function normalTag(template) {
    for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      expressions[_key - 1] = arguments[_key];
    }

    return template.reduce(function (accumulator, part, i) {
      return accumulator + expressions[i - 1] + part;
    });
  };

  return normalTag.apply(void 0, arguments).replace(/\n\s*/g, '');
}

function isNeedDataEncoding() {
  var isDownloadAttributeSupported = !isUndefined(document.createElement('a').download);
  var isMSSaveOrOpenBlobSupported = !isUndefined(window.Blob && window.navigator.msSaveOrOpenBlob);
  return !isMSSaveOrOpenBlobSupported && isDownloadAttributeSupported;
}

function getBulletLongestArrayLength(arr, field) {
  return arr.reduce(function (acc, cur, idx) {
    var _cur$field;

    return !idx || acc < (cur === null || cur === void 0 ? void 0 : (_cur$field = cur[field]) === null || _cur$field === void 0 ? void 0 : _cur$field.length) ? cur[field].length : acc;
  }, 0);
}

function makeBulletExportData(_ref) {
  var series = _ref.series;
  var seriesData = series.bullet.data;
  var markerCount = getBulletLongestArrayLength(seriesData, 'markers');
  var rangeCount = getBulletLongestArrayLength(seriesData, 'ranges');
  var rangesHeaders = range(0, rangeCount).map(function (idx) {
    return "Range ".concat(idx + 1);
  });
  var markerHeaders = range(0, markerCount).map(function (idx) {
    return "Marker ".concat(idx + 1);
  });
  return seriesData.reduce(function (acc, _ref2) {
    var data = _ref2.data,
        markers = _ref2.markers,
        name = _ref2.name,
        ranges = _ref2.ranges;
    var rangeDatum = rangesHeaders.map(function (_, index) {
      var rangeData = ranges === null || ranges === void 0 ? void 0 : ranges[index];
      return rangeData ? "".concat(rangeData[0], " ~ ").concat(rangeData[1]) : '';
    });
    var markerDatum = markerHeaders.map(function (_, index) {
      var _markers$index;

      return (_markers$index = markers === null || markers === void 0 ? void 0 : markers[index]) !== null && _markers$index !== void 0 ? _markers$index : '';
    });
    return [].concat(downloader_toConsumableArray(acc), [[name, data !== null && data !== void 0 ? data : ''].concat(downloader_toConsumableArray(rangeDatum), downloader_toConsumableArray(markerDatum))]);
  }, [['', 'Actual'].concat(downloader_toConsumableArray(rangesHeaders), downloader_toConsumableArray(markerHeaders))]);
}

function makeHeatmapExportData(_ref3) {
  var categories = _ref3.categories,
      series = _ref3.series;
  var xCategories = categories.x;
  return series.heatmap.data.reduce(function (acc, _ref4) {
    var data = _ref4.data,
        yCategory = _ref4.yCategory;
    return [].concat(downloader_toConsumableArray(acc), [[yCategory].concat(downloader_toConsumableArray(data.map(function (datum) {
      return isNull(datum) ? '' : datum;
    })))]);
  }, [[''].concat(downloader_toConsumableArray(xCategories))]);
}

function recursiveTreemapData(_ref5, result) {
  var label = _ref5.label,
      data = _ref5.data,
      _ref5$children = _ref5.children,
      children = _ref5$children === void 0 ? [] : _ref5$children;

  if (data) {
    result.push([label, data]);
  }

  children.forEach(function (childrenData) {
    return recursiveTreemapData(childrenData, result);
  });
  return result;
}

function makeTreemapExportData(exportData) {
  var series = exportData.series;
  var result = [['Label', 'Data']];
  series.treemap.data.forEach(function (datum) {
    recursiveTreemapData(datum, result);
  });
  return result;
}

function makeBubbleExportData(exportData) {
  var series = exportData.series;
  return series.bubble.data.reduce(function (acc, _ref6) {
    var name = _ref6.name,
        data = _ref6.data;
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(data.map(function (datum) {
      return isNull(datum) ? [] : [name, datum.label, String(datum.x), datum.y, datum.r];
    })));
  }, [['Name', 'Label', 'X', 'Y', 'Radius']]);
}

function makeBoxPlotExportData(exportData) {
  var _exportData$categorie;

  var series = exportData.series;
  var categories = (_exportData$categorie = exportData.categories) !== null && _exportData$categorie !== void 0 ? _exportData$categorie : [];
  return series.boxPlot.data.reduce(function (acc, _ref7) {
    var name = _ref7.name,
        data = _ref7.data,
        outliers = _ref7.outliers;
    var values = (data !== null && data !== void 0 ? data : []).map(function (rawData, index) {
      var _find;

      var outlierValue = (_find = (outliers !== null && outliers !== void 0 ? outliers : []).find(function (outlier) {
        return outlier[0] === index;
      })) === null || _find === void 0 ? void 0 : _find[1];
      var value = outlierValue ? [].concat(downloader_toConsumableArray(rawData), [outlierValue]) : downloader_toConsumableArray(rawData);
      return value.join();
    });
    return [].concat(downloader_toConsumableArray(acc), [[name].concat(downloader_toConsumableArray(values))]);
  }, [[''].concat(downloader_toConsumableArray(categories))]);
}

function makePieExportData(exportData) {
  var _exportData$categorie2;

  var series = exportData.series;
  var categories = (_exportData$categorie2 = exportData.categories) !== null && _exportData$categorie2 !== void 0 ? _exportData$categorie2 : [];
  return series.pie.data.reduce(function (acc, _ref8) {
    var name = _ref8.name,
        data = _ref8.data;
    var values = Array.isArray(data) ? (data !== null && data !== void 0 ? data : []).reduce(function (accNestedPieValue, value) {
      var _value$data;

      return [].concat(downloader_toConsumableArray(accNestedPieValue), [[value.name, (_value$data = value.data) !== null && _value$data !== void 0 ? _value$data : '']]);
    }, []) : [[name, data !== null && data !== void 0 ? data : '']];
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(values));
  }, categories.length ? [[''].concat(downloader_toConsumableArray(categories))] : []);
}

function makeCoordinateExportDataValues(type, categories, data) {
  return categories.map(function (category, index) {
    if (type === 'area' && Array.isArray(data[index])) {
      return data[index].join();
    }

    var foundItem = data.find(function (value) {
      return category === String(getCoordinateXValue(value));
    });
    return foundItem ? getCoordinateYValue(foundItem) : '';
  });
}

function makeExportData(exportData) {
  var series = exportData.series;
  var categories = exportData.categories;
  return Object.keys(series).reduce(function (acc, type) {
    var result = series[type].data.map(function (_ref9) {
      var name = _ref9.name,
          data = _ref9.data;
      var values = !isNumber(getFirstValidValue(data)) && includes(['line', 'area', 'scatter'], type) ? makeCoordinateExportDataValues(type, categories, data) : data.map(function (value) {
        return Array.isArray(value) ? value.join() : value;
      });
      return [name].concat(downloader_toConsumableArray(values));
    });
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(result));
  }, series.gauge ? [] : [[''].concat(downloader_toConsumableArray(categories))]);
}

function get2DArrayFromRawData(exportData) {
  var result;
  var series = exportData.series;

  if (series.bullet) {
    result = makeBulletExportData(exportData);
  } else if (series.heatmap) {
    result = makeHeatmapExportData(exportData);
  } else if (series.bubble) {
    result = makeBubbleExportData(exportData);
  } else if (series.boxPlot) {
    result = makeBoxPlotExportData(exportData);
  } else if (series.pie) {
    result = makePieExportData(exportData);
  } else if (series.treemap) {
    result = makeTreemapExportData(exportData);
  } else {
    result = makeExportData(exportData);
  }

  return result;
}

function getTableElementStringForXLS(chartData2DArray) {
  var tableElementString = '<table>';
  chartData2DArray.forEach(function (row, rowIndex) {
    var cellTagName = rowIndex === 0 ? 'th' : 'td';
    tableElementString += '<tr>';
    row.forEach(function (cell, cellIndex) {
      var cellNumberClass = rowIndex !== 0 || cellIndex === 0 ? ' class="number"' : '';
      var cellString = "<".concat(cellTagName).concat(cellNumberClass, ">").concat(cell, "</").concat(cellTagName, ">");
      tableElementString += cellString;
    });
    tableElementString += '</tr>';
  });
  tableElementString += '</table>';
  return tableElementString;
}

function makeXLSBodyWithRawData(chartData2DArray) {
  return oneLineTrim(_templateObject || (_templateObject = _taggedTemplateLiteral(["<html xmlns:o=\"urn:schemas-microsoft-com:office:office\"\n        xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\n        xmlns=\"http://www.w3.org/TR/REC-html40\">\n        <head>\n            <!--[if gte mso 9]>\n                <xml>\n                    <x:ExcelWorkbook>\n                        <x:ExcelWorksheets>\n                            <x:ExcelWorksheet>\n                                <x:Name>Ark1</x:Name>\n                                <x:WorksheetOptions>\n                                    <x:DisplayGridlines/>\n                                </x:WorksheetOptions>\n                            </x:ExcelWorksheet>\n                        </x:ExcelWorksheets>\n                        </x:ExcelWorkbook>\n                </xml>\n            <![endif]-->\n            <meta name=ProgId content=Excel.Sheet>\n            <meta charset=UTF-8>\n        </head>\n        <body>\n            ", "\n        </body>\n        </html>"])), getTableElementStringForXLS(chartData2DArray));
}

function makeCSVBodyWithRawData(chartData2DArray) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _option$lineDelimiter = option.lineDelimiter,
      lineDelimiter = _option$lineDelimiter === void 0 ? "\n" : _option$lineDelimiter,
      _option$itemDelimiter = option.itemDelimiter,
      itemDelimiter = _option$itemDelimiter === void 0 ? ',' : _option$itemDelimiter;
  var lastRowIndex = chartData2DArray.length - 1;
  var csvText = '';
  chartData2DArray.forEach(function (row, rowIndex) {
    var lastCellIndex = row.length - 1;
    row.forEach(function (cell, cellIndex) {
      var cellContent = isNumber(cell) ? cell : "\"".concat(cell, "\"");
      csvText += cellContent;

      if (cellIndex < lastCellIndex) {
        csvText += itemDelimiter;
      }
    });

    if (rowIndex < lastRowIndex) {
      csvText += lineDelimiter;
    }
  });
  return csvText;
}

function execDownload(fileName, extension, content, contentType) {
  var downloadMethod = getDownloadMethod();

  if (!utils_isString(content) || !downloadMethod) {
    return;
  }

  downloadMethod(fileName, extension, content, contentType);
}
function downloadSpreadSheet(fileName, extension, data) {
  var chartData2DArray = get2DArrayFromRawData(data);
  var contentType = DATA_URI_HEADERS[extension].replace(/(data:|;base64,|,%EF%BB%BF)/g, '');
  var content = '';

  if (extension === 'csv') {
    content = makeCSVBodyWithRawData(chartData2DArray);
  } else {
    content = makeXLSBodyWithRawData(chartData2DArray);
  }

  if (isNeedDataEncoding()) {
    if (extension !== 'csv') {
      // base64 encoding for data URI scheme.
      content = window.btoa(unescape(encodeURIComponent(content)));
    }

    content = DATA_URI_HEADERS[extension] + content;
  }

  execDownload(fileName, extension, content, contentType);
}
;// CONCATENATED MODULE: ./src/component/exportMenu.ts
function exportMenu_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { exportMenu_typeof = function _typeof(obj) { return typeof obj; }; } else { exportMenu_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return exportMenu_typeof(obj); }















function exportMenu_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function exportMenu_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function exportMenu_createClass(Constructor, protoProps, staticProps) { if (protoProps) exportMenu_defineProperties(Constructor.prototype, protoProps); if (staticProps) exportMenu_defineProperties(Constructor, staticProps); return Constructor; }

function exportMenu_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) exportMenu_setPrototypeOf(subClass, superClass); }

function exportMenu_setPrototypeOf(o, p) { exportMenu_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return exportMenu_setPrototypeOf(o, p); }

function exportMenu_createSuper(Derived) { var hasNativeReflectConstruct = exportMenu_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = exportMenu_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = exportMenu_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return exportMenu_possibleConstructorReturn(this, result); }; }

function exportMenu_possibleConstructorReturn(self, call) { if (call && (exportMenu_typeof(call) === "object" || typeof call === "function")) { return call; } return exportMenu_assertThisInitialized(self); }

function exportMenu_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function exportMenu_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function exportMenu_getPrototypeOf(o) { exportMenu_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return exportMenu_getPrototypeOf(o); }

function exportMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var EXPORT_MENU_WIDTH = 140;
var BUTTON_RECT_SIZE = 24;

var ExportMenu = /*#__PURE__*/function (_Component) {
  exportMenu_inherits(ExportMenu, _Component);

  var _super = exportMenu_createSuper(ExportMenu);

  function ExportMenu() {
    var _this;

    exportMenu_classCallCheck(this, ExportMenu);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "responders", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "models", {
      exportMenuButton: []
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "opened", false);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "fileName", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "data", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartEl", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "exportMenuEl", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "theme", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartBackgroundColor", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartWidth", 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "toggleExportMenu", function () {
      _this.opened = !_this.opened;
      _this.models.exportMenuButton[0].opened = _this.opened;

      _this.eventBus.emit('needDraw');

      if (_this.opened) {
        _this.applyPanelWrapperStyle();

        _this.chartEl.appendChild(_this.exportMenuEl);
      } else {
        _this.chartEl.removeChild(_this.exportMenuEl);
      }
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "getCanvasExportBtnRemoved", function () {
      var canvas = _this.chartEl.getElementsByTagName('canvas')[0];

      var ctx = canvas.getContext('2d');
      var _this$rect = _this.rect,
          x = _this$rect.x,
          y = _this$rect.y,
          h = _this$rect.height,
          w = _this$rect.width;
      ctx.clearRect(x, y, w, h);
      ctx.fillStyle = _this.chartBackgroundColor;
      ctx.fillRect(x, y, w, h);
      return canvas;
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "onClickExportButton", function (ev) {
      var id = ev.target.id;

      if (id === 'png' || id === 'jpeg') {
        var canvas = _this.getCanvasExportBtnRemoved();

        execDownload(_this.fileName, id, canvas.toDataURL("image/".concat(id), 1));
      } else {
        downloadSpreadSheet(_this.fileName, id, _this.data);
      }

      _this.toggleExportMenu();
    });

    return _this;
  }

  exportMenu_createClass(ExportMenu, [{
    key: "applyExportButtonPanelStyle",
    value: function applyExportButtonPanelStyle() {
      var exportMenuTitle = this.exportMenuEl.querySelector('.toastui-chart-export-menu-title');
      var menuBtnWrapper = this.exportMenuEl.querySelector('.toastui-chart-export-menu-btn-wrapper');
      exportMenuTitle.setAttribute('style', this.makePanelStyle('header'));
      menuBtnWrapper.setAttribute('style', this.makePanelStyle('body'));
    }
  }, {
    key: "makeExportMenuButton",
    value: function makeExportMenuButton() {
      var el = document.createElement('div');
      el.onclick = this.onClickExportButton;
      el.innerHTML = "\n        <div class=\"toastui-chart-export-menu\">\n          <p class=\"toastui-chart-export-menu-title\">Export to</p>\n          <div class=\"toastui-chart-export-menu-btn-wrapper\">\n            <button class=\"toastui-chart-export-menu-btn\" id=\"xls\">xls</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"csv\">csv</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"png\">png</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"jpeg\">jpeg</button>\n          </div>\n        </div>\n      ";
      return el;
    }
  }, {
    key: "initialize",
    value: function initialize(_ref) {
      var chartEl = _ref.chartEl;
      this.chartEl = chartEl;
      this.type = 'exportMenu';
      this.name = 'exportMenu';
      this.exportMenuEl = this.makeExportMenuButton();
    }
  }, {
    key: "onClick",
    value: function onClick(_ref2) {
      var responders = _ref2.responders;

      if (responders.length) {
        this.toggleExportMenu();
      }
    }
  }, {
    key: "getFileName",
    value: function getFileName(title) {
      var _title$text;

      return utils_isString(title) ? title : (_title$text = title === null || title === void 0 ? void 0 : title.text) !== null && _title$text !== void 0 ? _title$text : 'toast-ui-chart';
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _options$exportMenu;

      var options = _ref3.options,
          layout = _ref3.layout,
          chart = _ref3.chart,
          series = _ref3.series,
          rawCategories = _ref3.rawCategories,
          theme = _ref3.theme;
      this.isShow = isExportMenuVisible(options);
      this.chartWidth = chart.width;

      if (!this.isShow) {
        return;
      }

      this.chartBackgroundColor = theme.chart.backgroundColor;
      this.theme = theme.exportMenu;
      this.data = {
        series: series,
        categories: rawCategories
      };
      this.fileName = this.getFileName((options === null || options === void 0 ? void 0 : (_options$exportMenu = options.exportMenu) === null || _options$exportMenu === void 0 ? void 0 : _options$exportMenu.filename) || chart.title);
      this.applyExportButtonPanelStyle();
      this.rect = layout.exportMenu;
      this.models.exportMenuButton = [{
        type: 'exportMenuButton',
        x: 0,
        y: 0,
        opened: this.opened,
        theme: this.theme.button
      }];
      this.responders = [{
        type: 'rect',
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE,
        x: 0,
        y: 0
      }];
    }
  }, {
    key: "applyPanelWrapperStyle",
    value: function applyPanelWrapperStyle() {
      var exportMenu = this.exportMenuEl.querySelector('.toastui-chart-export-menu');
      var x = this.chartWidth - EXPORT_MENU_WIDTH - padding.X;
      var y = padding.Y + BUTTON_RECT_SIZE + 5;
      var _this$theme$panel = this.theme.panel,
          borderRadius = _this$theme$panel.borderRadius,
          borderWidth = _this$theme$panel.borderWidth,
          borderColor = _this$theme$panel.borderColor;
      var style = "\n      transform: ".concat(getTranslateString(x, y), ";\n      border: ").concat(borderWidth, "px solid ").concat(borderColor, ";\n      border-radius: ").concat(borderRadius, "px;");
      exportMenu.setAttribute('style', style);
    }
  }, {
    key: "makePanelStyle",
    value: function makePanelStyle(type) {
      var sectionTheme = this.theme.panel[type];
      var direction = type === 'header' ? 'top' : 'bottom';
      var _ref4 = this.theme.panel,
          borderRadius = _ref4.borderRadius,
          borderWidth = _ref4.borderWidth;
      var borderRadiusPx = "".concat(borderRadius - borderWidth, "px");
      return ["".concat(getFontStyleString(sectionTheme)), "border-".concat(direction, "-left-radius: ").concat(borderRadiusPx, ";"), "border-".concat(direction, "-right-radius: ").concat(borderRadiusPx, ";"), "background-color: ".concat(sectionTheme.backgroundColor, ";")].join('');
    }
  }]);

  return ExportMenu;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/dataLabel.ts







function dataLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function dataLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dataLabel_ownKeys(Object(source), true).forEach(function (key) { dataLabel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dataLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function dataLabel(ctx, model) {
  var x = model.x,
      y = model.y,
      text = model.text,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline,
      opacity = model.opacity,
      callout = model.callout,
      theme = model.theme,
      radian = model.radian;
  var color = theme.color,
      textBubble = theme.textBubble;
  var font = getFont(theme);
  var textStyle = {
    textAlign: textAlign,
    textBaseline: textBaseline,
    font: font,
    fillStyle: color
  };
  var textStrokeStyle = getTextStrokeStyle(theme);

  if (callout) {
    var _callout$theme = callout.theme,
        lineWidth = _callout$theme.lineWidth,
        lineColor = _callout$theme.lineColor;
    line(ctx, dataLabel_objectSpread(dataLabel_objectSpread({
      type: 'line'
    }, pick(callout, 'x', 'y', 'x2', 'y2')), {}, {
      strokeStyle: lineColor,
      lineWidth: lineWidth
    }));
  }

  if (textBubble !== null && textBubble !== void 0 && textBubble.visible) {
    drawBubbleLabel(ctx, model);
    return;
  }

  label(ctx, {
    type: 'label',
    x: x,
    y: y,
    text: text,
    style: [textStyle],
    stroke: [textStrokeStyle],
    opacity: opacity,
    radian: radian
  });
}
function drawBubbleLabel(ctx, model) {
  var text = model.text,
      theme = model.theme,
      _model$radian = model.radian,
      radian = _model$radian === void 0 ? 0 : _model$radian;
  var _ref = theme,
      color = _ref.color,
      textStrokeColor = _ref.textStrokeColor;
  var font = getFont(theme);
  var bubbleRect = getBubbleRect(model);
  var x = bubbleRect.x,
      y = bubbleRect.y,
      width = bubbleRect.width,
      height = bubbleRect.height;
  bubbleLabel(ctx, {
    type: 'bubbleLabel',
    radian: radian,
    rotationPosition: {
      x: model.x,
      y: model.y
    },
    bubble: bubbleRect,
    label: {
      x: x + width / 2,
      y: y + height / 2,
      text: text,
      style: [{
        font: font,
        fillStyle: color,
        textAlign: 'center',
        textBaseline: 'middle'
      }],
      strokeStyle: textStrokeColor
    }
  });
}
function getBubbleArrowPoints(direction, _ref2, arrowPointTheme) {
  var x = _ref2.x,
      y = _ref2.y;
  var width = arrowPointTheme.width;
  var height = arrowPointTheme.height;
  var points = [];

  if (direction === 'top') {
    points = [{
      x: x - width / 2,
      y: y + height
    }, {
      x: x,
      y: y
    }, {
      x: x + width / 2,
      y: y + height
    }];
  } else if (direction === 'bottom') {
    points = [{
      x: x + width / 2,
      y: y - height
    }, {
      x: x,
      y: y
    }, {
      x: x - width / 2,
      y: y - height
    }];
  } else if (direction === 'right') {
    points = [{
      x: x - height,
      y: y - width / 2
    }, {
      x: x,
      y: y
    }, {
      x: x - height,
      y: y + width / 2
    }];
  } else if (direction === 'left') {
    points = [{
      x: x + height,
      y: y + width / 2
    }, {
      x: x,
      y: y
    }, {
      x: x + height,
      y: y - width / 2
    }];
  }

  return points;
}

function getBubbleRect(model) {
  var text = model.text,
      theme = model.theme,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline;
  var font = getFont(theme);
  var _ref3 = theme.textBubble,
      arrow = _ref3.arrow,
      paddingX = _ref3.paddingX,
      paddingY = _ref3.paddingY,
      borderRadius = _ref3.borderRadius,
      borderColor = _ref3.borderColor,
      borderWidth = _ref3.borderWidth,
      backgroundColor = _ref3.backgroundColor,
      shadowBlur = _ref3.shadowBlur,
      shadowOffsetX = _ref3.shadowOffsetX,
      shadowOffsetY = _ref3.shadowOffsetY,
      shadowColor = _ref3.shadowColor;
  var labelWidth = getTextWidth(text, font);
  var width = labelWidth + paddingX * 2;
  var height = getTextHeight(text, font) + paddingY * 2;
  var x = model.x,
      y = model.y;

  if (textAlign === 'center') {
    x -= width / 2;
  } else if (includes(['right', 'end'], textAlign)) {
    x -= width;
  }

  if (textBaseline === 'middle') {
    y -= height / 2;
  } else if (textBaseline === 'bottom') {
    y -= height;
  }

  var rect = {
    x: x,
    y: y,
    width: width,
    height: height
  };
  return dataLabel_objectSpread(dataLabel_objectSpread({}, rect), {}, {
    radius: borderRadius,
    lineWidth: borderWidth,
    fill: backgroundColor,
    strokeStyle: borderColor,
    style: [{
      shadowBlur: shadowBlur,
      shadowOffsetX: shadowOffsetX,
      shadowOffsetY: shadowOffsetY,
      shadowColor: shadowColor
    }]
  }, getArrowInfo(rect, textAlign, textBaseline, arrow));
}

function getArrowInfo(rect, textAlign, textBaseline, theme) {
  var _theme$direction;

  if (!(theme !== null && theme !== void 0 && theme.visible)) {
    return null;
  }

  var arrowHeight = theme.height;
  var width = rect.width,
      height = rect.height;
  var direction = (_theme$direction = theme.direction) !== null && _theme$direction !== void 0 ? _theme$direction : getArrowDirection(textAlign, textBaseline);
  var boxX = rect.x,
      boxY = rect.y;
  var pointX = rect.x,
      pointY = rect.y;

  if (direction === 'top') {
    boxY += arrowHeight;
  } else if (direction === 'bottom') {
    boxY -= arrowHeight;
    pointY += height;
  } else if (direction === 'right') {
    boxX -= arrowHeight;
    pointX += width;
  } else if (direction === 'left') {
    boxX += arrowHeight;
  }

  if (textAlign === 'center') {
    pointX = rect.x + width / 2;
  } else if (textBaseline === 'middle') {
    pointY = rect.y + height / 2;
  }

  return {
    direction: direction,
    points: getBubbleArrowPoints(direction, {
      x: pointX,
      y: pointY
    }, theme),
    x: boxX,
    y: boxY
  };
}

function getArrowDirection(textAlign, textBaseline) {
  var direction = 'top';

  if (textAlign === 'center' && textBaseline === 'top') {
    direction = 'top';
  } else if (textAlign === 'center' && textBaseline === 'bottom') {
    direction = 'bottom';
  } else if (textBaseline === 'middle' && textAlign === 'right') {
    direction = 'right';
  } else if (textBaseline === 'middle' && textAlign === 'left') {
    direction = 'left';
  }

  return direction;
}

function getTextStrokeStyle(theme) {
  var textStrokeColor = theme.textStrokeColor;
  var textStrokeStyle = pick(theme, 'lineWidth', 'shadowColor', 'shadowBlur');

  if (textStrokeColor) {
    textStrokeStyle.strokeStyle = textStrokeColor;
  }

  return textStrokeStyle;
}
;// CONCATENATED MODULE: ./src/brushes/spectrumLegend.ts
function spectrumLegend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function spectrumLegend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { spectrumLegend_ownKeys(Object(source), true).forEach(function (key) { spectrumLegend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { spectrumLegend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function spectrumLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











var SPECTRUM_LEGEND_LABEL_HEIGHT = 12;
var spectrumLegendBar = {
  HEIGHT: 6,
  PADDING: 5
};
var spectrumLegendTooltip = {
  HEIGHT: 28,
  POINT_WIDTH: 8,
  POINT_HEIGHT: 6,
  PADDING: 6
};

function getBarStartPoint(model) {
  var align = model.align,
      modelX = model.x,
      modelY = model.y,
      labels = model.labels,
      width = model.width;
  var PADDING = spectrumLegendBar.PADDING;
  var x, y;

  if (align === 'top') {
    x = modelX;
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING;
  } else if (align === 'bottom') {
    x = modelX;
    y = modelY + spectrumLegendTooltip.HEIGHT;
  } else if (align === 'left') {
    x = modelX + getMaxLengthLabelWidth(labels) + PADDING;
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
  } else {
    x = modelX + width - (getMaxLengthLabelWidth(labels) + padding.X + PADDING * 2 + spectrumLegendBar.HEIGHT);
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
  }

  return {
    x: x,
    y: y
  };
}

function getLabelsStartPoint(model) {
  var align = model.align,
      modelX = model.x,
      modelY = model.y,
      labels = model.labels,
      width = model.width;
  var x, y;

  if (align === 'top') {
    x = modelX;
    y = modelY;
  } else if (align === 'bottom') {
    x = modelX;
    y = modelY + spectrumLegendTooltip.HEIGHT + spectrumLegendBar.HEIGHT + spectrumLegendBar.PADDING;
  } else if (align === 'left') {
    x = modelX + getMaxLengthLabelWidth(labels);
    y = modelY;
  } else {
    x = modelX + width - getMaxLengthLabelWidth(labels) - padding.X;
    y = modelY;
  }

  return {
    x: x,
    y: y
  };
}

function getBarSize(width, height, verticalAlign) {
  var HEIGHT = spectrumLegendBar.HEIGHT;
  var barWidth = verticalAlign ? width : HEIGHT;
  var barHeight = verticalAlign ? HEIGHT : height - SPECTRUM_LEGEND_LABEL_HEIGHT;
  return {
    barWidth: barWidth,
    barHeight: barHeight
  };
}

function drawLabels(ctx, model) {
  var labels = model.labels,
      align = model.align,
      x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      verticalAlign = model.verticalAlign;

  var _getBarSize = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize.barWidth,
      barHeight = _getBarSize.barHeight;

  var labelSize = labels.length - 1;
  var textBaseStyleMap = {
    left: {
      textAlign: 'right',
      textBaseline: 'top'
    },
    right: {
      textAlign: 'left',
      textBaseline: 'top'
    },
    top: {
      textAlign: 'center',
      textBaseline: 'top'
    },
    bottom: {
      textAlign: 'center',
      textBaseline: 'top'
    }
  };
  labels.forEach(function (text, idx) {
    var startX = verticalAlign ? x + barWidth / labelSize * idx : x;
    var startY = verticalAlign ? y : y + barHeight / labelSize * idx;
    label(ctx, {
      type: 'label',
      x: startX,
      y: startY,
      text: text,
      style: ['default', textBaseStyleMap[align]]
    });
  });
}

function drawBar(ctx, model) {
  var width = model.width,
      height = model.height,
      startColor = model.startColor,
      endColor = model.endColor,
      x = model.x,
      y = model.y,
      verticalAlign = model.verticalAlign;

  var _getBarSize2 = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize2.barWidth,
      barHeight = _getBarSize2.barHeight;

  var gradient = verticalAlign ? ctx.createLinearGradient(x, y, x + barWidth, y) : ctx.createLinearGradient(x, y, x, y + barHeight);
  gradient.addColorStop(0, startColor);
  gradient.addColorStop(1, endColor);
  ctx.fillStyle = gradient;
  ctx.fillRect(x, y, barWidth, barHeight);
}

function getTooltipArrowPoint(model) {
  var align = model.align,
      colorRatio = model.colorRatio,
      width = model.width,
      height = model.height,
      x = model.x,
      y = model.y,
      labels = model.labels,
      verticalAlign = model.verticalAlign;

  var _getBarSize3 = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize3.barWidth,
      barHeight = _getBarSize3.barHeight;

  var PADDING = spectrumLegendBar.PADDING,
      HEIGHT = spectrumLegendBar.HEIGHT;

  if (align === 'top') {
    return {
      x: x + barWidth * colorRatio,
      y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + HEIGHT + PADDING * 2
    };
  }

  if (align === 'bottom') {
    return {
      x: x + barWidth * colorRatio,
      y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2
    };
  }

  if (align === 'left') {
    return {
      x: x + getMaxLengthLabelWidth(labels) + HEIGHT + PADDING * 2,
      y: y + barHeight * colorRatio + PADDING
    };
  }

  if (align === 'right') {
    return {
      x: x + width - (getMaxLengthLabelWidth(labels) + padding.X + PADDING * 3 + HEIGHT),
      y: y + barHeight * colorRatio + PADDING
    };
  }
}

function spectrumLegend(ctx, model) {
  var labelsStartPoint = getLabelsStartPoint(model);
  var barStartPoint = getBarStartPoint(model);
  drawLabels(ctx, spectrumLegend_objectSpread(spectrumLegend_objectSpread({}, model), labelsStartPoint));
  drawBar(ctx, spectrumLegend_objectSpread(spectrumLegend_objectSpread({}, model), barStartPoint));
}
function spectrumTooltip(ctx, model) {
  var _ref = getTooltipArrowPoint(model),
      x = _ref.x,
      y = _ref.y;

  var PADDING = spectrumLegendTooltip.PADDING,
      POINT_HEIGHT = spectrumLegendTooltip.POINT_HEIGHT,
      POINT_WIDTH = spectrumLegendTooltip.POINT_WIDTH;
  var align = model.align,
      text = model.text,
      color = model.color;
  var labelWidth = getTextWidth(text);
  var width = labelWidth + PADDING * 2;
  var height = SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2;
  var direction = align;
  var boxStartX = x;
  var boxStartY = y;

  if (align === 'top') {
    boxStartY += POINT_HEIGHT;
  } else if (align === 'right') {
    boxStartX -= width / 2 + POINT_HEIGHT;
    boxStartY -= height / 2;
  } else if (align === 'left') {
    boxStartX += width / 2 + POINT_HEIGHT;
    boxStartY -= height / 2;
  } else if (align === 'bottom') {
    boxStartY -= height + POINT_HEIGHT;
  }

  var points = getBubbleArrowPoints(align, {
    x: x,
    y: y
  }, {
    visible: true,
    width: POINT_WIDTH,
    height: POINT_HEIGHT
  });
  bubbleLabel(ctx, {
    type: 'bubbleLabel',
    bubble: {
      x: boxStartX - width / 2,
      y: boxStartY,
      width: width,
      height: height,
      points: points,
      direction: direction,
      fill: color
    },
    label: {
      text: text,
      x: boxStartX,
      y: boxStartY + height / 2,
      style: [{
        font: 'normal 11px Arial',
        fillStyle: '#333333',
        textAlign: 'center',
        textBaseline: 'middle'
      }]
    }
  });
}
;// CONCATENATED MODULE: ./src/store/layout.ts







function layout_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function layout_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { layout_ownKeys(Object(source), true).forEach(function (key) { layout_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { layout_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function layout_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var padding = {
  X: 10,
  Y: 15
};
var X_AXIS_HEIGHT = 20;
var Y_AXIS_MIN_WIDTH = 40;
function isVerticalAlign(align) {
  return align === 'top' || align === 'bottom';
}

function getValidRectSize(size, width, height) {
  var _size$height, _size$width;

  return {
    height: (_size$height = size === null || size === void 0 ? void 0 : size.height) !== null && _size$height !== void 0 ? _size$height : height,
    width: (_size$width = size === null || size === void 0 ? void 0 : size.width) !== null && _size$width !== void 0 ? _size$width : width
  };
}

function getDefaultXAxisHeight(size) {
  var _size$xAxis;

  return (_size$xAxis = size.xAxis) !== null && _size$xAxis !== void 0 && _size$xAxis.height && !size.yAxis ? size.xAxis.height : X_AXIS_HEIGHT;
}

function getDefaultYAxisXPoint(yAxisRectParam) {
  var yAxisTitle = yAxisRectParam.yAxisTitle,
      isRightSide = yAxisRectParam.isRightSide,
      visibleSecondaryYAxis = yAxisRectParam.visibleSecondaryYAxis;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
  return isRightSide && visibleSecondaryYAxis ? Math.max(yAxisTitle.x + yAxisTitle.width - yAxisWidth, 0) : yAxisTitle.x;
}

function getYAxisXPoint(yAxisRectParam) {
  var chartSize = yAxisRectParam.chartSize,
      legend = yAxisRectParam.legend,
      circleLegend = yAxisRectParam.circleLegend,
      hasCenterYAxis = yAxisRectParam.hasCenterYAxis,
      maxLabelWidth = yAxisRectParam.maxLabelWidth;
  var width = chartSize.width;
  var align = legend.align;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
  var x = getDefaultYAxisXPoint(yAxisRectParam);

  if (hasCenterYAxis) {
    yAxisWidth = maxLabelWidth + (TICK_SIZE + padding.X) * 2;
    x = (width - legend.width - yAxisWidth + padding.X * 2) / 2;
  }

  if (legend.visible && align === 'left') {
    x = getDefaultYAxisXPoint(yAxisRectParam);
  }

  if (circleLegend.visible && align === 'left') {
    x = Math.max(circleLegend.width + padding.X, x);
  }

  return x;
}

function getYAxisYPoint(_ref) {
  var yAxisTitle = _ref.yAxisTitle;
  return yAxisTitle.y + yAxisTitle.height;
}

function getDefaultYAxisWidth(_ref2) {
  var _size$width2, _size;

  var maxLabelWidth = _ref2.maxLabelWidth,
      size = _ref2.size,
      isRightSide = _ref2.isRightSide;
  return (_size$width2 = size === null || size === void 0 ? void 0 : (_size = size[isRightSide ? 'secondaryYAxis' : 'yAxis']) === null || _size === void 0 ? void 0 : _size.width) !== null && _size$width2 !== void 0 ? _size$width2 : maxLabelWidth;
}

function getYAxisWidth(yAxisRectParam) {
  var hasCenterYAxis = yAxisRectParam.hasCenterYAxis,
      hasXYAxis = yAxisRectParam.hasXYAxis,
      maxLabelWidth = yAxisRectParam.maxLabelWidth,
      _yAxisRectParam$visib = yAxisRectParam.visibleSecondaryYAxis,
      visibleSecondaryYAxis = _yAxisRectParam$visib === void 0 ? false : _yAxisRectParam$visib,
      _yAxisRectParam$isRig = yAxisRectParam.isRightSide,
      isRightSide = _yAxisRectParam$isRig === void 0 ? false : _yAxisRectParam$isRig;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);

  if (hasCenterYAxis && !isRightSide) {
    yAxisWidth = maxLabelWidth + (TICK_SIZE + padding.X) * 2;
  } else if (!hasXYAxis || isRightSide && !visibleSecondaryYAxis) {
    yAxisWidth = 0;
  }

  return yAxisWidth;
}

function getYAxisHeight(_ref3) {
  var _size$yAxis, _size$plot;

  var chartSize = _ref3.chartSize,
      legend = _ref3.legend,
      yAxisTitle = _ref3.yAxisTitle,
      hasXYAxis = _ref3.hasXYAxis,
      size = _ref3.size,
      xAxisTitleHeight = _ref3.xAxisTitleHeight;
  var height = chartSize.height;
  var align = legend.align,
      legendHeight = legend.height;
  var xAxisHeight = getDefaultXAxisHeight(size);
  var y = yAxisTitle.y + yAxisTitle.height;
  var yAxisHeight = height - y - xAxisHeight - xAxisTitleHeight;

  if (!hasXYAxis) {
    yAxisHeight = height - y;
  }

  if (legend.visible) {
    var topArea = Math.max(y, legendHeight);

    if (align === 'top') {
      yAxisHeight = height - topArea - (hasXYAxis ? X_AXIS_HEIGHT + xAxisTitleHeight : 0);
    } else if (align === 'bottom') {
      yAxisHeight = height - y - X_AXIS_HEIGHT - xAxisTitleHeight - legendHeight;
    }
  }

  if (!(size !== null && size !== void 0 && (_size$yAxis = size.yAxis) !== null && _size$yAxis !== void 0 && _size$yAxis.height) && size !== null && size !== void 0 && (_size$plot = size.plot) !== null && _size$plot !== void 0 && _size$plot.height) {
    yAxisHeight = size.plot.height;
  }

  return yAxisHeight;
}

function getYAxisRect(yAxisRectParam) {
  var size = yAxisRectParam.size,
      _yAxisRectParam$isRig2 = yAxisRectParam.isRightSide,
      isRightSide = _yAxisRectParam$isRig2 === void 0 ? false : _yAxisRectParam$isRig2;
  var x = getYAxisXPoint(yAxisRectParam);
  var y = getYAxisYPoint(yAxisRectParam);
  var yAxisWidth = getYAxisWidth(yAxisRectParam);
  var yAxisHeight = getYAxisHeight(yAxisRectParam);
  return layout_objectSpread({
    x: x,
    y: y
  }, getValidRectSize(isRightSide ? size === null || size === void 0 ? void 0 : size.secondaryYAxis : size === null || size === void 0 ? void 0 : size.yAxis, yAxisWidth, yAxisHeight));
}

function getXAxisWidth(_ref4) {
  var chartSize = _ref4.chartSize,
      yAxis = _ref4.yAxis,
      hasCenterYAxis = _ref4.hasCenterYAxis,
      legend = _ref4.legend,
      circleLegend = _ref4.circleLegend,
      secondaryYAxis = _ref4.secondaryYAxis,
      xAxisData = _ref4.xAxisData;
  var width = chartSize.width;
  var align = legend.align,
      legendWidth = legend.width;
  var legendVerticalAlign = isVerticalAlign(align);
  var xAxisWidth;

  if (legendVerticalAlign) {
    xAxisWidth = width - (yAxis.x + yAxis.width + padding.X);

    if (circleLegend.visible) {
      xAxisWidth -= circleLegend.width;
    }
  } else {
    xAxisWidth = width - (yAxis.width + Math.max(legendWidth, circleLegend.visible ? circleLegend.width : 0));
  }

  if (hasCenterYAxis) {
    xAxisWidth = width - (legendVerticalAlign ? 0 : legendWidth) - padding.X * 2;
  }

  if (secondaryYAxis.width) {
    xAxisWidth -= secondaryYAxis.width;
  }

  if (xAxisData !== null && xAxisData !== void 0 && xAxisData.maxLabelWidth) {
    // subtract half of the maximum label length to secure margin size
    xAxisWidth -= xAxisData.maxLabelWidth * 0.5;
  }

  return xAxisWidth;
}

function getXAxisHeight(xAxisData) {
  var _xAxisData$maxHeight;

  var hasXYAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!hasXYAxis) {
    return 0;
  }

  return (_xAxisData$maxHeight = xAxisData === null || xAxisData === void 0 ? void 0 : xAxisData.maxHeight) !== null && _xAxisData$maxHeight !== void 0 ? _xAxisData$maxHeight : X_AXIS_HEIGHT;
}

function getXAxisRect(xAxisRectParam) {
  var hasXYAxis = xAxisRectParam.hasXYAxis,
      hasCenterYAxis = xAxisRectParam.hasCenterYAxis,
      yAxis = xAxisRectParam.yAxis,
      size = xAxisRectParam.size,
      xAxisData = xAxisRectParam.xAxisData;
  var x = hasCenterYAxis ? padding.X * 2 : yAxis.x + yAxis.width;
  var y = yAxis.y + yAxis.height;
  var xAxisWidth = getXAxisWidth(xAxisRectParam);
  var xAxisHeight = getXAxisHeight(xAxisData, hasXYAxis);
  return layout_objectSpread({
    x: x,
    y: y
  }, getValidRectSize(size === null || size === void 0 ? void 0 : size.xAxis, xAxisWidth, xAxisHeight));
}

function getLegendRect(legendRectParams) {
  var legend = legendRectParams.legend,
      xAxis = legendRectParams.xAxis,
      yAxis = legendRectParams.yAxis,
      chartSize = legendRectParams.chartSize,
      title = legendRectParams.title,
      hasXYAxis = legendRectParams.hasXYAxis,
      secondaryYAxis = legendRectParams.secondaryYAxis,
      xAxisTitleHeight = legendRectParams.xAxisTitleHeight;

  if (!legend.visible) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  var align = legend.align,
      legendWidth = legend.width,
      legendHeight = legend.height;
  var width = chartSize.width;
  var verticalAlign = isVerticalAlign(align);
  var x = xAxis.x + xAxis.width + secondaryYAxis.width + padding.X;
  var y = Math.max(yAxis.y, BUTTON_RECT_SIZE);

  if (verticalAlign) {
    x = (width - legendWidth) / 2;

    if (align === 'top') {
      y = title.y + title.height;
    } else {
      y = yAxis.y + yAxis.height + (hasXYAxis ? xAxis.height + xAxisTitleHeight : padding.Y);
    }
  } else if (align === 'left') {
    x = padding.X;
  }

  return {
    width: legendWidth,
    height: legendHeight,
    x: x,
    y: y
  };
}

function getCircleLegendRect(xAxis, yAxis, align, width) {
  return {
    width: width,
    height: yAxis.height,
    x: align === 'left' ? padding.X : xAxis.x + xAxis.width + padding.X,
    y: yAxis.y
  };
}

function getPlotRect(xAxis, yAxis, size) {
  return layout_objectSpread({
    x: xAxis.x,
    y: yAxis.y
  }, getValidRectSize(size, xAxis.width, yAxis.height));
}

function getTitleRect(chartSize, exportMenu, visible, titleHeight) {
  var point = {
    x: padding.X,
    y: padding.Y
  };
  var marginBottom = 5;
  var width = visible ? chartSize.width - exportMenu.width : 0;
  var height = visible ? Math.max(titleHeight + marginBottom, exportMenu.height) : exportMenu.height;
  return layout_objectSpread({
    width: width,
    height: height
  }, point);
}

function getTopLegendAreaHeight(useSpectrumLegend, legendHeight) {
  return useSpectrumLegend ? SPECTRUM_LEGEND_LABEL_HEIGHT + spectrumLegendBar.PADDING * 2 + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendTooltip.HEIGHT + padding.Y : legendHeight + padding.Y;
}

function getYAxisTitleRect(_ref5) {
  var chartSize = _ref5.chartSize,
      visible = _ref5.visible,
      title = _ref5.title,
      _ref5$legend = _ref5.legend,
      legendAlign = _ref5$legend.align,
      legendWidth = _ref5$legend.width,
      legendHeight = _ref5$legend.height,
      legendVisible = _ref5$legend.visible,
      useSpectrumLegend = _ref5$legend.useSpectrumLegend,
      hasCenterYAxis = _ref5.hasCenterYAxis,
      visibleSecondaryYAxis = _ref5.visibleSecondaryYAxis,
      _ref5$isRightSide = _ref5.isRightSide,
      isRightSide = _ref5$isRightSide === void 0 ? false : _ref5$isRightSide,
      yAxisTitleHeight = _ref5.yAxisTitleHeight;
  var marginBottom = 5;
  var height = visible ? yAxisTitleHeight + marginBottom : 0;
  var verticalLegendAlign = isVerticalAlign(legendAlign);
  var width = (chartSize.width - (verticalLegendAlign ? padding.X * 2 : legendWidth)) / (visibleSecondaryYAxis ? 2 : 1);
  var point = {
    x: isRightSide ? title.x + width : title.x,
    y: title.y + title.height
  };

  if (legendVisible) {
    if (legendAlign === 'left') {
      point.x += legendWidth;
    } else if (legendAlign === 'top') {
      point.y += getTopLegendAreaHeight(useSpectrumLegend, legendHeight);
    }
  }

  if (hasCenterYAxis) {
    point.x = (width + padding.X * 2) / 2;
  }

  return layout_objectSpread({
    height: height,
    width: width
  }, point);
}

function getXAxisTitleRect(visible, xAxis, xAxisTitleHeight) {
  var point = {
    x: xAxis.x,
    y: xAxis.y + xAxis.height
  };
  var height = visible ? xAxisTitleHeight : 0;
  var width = visible ? xAxis.width : 0;
  return layout_objectSpread({
    height: height,
    width: width
  }, point);
}

function getExportMenuRect(chartSize, visible) {
  var marginY = 5;
  var x = visible ? padding.X + chartSize.width - BUTTON_RECT_SIZE : padding.X + chartSize.width;
  var y = padding.Y;
  var height = visible ? BUTTON_RECT_SIZE + marginY : 0;
  var width = visible ? BUTTON_RECT_SIZE : 0;
  return {
    x: x,
    y: y,
    height: height,
    width: width
  };
}

function getResetButtonRect(exportMenu, useResetButton) {
  var marginY = 5;
  var x = useResetButton ? exportMenu.x - BUTTON_RECT_SIZE - padding.X : 0;
  var y = useResetButton ? exportMenu.y : 0;
  var height = useResetButton ? BUTTON_RECT_SIZE + marginY : 0;
  var width = useResetButton ? BUTTON_RECT_SIZE : 0;
  return {
    x: x,
    y: y,
    height: height,
    width: width
  };
}

function isUsingResetButton(options) {
  var _options$series;

  return !!((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.zoomable);
}
function isExportMenuVisible(options) {
  var _options$exportMenu;

  var visible = (_options$exportMenu = options.exportMenu) === null || _options$exportMenu === void 0 ? void 0 : _options$exportMenu.visible;
  return isUndefined(visible) ? true : visible;
}

function getYAxisMaxLabelWidth(maxLabelLength) {
  return maxLabelLength ? maxLabelLength + padding.X : Y_AXIS_MIN_WIDTH;
}

function pickOptionSize(option) {
  if (!option || isUndefined(option.width) && isUndefined(option.height)) {
    return null;
  }

  return pick(option, 'width', 'height');
}

function validOffsetValue(axis, plot, sizeKey) {
  var axisSize = axis[sizeKey];
  var plotSize = plot[sizeKey];

  if (isNumber(axisSize) && isNumber(plotSize)) {
    return Math.max(axisSize, plotSize);
  }
}

function getOptionSize(options) {
  var xAxis = pickOptionSize(options.xAxis);
  var yAxisOptions = getYAxisOption(options);
  var yAxis = pickOptionSize(yAxisOptions.yAxis);
  var secondaryYAxis = pickOptionSize(yAxisOptions.secondaryYAxis);
  var plot = pickOptionSize(options.plot);

  if (plot) {
    /*
    If both the width of the x-axis and the width of the plot are entered,
    set the maximum value.
    */
    if (xAxis) {
      xAxis.width = plot.width = validOffsetValue(xAxis, plot, 'width');
    }
    /*
    If both the height of the y-axis and the height of the plot are entered,
    set the maximum value.
    */


    if (yAxis) {
      yAxis.height = plot.height = validOffsetValue(yAxis, plot, 'height');
    }

    if (secondaryYAxis) {
      secondaryYAxis.height = plot.height = validOffsetValue(secondaryYAxis, plot, 'height');
    }
  }

  return {
    xAxis: xAxis,
    yAxis: yAxis,
    plot: plot,
    secondaryYAxis: secondaryYAxis
  };
}

function getAxisTitleHeight(axisTheme) {
  var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var fontSize = Array.isArray(axisTheme) ? Math.max(axisTheme[0].title.fontSize, axisTheme[1].title.fontSize) : axisTheme.title.fontSize;
  return fontSize + offsetY;
}

function adjustAxisSize(_ref6, layout, legendState) {
  var width = _ref6.width,
      height = _ref6.height;

  if (width < 0 || height < 0) {
    return;
  }

  var title = layout.title,
      yAxisTitle = layout.yAxisTitle,
      yAxis = layout.yAxis,
      xAxis = layout.xAxis,
      xAxisTitle = layout.xAxisTitle,
      legend = layout.legend,
      secondaryYAxis = layout.secondaryYAxis;
  var align = legendState.align;
  var hasVerticalLegend = isVerticalAlign(align);
  var legendHeight = hasVerticalLegend ? legend.height : 0;
  var diffHeight = xAxis.height + xAxisTitle.height + yAxis.height + yAxisTitle.height + title.height + legendHeight - height;

  if (diffHeight > 0) {
    yAxis.height -= diffHeight;
    xAxis.y -= diffHeight;
    xAxisTitle.y -= diffHeight;

    if (hasVerticalLegend) {
      legend.y -= diffHeight;
    }
  }

  secondaryYAxis.x = xAxis.x + xAxis.width;
  secondaryYAxis.height = yAxis.height;
}

function getCircularAxisTitleRect(plot, axisTheme, circularAxis) {
  var _title$offsetY;

  if (!circularAxis) {
    return layout_objectSpread({}, plot);
  }

  var x = plot.x,
      y = plot.y;
  var centerX = circularAxis.centerX,
      centerY = circularAxis.centerY,
      axisSize = circularAxis.axisSize,
      title = circularAxis.title,
      outer = circularAxis.radius.outer;
  var offsetY = (_title$offsetY = title === null || title === void 0 ? void 0 : title.offsetY) !== null && _title$offsetY !== void 0 ? _title$offsetY : 0;
  return {
    x: centerX + x - axisSize / 2,
    y: centerY + y - outer / 2,
    width: axisSize,
    height: axisTheme.title.fontSize + offsetY
  };
}

function hasXYAxes(series) {
  return !(series.pie || series.radar || series.treemap || series.radialBar || series.gauge);
}

function getYAxisOptions(options, hasXYAxis) {
  return hasXYAxis ? getYAxisOption(options) : {
    yAxis: null,
    secondaryYAxis: null
  };
}

var layout = {
  name: 'layout',
  state: function state() {
    return {
      layout: {}
    };
  },
  action: {
    setLayout: function setLayout(_ref7) {
      var _getAxisTitleHeight, _axes$yAxis, _axes$yAxis$title, _getAxisTitleHeight2, _axes$xAxis, _axes$xAxis$title, _options$chart, _axes$secondaryYAxis, _options$xAxis;

      var state = _ref7.state;
      var legendState = state.legend,
          theme = state.theme,
          circleLegendState = state.circleLegend,
          series = state.series,
          options = state.options,
          chart = state.chart,
          axes = state.axes,
          radialAxes = state.radialAxes;
      var width = chart.width,
          height = chart.height;
      var chartSize = {
        height: height - padding.Y * 2,
        width: width - padding.X * 2
      };
      var hasCenterYAxis = series.bar ? isCenterYAxis(options) : false;
      var hasXYAxis = hasXYAxes(series);
      var optionSize = getOptionSize(options);

      var _getYAxisOptions = getYAxisOptions(options, hasXYAxis),
          yAxisOption = _getYAxisOptions.yAxis,
          secondaryYAxisOption = _getYAxisOptions.secondaryYAxis;

      var visibleSecondaryYAxis = !!secondaryYAxisOption;
      var titleHeight = theme.title.fontSize;
      var yAxisTitleHeight = (_getAxisTitleHeight = getAxisTitleHeight(theme.yAxis, axes === null || axes === void 0 ? void 0 : (_axes$yAxis = axes.yAxis) === null || _axes$yAxis === void 0 ? void 0 : (_axes$yAxis$title = _axes$yAxis.title) === null || _axes$yAxis$title === void 0 ? void 0 : _axes$yAxis$title.offsetY)) !== null && _getAxisTitleHeight !== void 0 ? _getAxisTitleHeight : 0;
      var xAxisTitleHeight = (_getAxisTitleHeight2 = getAxisTitleHeight(theme.xAxis, axes === null || axes === void 0 ? void 0 : (_axes$xAxis = axes.xAxis) === null || _axes$xAxis === void 0 ? void 0 : (_axes$xAxis$title = _axes$xAxis.title) === null || _axes$xAxis$title === void 0 ? void 0 : _axes$xAxis$title.offsetY)) !== null && _getAxisTitleHeight2 !== void 0 ? _getAxisTitleHeight2 : 0; // Don't change the order!
      // exportMenu -> resetButton -> title -> yAxis.title -> yAxis -> secondaryYAxisTitle -> secondaryYAxis -> xAxis -> xAxis.title -> legend -> circleLegend -> plot -> circularAxis.title

      var exportMenu = getExportMenuRect(chartSize, isExportMenuVisible(options));
      var resetButton = getResetButtonRect(exportMenu, isUsingResetButton(options));
      var btnAreaRect = exportMenu.height ? exportMenu : resetButton;
      var title = getTitleRect(chartSize, btnAreaRect, !!((_options$chart = options.chart) !== null && _options$chart !== void 0 && _options$chart.title), titleHeight);
      var yAxisTitleVisible = !!(yAxisOption !== null && yAxisOption !== void 0 && yAxisOption.title) || !!(secondaryYAxisOption !== null && secondaryYAxisOption !== void 0 && secondaryYAxisOption.title);
      var yAxisTitle = getYAxisTitleRect({
        chartSize: chartSize,
        visible: yAxisTitleVisible,
        title: title,
        legend: legendState,
        hasCenterYAxis: hasCenterYAxis,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        yAxisTitleHeight: yAxisTitleHeight
      });
      var yAxis = getYAxisRect({
        chartSize: chartSize,
        legend: legendState,
        circleLegend: circleLegendState,
        yAxisTitle: yAxisTitle,
        hasCenterYAxis: hasCenterYAxis,
        hasXYAxis: hasXYAxis,
        maxLabelWidth: getYAxisMaxLabelWidth(axes === null || axes === void 0 ? void 0 : axes.yAxis.maxLabelWidth),
        size: optionSize,
        xAxisTitleHeight: xAxisTitleHeight
      });
      var secondaryYAxisTitle = getYAxisTitleRect({
        chartSize: chartSize,
        visible: yAxisTitleVisible,
        title: title,
        legend: legendState,
        hasCenterYAxis: hasCenterYAxis,
        isRightSide: true,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        yAxisTitleHeight: yAxisTitleHeight
      });
      var secondaryYAxis = getYAxisRect({
        chartSize: chartSize,
        legend: legendState,
        circleLegend: circleLegendState,
        yAxisTitle: secondaryYAxisTitle,
        hasCenterYAxis: hasCenterYAxis,
        hasXYAxis: hasXYAxis,
        maxLabelWidth: getYAxisMaxLabelWidth(axes === null || axes === void 0 ? void 0 : (_axes$secondaryYAxis = axes.secondaryYAxis) === null || _axes$secondaryYAxis === void 0 ? void 0 : _axes$secondaryYAxis.maxLabelWidth),
        size: optionSize,
        isRightSide: true,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        xAxisTitleHeight: xAxisTitleHeight
      });
      var xAxis = getXAxisRect({
        chartSize: chartSize,
        yAxis: yAxis,
        secondaryYAxis: secondaryYAxis,
        legend: legendState,
        circleLegend: circleLegendState,
        hasCenterYAxis: hasCenterYAxis,
        hasXYAxis: hasXYAxis,
        size: optionSize,
        xAxisData: axes === null || axes === void 0 ? void 0 : axes.xAxis
      });
      var xAxisTitle = getXAxisTitleRect(!!((_options$xAxis = options.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.title), xAxis, xAxisTitleHeight);
      var legend = getLegendRect({
        chartSize: chartSize,
        xAxis: xAxis,
        yAxis: yAxis,
        secondaryYAxis: secondaryYAxis,
        title: title,
        legend: legendState,
        hasXYAxis: hasXYAxis,
        xAxisTitleHeight: xAxisTitleHeight
      });
      adjustAxisSize(chartSize, {
        title: title,
        yAxisTitle: yAxisTitle,
        yAxis: yAxis,
        xAxis: xAxis,
        xAxisTitle: xAxisTitle,
        legend: legend,
        secondaryYAxis: secondaryYAxis
      }, legendState);
      var circleLegend = getCircleLegendRect(xAxis, yAxis, legendState.align, circleLegendState.width);
      var plot = getPlotRect(xAxis, yAxis, optionSize.plot);
      var circularAxisTitle = getCircularAxisTitleRect(plot, theme.circularAxis, radialAxes === null || radialAxes === void 0 ? void 0 : radialAxes.circularAxis);
      store_extend(state.layout, {
        chart: {
          x: 0,
          y: 0,
          width: width,
          height: height
        },
        title: title,
        plot: plot,
        legend: legend,
        circleLegend: circleLegend,
        xAxis: xAxis,
        xAxisTitle: xAxisTitle,
        yAxis: yAxis,
        yAxisTitle: yAxisTitle,
        exportMenu: exportMenu,
        resetButton: resetButton,
        secondaryYAxisTitle: secondaryYAxisTitle,
        secondaryYAxis: secondaryYAxis,
        circularAxisTitle: circularAxisTitle
      });
    }
  },
  observe: {
    updateLayoutObserve: function updateLayoutObserve() {
      this.dispatch('setLayout');
    }
  }
};
/* harmony default export */ var store_layout = (layout);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__(1235);
;// CONCATENATED MODULE: ./src/helpers/range.ts


function isRangeValue(value) {
  return Array.isArray(value) && value.length === 2;
}
function isRangeData(data) {
  return Array.isArray(data) && isRangeValue(getFirstValidValue(data));
}
function isZooming(categories, zoomRange) {
  return !!(zoomRange && (zoomRange[0] !== 0 || zoomRange[1] !== categories.length - 1));
}
function getDataInRange(data, range) {
  if (!range) {
    return data;
  }

  return data.slice(range[0], range[1] + 1);
}
;// CONCATENATED MODULE: ./src/store/category.ts
function category_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function category_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { category_ownKeys(Object(source), true).forEach(function (key) { category_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { category_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function category_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





















function makeRawCategories(series, categories) {
  if (categories) {
    return categories;
  }

  var firstValues = new Set();
  Object.keys(series).forEach(function (key) {
    var _series$key$data;

    if (key === 'pie' || key === 'gauge') {
      return;
    }

    ((_series$key$data = series[key].data) !== null && _series$key$data !== void 0 ? _series$key$data : series[key]).forEach(function (_ref) {
      var data = _ref.data,
          name = _ref.name,
          visible = _ref.visible;

      if (Array.isArray(data)) {
        data.forEach(function (datum) {
          if (!isNull(datum)) {
            var rawXValue = getCoordinateXValue(datum);
            firstValues.add(isNumber(rawXValue) ? rawXValue : rawXValue.toString());
          }
        });
      } else if (key === 'bullet' && isUndefined(visible) || visible) {
        firstValues.add(name);
      }
    });
  });
  return Array.from(firstValues).sort(sortCategories).map(function (category) {
    return String(category);
  });
}
var category = {
  name: 'category',
  state: function state(_ref2) {
    var categories = _ref2.categories,
        series = _ref2.series;
    return {
      categories: makeRawCategories(series, categories)
    };
  },
  action: {
    setCategory: function setCategory(_ref3) {
      var state = _ref3.state,
          computed = _ref3.computed;
      var viewRange = computed.viewRange;
      var categories = state.rawCategories;

      if (viewRange) {
        if (Array.isArray(categories)) {
          categories = getDataInRange(categories, viewRange);
        } else {
          categories = category_objectSpread(category_objectSpread({}, categories), {}, {
            x: getDataInRange(categories.x, viewRange)
          });
        }
      }

      state.categories = categories;
      this.notify(state, 'categories');
    },
    initCategory: function initCategory(_ref4) {
      var initStoreState = _ref4.initStoreState,
          state = _ref4.state;
      var zoomRange = state.zoomRange;
      var categories = makeRawCategories(initStoreState.series);

      if (zoomRange && Array.isArray(categories)) {
        categories = getDataInRange(categories, zoomRange);
      }

      state.categories = categories;
      this.notify(state, 'categories');
    },
    removeCategoryByName: function removeCategoryByName(_ref5, name) {
      var state = _ref5.state;
      var index = state.categories.findIndex(function (seriesName) {
        return seriesName === name;
      });
      state.categories.splice(index, 1);
      this.notify(state, 'axes');
    }
  },
  observe: {
    updateCategory: function updateCategory() {
      this.dispatch('setCategory');
    }
  }
};
/* harmony default export */ var store_category = (category);
;// CONCATENATED MODULE: ./src/store/seriesData.ts
function seriesData_toConsumableArray(arr) { return seriesData_arrayWithoutHoles(arr) || seriesData_iterableToArray(arr) || seriesData_unsupportedIterableToArray(arr) || seriesData_nonIterableSpread(); }

function seriesData_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function seriesData_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function seriesData_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return seriesData_arrayLikeToArray(arr); }

function seriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function seriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { seriesData_ownKeys(Object(source), true).forEach(function (key) { seriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { seriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function seriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function seriesData_slicedToArray(arr, i) { return seriesData_arrayWithHoles(arr) || seriesData_iterableToArrayLimit(arr, i) || seriesData_unsupportedIterableToArray(arr, i) || seriesData_nonIterableRest(); }

function seriesData_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function seriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return seriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return seriesData_arrayLikeToArray(o, minLen); }

function seriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function seriesData_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function seriesData_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }































function initRange(series, categories) {
  var rawCategoriesLength;

  if (categories) {
    rawCategoriesLength = Array.isArray(categories) ? categories.length : categories.x.length;
  } else {
    rawCategoriesLength = Object.keys(makeRawCategories(series, categories)).length;
  }

  return [0, rawCategoriesLength - 1];
}

function initZoomRange(series, options, categories) {
  var _options$series;

  if (!(series.line || series.area) || !((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.zoomable)) {
    return;
  }

  return initRange(series, categories);
}

function initShiftRange(series, options, categories) {
  var _options$series2;

  if (!(series.line || series.area || series.column || series.heatmap) || !((_options$series2 = options.series) !== null && _options$series2 !== void 0 && _options$series2.shift)) {
    return;
  }

  return initRange(series, categories);
}

function getCoordinateDataRange(data, rawCategories, zoomRange) {
  var _zoomRange = seriesData_slicedToArray(zoomRange, 2),
      zoomStart = _zoomRange[0],
      zoomEnd = _zoomRange[1];

  var start, end;
  range(zoomStart, zoomEnd + 1).forEach(function (i) {
    var idx = data.findIndex(function (datum) {
      return getCoordinateXValue(datum).toString() === rawCategories[i];
    });

    if (idx !== -1) {
      if (isUndefined(start)) {
        start = idx;
      }

      if (!isUndefined(start)) {
        var _end;

        end = Math.max(idx, (_end = end) !== null && _end !== void 0 ? _end : 0);
      }
    }
  });
  return [start, end];
}

function getSeriesDataInRange(data, rawCategories, chartType, zoomRange) {
  if (!zoomRange) {
    return data;
  }

  var _zoomRange2 = seriesData_slicedToArray(zoomRange, 2),
      startIdx = _zoomRange2[0],
      endIdx = _zoomRange2[1];

  var firstValidValue = getFirstValidValue(data);
  var isCoordinateChart = chartType !== 'area' && !isUndefined(firstValidValue) && !isNumber(firstValidValue);

  if (isCoordinateChart) {
    var _getCoordinateDataRan = getCoordinateDataRange(data, rawCategories, zoomRange);

    var _getCoordinateDataRan2 = seriesData_slicedToArray(_getCoordinateDataRan, 2);

    startIdx = _getCoordinateDataRan2[0];
    endIdx = _getCoordinateDataRan2[1];
  } else {
    startIdx = startIdx > 1 ? startIdx - 1 : startIdx;
    endIdx = endIdx < rawCategories.length - 1 ? endIdx + 1 : endIdx;
  }

  return data.slice(startIdx, endIdx + 1);
}

function isCoordinateTypeSeries(series, chartType) {
  return isCoordinateSeries(series) && (isUndefined(chartType) || chartType === 'line' || chartType === 'scatter');
}

function isSeriesAlreadyExist(series, seriesName, data) {
  return series[seriesName].some(function (_ref) {
    var label = _ref.label;
    return label === data.name;
  });
}

function isTreemapSeriesAlreadyExist(series, data) {
  return series.treemap.some(function (_ref2) {
    var label = _ref2.label;
    return label === data.label;
  });
}

function isHeatmapSeriesAlreadyExist(categories, category) {
  return includes(categories.y, category);
}

function initDisabledSeries(series) {
  var nestedPieChart = hasNestedPieSeries(series);
  var disabledSeries = [];

  if (nestedPieChart) {
    series.pie.forEach(function (_ref3) {
      var data = _ref3.data;
      data.forEach(function (datum) {
        if (isBoolean(datum.visible) && !datum.visible) {
          disabledSeries.push(datum.name);
        }
      });
    });
  } else {
    Object.keys(series).forEach(function (type) {
      series[type].forEach(function (_ref4) {
        var name = _ref4.name,
            visible = _ref4.visible;

        if (isBoolean(visible) && !visible) {
          disabledSeries.push(name);
        }
      });
    });
  }

  return disabledSeries;
}

var seriesData = {
  name: 'seriesData',
  state: function state(_ref5) {
    var series = _ref5.series,
        categories = _ref5.categories,
        options = _ref5.options;
    return {
      rawCategories: makeRawCategories(series, categories),
      series: seriesData_objectSpread({}, series),
      zoomRange: initZoomRange(series, options, categories),
      shiftRange: initShiftRange(series, options, categories),
      disabledSeries: initDisabledSeries(series)
    };
  },
  action: {
    setSeriesData: function setSeriesData(_ref6) {
      var state = _ref6.state,
          initStoreState = _ref6.initStoreState;
      var rawSeries = deepCopy(initStoreState.series);
      var disabledSeries = state.disabledSeries,
          theme = state.theme,
          zoomRange = state.zoomRange,
          rawCategories = state.rawCategories;
      var newSeriesData = {};
      Object.keys(rawSeries).forEach(function (seriesName) {
        var _originSeriesData$0$d, _originSeriesData$, _originSeriesData$$da;

        var _seriesName = theme.series[seriesName],
            colors = _seriesName.colors,
            iconTypes = _seriesName.iconTypes;
        var originSeriesData = rawSeries[seriesName].map(function (m, idx) {
          return seriesData_objectSpread(seriesData_objectSpread({}, m), {}, {
            rawData: m.data,
            data: getSeriesDataInRange(m.data, rawCategories, seriesName, zoomRange),
            color: colors ? colors[idx % colors.length] : ''
          });
        });

        if (seriesName === 'scatter') {
          originSeriesData = originSeriesData.map(function (m, idx) {
            return seriesData_objectSpread(seriesData_objectSpread({}, m), {}, {
              iconType: iconTypes ? iconTypes[idx] : 'circle'
            });
          });
        }

        var seriesCount = originSeriesData.length;
        var seriesGroupCount = (_originSeriesData$0$d = (_originSeriesData$ = originSeriesData[0]) === null || _originSeriesData$ === void 0 ? void 0 : (_originSeriesData$$da = _originSeriesData$.data) === null || _originSeriesData$$da === void 0 ? void 0 : _originSeriesData$$da.length) !== null && _originSeriesData$0$d !== void 0 ? _originSeriesData$0$d : 0;
        var data = originSeriesData.filter(function (_ref7) {
          var name = _ref7.name;
          return !disabledSeries.includes(name);
        });
        newSeriesData[seriesName] = {
          seriesCount: seriesCount,
          seriesGroupCount: seriesGroupCount,
          data: data,
          colors: colors
        };
      });
      store_extend(state.series, newSeriesData);
    },
    disableSeries: function disableSeries(_ref8, name) {
      var state = _ref8.state;
      state.disabledSeries.push(name);
      this.notify(state, 'disabledSeries');

      if (state.series.bullet) {
        this.dispatch('removeCategoryByName', name);
      }
    },
    enableSeries: function enableSeries(_ref9, name) {
      var state = _ref9.state;
      var index = state.disabledSeries.findIndex(function (disabled) {
        return disabled === name;
      });
      state.disabledSeries.splice(index, 1);
      this.notify(state, 'disabledSeries');

      if (state.series.bullet) {
        state.categories = state.series.bullet.data.map(function (_ref10) {
          var seriesName = _ref10.name;
          return seriesName;
        });
        this.notify(state, 'axes');
      }
    },
    zoom: function zoom(_ref11, rangeCategories) {
      var state = _ref11.state;
      var rawCategories = state.rawCategories;
      state.zoomRange = rangeCategories.map(function (rangeCategory) {
        return rawCategories.findIndex(function (category) {
          return category === rangeCategory;
        });
      });
      this.notify(state, 'zoomRange');
    },
    resetZoom: function resetZoom(_ref12) {
      var state = _ref12.state,
          initStoreState = _ref12.initStoreState;
      var series = initStoreState.series,
          options = initStoreState.options;
      var rawCategories = state.rawCategories;
      state.zoomRange = initZoomRange(series, options, rawCategories);
      this.notify(state, 'zoomRange');
    },
    addData: function addData(_ref13, _ref14) {
      var state = _ref13.state,
          initStoreState = _ref13.initStoreState;
      var data = _ref14.data,
          category = _ref14.category,
          chartType = _ref14.chartType;
      var series = initStoreState.series;
      var coordinateChart = isCoordinateTypeSeries(state.series, chartType);
      var categories = initStoreState.categories;
      categories = series.heatmap ? categories.x : categories;

      if (category && Array.isArray(categories)) {
        var isExist = categories.some(function (c) {
          return c === category;
        });

        if (!isExist) {
          categories.push(category);

          if (Array.isArray(state.shiftRange)) {
            var _state$shiftRange = seriesData_slicedToArray(state.shiftRange, 2),
                start = _state$shiftRange[0],
                end = _state$shiftRange[1];

            state.shiftRange = [start + 1, end + 1];
          }
        }
      }

      if (chartType) {
        series[chartType].forEach(function (datum, idx) {
          datum.data.push(data[idx]);
        });
      } else {
        var _Object$keys = Object.keys(initStoreState.series),
            _Object$keys2 = seriesData_slicedToArray(_Object$keys, 1),
            seriesName = _Object$keys2[0];

        series[seriesName].forEach(function (datum, idx) {
          datum.data.push(data[idx]);
        });
      }

      this.notify(state, 'series');
      this.notify(state, 'rawCategories');

      if (Array.isArray(state.zoomRange)) {
        this.dispatch('resetZoom');
      }

      if (coordinateChart) {
        this.dispatch('initCategory');
      }
    },
    addSeries: function addSeries(_ref15, _ref16) {
      var state = _ref15.state,
          initStoreState = _ref15.initStoreState;
      var data = _ref16.data,
          chartType = _ref16.chartType,
          category = _ref16.category;
      var series = initStoreState.series,
          categories = initStoreState.categories;
      var coordinateChart = isCoordinateTypeSeries(state.series, chartType);
      var seriesName = chartType || Object.keys(series)[0];
      var isExist = isSeriesAlreadyExist(series, seriesName, data);

      if (!isExist) {
        series[seriesName].push(data);

        if (Array.isArray(categories) && category) {
          categories.push(category);
        }
      }

      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
      this.notify(state, 'series');

      if (coordinateChart || seriesName === 'bullet') {
        this.dispatch('initCategory');
      }
    },
    addHeatmapSeries: function addHeatmapSeries(_ref17, _ref18) {
      var state = _ref17.state,
          initStoreState = _ref17.initStoreState;
      var data = _ref18.data,
          category = _ref18.category;
      var series = initStoreState.series,
          categories = initStoreState.categories;
      var isExist = isHeatmapSeriesAlreadyExist(categories, category);

      if (!isExist) {
        series.heatmap.push({
          data: data,
          yCategory: category
        });
      }

      if (!isExist && category) {
        categories.y.push(category);
        this.notify(state, 'rawCategories');
      }

      this.notify(state, 'series');
      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    },
    addTreemapSeries: function addTreemapSeries(_ref19, _ref20) {
      var state = _ref19.state,
          initStoreState = _ref19.initStoreState;
      var data = _ref20.data;
      var series = initStoreState.series;
      var isExist = isTreemapSeriesAlreadyExist(series, data);

      if (!isExist) {
        series.treemap.push(data);
      }

      this.notify(state, 'series');
      this.notify(state, 'treemapSeries');
      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    },
    setData: function setData(_ref21, _ref22) {
      var state = _ref21.state,
          initStoreState = _ref21.initStoreState;
      var series = _ref22.series,
          categories = _ref22.categories;
      initStoreState.series = series;
      var isNestedPieChart = hasNestedPieSeries(series);

      if (!isNestedPieChart) {
        state.rawCategories = makeRawCategories(series, categories);
      }

      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    },
    addOutlier: function addOutlier(_ref23, _ref24) {
      var _seriesRawData$outlie;

      var state = _ref23.state,
          initStoreState = _ref23.initStoreState;
      var seriesIndex = _ref24.seriesIndex,
          outliers = _ref24.outliers;
      var series = initStoreState.series;
      var seriesRawData = series.boxPlot[seriesIndex];

      if (!seriesRawData) {
        throw new Error(message.SERIES_INDEX_ERROR);
      }

      seriesRawData.outliers = [].concat(seriesData_toConsumableArray((_seriesRawData$outlie = seriesRawData.outliers) !== null && _seriesRawData$outlie !== void 0 ? _seriesRawData$outlie : []), seriesData_toConsumableArray(outliers));
      this.notify(state, 'series');
    }
  },
  observe: {
    updateSeriesData: function updateSeriesData() {
      this.dispatch('setSeriesData');
    }
  },
  computed: {
    isLineTypeSeriesZooming: function isLineTypeSeriesZooming(_ref25) {
      var zoomRange = _ref25.zoomRange,
          rawCategories = _ref25.rawCategories;
      return isZooming(rawCategories, zoomRange);
    },
    viewRange: function viewRange(_ref26) {
      var zoomRange = _ref26.zoomRange,
          shiftRange = _ref26.shiftRange;
      return zoomRange || shiftRange;
    }
  }
};
/* harmony default export */ var store_seriesData = (seriesData);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.flat-map.js
var es_array_flat_map = __webpack_require__(4870);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.unscopables.flat-map.js
var es_array_unscopables_flat_map = __webpack_require__(3985);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.values.js
var es_object_values = __webpack_require__(7890);
;// CONCATENATED MODULE: ./src/brushes/polygon.ts


function polygon(ctx, polygonModel) {
  var strokeStyle = polygonModel.color,
      points = polygonModel.points,
      lineWidth = polygonModel.lineWidth,
      fillColor = polygonModel.fillColor,
      _polygonModel$dashSeg = polygonModel.dashSegments,
      dashSegments = _polygonModel$dashSeg === void 0 ? [] : _polygonModel$dashSeg;

  if (!points.length) {
    return;
  }

  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  points.forEach(function (_ref, idx) {
    var x = _ref.x,
        y = _ref.y;

    if (idx === 0) {
      ctx.moveTo(x, y);
      return;
    }

    ctx.lineTo(x, y);
  });
  ctx.lineTo(points[0].x, points[0].y);

  if (fillColor) {
    fillStyle(ctx, fillColor);
  }

  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
}
;// CONCATENATED MODULE: ./src/brushes/scatterSeries.ts
function scatterSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function scatterSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { scatterSeries_ownKeys(Object(source), true).forEach(function (key) { scatterSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { scatterSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function scatterSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













function regularPolygon(ctx, model) {
  var numberOfSides = model.numberOfSides,
      size = model.size,
      x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      fillColor = model.fillColor;
  var s = size / 2;
  var shift = numberOfSides % 2 ? Math.PI / 180.0 * (10 + (numberOfSides - 3) / 2) * numberOfSides : 0;
  var step = 2 * Math.PI / numberOfSides;
  ctx.beginPath();

  for (var i = 0; i <= numberOfSides; i += 1) {
    var curStep = i * step + shift;
    ctx.lineTo(x + s * Math.cos(curStep), y + s * Math.sin(curStep));
  }

  ctx.strokeStyle = borderColor;
  ctx.lineWidth = borderWidth;
  fillStyle(ctx, fillColor);
  ctx.stroke();
  ctx.closePath();
} // https://programmingthomas.wordpress.com/2012/05/16/drawing-stars-with-html5-canvas/


function star(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      size = model.size,
      fillColor = model.fillColor;
  ctx.lineWidth = borderWidth;
  ctx.strokeStyle = borderColor;
  ctx.fillStyle = fillColor;
  ctx.save();
  ctx.beginPath();
  ctx.translate(x, y);
  ctx.moveTo(0, -size);

  for (var i = 0; i < 5; i += 1) {
    ctx.rotate(Math.PI / 5);
    ctx.lineTo(0, -size / 2);
    ctx.rotate(Math.PI / 5);
    ctx.lineTo(0, -size);
  }

  ctx.fill();
  ctx.stroke();
  ctx.restore();
  ctx.closePath();
}

function cross(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      size = model.size,
      fillColor = model.fillColor;
  var quarter = size / 4;
  var half = size / 2;
  var xPointsOffset = [-half, -half, -quarter, -quarter, quarter, quarter, half, half, quarter, quarter, -quarter, -quarter];
  var yPointsOffset = [];

  for (var idx = 0, len = xPointsOffset.length; idx < len; idx += 1) {
    var startIdx = 9;
    yPointsOffset.push(xPointsOffset[(startIdx + idx) % len]);
  }

  polygon(ctx, {
    type: 'polygon',
    lineWidth: borderWidth,
    color: borderColor,
    points: xPointsOffset.map(function (val, idx) {
      return {
        x: x + val,
        y: y + yPointsOffset[idx]
      };
    }),
    fillColor: fillColor
  });
}

function getNumberOfSidesByIconType(iconType) {
  switch (iconType) {
    case 'triangle':
      return 3;

    case 'diamond':
      return 4;

    case 'pentagon':
      return 5;

    case 'hexagon':
      return 6;
  }
}

function scatterSeries(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      fillColor = model.fillColor,
      iconType = model.iconType,
      size = model.size;
  var commonModel = {
    x: x,
    y: y,
    fillColor: fillColor,
    borderColor: borderColor,
    borderWidth: borderWidth,
    size: size
  };
  ctx.beginPath();

  switch (iconType) {
    case 'rect':
      pathRect(ctx, {
        type: 'pathRect',
        x: x - size / 2,
        y: y - size / 2,
        width: size,
        height: size,
        stroke: borderColor,
        lineWidth: borderWidth,
        fill: fillColor
      });
      break;

    case 'triangle':
    case 'pentagon':
    case 'diamond':
    case 'hexagon':
      regularPolygon(ctx, scatterSeries_objectSpread({
        type: 'regularPolygon',
        numberOfSides: getNumberOfSidesByIconType(iconType)
      }, commonModel));
      break;

    case 'star':
      star(ctx, scatterSeries_objectSpread(scatterSeries_objectSpread({
        type: 'star'
      }, commonModel), {}, {
        size: size / 2
      }));
      break;

    case 'cross':
      cross(ctx, scatterSeries_objectSpread({
        type: 'cross'
      }, commonModel));
      break;

    default:
      circle(ctx, {
        type: 'circle',
        x: x,
        y: y,
        radius: size / 2,
        style: [{
          strokeStyle: borderColor,
          lineWidth: borderWidth
        }],
        color: fillColor
      });
  }

  ctx.stroke();
  ctx.closePath();
}
;// CONCATENATED MODULE: ./src/brushes/legend.ts








var LEGEND_ITEM_MARGIN_X = 40;
var LEGEND_MARGIN_X = 5;
var LEGEND_CHECKBOX_SIZE = 12;
var LEGEND_ICON_SIZE = 12;
var ICON_BORDER_WIDTH = 1.5;
var INACTIVE_OPACITY = 0.3;
var RECT_SIZE = 10;
var LINE_ICON_PADDING = 2;
var CIRCLE_ICON_RADIUS = 6;
function getLegendItemHeight(fontSize) {
  return fontSize + padding.Y;
}

function drawLineIcon(ctx, x, y, color) {
  var xCurveOffset = [2, 2, 6, 6, 10, 10];
  var yCurveOffset = [8, 0, 0, 8, 8, 0];
  xCurveOffset.forEach(function (xOffset, idx) {
    if (idx === 5) {
      return;
    }

    line(ctx, {
      type: 'line',
      x: x + xOffset,
      y: y + yCurveOffset[idx],
      x2: x + xCurveOffset[idx + 1],
      y2: y + yCurveOffset[idx + 1],
      lineWidth: 2,
      strokeStyle: color
    });
  });
}

function drawCheckIcon(ctx, x, y, active) {
  var color = '#555555';
  var strokeStyle = active ? color : getRGBA(color, INACTIVE_OPACITY);
  line(ctx, {
    type: 'line',
    x: x + 2,
    y: y + 5,
    x2: x + 5,
    y2: y + 8,
    strokeStyle: strokeStyle,
    lineWidth: 2
  });
  line(ctx, {
    type: 'line',
    x: x + 5,
    y: y + 9,
    x2: x + 10,
    y2: y + 3,
    strokeStyle: strokeStyle,
    lineWidth: 2
  });
}

function drawCheckbox(ctx, x, y, renderOptions) {
  var active = renderOptions.active,
      checked = renderOptions.checked;
  var borderColor = active ? '#bbb' : getRGBA('#bbbbbb', INACTIVE_OPACITY);
  rect(ctx, {
    type: 'rect',
    x: x,
    y: y,
    width: LEGEND_CHECKBOX_SIZE,
    height: LEGEND_CHECKBOX_SIZE,
    color: '#fff',
    borderColor: borderColor,
    thickness: 1
  });

  if (checked) {
    drawCheckIcon(ctx, x, y, active);
  }
}

function drawIcon(ctx, x, y, renderOptions) {
  var iconType = renderOptions.iconType,
      active = renderOptions.active,
      color = renderOptions.color,
      showCheckbox = renderOptions.showCheckbox;
  var iconX = x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
  var iconColor = active ? color : getRGBA(color, INACTIVE_OPACITY);

  if (iconType === 'rect') {
    rect(ctx, {
      type: 'rect',
      x: iconX,
      y: y + (LEGEND_CHECKBOX_SIZE - RECT_SIZE) / 2,
      width: RECT_SIZE,
      height: RECT_SIZE,
      color: iconColor
    });
  } else if (iconType === 'line') {
    drawLineIcon(ctx, iconX, y + LINE_ICON_PADDING, iconColor);
  } else if (iconType === 'circle') {
    circle(ctx, {
      type: 'circle',
      x: iconX + CIRCLE_ICON_RADIUS,
      y: y + CIRCLE_ICON_RADIUS,
      radius: CIRCLE_ICON_RADIUS,
      color: iconColor,
      style: ['default']
    });
  }
}

function drawScatterIcon(ctx, x, y, renderOptions) {
  var iconType = renderOptions.iconType,
      active = renderOptions.active,
      color = renderOptions.color,
      showCheckbox = renderOptions.showCheckbox;
  var iconX = x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
  var iconColor = active ? color : getRGBA(color, INACTIVE_OPACITY);
  scatterSeries(ctx, {
    type: 'scatterSeries',
    iconType: iconType,
    x: iconX + CIRCLE_ICON_RADIUS,
    y: y + CIRCLE_ICON_RADIUS,
    borderColor: iconColor,
    size: CIRCLE_ICON_RADIUS * 2,
    fillColor: 'rgba(255, 255, 255, 0)',
    borderWidth: ICON_BORDER_WIDTH
  });
}

function drawLabel(ctx, x, y, text, renderOptions) {
  var active = renderOptions.active,
      showCheckbox = renderOptions.showCheckbox,
      font = renderOptions.font,
      fontColor = renderOptions.fontColor;
  var fillStyle = active ? fontColor : getRGBA(fontColor, INACTIVE_OPACITY);
  label(ctx, {
    type: 'label',
    x: x + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0),
    y: y,
    text: text,
    style: ['default', {
      font: font,
      textBaseline: 'top',
      fillStyle: fillStyle
    }]
  });
}

function legend(ctx, model) {
  var data = model.data,
      showCheckbox = model.showCheckbox,
      align = model.align,
      fontSize = model.fontSize,
      fontFamily = model.fontFamily,
      fontWeight = model.fontWeight;
  var font = getTitleFontString({
    fontSize: fontSize,
    fontFamily: fontFamily,
    fontWeight: fontWeight
  });
  var fontColor = model.color;
  data.forEach(function (datum) {
    var x = datum.x,
        y = datum.y,
        checked = datum.checked,
        active = datum.active,
        color = datum.color,
        iconType = datum.iconType,
        useScatterChartIcon = datum.useScatterChartIcon,
        legendLabel = datum.viewLabel;
    var iconY = y - 1 + (getTextHeight(legendLabel, font) - 11) / 4;
    var renderOptions = {
      iconType: iconType,
      checked: checked,
      active: active,
      color: color,
      showCheckbox: showCheckbox,
      align: align,
      font: font,
      fontColor: fontColor
    };

    if (showCheckbox) {
      drawCheckbox(ctx, x, iconY, renderOptions);
    }

    if (useScatterChartIcon && iconType !== 'line') {
      drawScatterIcon(ctx, x, iconY, renderOptions);
    } else {
      drawIcon(ctx, x, iconY, renderOptions);
    }

    drawLabel(ctx, x, y, legendLabel, renderOptions);
  });
}
;// CONCATENATED MODULE: ./src/helpers/theme.ts







function theme_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function theme_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { theme_ownKeys(Object(source), true).forEach(function (key) { theme_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { theme_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function theme_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var DEFAULT_LINE_SERIES_WIDTH = 2;
var DEFAULT_LINE_SERIES_DOT_RADIUS = 3;
var DEFAULT_AREA_OPACITY = 0.3;
var DEFAULT_AREA_SELECTED_SERIES_OPACITY = DEFAULT_AREA_OPACITY;
var DEFAULT_AREA_UNSELECTED_SERIES_OPACITY = 0.06;
var radarDefault = {
  LINE_WIDTH: 2,
  DOT_RADIUS: 3,
  HOVER_DOT_RADIUS: 4,
  SELECTED_SERIES_OPACITY: 0.3,
  UNSELECTED_SERIES_OPACITY: 0.05
};
var boxDefault = {
  HOVER_THICKNESS: 4,
  BOX_HOVER: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetX: 2,
    shadowOffsetY: 2,
    shadowBlur: 6
  }
};
var boxplotDefault = {
  OUTLIER_RADIUS: 4,
  OUTLIER_BORDER_WIDTH: 2,
  LINE_TYPE: {
    whisker: {
      lineWidth: 1
    },
    maximum: {
      lineWidth: 1
    },
    minimum: {
      lineWidth: 1
    },
    median: {
      lineWidth: 1,
      color: '#ffffff'
    }
  }
};
var DEFAULT_BULLET_RANGE_OPACITY = [0.5, 0.3, 0.1];
var DEFAULT_PIE_LINE_WIDTH = 3;

function makeDefaultDataLabelsTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontFamily: globalFontFamily,
    fontSize: 11,
    fontWeight: 400,
    color: '#333333',
    useSeriesColor: false
  };
}

var DEFAULT_BUBBLE_ARROW = {
  width: 8,
  height: 6
};
var defaultSeriesTheme = {
  colors: ['#00a9ff', '#ffb840', '#ff5a46', '#00bd9f', '#785fff', '#f28b8c', '#989486', '#516f7d', '#28e6eb', '#28695f', '#96c85a', '#45ba3f', '#295ba0', '#2a4175', '#289399', '#66c8d3', '#617178', '#8a9a9a', '#bebebe', '#374b5a', '#64eba0', '#ffe155', '#ff9141', '#af4beb', '#ff73fa', '#ff55b2', '#2869f5', '#3296ff', '#8cc3ff', '#2828b9', '#fa8787', '#e13782', '#7d5aaa', '#643c91', '#d25f5f', '#fabe6e', '#c3a9eb', '#b9c8f5', '#73a0cd', '#0f5a8c'],
  startColor: '#ffe98a',
  endColor: '#d74177',
  lineWidth: DEFAULT_LINE_SERIES_WIDTH,
  dashSegments: [],
  borderWidth: 0,
  borderColor: '#ffffff',
  select: {
    dot: {
      radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
      borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2
    },
    areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
    restSeries: {
      areaOpacity: DEFAULT_AREA_UNSELECTED_SERIES_OPACITY
    }
  },
  hover: {
    dot: {
      radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
      borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2
    }
  },
  dot: {
    radius: DEFAULT_LINE_SERIES_DOT_RADIUS
  },
  areaOpacity: DEFAULT_AREA_OPACITY
};
function makeAxisTitleTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontSize: 11,
    fontFamily: globalFontFamily,
    fontWeight: 700,
    color: '#bbbbbb'
  };
}

function makeCommonTextTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontSize: 11,
    fontFamily: globalFontFamily,
    fontWeight: 'normal',
    color: '#333333'
  };
}

function makeDefaultTheme(series) {
  var globalFontFamily = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Arial';
  var axisTitleTheme = makeAxisTitleTheme(globalFontFamily);
  var commonTextTheme = makeCommonTextTheme(globalFontFamily);
  var hasRadarSeries = !!(series !== null && series !== void 0 && series.radar);
  var hasGaugeSeries = !!(series !== null && series !== void 0 && series.gauge);
  return {
    chart: {
      fontFamily: globalFontFamily,
      backgroundColor: '#ffffff'
    },
    noData: {
      fontSize: 18,
      fontFamily: globalFontFamily,
      fontWeight: 'normal',
      color: '#333333'
    },
    title: {
      fontSize: 18,
      fontFamily: globalFontFamily,
      fontWeight: 100,
      color: '#333333'
    },
    yAxis: {
      title: theme_objectSpread({}, axisTitleTheme),
      label: theme_objectSpread({}, commonTextTheme),
      width: 1,
      color: '#333333'
    },
    xAxis: {
      title: theme_objectSpread({}, axisTitleTheme),
      label: theme_objectSpread({}, commonTextTheme),
      width: 1,
      color: '#333333'
    },
    verticalAxis: {
      label: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
        textBubble: {
          visible: hasRadarSeries,
          backgroundColor: hasRadarSeries ? '#f3f3f3' : 'rgba(0, 0, 0, 0)',
          borderRadius: 7,
          paddingX: 7,
          paddingY: 2,
          borderColor: 'rgba(0, 0, 0, 0)',
          borderWidth: 1
        }
      })
    },
    circularAxis: {
      title: theme_objectSpread({}, axisTitleTheme),
      label: theme_objectSpread({}, commonTextTheme),
      lineWidth: 1,
      strokeStyle: hasGaugeSeries ? 'rgba(0, 0, 0, 0.5)' : 'rgba(0, 0, 0, 0.05)',
      dotColor: 'rgba(0, 0, 0, 0.5)',
      tick: {
        lineWidth: 1,
        strokeStyle: 'rgba(0, 0, 0, 0.5)'
      }
    },
    legend: {
      label: {
        color: '#333333',
        fontSize: 11,
        fontWeight: 'normal',
        fontFamily: globalFontFamily
      }
    },
    tooltip: {
      background: 'rgba(85, 85, 85, 0.95)',
      borderColor: 'rgba(255, 255, 255, 0)',
      borderWidth: 0,
      borderRadius: 3,
      borderStyle: 'solid',
      body: {
        fontSize: 12,
        fontFamily: "".concat(globalFontFamily, ", sans-serif"),
        fontWeight: 'normal',
        color: '#ffffff'
      },
      header: {
        fontSize: 13,
        fontFamily: "".concat(globalFontFamily, ", sans-serif"),
        fontWeight: 'bold',
        color: '#ffffff'
      }
    },
    plot: {
      lineColor: 'rgba(0, 0, 0, 0.05)',
      backgroundColor: 'rgba(255, 255, 255, 0)'
    },
    exportMenu: {
      button: theme_objectSpread(theme_objectSpread({}, makeBorderTheme(5, '#f4f4f4')), {}, {
        backgroundColor: '#f4f4f4',
        xIcon: {
          color: '#555555',
          lineWidth: 2
        },
        dotIcon: {
          color: '#555555',
          width: 2,
          height: 2,
          gap: 2
        }
      }),
      panel: theme_objectSpread(theme_objectSpread({}, makeBorderTheme(0, '#bab9ba')), {}, {
        header: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
          backgroundColor: '#f4f4f4'
        }),
        body: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
          backgroundColor: '#ffffff'
        })
      })
    }
  };
}

function makeBorderTheme(borderRadius, borderColor) {
  var borderWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return {
    borderWidth: borderWidth,
    borderRadius: borderRadius,
    borderColor: borderColor
  };
}

function makeDefaultTextBubbleTheme() {
  var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var borderRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
  var paddingX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;
  var paddingY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var backgroundColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#ffffff';
  return {
    visible: visible,
    paddingX: paddingX,
    paddingY: paddingY,
    borderRadius: borderRadius,
    backgroundColor: backgroundColor,
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetY: 2,
    shadowBlur: 4
  };
}

function getLineTypeSeriesTheme(globalFontFamily) {
  var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
  return {
    lineWidth: defaultSeriesTheme.lineWidth,
    dashSegments: defaultSeriesTheme.dashSegments,
    select: {
      dot: defaultSeriesTheme.select.dot
    },
    hover: {
      dot: defaultSeriesTheme.hover.dot
    },
    dot: defaultSeriesTheme.dot,
    dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
      textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme()), {}, {
        arrow: theme_objectSpread({
          visible: false,
          direction: 'bottom'
        }, DEFAULT_BUBBLE_ARROW)
      })
    })
  };
}

function getTreemapHeatmapSeriesTheme(globalFontFamily) {
  var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
  return {
    startColor: defaultSeriesTheme.startColor,
    endColor: defaultSeriesTheme.endColor,
    borderWidth: 0,
    borderColor: '#ffffff',
    hover: {
      borderWidth: boxDefault.HOVER_THICKNESS,
      borderColor: '#ffffff'
    },
    select: {
      borderWidth: boxDefault.HOVER_THICKNESS,
      borderColor: '#ffffff'
    },
    dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
      color: '#ffffff',
      textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 1, 5, 1, 'rgba(255, 255, 255, 0.5)'))
    })
  };
}

function getBarColumnSeriesTheme(globalFontFamily) {
  var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
  return {
    colorByPoint: false,
    areaOpacity: 1,
    hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
      borderWidth: boxDefault.HOVER_THICKNESS,
      borderColor: '#ffffff',
      groupedRect: {
        color: '#000000',
        opacity: 0.05
      }
    }),
    select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
      borderWidth: boxDefault.HOVER_THICKNESS,
      borderColor: '#ffffff',
      groupedRect: {
        color: '#000000',
        opacity: 0.2
      },
      restSeries: {
        areaOpacity: 0.2
      },
      areaOpacity: 1
    }),
    connector: {
      color: 'rgba(51, 85, 139, 0.3)',
      lineWidth: 1,
      dashSegments: []
    },
    dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
      textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 1, 4, 3)), {}, {
        arrow: theme_objectSpread({
          visible: false
        }, DEFAULT_BUBBLE_ARROW)
      }),
      stackTotal: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
        textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true, 1, 4, 3)), {}, {
          arrow: theme_objectSpread({
            visible: true
          }, DEFAULT_BUBBLE_ARROW)
        })
      })
    })
  };
}

var transparentColor = 'rgba(255, 255, 255, 0)';
var defaultThemeMakers = {
  line: function line(globalFontFamily) {
    return theme_objectSpread({}, getLineTypeSeriesTheme(globalFontFamily));
  },
  area: function area(globalFontFamily) {
    var lineTypeSeriesTheme = getLineTypeSeriesTheme(globalFontFamily);
    return theme_objectSpread(theme_objectSpread({}, lineTypeSeriesTheme), {}, {
      select: theme_objectSpread(theme_objectSpread({}, lineTypeSeriesTheme.select), {}, {
        areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
        restSeries: defaultSeriesTheme.select.restSeries
      }),
      areaOpacity: DEFAULT_AREA_OPACITY
    });
  },
  treemap: function treemap(globalFontFamily) {
    return getTreemapHeatmapSeriesTheme(globalFontFamily);
  },
  heatmap: function heatmap(globalFontFamily) {
    return getTreemapHeatmapSeriesTheme(globalFontFamily);
  },
  scatter: function scatter() {
    return {
      size: 12,
      borderWidth: 1.5,
      fillColor: transparentColor,
      select: {
        fillColor: 'rgba(255, 255, 255, 1)',
        borderWidth: 2.5,
        size: 12
      },
      hover: {
        fillColor: 'rgba(255, 255, 255, 1)',
        borderWidth: 2.5,
        size: 12
      }
    };
  },
  bubble: function bubble() {
    return {
      borderWidth: 0,
      borderColor: transparentColor,
      select: {},
      hover: {
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        shadowBlur: 2,
        shadowOffsetY: 2,
        lineWidth: 2
      }
    };
  },
  radar: function radar() {
    return {
      areaOpacity: radarDefault.SELECTED_SERIES_OPACITY,
      hover: {
        dot: {
          radius: radarDefault.HOVER_DOT_RADIUS,
          borderWidth: radarDefault.HOVER_DOT_RADIUS + 1
        }
      },
      select: {
        dot: {
          radius: radarDefault.HOVER_DOT_RADIUS,
          borderWidth: radarDefault.HOVER_DOT_RADIUS + 1
        },
        restSeries: {
          areaOpacity: radarDefault.UNSELECTED_SERIES_OPACITY
        },
        areaOpacity: radarDefault.SELECTED_SERIES_OPACITY
      },
      dot: {
        radius: radarDefault.DOT_RADIUS
      }
    };
  },
  bar: function bar(globalFontFamily) {
    return theme_objectSpread({}, getBarColumnSeriesTheme(globalFontFamily));
  },
  column: function column(globalFontFamily) {
    return theme_objectSpread({}, getBarColumnSeriesTheme(globalFontFamily));
  },
  bullet: function bullet(globalFontFamily) {
    var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
    return {
      areaOpacity: 1,
      barWidthRatios: {
        rangeRatio: 1,
        bulletRatio: 0.5,
        markerRatio: 0.8
      },
      markerLineWidth: 1,
      borderWidth: 0,
      borderColor: 'rgba(255, 255, 255, 0)',
      hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
        borderWidth: boxDefault.HOVER_THICKNESS,
        borderColor: '#ffffff',
        groupedRect: {
          color: '#000000',
          opacity: 0.05
        }
      }),
      select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
        borderWidth: boxDefault.HOVER_THICKNESS,
        borderColor: '#ffffff',
        groupedRect: {
          color: '#000000',
          opacity: 0.2
        },
        restSeries: {
          areaOpacity: 0.2
        },
        areaOpacity: 1
      }),
      dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
        textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme()), {}, {
          arrow: theme_objectSpread({
            visible: false
          }, DEFAULT_BUBBLE_ARROW)
        }),
        marker: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
          fontSize: 9,
          useSeriesColor: true,
          textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true)), {}, {
            backgroundColor: 'rgba(255, 255, 255, 0.8)',
            shadowColor: 'rgba(0, 0, 0, 0.0)',
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 0,
            arrow: theme_objectSpread({
              visible: false
            }, DEFAULT_BUBBLE_ARROW)
          })
        })
      })
    };
  },
  boxPlot: function boxPlot() {
    return {
      areaOpacity: 1,
      barWidthRatios: {
        barRatio: 1,
        minMaxBarRatio: 0.5
      },
      markerLineWidth: 1,
      dot: {
        color: '#ffffff',
        radius: boxplotDefault.OUTLIER_RADIUS,
        borderWidth: boxplotDefault.OUTLIER_BORDER_WIDTH,
        useSeriesColor: false
      },
      rect: {
        borderWidth: 0
      },
      line: theme_objectSpread({}, boxplotDefault.LINE_TYPE),
      hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
        rect: {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff'
        },
        dot: {
          radius: boxplotDefault.OUTLIER_RADIUS,
          borderWidth: 0,
          useSeriesColor: true
        },
        line: theme_objectSpread({}, boxplotDefault.LINE_TYPE)
      }),
      select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
        rect: {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff'
        },
        dot: {
          radius: boxplotDefault.OUTLIER_RADIUS,
          borderWidth: 0,
          useSeriesColor: true
        },
        line: theme_objectSpread({}, boxplotDefault.LINE_TYPE),
        restSeries: {
          areaOpacity: 0.2
        },
        areaOpacity: 1
      })
    };
  },
  pie: function pie(globalFontFamily, _ref) {
    var _ref$hasOuterAnchor = _ref.hasOuterAnchor,
        hasOuterAnchor = _ref$hasOuterAnchor === void 0 ? false : _ref$hasOuterAnchor,
        _ref$hasOuterAnchorPi = _ref.hasOuterAnchorPieSeriesName,
        hasOuterAnchorPieSeriesName = _ref$hasOuterAnchorPi === void 0 ? false : _ref$hasOuterAnchorPi;
    var isNestedPieChart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
    return {
      areaOpacity: 1,
      strokeStyle: isNestedPieChart ? '#ffffff' : 'rgba(255, 255, 255, 0)',
      lineWidth: isNestedPieChart ? 1 : 0,
      hover: {
        lineWidth: DEFAULT_PIE_LINE_WIDTH,
        strokeStyle: '#ffffff',
        shadowColor: '#cccccc',
        shadowBlur: 5,
        shadowOffsetX: 0,
        shadowOffsetY: 0
      },
      select: {
        lineWidth: DEFAULT_PIE_LINE_WIDTH,
        strokeStyle: '#ffffff',
        shadowColor: '#cccccc',
        shadowBlur: 5,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        restSeries: {
          areaOpacity: 0.3
        },
        areaOpacity: 1
      },
      dataLabels: {
        fontFamily: globalFontFamily,
        fontSize: 16,
        fontWeight: 600,
        color: hasOuterAnchor ? '#333333' : '#ffffff',
        useSeriesColor: hasOuterAnchor,
        textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0)),
        callout: {
          lineWidth: 1,
          useSeriesColor: true,
          lineColor: '#e9e9e9'
        },
        pieSeriesName: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
          useSeriesColor: hasOuterAnchorPieSeriesName,
          color: hasOuterAnchorPieSeriesName ? '#333333' : '#ffffff',
          textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0))
        })
      }
    };
  },
  radialBar: function radialBar(globalFontFamily) {
    return {
      areaOpacity: 1,
      strokeStyle: 'rgba(255, 255, 255, 0)',
      lineWidth: 0,
      hover: {
        lineWidth: DEFAULT_PIE_LINE_WIDTH,
        strokeStyle: '#fff',
        shadowColor: '#cccccc',
        shadowBlur: 5,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        groupedSector: {
          color: '#000000',
          opacity: 0.05
        }
      },
      select: {
        lineWidth: DEFAULT_PIE_LINE_WIDTH,
        strokeStyle: '#fff',
        shadowColor: '#cccccc',
        shadowBlur: 5,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        restSeries: {
          areaOpacity: 0.3
        },
        areaOpacity: 1,
        groupedSector: {
          color: '#000000',
          opacity: 0.2
        }
      },
      dataLabels: {
        fontFamily: globalFontFamily,
        fontSize: 11,
        fontWeight: 400,
        color: '#333333',
        useSeriesColor: false,
        textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0))
      }
    };
  },
  gauge: function gauge(globalFontFamily) {
    return {
      areaOpacity: 1,
      hover: {
        clockHand: {
          baseLine: 5
        },
        pin: {
          radius: 5,
          borderWidth: 5
        },
        solid: {
          lineWidth: DEFAULT_PIE_LINE_WIDTH,
          strokeStyle: '#ffffff',
          shadowColor: '#cccccc',
          shadowBlur: 5,
          shadowOffsetX: 0,
          shadowOffsetY: 0
        }
      },
      select: {
        clockHand: {
          baseLine: 5
        },
        pin: {
          radius: 6,
          borderWidth: 4
        },
        solid: {
          lineWidth: DEFAULT_PIE_LINE_WIDTH,
          strokeStyle: '#ffffff',
          shadowColor: '#cccccc',
          shadowBlur: 5,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          restSeries: {
            areaOpacity: 0.3
          },
          areaOpacity: 1
        },
        areaOpacity: 1,
        restSeries: {
          areaOpacity: 0.3
        }
      },
      clockHand: {
        baseLine: 4
      },
      pin: {
        radius: 5,
        borderWidth: 5
      },
      solid: {
        lineWidth: 0,
        backgroundSolid: {
          color: 'rgba(0, 0, 0, 0.1)'
        }
      },
      dataLabels: {
        fontFamily: globalFontFamily,
        fontSize: 11,
        fontWeight: 400,
        color: '#333333',
        useSeriesColor: false,
        textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true, 4, 4, 3)), {}, {
          shadowColor: 'rgba(0, 0, 0, 0)',
          shadowOffsetY: 0,
          shadowBlur: 0,
          borderColor: '#ccc',
          borderWidth: 1
        })
      }
    };
  }
};

function getSeriesTheme(globalFontFamily, seriesName, paramForPieSeries) {
  var isNestedPieChart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (seriesName === 'pie') {
    return defaultThemeMakers[seriesName](globalFontFamily, paramForPieSeries, isNestedPieChart);
  }

  if (includes(['bubble', 'radar', 'boxPlot'], seriesName)) {
    return defaultThemeMakers[seriesName]();
  }

  return defaultThemeMakers[seriesName](globalFontFamily);
}

function getDefaultTheme(series, pieSeriesOuterAnchors) {
  var globalFontFamily = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Arial';
  var isNestedPieChart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var result = Object.keys(series).reduce(function (acc, seriesName) {
    return theme_objectSpread(theme_objectSpread({}, acc), {}, {
      series: theme_objectSpread(theme_objectSpread({}, acc.series), {}, theme_defineProperty({}, seriesName, getSeriesTheme(globalFontFamily, seriesName, pieSeriesOuterAnchors)))
    });
  }, makeDefaultTheme(series, globalFontFamily));

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    result.series.pie = aliasNames.reduce(function (acc, cur) {
      return theme_objectSpread(theme_objectSpread({}, acc), {}, theme_defineProperty({}, cur, getSeriesTheme(globalFontFamily, 'pie', pieSeriesOuterAnchors[cur], isNestedPieChart)));
    }, {});
  }

  return result;
}
;// CONCATENATED MODULE: ./src/helpers/validation.ts


function isAvailableShowTooltipInfo(info, eventDetectType, targetChartType) {
  var index = info.index,
      seriesIndex = info.seriesIndex,
      chartType = info.chartType;
  return isNumber(index) && (eventDetectType === 'grouped' || isNumber(seriesIndex)) && (isUndefined(chartType) || chartType === targetChartType);
}
function isAvailableSelectSeries(info, targetChartType) {
  var index = info.index,
      seriesIndex = info.seriesIndex,
      chartType = info.chartType;
  return isNumber(index) && isNumber(seriesIndex) && (isUndefined(chartType) || chartType === targetChartType);
}
function isNoData(series) {
  return Object.keys(series).reduce(function (acc, chartType) {
    return !series[chartType].data.length && acc;
  }, true);
}
;// CONCATENATED MODULE: ./src/helpers/legend.ts







function legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { legend_ownKeys(Object(source), true).forEach(function (key) { legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function getActiveSeriesMap(legend) {
  return legend.data.reduce(function (acc, _ref) {
    var active = _ref.active,
        label = _ref.label;
    return legend_objectSpread(legend_objectSpread({}, acc), {}, legend_defineProperty({}, label, active));
  }, {});
}
function showCircleLegend(options) {
  var _options$circleLegend, _options$circleLegend2;

  return (_options$circleLegend = options === null || options === void 0 ? void 0 : (_options$circleLegend2 = options.circleLegend) === null || _options$circleLegend2 === void 0 ? void 0 : _options$circleLegend2.visible) !== null && _options$circleLegend !== void 0 ? _options$circleLegend : true;
}
function showLegend(options, series) {
  var _options$series, _options$legend, _options$legend2;

  if (series.gauge || series.treemap && !((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.useColorValue)) {
    return false;
  }

  return isUndefined((_options$legend = options.legend) === null || _options$legend === void 0 ? void 0 : _options$legend.visible) ? true : !!((_options$legend2 = options.legend) !== null && _options$legend2 !== void 0 && _options$legend2.visible);
}
function showCheckbox(options) {
  var _options$legend3, _options$legend4;

  return isUndefined((_options$legend3 = options.legend) === null || _options$legend3 === void 0 ? void 0 : _options$legend3.showCheckbox) ? true : !!((_options$legend4 = options.legend) !== null && _options$legend4 !== void 0 && _options$legend4.showCheckbox);
} // @TODO: Need to manage with chart type constant/Enum

function useRectIcon(type) {
  return includes(['bar', 'column', 'area', 'pie', 'boxPlot', 'bullet', 'radialBar'], type);
}

function useCircleIcon(type) {
  return includes(['bubble', 'scatter'], type);
}

function useLineIcon(type) {
  return includes(['line', 'radar'], type);
}

function getIconType(type) {
  var iconType = 'spectrum';

  if (useCircleIcon(type)) {
    iconType = 'circle';
  } else if (useRectIcon(type)) {
    iconType = 'rect';
  } else if (useLineIcon(type)) {
    iconType = 'line';
  }

  return iconType;
}
function getLegendAlign(options) {
  var _options$legend$align, _options$legend5;

  return (_options$legend$align = (_options$legend5 = options.legend) === null || _options$legend5 === void 0 ? void 0 : _options$legend5.align) !== null && _options$legend$align !== void 0 ? _options$legend$align : 'right';
}
;// CONCATENATED MODULE: ./src/store/legend.ts
function legend_slicedToArray(arr, i) { return legend_arrayWithHoles(arr) || legend_iterableToArrayLimit(arr, i) || legend_unsupportedIterableToArray(arr, i) || legend_nonIterableRest(); }

function legend_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function legend_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function legend_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function store_legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function store_legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_legend_ownKeys(Object(source), true).forEach(function (key) { store_legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function store_legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function legend_toConsumableArray(arr) { return legend_arrayWithoutHoles(arr) || legend_iterableToArray(arr) || legend_unsupportedIterableToArray(arr) || legend_nonIterableSpread(); }

function legend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function legend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return legend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return legend_arrayLikeToArray(o, minLen); }

function legend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function legend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return legend_arrayLikeToArray(arr); }

function legend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

































var INITIAL_LEGEND_WIDTH = 100;
var INITIAL_CIRCLE_LEGEND_WIDTH = 150;
var COMPONENT_HEIGHT_EXCEPT_Y_AXIS = 100;
var ELLIPSIS_DOT_TEXT = '...';
var WIDEST_TEXT = 'W'; // The widest text width in Arial font.

var NUMBER_OF_BOTH_SIDES = 2;

function recalculateLegendWhenHeightOverflows(params, legendHeight) {
  var legendWidths = params.legendWidths,
      itemHeight = params.itemHeight;
  var totalHeight = legendWidths.length * itemHeight;
  var columnCount = Math.ceil(totalHeight / legendHeight);
  var rowCount = legendWidths.length / columnCount;
  var legendWidth = 0;
  range(0, columnCount).forEach(function (count) {
    legendWidth += Math.max.apply(Math, legend_toConsumableArray(legendWidths.slice(count * rowCount, (count + 1) * rowCount)));
  });
  legendWidth += LEGEND_ITEM_MARGIN_X * (columnCount - 1);
  return {
    legendWidth: legendWidth,
    legendHeight: rowCount * itemHeight + padding.Y,
    columnCount: columnCount,
    rowCount: rowCount
  };
}

function recalculateLegendWhenWidthOverflows(params, prevLegendWidth) {
  var legendWidths = params.legendWidths,
      itemHeight = params.itemHeight;
  var columnCount = 0;
  var legendWidth = 0;

  var _legendWidths$reduce = legendWidths.reduce(function (acc, width) {
    var widthWithMargin = LEGEND_ITEM_MARGIN_X + width;

    if (acc.totalWidth + width > prevLegendWidth) {
      acc.totalWidth = widthWithMargin;
      acc.rowCount += 1;
      acc.columnCount = 1;
      columnCount = Math.max(columnCount, acc.columnCount);
    } else {
      acc.totalWidth += widthWithMargin;
      acc.columnCount += 1;
    }

    legendWidth = Math.max(legendWidth, acc.totalWidth);
    return acc;
  }, {
    totalWidth: 0,
    rowCount: 1,
    columnCount: 0
  }),
      rowCount = _legendWidths$reduce.rowCount;

  return {
    legendHeight: itemHeight * rowCount,
    rowCount: rowCount,
    columnCount: columnCount,
    legendWidth: legendWidth
  };
}

function calculateLegendSize(params) {
  if (!params.visible) {
    return {
      legendWidth: 0,
      legendHeight: 0,
      rowCount: 0,
      columnCount: 0
    };
  }

  var chart = params.chart,
      verticalAlign = params.verticalAlign,
      legendWidths = params.legendWidths;

  var _calculateLegendWidth = calculateLegendWidth(params),
      legendWidth = _calculateLegendWidth.legendWidth,
      widthOverflow = _calculateLegendWidth.isOverflow;

  var _calculateLegendHeigh = calculateLegendHeight(params),
      legendHeight = _calculateLegendHeigh.legendHeight,
      heightOverflow = _calculateLegendHeigh.isOverflow;

  var columnCount = verticalAlign ? legendWidths.length : 1;
  var rowCount = verticalAlign ? Math.ceil(legendWidth / chart.width) : legendWidths.length;

  if (widthOverflow) {
    return recalculateLegendWhenWidthOverflows(params, legendWidth / rowCount);
  }

  if (heightOverflow) {
    return recalculateLegendWhenHeightOverflows(params, legendHeight);
  }

  return {
    legendWidth: legendWidth,
    legendHeight: legendHeight,
    columnCount: columnCount,
    rowCount: rowCount
  };
}

function calculateLegendHeight(params) {
  var verticalAlign = params.verticalAlign,
      itemHeight = params.itemHeight,
      legendWidths = params.legendWidths;

  var _getDefaultLegendSize = getDefaultLegendSize(params),
      chartHeight = _getDefaultLegendSize.height;

  var legendHeight;
  var isOverflow = false;

  if (verticalAlign) {
    legendHeight = chartHeight;
  } else {
    var totalHeight = legendWidths.length * itemHeight;
    isOverflow = chartHeight < totalHeight;
    legendHeight = isOverflow ? chartHeight : totalHeight;
  }

  return {
    legendHeight: legendHeight,
    isOverflow: isOverflow
  };
}

function getSpectrumLegendWidth(legendWidths, chartWidth, verticalAlign) {
  if (verticalAlign) {
    var labelAreaWidth = sum(legendWidths);
    return Math.max(chartWidth / 4, labelAreaWidth);
  }

  var spectrumAreaWidth = (spectrumLegendTooltip.PADDING + spectrumLegendBar.PADDING + padding.X) * NUMBER_OF_BOTH_SIDES + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendBar.HEIGHT;
  return Math.max.apply(Math, legend_toConsumableArray(legendWidths)) + spectrumAreaWidth;
}

function getSpectrumLegendHeight(itemHeight, chartHeight, verticalAlign) {
  return verticalAlign ? SPECTRUM_LEGEND_LABEL_HEIGHT + spectrumLegendBar.PADDING * NUMBER_OF_BOTH_SIDES + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendTooltip.HEIGHT + padding.Y : chartHeight * 3 / 4;
}

function getNormalLegendWidth(params) {
  var initialWidth = params.initialWidth,
      legendWidths = params.legendWidths,
      checkbox = params.checkbox,
      verticalAlign = params.verticalAlign;
  var isOverflow = false;
  var legendWidth;

  if (verticalAlign) {
    var _getDefaultLegendSize2 = getDefaultLegendSize(params),
        chartWidth = _getDefaultLegendSize2.width;

    var totalWidth = sum(legendWidths) + LEGEND_ITEM_MARGIN_X * (legendWidths.length - 1);
    isOverflow = totalWidth > chartWidth;
    legendWidth = totalWidth;
  } else {
    var labelAreaWidth = Math.max.apply(Math, legend_toConsumableArray(legendWidths));
    legendWidth = (checkbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + Math.max(labelAreaWidth, initialWidth);
  }

  return {
    legendWidth: legendWidth,
    isOverflow: isOverflow
  };
}

function calculateLegendWidth(params) {
  var options = params.options,
      visible = params.visible;
  var legendOptions = options === null || options === void 0 ? void 0 : options.legend;

  if (!visible) {
    return {
      legendWidth: 0,
      isOverflow: false
    };
  }

  if (legendOptions !== null && legendOptions !== void 0 && legendOptions.width) {
    return {
      legendWidth: legendOptions.width,
      isOverflow: false
    };
  }

  return getNormalLegendWidth(params);
}

function getDefaultLegendSize(params) {
  var verticalAlign = params.verticalAlign,
      chart = params.chart,
      itemHeight = params.itemHeight,
      initialWidth = params.initialWidth,
      circleLegendVisible = params.circleLegendVisible;
  var restAreaHeight = COMPONENT_HEIGHT_EXCEPT_Y_AXIS + (circleLegendVisible ? INITIAL_CIRCLE_LEGEND_WIDTH : 0); // rest area temporary value (yAxisTitle.height + xAxis.height + circleLegend.height)

  return verticalAlign ? {
    width: chart.width - padding.X * NUMBER_OF_BOTH_SIDES,
    height: itemHeight
  } : {
    width: initialWidth,
    height: chart.height - restAreaHeight
  };
}

function getNestedPieLegendLabelsInfo(series, legendInfo) {
  var result = [];
  var maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);
  series.pie.forEach(function (_ref) {
    var data = _ref.data;
    data.forEach(function (_ref2) {
      var name = _ref2.name,
          parentName = _ref2.parentName,
          visible = _ref2.visible;

      if (!parentName) {
        var _getViewLabelInfo = getViewLabelInfo(legendInfo, name, maxTextLengthWithEllipsis),
            width = _getViewLabelInfo.width,
            viewLabel = _getViewLabelInfo.viewLabel;

        result.push({
          label: name,
          type: 'pie',
          checked: visible !== null && visible !== void 0 ? visible : true,
          viewLabel: viewLabel,
          width: width
        });
      }
    });
  });
  return result;
}

function getMaxTextLengthWithEllipsis(legendInfo) {
  var _legendOptions$item;

  var legendOptions = legendInfo.legendOptions,
      font = legendInfo.font,
      checkboxVisible = legendInfo.checkboxVisible;
  var width = legendOptions === null || legendOptions === void 0 ? void 0 : (_legendOptions$item = legendOptions.item) === null || _legendOptions$item === void 0 ? void 0 : _legendOptions$item.width;

  if (isUndefined(width)) {
    return;
  }

  var checkboxWidth = checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0;
  var iconWidth = LEGEND_ICON_SIZE + LEGEND_MARGIN_X;
  var ellipsisDotWidth = getTextWidth(ELLIPSIS_DOT_TEXT, font);
  var widestTextWidth = getTextWidth(WIDEST_TEXT, font);
  var maxTextCount = Math.floor((width - ellipsisDotWidth - checkboxWidth - iconWidth) / widestTextWidth);
  return maxTextCount > 0 ? maxTextCount : 0;
}

function getViewLabelInfo(legendInfo, label, maxTextLength) {
  var _legendOptions$item2;

  var checkboxVisible = legendInfo.checkboxVisible,
      useSpectrumLegend = legendInfo.useSpectrumLegend,
      font = legendInfo.font,
      legendOptions = legendInfo.legendOptions;
  var viewLabel = label;
  var itemWidth = legendOptions === null || legendOptions === void 0 ? void 0 : (_legendOptions$item2 = legendOptions.item) === null || _legendOptions$item2 === void 0 ? void 0 : _legendOptions$item2.width;
  var itemWidthWithFullText = getItemWidth(viewLabel, checkboxVisible, useSpectrumLegend, font);

  if (isNumber(itemWidth) && isNumber(maxTextLength) && itemWidth < itemWidthWithFullText) {
    viewLabel = "".concat(label.slice(0, maxTextLength)).concat(ELLIPSIS_DOT_TEXT);
  }

  return {
    viewLabel: viewLabel,
    width: itemWidth !== null && itemWidth !== void 0 ? itemWidth : itemWidthWithFullText
  };
}

function getLegendLabelsInfo(series, legendInfo) {
  var maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);
  return Object.keys(series).flatMap(function (type) {
    return series[type].map(function (_ref3) {
      var name = _ref3.name,
          colorValue = _ref3.colorValue,
          visible = _ref3.visible;
      var label = colorValue ? colorValue : name;

      var _getViewLabelInfo2 = getViewLabelInfo(legendInfo, label, maxTextLengthWithEllipsis),
          width = _getViewLabelInfo2.width,
          viewLabel = _getViewLabelInfo2.viewLabel;

      return {
        label: label,
        type: type,
        checked: visible !== null && visible !== void 0 ? visible : true,
        viewLabel: viewLabel,
        width: width
      };
    });
  });
}

function getItemWidth(label, checkboxVisible, useSpectrumLegend, font) {
  return (useSpectrumLegend ? 0 : (checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X) + getTextWidth(label, font);
}

function getLegendDataAppliedTheme(data, series) {
  var colors = Object.values(series).reduce(function (acc, cur) {
    return cur && cur.colors ? [].concat(legend_toConsumableArray(acc), legend_toConsumableArray(cur.colors)) : acc;
  }, []);
  return data.map(function (datum, idx) {
    return store_legend_objectSpread(store_legend_objectSpread({}, datum), {}, {
      color: colors[idx]
    });
  });
}

function getLegendState(options, series) {
  var _useColorValue, _options$series, _options$theme, _options$theme$chart, _options$theme2, _options$theme2$legen;

  var useSpectrumLegend = (_useColorValue = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.useColorValue) !== null && _useColorValue !== void 0 ? _useColorValue : !!series.heatmap;
  var useScatterChartIcon = !!(series !== null && series !== void 0 && series.scatter);
  var checkboxVisible = useSpectrumLegend ? false : showCheckbox(options);
  var defaultTheme = makeDefaultTheme(series, options === null || options === void 0 ? void 0 : (_options$theme = options.theme) === null || _options$theme === void 0 ? void 0 : (_options$theme$chart = _options$theme.chart) === null || _options$theme$chart === void 0 ? void 0 : _options$theme$chart.fontFamily);
  var font = getTitleFontString(deepMergedCopy(defaultTheme.legend.label, store_legend_objectSpread({}, (_options$theme2 = options.theme) === null || _options$theme2 === void 0 ? void 0 : (_options$theme2$legen = _options$theme2.legend) === null || _options$theme2$legen === void 0 ? void 0 : _options$theme2$legen.label)));
  var legendInfo = {
    checkboxVisible: checkboxVisible,
    font: font,
    useSpectrumLegend: useSpectrumLegend,
    legendOptions: options.legend
  };
  var legendLabelsInfo = hasNestedPieSeries(series) ? getNestedPieLegendLabelsInfo(series, legendInfo) : getLegendLabelsInfo(series, legendInfo);
  var data = legendLabelsInfo.map(function (_ref4) {
    var label = _ref4.label,
        type = _ref4.type,
        checked = _ref4.checked,
        width = _ref4.width,
        viewLabel = _ref4.viewLabel;
    return {
      label: label,
      active: true,
      checked: checked,
      width: width,
      iconType: getIconType(type),
      chartType: type,
      rowIndex: 0,
      columnIndex: 0,
      viewLabel: viewLabel
    };
  });
  return {
    useSpectrumLegend: useSpectrumLegend,
    useScatterChartIcon: useScatterChartIcon,
    data: data
  };
}

function getNextColumnRowIndex(params) {
  var verticalAlign = params.verticalAlign,
      columnCount = params.columnCount,
      rowCount = params.rowCount,
      legendCount = params.legendCount;
  var rowIndex = params.rowIndex,
      columnIndex = params.columnIndex;

  if (verticalAlign) {
    var maxLen = legendCount / rowCount;

    if (maxLen - 1 > columnIndex) {
      columnIndex += 1;
    } else {
      rowIndex += 1;
      columnIndex = 0;
    }
  } else {
    var _maxLen = legendCount / columnCount;

    if (_maxLen - 1 > rowIndex) {
      rowIndex += 1;
    } else {
      columnIndex += 1;
      rowIndex = 0;
    }
  }

  return [rowIndex, columnIndex];
}

function setIndexToLegendData(legendData, rowCount, columnCount, legendCount, verticalAlign) {
  var columnIndex = 0;
  var rowIndex = 0;
  legendData.forEach(function (datum) {
    datum.rowIndex = rowIndex;
    datum.columnIndex = columnIndex;

    var _getNextColumnRowInde = getNextColumnRowIndex({
      rowCount: rowCount,
      columnCount: columnCount,
      verticalAlign: verticalAlign,
      legendCount: legendCount,
      rowIndex: rowIndex,
      columnIndex: columnIndex
    });

    var _getNextColumnRowInde2 = legend_slicedToArray(_getNextColumnRowInde, 2);

    rowIndex = _getNextColumnRowInde2[0];
    columnIndex = _getNextColumnRowInde2[1];
  });
}

var legend_legend = {
  name: 'legend',
  state: function state(_ref5) {
    var options = _ref5.options,
        series = _ref5.series;
    return {
      legend: getLegendState(options, series),
      circleLegend: {}
    };
  },
  action: {
    initLegendState: function initLegendState(_ref6) {
      var state = _ref6.state,
          initStoreState = _ref6.initStoreState;
      store_extend(state.legend, getLegendState(initStoreState.options, initStoreState.series));
    },
    setLegendLayout: function setLegendLayout(_ref7) {
      var state = _ref7.state;

      if (state.legend.useSpectrumLegend) {
        this.dispatch('setSpectrumLegendLayout');
      } else {
        this.dispatch('setNormalLegendLayout');
      }
    },
    setSpectrumLegendLayout: function setSpectrumLegendLayout(_ref8) {
      var state = _ref8.state;
      var legendData = state.legend.data,
          series = state.series,
          options = state.options,
          chart = state.chart,
          theme = state.theme;
      var align = getLegendAlign(options);
      var visible = showLegend(options, series);
      var verticalAlign = isVerticalAlign(align);
      var legendWidths = legendData.map(function (_ref9) {
        var width = _ref9.width;
        return width;
      });
      var itemHeight = getLegendItemHeight(theme.legend.label.fontSize);
      var width = getSpectrumLegendWidth(legendWidths, chart.width, verticalAlign);
      var height = getSpectrumLegendHeight(itemHeight, chart.height, verticalAlign);
      store_extend(state.legend, {
        visible: visible,
        align: align,
        width: width,
        height: height
      });
    },
    setNormalLegendLayout: function setNormalLegendLayout(_ref10) {
      var state = _ref10.state,
          initStoreState = _ref10.initStoreState;
      var legendData = state.legend.data,
          series = state.series,
          options = state.options,
          chart = state.chart,
          theme = state.theme;
      var align = getLegendAlign(options);
      var visible = showLegend(options, series);
      var checkbox = showCheckbox(options);
      var initialWidth = Math.min(chart.width / 5, INITIAL_LEGEND_WIDTH);
      var verticalAlign = isVerticalAlign(align);
      var isNestedPieChart = hasNestedPieSeries(initStoreState.series);
      var isScatterChart = !!series.scatter;
      var isBubbleChart = !!series.bubble;
      var circleLegendVisible = isBubbleChart ? showCircleLegend(options) : false;
      var legendWidths = legendData.map(function (_ref11) {
        var width = _ref11.width;
        return width;
      });
      var itemHeight = getLegendItemHeight(theme.legend.label.fontSize);

      var _calculateLegendSize = calculateLegendSize({
        initialWidth: initialWidth,
        legendWidths: legendWidths,
        options: options,
        verticalAlign: verticalAlign,
        visible: visible,
        checkbox: checkbox,
        chart: chart,
        itemHeight: itemHeight,
        circleLegendVisible: circleLegendVisible
      }),
          legendWidth = _calculateLegendSize.legendWidth,
          legendHeight = _calculateLegendSize.legendHeight,
          rowCount = _calculateLegendSize.rowCount,
          columnCount = _calculateLegendSize.columnCount;

      setIndexToLegendData(legendData, rowCount, columnCount, legendWidths.length, verticalAlign);
      store_extend(state.legend, {
        visible: visible,
        align: align,
        showCheckbox: checkbox,
        width: legendWidth,
        height: legendHeight
      });

      if (isBubbleChart && circleLegendVisible) {
        this.dispatch('updateCircleLegendLayout', {
          legendWidth: legendWidth
        });
      }

      if (!isNestedPieChart && !isNoData(series)) {
        this.dispatch('updateLegendColor');
      }

      if (isScatterChart) {
        this.dispatch('updateLegendIcon');
      }
    },
    updateCircleLegendLayout: function updateCircleLegendLayout(_ref12, _ref13) {
      var state = _ref12.state;
      var legendWidth = _ref13.legendWidth;
      var width = legendWidth === 0 ? INITIAL_CIRCLE_LEGEND_WIDTH : Math.min(legendWidth, INITIAL_CIRCLE_LEGEND_WIDTH);
      var radius = Math.max((width - LEGEND_MARGIN_X) / 2, 0);
      store_extend(state.circleLegend, {
        visible: true,
        width: width,
        radius: radius
      });
    },
    setLegendActiveState: function setLegendActiveState(_ref14, _ref15) {
      var state = _ref14.state;
      var name = _ref15.name,
          active = _ref15.active;
      var data = state.legend.data;
      var model = data.find(function (_ref16) {
        var label = _ref16.label;
        return label === name;
      });
      model.active = active;
      this.notify(state, 'legend');
    },
    setAllLegendActiveState: function setAllLegendActiveState(_ref17, active) {
      var state = _ref17.state;
      state.legend.data.forEach(function (datum) {
        datum.active = active;
      });
      this.notify(state, 'legend');
    },
    setLegendCheckedState: function setLegendCheckedState(_ref18, _ref19) {
      var state = _ref18.state;
      var name = _ref19.name,
          checked = _ref19.checked;
      var model = state.legend.data.find(function (_ref20) {
        var label = _ref20.label;
        return label === name;
      });
      model.checked = checked;
      this.notify(state, 'legend');
    },
    updateLegendColor: function updateLegendColor(_ref21) {
      var state = _ref21.state;
      var legendData = state.legend,
          series = state.series;
      var data = getLegendDataAppliedTheme(legendData.data, series);
      store_extend(state.legend, {
        data: data
      });
    },
    updateLegendIcon: function updateLegendIcon(_ref22) {
      var state = _ref22.state;
      var legendData = state.legend,
          series = state.series;
      var data = legendData.data.reduce(function (acc, cur) {
        var _series$scatter;

        if (cur.chartType === 'scatter' && (_series$scatter = series.scatter) !== null && _series$scatter !== void 0 && _series$scatter.data) {
          var model = series.scatter.data.find(function (_ref23) {
            var name = _ref23.name;
            return name === cur.label;
          });
          var iconType = model ? model.iconType : cur.iconType;
          return [].concat(legend_toConsumableArray(acc), [store_legend_objectSpread(store_legend_objectSpread({}, cur), {}, {
            iconType: iconType
          })]);
        }

        return [].concat(legend_toConsumableArray(acc), [cur]);
      }, []);
      store_extend(state.legend, {
        data: data
      });
    },
    updateNestedPieChartLegend: function updateNestedPieChartLegend(_ref24) {
      var state = _ref24.state;
      var legendData = state.legend,
          nestedPieSeries = state.nestedPieSeries;
      store_extend(state.legend, {
        data: getLegendDataAppliedTheme(legendData.data, nestedPieSeries)
      });
    }
  },
  observe: {
    updateLegendLayout: function updateLegendLayout() {
      this.dispatch('setLegendLayout');
    }
  }
};
/* harmony default export */ var store_legend = (legend_legend);
;// CONCATENATED MODULE: ./src/store/options.ts


function getOptionsBySize(size, options) {
  var _options$responsive;

  var rules = (_options$responsive = options.responsive) === null || _options$responsive === void 0 ? void 0 : _options$responsive.rules;
  return Array.isArray(rules) ? rules.reduce(function (acc, cur) {
    return cur.condition(size) ? deepMergedCopy(acc, cur.options) : acc;
  }, options) : options;
}

function getSize(usingContainerSize, containerSize, chartSize) {
  var usingContainerWidth = usingContainerSize.width,
      usingContainerHeight = usingContainerSize.height;
  return {
    width: usingContainerWidth ? containerSize.width : chartSize === null || chartSize === void 0 ? void 0 : chartSize.width,
    height: usingContainerHeight ? containerSize.height : chartSize === null || chartSize === void 0 ? void 0 : chartSize.height
  };
}

var optionsData = {
  name: 'options',
  state: function state(_ref) {
    var options = _ref.options;
    return {
      originalOptions: deepCopy(options),
      options: options
    };
  },
  action: {
    setOptions: function setOptions(_ref2) {
      var state = _ref2.state;
      var _state$chart = state.chart,
          width = _state$chart.width,
          height = _state$chart.height;

      if (width < 0 || height < 0) {
        return;
      }

      state.options = getOptionsBySize({
        width: width,
        height: height
      }, state.originalOptions);
    },
    initOptions: function initOptions(_ref3, _ref4) {
      var initStoreState = _ref3.initStoreState,
          state = _ref3.state;
      var options = _ref4.options,
          containerSize = _ref4.containerSize;
      initStoreState.options = options;
      state.originalOptions = deepCopy(options);
      var usingContainerSize = state.usingContainerSize,
          originalOptions = state.originalOptions;
      var size = getSize(usingContainerSize, containerSize, {
        width: originalOptions.chart.width,
        height: originalOptions.chart.height
      });
      this.dispatch('setChartSize', size);
    },
    updateOptions: function updateOptions(_ref5, _ref6) {
      var _originalOptions$char, _originalOptions$char2;

      var state = _ref5.state,
          initStoreState = _ref5.initStoreState;
      var options = _ref6.options,
          containerSize = _ref6.containerSize;
      initStoreState.options = deepMergedCopy(initStoreState.options, options);
      state.originalOptions = deepMergedCopy(state.originalOptions, options);
      var usingContainerSize = state.usingContainerSize,
          originalOptions = state.originalOptions;
      var size = getSize(usingContainerSize, containerSize, {
        width: (_originalOptions$char = originalOptions.chart) === null || _originalOptions$char === void 0 ? void 0 : _originalOptions$char.width,
        height: (_originalOptions$char2 = originalOptions.chart) === null || _originalOptions$char2 === void 0 ? void 0 : _originalOptions$char2.height
      });
      this.dispatch('setChartSize', size);
      this.dispatch('initThemeState');
    }
  },
  observe: {
    updateOptions: function updateOptions() {
      this.dispatch('setOptions');
    }
  }
};
/* harmony default export */ var options = (optionsData);
;// CONCATENATED MODULE: ./src/store/theme.ts
function theme_toConsumableArray(arr) { return theme_arrayWithoutHoles(arr) || theme_iterableToArray(arr) || theme_unsupportedIterableToArray(arr) || theme_nonIterableSpread(); }

function theme_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function theme_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return theme_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return theme_arrayLikeToArray(o, minLen); }

function theme_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function theme_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return theme_arrayLikeToArray(arr); }

function theme_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function store_theme_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function store_theme_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_theme_ownKeys(Object(source), true).forEach(function (key) { store_theme_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_theme_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function store_theme_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }























function getCommonSeriesOptions(options, series, isNestedPieChart) {
  var theme = options === null || options === void 0 ? void 0 : options.theme;

  if (!(theme !== null && theme !== void 0 && theme.series)) {
    return {};
  }

  var seriesNames = isNestedPieChart ? getNestedPieChartAliasNames(series) : Object.keys(series);
  return seriesNames.reduce(function (acc, seriesName) {
    delete acc[seriesName];
    return acc;
  }, store_theme_objectSpread({}, theme.series));
}

function getThemeAppliedSecondaryYAxis(options) {
  var _options$theme, _options$theme$chart;

  var theme = store_theme_objectSpread({}, options.theme);

  if (!Array.isArray(theme.yAxis)) {
    return theme;
  }

  var axisTitleTheme = makeAxisTitleTheme(options === null || options === void 0 ? void 0 : (_options$theme = options.theme) === null || _options$theme === void 0 ? void 0 : (_options$theme$chart = _options$theme.chart) === null || _options$theme$chart === void 0 ? void 0 : _options$theme$chart.fontFamily);
  var yAxis = theme.yAxis.map(function (yAxisTheme) {
    return deepMergedCopy({
      title: store_theme_objectSpread({}, axisTitleTheme)
    }, store_theme_objectSpread({}, yAxisTheme));
  });
  return store_theme_objectSpread(store_theme_objectSpread({}, theme), {}, {
    yAxis: yAxis
  });
}

function getThemeOptionsWithSeriesName(options, series, commonSeriesOptions, isNestedPieChart) {
  var theme = getThemeAppliedSecondaryYAxis(options);

  if (!(theme !== null && theme !== void 0 && theme.series)) {
    return store_theme_objectSpread({}, theme);
  }

  var seriesTheme = store_theme_objectSpread(store_theme_objectSpread({}, theme), {}, {
    series: {}
  });

  var seriesNames = Object.keys(series);
  var isComboChart = seriesNames.length > 1;

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    seriesTheme.series = {
      pie: aliasNames.reduce(function (acc, aliasName) {
        var _theme$series;

        return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, aliasName, deepMergedCopy((_theme$series = theme.series) === null || _theme$series === void 0 ? void 0 : _theme$series[aliasName], omit(commonSeriesOptions, 'colors'))));
      }, {})
    };
  } else if (isComboChart) {
    seriesTheme.series = store_theme_objectSpread({}, seriesNames.reduce(function (acc, seriesName) {
      var _theme$series2;

      return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, seriesName, deepMergedCopy((_theme$series2 = theme.series) === null || _theme$series2 === void 0 ? void 0 : _theme$series2[seriesName], omit(commonSeriesOptions, 'colors'))));
    }, {}));
  } else {
    seriesTheme.series = store_theme_defineProperty({}, seriesNames[0], theme.series);
  }

  return seriesTheme;
}

function setColors(theme, series, commonSeriesOptions, isNestedPieChart) {
  var _ref;

  var index = 0;
  var commonColorsOption = [].concat(theme_toConsumableArray((_ref = commonSeriesOptions === null || commonSeriesOptions === void 0 ? void 0 : commonSeriesOptions.colors) !== null && _ref !== void 0 ? _ref : []), theme_toConsumableArray(defaultSeriesTheme.colors));
  var themeNames = isNestedPieChart ? getNestedPieChartAliasNames(series) : Object.keys(series);
  themeNames.forEach(function (name, idx) {
    var _target$name;

    var size = isNestedPieChart ? series.pie[idx].data.length : series[name].length;
    var target = isNestedPieChart ? theme.series.pie : theme.series;

    if (!((_target$name = target[name]) !== null && _target$name !== void 0 && _target$name.colors)) {
      target[name] = store_theme_objectSpread(store_theme_objectSpread({}, target[name]), {}, {
        colors: commonColorsOption.slice(index, index + size)
      });
      index += size;
    }
  });
}

function setPlot(theme) {
  ['vertical', 'horizontal'].reduce(function (acc, cur) {
    if (!acc[cur]) {
      acc[cur] = {
        lineColor: acc.lineColor
      };
    }

    return acc;
  }, theme.plot);
}

function checkAnchorPieSeriesOption(options, series, alias) {
  var _options$series, _options$series$alias, _options$series$alias2, _options$series2, _options$series2$alia, _options$series2$alia2, _options$series2$alia3;

  return {
    hasOuterAnchor: !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : (_options$series$alias = _options$series[alias]) === null || _options$series$alias === void 0 ? void 0 : (_options$series$alias2 = _options$series$alias.dataLabels) === null || _options$series$alias2 === void 0 ? void 0 : _options$series$alias2.anchor) === 'outer',
    hasOuterAnchorPieSeriesName: !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$alia = _options$series2[alias]) === null || _options$series2$alia === void 0 ? void 0 : (_options$series2$alia2 = _options$series2$alia.dataLabels) === null || _options$series2$alia2 === void 0 ? void 0 : (_options$series2$alia3 = _options$series2$alia2.pieSeriesName) === null || _options$series2$alia3 === void 0 ? void 0 : _options$series2$alia3.anchor) === 'outer'
  };
}

function getTheme(options, series) {
  var _options$theme2, _options$theme2$chart;

  var isNestedPieChart = hasNestedPieSeries(series);
  var commonSeriesOptions = getCommonSeriesOptions(options, series, isNestedPieChart);
  var pieSeriesOuterAnchors = {
    hasOuterAnchor: hasOuterDataLabel(options, series),
    hasOuterAnchorPieSeriesName: hasOuterPieSeriesName(options, series)
  };

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    pieSeriesOuterAnchors = aliasNames.reduce(function (acc, cur) {
      return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, cur, checkAnchorPieSeriesOption(options, series, cur)));
    }, {});
  }

  var globalFontFamily = options === null || options === void 0 ? void 0 : (_options$theme2 = options.theme) === null || _options$theme2 === void 0 ? void 0 : (_options$theme2$chart = _options$theme2.chart) === null || _options$theme2$chart === void 0 ? void 0 : _options$theme2$chart.fontFamily;
  var theme = deepMergedCopy(getDefaultTheme(series, pieSeriesOuterAnchors, globalFontFamily, isNestedPieChart), getThemeOptionsWithSeriesName(options, series, commonSeriesOptions, isNestedPieChart));

  if (!series.heatmap) {
    setColors(theme, series, commonSeriesOptions, isNestedPieChart);
  }

  setPlot(theme);
  return theme;
}

var theme = {
  name: 'theme',
  state: function state(_ref2) {
    var options = _ref2.options,
        series = _ref2.series;
    return {
      theme: getTheme(options, series)
    };
  },
  action: {
    initThemeState: function initThemeState(_ref3) {
      var state = _ref3.state,
          initStoreState = _ref3.initStoreState;
      state.theme = getTheme(state.options, initStoreState.series);
    }
  },
  observe: {
    updateTheme: function updateTheme() {
      this.dispatch('initThemeState');
    }
  }
};
/* harmony default export */ var store_theme = (theme);
;// CONCATENATED MODULE: ./src/eventEmitter.ts


function eventEmitter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function eventEmitter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function eventEmitter_createClass(Constructor, protoProps, staticProps) { if (protoProps) eventEmitter_defineProperties(Constructor.prototype, protoProps); if (staticProps) eventEmitter_defineProperties(Constructor, staticProps); return Constructor; }

function eventEmitter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    eventEmitter_classCallCheck(this, EventEmitter);

    eventEmitter_defineProperty(this, "handlers", []);
  }

  eventEmitter_createClass(EventEmitter, [{
    key: "on",
    value: function on(type, handler) {
      if (!this.handlers[type]) {
        this.handlers[type] = [];
      }

      this.handlers[type].push(handler);
    }
  }, {
    key: "emit",
    value: function emit(type) {
      var _this$handlers$type;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_this$handlers$type = this.handlers[type]) === null || _this$handlers$type === void 0 ? void 0 : _this$handlers$type.forEach(function (handler) {
        return handler.apply(void 0, args);
      });
    }
  }]);

  return EventEmitter;
}();


;// CONCATENATED MODULE: ./src/component/componentManager.ts



function componentManager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function componentManager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function componentManager_createClass(Constructor, protoProps, staticProps) { if (protoProps) componentManager_defineProperties(Constructor.prototype, protoProps); if (staticProps) componentManager_defineProperties(Constructor, staticProps); return Constructor; }

function componentManager_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var ComponentManager = /*#__PURE__*/function () {
  function ComponentManager(_ref) {
    var store = _ref.store,
        eventBus = _ref.eventBus;

    componentManager_classCallCheck(this, ComponentManager);

    componentManager_defineProperty(this, "components", []);

    componentManager_defineProperty(this, "store", void 0);

    componentManager_defineProperty(this, "eventBus", void 0);

    this.store = store;
    this.eventBus = eventBus;
  }

  componentManager_createClass(ComponentManager, [{
    key: "add",
    value: function add(ComponentCtor, initialParam) {
      var _this = this;

      var component = new ComponentCtor({
        store: this.store,
        eventBus: this.eventBus
      });

      if (component.initialize) {
        component.initialize(initialParam);
      }

      var proc = function proc() {
        component.render(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]); // rest 

        component.sync();

        _this.eventBus.emit('needLoop');
      };

      this.store.observe(function () {
        proc.apply(void 0, arguments);
      });
      proc = debounce(proc);
      this.components.push(component);
    }
  }, {
    key: "remove",
    value: function remove(ComponentCtor) {
      this.components = this.components.filter(function (component) {
        return !(component instanceof ComponentCtor);
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.components = [];
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "invoke",
    value: function invoke(method, params) {
      this.components.forEach(function (component) {
        var fn = component[method];

        if (fn) {
          fn.call(component, params);
        }
      });
    }
  }, {
    key: "forEach",
    value: function forEach(iteratee) {
      this.components.forEach(iteratee);
    }
  }]);

  return ComponentManager;
}();


;// CONCATENATED MODULE: ./src/painter.ts



function painter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function painter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function painter_createClass(Constructor, protoProps, staticProps) { if (protoProps) painter_defineProperties(Constructor.prototype, protoProps); if (staticProps) painter_defineProperties(Constructor, staticProps); return Constructor; }

function painter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Painter = /*#__PURE__*/function () {
  function Painter(chart) {
    painter_classCallCheck(this, Painter);

    painter_defineProperty(this, "width", 0);

    painter_defineProperty(this, "height", 0);

    painter_defineProperty(this, "brushes", {});

    painter_defineProperty(this, "chart", void 0);

    painter_defineProperty(this, "canvas", void 0);

    painter_defineProperty(this, "ctx", void 0);

    this.chart = chart;
  }

  painter_createClass(Painter, [{
    key: "showUnsupportedCanvasFeatureError",
    value: function showUnsupportedCanvasFeatureError() {
      if (!this.ctx.setLineDash) {
        console.warn(message.DASH_SEGMENTS_UNAVAILABLE_ERROR);
      }
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this$chart$store$sta = this.chart.store.state.chart,
          height = _this$chart$store$sta.height,
          width = _this$chart$store$sta.width;

      if (!this.canvas) {
        var canvas = document.createElement('canvas');
        this.canvas = canvas;
        this.chart.el.appendChild(canvas);
        canvas.addEventListener('click', this.chart);
        canvas.addEventListener('mousemove', this.chart);
        canvas.addEventListener('mousedown', this.chart);
        canvas.addEventListener('mouseup', this.chart);
        canvas.addEventListener('mouseout', this.chart);

        var _ctx = canvas.getContext('2d');

        if (_ctx) {
          this.ctx = _ctx;
        }
      }

      this.setSize(width, height);
      this.showUnsupportedCanvasFeatureError();
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this.canvas.style.width = "".concat(width, "px");
      this.canvas.style.height = "".concat(height, "px");
      var ratio = 1;

      if ('deviceXDPI' in window.screen) {
        // IE mobile or IE
        ratio = window.screen.deviceXDPI / window.screen.logicalXDPI;
      } else if (window.hasOwnProperty('devicePixelRatio')) {
        ratio = window.devicePixelRatio;
      }

      this.width = width * ratio || 0;
      this.height = height * ratio || 0;
      this.scaleCanvasRatio(ratio);
    }
  }, {
    key: "scaleCanvasRatio",
    value: function scaleCanvasRatio(ratio) {
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.ctx.scale(ratio, ratio);
    }
  }, {
    key: "add",
    value: function add(name, brush) {
      this.brushes[name] = brush;
    }
  }, {
    key: "addGroups",
    value: function addGroups(groups) {
      var _this = this;

      groups.forEach(function (group) {
        Object.keys(group).forEach(function (key) {
          _this.add(key, group[key]);
        });
      });
    }
  }, {
    key: "paint",
    value: function paint(name, brushModel) {
      if (this.brushes[name]) {
        this.brushes[name](this.ctx, brushModel);
      } else {
        throw new Error(message.noBrushError(name));
      }
    }
  }, {
    key: "paintForEach",
    value: function paintForEach(brushModels) {
      var _this2 = this;

      brushModels.forEach(function (m) {
        return _this2.paint(m.type, m);
      });
    }
  }, {
    key: "beforeFrame",
    value: function beforeFrame() {
      this.ctx.clearRect(0, 0, this.width, this.height);
      this.ctx.fillStyle = 'transparent';
      this.ctx.fillRect(0, 0, this.width, this.height);
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(transX, transY) {
      this.ctx.save();
      this.ctx.translate(transX, transY);
    }
  }, {
    key: "afterDraw",
    value: function afterDraw() {
      this.ctx.restore();
    }
  }]);

  return Painter;
}();


;// CONCATENATED MODULE: ./src/animator.ts



function animator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function animator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function animator_createClass(Constructor, protoProps, staticProps) { if (protoProps) animator_defineProperties(Constructor.prototype, protoProps); if (staticProps) animator_defineProperties(Constructor, staticProps); return Constructor; }

function animator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Animator = /*#__PURE__*/function () {
  function Animator() {
    animator_classCallCheck(this, Animator);

    animator_defineProperty(this, "anims", []);

    animator_defineProperty(this, "state", 'IDLE');

    animator_defineProperty(this, "requestId", null);

    animator_defineProperty(this, "firstRendering", true);
  }

  animator_createClass(Animator, [{
    key: "add",
    value: function add(_ref) {
      var _this = this;

      var chart = _ref.chart,
          duration = _ref.duration,
          requester = _ref.requester,
          _ref$onCompleted = _ref.onCompleted,
          onCompleted = _ref$onCompleted === void 0 ? function () {} : _ref$onCompleted,
          _ref$onFrame = _ref.onFrame,
          onFrame = _ref$onFrame === void 0 ? function (delta) {
        if (!_this.firstRendering) {
          chart.update(delta);
        }

        if (_this.firstRendering) {
          chart.initUpdate(delta);

          if (delta === 1) {
            _this.firstRendering = false;
          }
        }
      } : _ref$onFrame;

      if (this.anims.length) {
        this.reset();
      }

      if (this.state === 'IDLE') {
        this.anims.push({
          chart: chart,
          requester: requester,
          duration: duration,
          onFrame: onFrame,
          onCompleted: onCompleted,
          start: null,
          current: null,
          completed: false
        });
        this.start();
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.anims.forEach(function (anim) {
        anim.current = 1;
        anim.onFrame(anim.current);
        anim.completed = true;
      });
      this.anims = [];
      this.cancelAnimFrame();
      this.state = 'IDLE';
      this.requestId = null;
    }
  }, {
    key: "start",
    value: function start() {
      if (this.anims.length) {
        this.state = 'RUNNING';
        this.runFrame();
      }
    }
  }, {
    key: "runFrame",
    value: function runFrame() {
      var _this2 = this;

      this.requestId = window.requestAnimationFrame(function (timestamp) {
        _this2.runAnims(timestamp);
      });
    }
  }, {
    key: "runAnims",
    value: function runAnims(timestamp) {
      this.next(timestamp);

      if (this.anims.length) {
        this.runFrame();
      } else {
        this.state = 'IDLE';
        this.requestId = null;
      }
    }
  }, {
    key: "next",
    value: function next(timestamp) {
      var _this3 = this;

      this.anims.forEach(function (anim) {
        if (isNull(anim.start)) {
          anim.start = timestamp;
        }

        Object.defineProperty(anim.chart, '___animId___', {
          value: timestamp,
          enumerable: false,
          writable: false,
          configurable: true
        });
        anim.current = anim.duration ? Math.min((timestamp - anim.start) / anim.duration, 1) : 1;
        anim.onFrame(anim.current);
        anim.completed = anim.current === 1;
      });
      this.anims.forEach(function (anim) {
        if (anim.chart.___animId___ === timestamp) {
          anim.chart.draw();
          delete anim.chart.___animId___;
        }

        if (anim.completed) {
          _this3.cancelAnimFrame();

          anim.onCompleted();
          anim.chart.eventBus.emit('animationCompleted', anim.requester);
        }
      });
      this.anims = this.anims.filter(function (anim) {
        return !anim.completed;
      });
    }
  }, {
    key: "cancelAnimFrame",
    value: function cancelAnimFrame() {
      if (this.requestId) {
        window.cancelAnimationFrame(this.requestId);
      }
    }
  }]);

  return Animator;
}();


;// CONCATENATED MODULE: ./src/responderDetectors.ts











function responderDetectors_slicedToArray(arr, i) { return responderDetectors_arrayWithHoles(arr) || responderDetectors_iterableToArrayLimit(arr, i) || responderDetectors_unsupportedIterableToArray(arr, i) || responderDetectors_nonIterableRest(); }

function responderDetectors_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function responderDetectors_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return responderDetectors_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return responderDetectors_arrayLikeToArray(o, minLen); }

function responderDetectors_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function responderDetectors_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function responderDetectors_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




function withinRotationRect(_ref) {
  var slope = _ref.slope,
      yIntercept = _ref.yIntercept,
      mouseX = _ref.mouseX,
      mouseY = _ref.mouseY,
      modelXPositions = _ref.modelXPositions,
      compX = _ref.compX,
      compY = _ref.compY,
      _ref$detectionSize = _ref.detectionSize,
      detectionSize = _ref$detectionSize === void 0 ? 0 : _ref$detectionSize;

  var _modelXPositions = responderDetectors_slicedToArray(modelXPositions, 2),
      x1 = _modelXPositions[0],
      x2 = _modelXPositions[1];

  var posY = slope * (mouseX - compX) + yIntercept;
  var withinRadius = x1 > x2 && mouseX >= compX + x2 && mouseX <= compX + x1 || x1 < x2 && mouseX <= compX + x2 && mouseX >= compX + x1;
  var withinDetectionSize = posY - detectionSize + compY <= mouseY && mouseY <= posY + detectionSize + compY;
  return withinRadius && withinDetectionSize;
}

var responderDetectors = {
  circle: function circle(mousePosition, model, componentRect) {
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        radius = model.radius,
        detectionSize = model.detectionSize;
    var compX = componentRect.x,
        compY = componentRect.y;
    var radiusAdjustment = isUndefined(detectionSize) ? 10 : detectionSize;
    return Math.pow(x - (modelX + compX), 2) + Math.pow(y - (modelY + compY), 2) < Math.pow(radius + radiusAdjustment, 2);
  },
  rect: function rect(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        width = model.width,
        height = model.height;
    var compX = componentRect.x,
        compY = componentRect.y;
    return x >= modelX + compX && x <= modelX + compX + width && y >= modelY + compY && y <= modelY + compY + height;
  },
  sector: function sector(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        _model$radius = model.radius,
        outer = _model$radius.outer,
        inner = _model$radius.inner,
        _model$degree = model.degree,
        start = _model$degree.start,
        end = _model$degree.end,
        drawingStartAngle = model.drawingStartAngle,
        clockwise = model.clockwise;
    var compX = componentRect.x,
        compY = componentRect.y;
    var xPos = x - (modelX + compX);
    var yPos = y - (modelY + compY);
    var insideOuterRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) < Math.pow(outer, 2);
    var outsideInnerRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) > Math.pow(inner, 2);
    var withinRadius = insideOuterRadius && outsideInnerRadius;
    var detectionDegree = calculateRadianToDegree(Math.atan2(yPos, xPos), drawingStartAngle);
    return withinRadius && withinRadian(clockwise, start, end, detectionDegree);
  },
  line: function line(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var compX = componentRect.x,
        compY = componentRect.y;
    var modelX = model.x,
        modelY = model.y,
        x2 = model.x2,
        y2 = model.y2,
        _model$detectionSize = model.detectionSize,
        detectionSize = _model$detectionSize === void 0 ? 3 : _model$detectionSize;
    var numerator = y2 - modelY;
    var denominator = x2 - modelX;
    var withinLine = false;

    if (numerator === 0) {
      var minX = Math.min(modelX, x2);
      var maxX = Math.max(modelX, x2);
      withinLine = x - compX >= minX && x - compX <= maxX && y >= modelY + compY - detectionSize && y <= modelY + compY + detectionSize;
    } else if (denominator === 0) {
      var minY = Math.min(modelY, y2);
      var maxY = Math.max(modelY, y2);
      withinLine = y - compY >= minY && y - compY <= maxY && x >= modelX + compX - detectionSize && x <= modelX + compX + detectionSize;
    } else {
      var slope = numerator / denominator;
      var xPos = x - (modelX + compX);
      var yPos = y - (modelY + compY);
      withinLine = slope * xPos === yPos;
    }

    return withinLine;
  },
  boxPlot: function boxPlot(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    return ['rect', 'median', 'minimum', 'maximum', 'upperWhisker', 'lowerWhisker'].some(function (prop) {
      if (!model[prop]) {
        return false;
      }

      return prop === 'rect' ? responderDetectors.rect(mousePosition, model[prop], componentRect) : responderDetectors.line(mousePosition, model[prop], componentRect);
    });
  },
  clockHand: function clockHand(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var compX = componentRect.x,
        compY = componentRect.y;
    var centerX = model.x,
        centerY = model.y,
        x2 = model.x2,
        y2 = model.y2,
        _model$detectionSize2 = model.detectionSize,
        detectionSize = _model$detectionSize2 === void 0 ? 5 : _model$detectionSize2;
    var numerator = y2 - centerY;
    var denominator = x2 - centerX;
    var withinClockHand = false;

    if (numerator === 0) {
      var minX = Math.min(centerX, x2);
      var maxX = Math.max(centerX, x2);
      withinClockHand = x - compX >= minX && x - compX <= maxX && y >= centerY + compY - detectionSize && y <= centerY + compY + detectionSize;
    } else if (denominator === 0) {
      var minY = Math.min(centerY, y2);
      var maxY = Math.max(centerY, y2);
      withinClockHand = y - compY >= minY && y - compY <= maxY && x >= centerX + compX - detectionSize && x <= centerX + compX + detectionSize;
    } else {
      var slope = numerator / denominator;
      var yIntercept = centerY - slope * centerX;
      withinClockHand = withinRotationRect({
        slope: slope,
        yIntercept: yIntercept,
        mouseX: x,
        mouseY: y,
        modelXPositions: [centerX, x2],
        compX: compX,
        compY: compY,
        detectionSize: detectionSize
      });
    }

    return withinClockHand;
  }
};
;// CONCATENATED MODULE: ./src/helpers/googleAnalytics.ts





var MS_7_DAYS = 7 * 24 * 60 * 60 * 1000;

function isExpired(date) {
  var now = new Date().getTime();
  return now - date > MS_7_DAYS;
}

function imagePing(url, trackingInfo) {
  var queryString = Object.keys(trackingInfo).map(function (id, index) {
    return "".concat(index ? '&' : '').concat(id, "=").concat(trackingInfo[id]);
  }).join('');
  var trackingElement = document.createElement('img');
  trackingElement.src = "".concat(url, "?").concat(queryString);
  trackingElement.style.display = 'none';
  document.body.appendChild(trackingElement);
  document.body.removeChild(trackingElement);
  return trackingElement;
}

function sendHostname() {
  var hostname = location.hostname;
  var applicationKeyForStorage = "TOAST UI chart for ".concat(hostname, ": Statistics");
  var date = window.localStorage.getItem(applicationKeyForStorage);

  if (date && !isExpired(Number(date))) {
    return;
  }

  window.localStorage.setItem(applicationKeyForStorage, String(new Date().getTime()));
  setTimeout(function () {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      imagePing('https://www.google-analytics.com/collect', {
        v: 1,
        t: 'event',
        tid: 'UA-129983528-2',
        cid: hostname,
        dp: hostname,
        dh: 'chart',
        el: 'chart',
        ec: 'use'
      });
    }
  }, 1000);
}
;// CONCATENATED MODULE: ./src/charts/chart.ts
function chart_toConsumableArray(arr) { return chart_arrayWithoutHoles(arr) || chart_iterableToArray(arr) || chart_unsupportedIterableToArray(arr) || chart_nonIterableSpread(); }

function chart_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function chart_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return chart_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return chart_arrayLikeToArray(o, minLen); }

function chart_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function chart_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return chart_arrayLikeToArray(arr); }

function chart_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function chart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function chart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { chart_ownKeys(Object(source), true).forEach(function (key) { chart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { chart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



















function chart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function chart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function chart_createClass(Constructor, protoProps, staticProps) { if (protoProps) chart_defineProperties(Constructor.prototype, protoProps); if (staticProps) chart_defineProperties(Constructor, staticProps); return Constructor; }

function chart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



















var DEFAULT_ANIM_DURATION = 500;

function getUsingContainerSize(eventName, usingContainerSize, width, height) {
  var usingContainerWidth = usingContainerSize.width,
      usingContainerHeight = usingContainerSize.height;
  var isAutoWidth = isAutoValue(width);
  var isAutoHeight = isAutoValue(height);
  return eventName === 'updateOptions' ? {
    width: !isUndefined(width) && usingContainerWidth !== isAutoWidth ? isAutoWidth : usingContainerWidth,
    height: !isUndefined(height) && usingContainerHeight !== isAutoHeight ? isAutoHeight : usingContainerHeight
  } : {
    width: isAutoWidth,
    height: isAutoHeight
  };
}
/**
 * @class
 * @abstract
 * Abstract class used to implement each chart.
 */


var Chart = /*#__PURE__*/function () {
  function Chart(props) {
    var _this = this,
        _options$chart4,
        _options$chart5;

    chart_classCallCheck(this, Chart);

    chart_defineProperty(this, "store", void 0);

    chart_defineProperty(this, "___animId___", null);

    chart_defineProperty(this, "animator", void 0);

    chart_defineProperty(this, "containerEl", void 0);

    chart_defineProperty(this, "el", void 0);

    chart_defineProperty(this, "ctx", void 0);

    chart_defineProperty(this, "painter", new Painter(this));

    chart_defineProperty(this, "eventBus", new EventEmitter());

    chart_defineProperty(this, "componentManager", void 0);

    chart_defineProperty(this, "modules", void 0);

    chart_defineProperty(this, "enteredComponents", []);

    chart_defineProperty(this, "animationControlFlag", {
      resizing: false,
      updating: false
    });

    chart_defineProperty(this, "resizeObserver", null);

    chart_defineProperty(this, "debounceResizeEvent", debounce(function () {
      var _this$containerEl = _this.containerEl,
          offsetWidth = _this$containerEl.offsetWidth,
          offsetHeight = _this$containerEl.offsetHeight;

      _this.resizeChartSize(offsetWidth, offsetHeight);
    }, 100));

    chart_defineProperty(this, "getCheckedLegend", function () {
      var data = _this.store.state.legend.data;
      return data.filter(function (datum) {
        return datum.checked;
      }).map(function (datum) {
        return pick(datum, 'chartType', 'label', 'checked');
      });
    });

    chart_defineProperty(this, "getOptions", function () {
      return makeObservableObjectToNormal(_this.store.initStoreState.options);
    });

    chart_defineProperty(this, "on", function (eventName, handler) {
      /**
       * Register Events that occur when click legend label
       * @event ChartBase#clickLegendLabel
       * @param {object} info selected legend information
       * @api
       * @example
       * chart.on('clickLegendLabel', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when click legend checkbox
       * @event ChartBase#clickLegendCheckbox
       * @param {object} info selected legend info
       * @api
       * @example
       * chart.on('clickLegendCheckbox', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when select series
       * @event ChartBase#selectSeries
       * @param {object} info selected series info
       * @api
       * @example
       * chart.on('selectSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when unselect series
       * @event ChartBase#unselectSeries
       * @param {object} info unselected series info
       * @api
       * @example
       * chart.on('unselectSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when hover to series
       * @event ChartBase#hoverSeries
       * @param {object} info hovered series info
       * @api
       * @example
       * chart.on('hoverSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when unhover from series
       * @event ChartBase#unhoverSeries
       * @param {object} info unhovered series info
       * @api
       * @example
       * chart.on('unhoverSeries', (info) => {
       *  console.log(info);
       * });
       */

      /**
       * Register Events that occur when zooming
       * @event ChartBase#zoom
       * @param {string[]} dataRange - []
       * @api
       * @example
       * chart.on('zoom', (dataRange) => {
       *    console.log(dataRange);
       * });
       */

      /**
       * Register Events that occur when zoom is reset
       * @event ChartBase#resetZoom
       * @api
       * @example
       * chart.on('resetZoom', () => {});
       */
      _this.eventBus.on(eventName, handler);
    });

    chart_defineProperty(this, "destroy", function () {
      _this.componentManager.clear();

      _this.clearResizeEvent();

      _this.containerEl.innerHTML = '';
    });

    chart_defineProperty(this, "selectSeries", function (seriesInfo) {
      if (!_this.isSelectableSeries()) {
        throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);
      }

      _this.eventBus.emit('selectSeries', chart_objectSpread(chart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    chart_defineProperty(this, "unselectSeries", function () {
      if (!_this.isSelectableSeries()) {
        throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);
      }

      _this.store.dispatch('setAllLegendActiveState', true);

      _this.eventBus.emit('resetSelectedSeries');
    });

    chart_defineProperty(this, "resize", function (size) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', {
        chart: chart_objectSpread({}, size)
      });
    });

    chart_defineProperty(this, "resetSeries", function () {
      _this.eventBus.emit('resetHoveredSeries');

      _this.eventBus.emit('resetSelectedSeries');
    });

    chart_defineProperty(this, "setResizeEventListeners", function (eventName, options) {
      var _options$chart, _options$chart2;

      var usingContainerSize = _this.store.state.usingContainerSize;
      var usingContainerWidth = usingContainerSize.width,
          usingContainerHeight = usingContainerSize.height;
      var width = options === null || options === void 0 ? void 0 : (_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width;
      var height = options === null || options === void 0 ? void 0 : (_options$chart2 = options.chart) === null || _options$chart2 === void 0 ? void 0 : _options$chart2.height;
      var isAutoWidth = isAutoValue(width);
      var isAutoHeight = isAutoValue(height);

      _this.store.dispatch('setUsingContainerSize', getUsingContainerSize(eventName, usingContainerSize, width, height));

      if ((usingContainerWidth || usingContainerHeight) && isNumber(width) && isNumber(height)) {
        _this.clearResizeEvent();
      } else if (!(usingContainerWidth || usingContainerHeight) && (isAutoWidth || isAutoHeight)) {
        _this.setResizeEvent();
      }
    });

    var el = props.el,
        _options = props.options,
        series = props.series,
        categories = props.categories,
        modules = props.modules;
    this.modules = modules !== null && modules !== void 0 ? modules : [];

    if (isUndefined(_options.usageStatistics) || _options.usageStatistics) {
      sendHostname();
    }

    this.containerEl = el;
    this.el = this.createChartWrapper();
    this.containerEl.appendChild(this.el);
    this.animator = new Animator();
    this.store = new Store({
      series: series,
      categories: categories,
      options: _options
    });
    this.componentManager = new ComponentManager({
      store: this.store,
      eventBus: this.eventBus
    });
    this.eventBus.on('needLoop', debounce(function () {
      var _options$chart3;

      var duration = _this.getAnimationDuration((_options$chart3 = _options.chart) === null || _options$chart3 === void 0 ? void 0 : _options$chart3.animation);

      if (_this.animationControlFlag.resizing) {
        var _options$responsive;

        duration = isUndefined(_options.responsive) ? _this.getAnimationDuration() : _this.getAnimationDuration((_options$responsive = _options.responsive) === null || _options$responsive === void 0 ? void 0 : _options$responsive.animation);
        _this.animationControlFlag.resizing = false;
      }

      _this.eventBus.emit('loopStart');

      _this.animator.add({
        onCompleted: function onCompleted() {
          _this.eventBus.emit('loopComplete');
        },
        chart: _this,
        duration: duration,
        requester: _this
      });
    }, 10));
    this.eventBus.on('needSubLoop', function (opts) {
      _this.animator.add(chart_objectSpread(chart_objectSpread({}, opts), {}, {
        chart: _this
      }));
    });
    this.eventBus.on('needDraw', debounce(function () {
      _this.draw();
    }, 10));
    this.initialize();
    this.store.observe(function () {
      _this.painter.setup();
    });

    if (isAutoValue(_options === null || _options === void 0 ? void 0 : (_options$chart4 = _options.chart) === null || _options$chart4 === void 0 ? void 0 : _options$chart4.width) || isAutoValue(_options === null || _options === void 0 ? void 0 : (_options$chart5 = _options.chart) === null || _options$chart5 === void 0 ? void 0 : _options$chart5.height)) {
      this.setResizeEvent();
    }
  }

  chart_createClass(Chart, [{
    key: "getAnimationDuration",
    value: function getAnimationDuration(animationOption) {
      var firstRendering = this.animator.firstRendering;
      var _this$animationContro = this.animationControlFlag,
          resizing = _this$animationContro.resizing,
          updating = _this$animationContro.updating;
      var duration;

      if (!firstRendering && !resizing || isUndefined(animationOption)) {
        duration = DEFAULT_ANIM_DURATION;
      } else if (isBoolean(animationOption)) {
        duration = animationOption ? DEFAULT_ANIM_DURATION : 0;
      } else if (isNumber(animationOption.duration)) {
        duration = animationOption.duration;
      }

      if (updating) {
        duration = 0;
      }

      this.animationControlFlag.updating = false;
      return duration;
    }
  }, {
    key: "createChartWrapper",
    value: function createChartWrapper() {
      var el = document.createElement('div');
      el.classList.add('toastui-chart-wrapper');
      return el;
    }
  }, {
    key: "resizeChartSize",
    value: function resizeChartSize(containerWidth, containerHeight) {
      this.animationControlFlag.resizing = true;
      var _this$store$state = this.store.state,
          _this$store$state$usi = _this$store$state.usingContainerSize,
          usingContainerWidth = _this$store$state$usi.width,
          usingContainerHeight = _this$store$state$usi.height,
          _this$store$state$cha = _this$store$state.chart,
          width = _this$store$state$cha.width,
          height = _this$store$state$cha.height;

      if (!(usingContainerWidth || usingContainerHeight) || !(containerWidth || containerHeight) || containerWidth === width && containerHeight === height) {
        this.animationControlFlag.resizing = false;
        return;
      } // @TODO: For updates where the data doesn't change, it looks good to recalculate the selected series position.


      this.resetSeries();
      this.store.dispatch('setChartSize', {
        width: usingContainerWidth ? containerWidth : width,
        height: usingContainerHeight ? containerHeight : height
      });
      this.draw();
    }
  }, {
    key: "setResizeEvent",
    value: function setResizeEvent() {
      var _this2 = this;

      var usingContainerSize = this.store.state.usingContainerSize;

      if (usingContainerSize.height && !this.containerEl.style.height.length || usingContainerSize.width && !this.containerEl.style.width.length) {
        throw new Error(message.AUTO_LAYOUT_CONTAINER_SIZE_ERROR);
      }

      var isResizeObserverAPIExist = typeof ResizeObserver === 'undefined';

      if (isResizeObserverAPIExist) {
        window.addEventListener('resize', this.debounceResizeEvent);
      } else {
        this.resizeObserver = new ResizeObserver(function (entries) {
          entries.forEach(function () {
            _this2.debounceResizeEvent();
          });
        });
        this.resizeObserver.observe(this.containerEl);
      }
    }
  }, {
    key: "clearResizeEvent",
    value: function clearResizeEvent() {
      if (this.resizeObserver) {
        this.resizeObserver.unobserve(this.containerEl);
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      } else {
        window.removeEventListener('resize', this.debounceResizeEvent);
      }
    }
  }, {
    key: "handleCanvasMouseEvent",
    value: function handleCanvasMouseEvent(eventType, mousePosition) {
      var _this3 = this;

      var newEnteredComponents = [];
      this.componentManager.forEach(function (component) {
        if (eventType === 'mousemove') {
          var exist = _this3.enteredComponents.some(function (enteredComponent) {
            return enteredComponent === component;
          });

          if (isMouseInRect(component.rect, mousePosition)) {
            newEnteredComponents.push(component);

            if (!exist && component.onMouseenterComponent) {
              component.onMouseenterComponent();
            }
          } else if (exist && component.onMouseoutComponent) {
            component.onMouseoutComponent();
          }
        } else if (eventType === 'mouseout' && component.onMouseoutComponent) {
          component.onMouseoutComponent();
        }
      });
      this.enteredComponents = newEnteredComponents;
    }
  }, {
    key: "handleResponderEvent",
    value: function handleResponderEvent(event, mousePosition) {
      var eventType = event.type;
      var delegationMethod = "on".concat(eventType[0].toUpperCase() + eventType.substring(1));
      var allResponders = [];
      this.componentManager.forEach(function (component) {
        if (!component[delegationMethod]) {
          return;
        }

        if (!responderDetectors.rect(mousePosition, component.rect)) {
          return;
        }

        var detected = (component.responders || []).filter(function (m) {
          return responderDetectors[m.type](mousePosition, m, component.rect);
        });

        if (detected.length) {
          allResponders.push({
            component: component,
            detected: detected
          });
        }

        component[delegationMethod]({
          mousePosition: mousePosition,
          responders: detected
        }, event);
      });

      if (this.handleEventForAllResponders) {
        this.handleEventForAllResponders(event, allResponders, delegationMethod, mousePosition);
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      var clientX = event.clientX,
          clientY = event.clientY,
          eventType = event.type;
      var canvas = this.painter.ctx.canvas;

      var _canvas$getBoundingCl = canvas.getBoundingClientRect(),
          width = _canvas$getBoundingCl.width,
          height = _canvas$getBoundingCl.height,
          left = _canvas$getBoundingCl.left,
          top = _canvas$getBoundingCl.top; // Calculate scale for chart affected by a CSS transform.


      var scaleX = width / canvas.offsetWidth;
      var scaleY = height / canvas.offsetHeight;
      var mousePosition = {
        x: (clientX - left) / scaleX,
        y: (clientY - top) / scaleY
      };

      if (eventType === 'mousemove' || eventType === 'mouseout') {
        this.handleCanvasMouseEvent(eventType, mousePosition);
      }

      this.handleResponderEvent(event, mousePosition);
    }
  }, {
    key: "initStore",
    value: function initStore() {
      var _this4 = this;

      [store_root, options, store_theme, store_seriesData, store_legend, store_layout, store_category].concat(chart_toConsumableArray(this.modules)).forEach(function (module) {
        return _this4.store.setModule(module);
      });
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.initStore();
      this.store.dispatch('initChartSize', this.containerEl);
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this5 = this;

      this.painter.beforeFrame();
      this.componentManager.forEach(function (component) {
        if (!component.isShow) {
          return;
        }

        _this5.painter.beforeDraw(component.rect.x, component.rect.y);

        if (component.beforeDraw) {
          component.beforeDraw(_this5.painter);
        }

        component.draw(_this5.painter);

        _this5.painter.afterDraw();
      });
    }
  }, {
    key: "update",
    value: function update(delta) {
      this.componentManager.invoke('update', delta);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.componentManager.invoke('initUpdate', delta);
    }
  }, {
    key: "isSelectableSeries",
    value: function isSelectableSeries() {
      var _this$store$initStore;

      return (_this$store$initStore = this.store.initStoreState.options.series) === null || _this$store$initStore === void 0 ? void 0 : _this$store$initStore.selectable;
    }
    /**
     * Select series. It works only when the selectable option is true.
     * @param {Object} seriesInfo - Information of the series to be selected
     *      @param {number} [seriesInfo.seriesIndex] - Index of series
     *      @param {number} [seriesInfo.index] - Index of data within series
     *      @param {string} [seriesInfo.name] - Specify name for NestedPie Chart
     *      @param {string} [seriesInfo.chartType] - Specify which chart to select when using LineArea, LineScatter, and ColumnLine charts.specifies which chart to select when using LineArea, LineScatter, and ColumnLine charts.
     * @api
     * @example
     * chart.selectSeries({index: 1, seriesIndex: 2});
     */

  }, {
    key: "setTooltipOffset",
    value:
    /**
     * Set tooltip offset.
     * @param {Object} offset - Offset size
     *   @param {number} [offset.x] Offset value to move title horizontally
     *   @param {number} [offset.y] Offset value to move title vertically
     * @api
     * @example
     * chart.setTooltipOffset({x: 10, y: -20});
     */
    function setTooltipOffset(offset) {
      var offsetX = offset.x,
          offsetY = offset.y;
      this.store.dispatch('updateOptions', {
        options: {
          tooltip: {
            offsetX: offsetX,
            offsetY: offsetY
          }
        }
      });
    }
  }, {
    key: "dispatchOptionsEvent",
    value: function dispatchOptionsEvent(eventName, options) {
      this.setResizeEventListeners(eventName, options);
      var _this$containerEl2 = this.containerEl,
          offsetWidth = _this$containerEl2.offsetWidth,
          offsetHeight = _this$containerEl2.offsetHeight;
      this.store.dispatch(eventName, {
        options: options,
        containerSize: {
          width: offsetWidth,
          height: offsetHeight
        }
      });
    }
  }]);

  return Chart;
}();


// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.number.max-safe-integer.js
var es_number_max_safe_integer = __webpack_require__(8143);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.number.min-safe-integer.js
var es_number_min_safe_integer = __webpack_require__(2023);
;// CONCATENATED MODULE: ./src/store/dataRange.ts

























function dataRange_slicedToArray(arr, i) { return dataRange_arrayWithHoles(arr) || dataRange_iterableToArrayLimit(arr, i) || dataRange_unsupportedIterableToArray(arr, i) || dataRange_nonIterableRest(); }

function dataRange_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataRange_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function dataRange_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function dataRange_toConsumableArray(arr) { return dataRange_arrayWithoutHoles(arr) || dataRange_iterableToArray(arr) || dataRange_unsupportedIterableToArray(arr) || dataRange_nonIterableSpread(); }

function dataRange_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataRange_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataRange_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataRange_arrayLikeToArray(o, minLen); }

function dataRange_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function dataRange_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return dataRange_arrayLikeToArray(arr); }

function dataRange_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







function getLimitSafely(baseValues) {
  var isXAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var limit = {
    min: Math.min.apply(Math, dataRange_toConsumableArray(baseValues)),
    max: Math.max.apply(Math, dataRange_toConsumableArray(baseValues))
  };

  if (baseValues.length === 1) {
    var _baseValues = dataRange_slicedToArray(baseValues, 1),
        firstValue = _baseValues[0];

    if (isXAxis) {
      limit.min = firstValue;
      limit.max = firstValue;
    } else if (firstValue > 0) {
      limit.min = 0;
    } else if (firstValue === 0) {
      limit.max = 10;
    } else {
      limit.max = 0;
    }
  } else if (limit.min === 0 && limit.max === 0) {
    limit.max = 10;
  } else if (limit.min === limit.max) {
    limit.min -= limit.min / 10;
    limit.max += limit.max / 10;
  }

  return limit;
}

function initDataRange(accDataRangeValue, curDataRangeValue, axisName) {
  var _accDataRangeValue$ax, _accDataRangeValue$ax2, _accDataRangeValue$ax3, _accDataRangeValue$ax4;

  var defaultDataRange = {
    min: Number.MAX_SAFE_INTEGER,
    max: Number.MIN_SAFE_INTEGER
  };
  return {
    min: Math.min(curDataRangeValue[axisName].min, (_accDataRangeValue$ax = (_accDataRangeValue$ax2 = accDataRangeValue[axisName]) === null || _accDataRangeValue$ax2 === void 0 ? void 0 : _accDataRangeValue$ax2.min) !== null && _accDataRangeValue$ax !== void 0 ? _accDataRangeValue$ax : defaultDataRange.min),
    max: Math.max(curDataRangeValue[axisName].max, (_accDataRangeValue$ax3 = (_accDataRangeValue$ax4 = accDataRangeValue[axisName]) === null || _accDataRangeValue$ax4 === void 0 ? void 0 : _accDataRangeValue$ax4.max) !== null && _accDataRangeValue$ax3 !== void 0 ? _accDataRangeValue$ax3 : defaultDataRange.max)
  };
}

function getTotalDataRange(seriesDataRange) {
  return Object.values(seriesDataRange).reduce(function (acc, cur) {
    if (cur.xAxis) {
      acc.xAxis = initDataRange(acc, cur, 'xAxis');
    }

    if (cur.yAxis) {
      acc.yAxis = initDataRange(acc, cur, 'yAxis');
    }

    if (cur.secondaryYAxis) {
      acc.secondaryYAxis = initDataRange(acc, cur, 'secondaryYAxis');
    }

    if (cur.circularAxis) {
      acc.circularAxis = initDataRange(acc, cur, 'circularAxis');
    }

    if (cur.verticalAxis) {
      acc.verticalAxis = initDataRange(acc, cur, 'verticalAxis');
    }

    return acc;
  }, {});
}

function setSeriesDataRange(_ref) {
  var options = _ref.options,
      seriesName = _ref.seriesName,
      values = _ref.values,
      valueAxisName = _ref.valueAxisName,
      seriesDataRange = _ref.seriesDataRange;
  var axisNames;

  if (includes([AxisType.X, AxisType.CIRCULAR, AxisType.VERTICAL], valueAxisName)) {
    axisNames = [valueAxisName];
  } else {
    var optionsUsingYAxis = options;

    var _getYAxisOption = getYAxisOption(optionsUsingYAxis),
        secondaryYAxis = _getYAxisOption.secondaryYAxis;

    axisNames = hasSecondaryYAxis(optionsUsingYAxis) && secondaryYAxis !== null && secondaryYAxis !== void 0 && secondaryYAxis.chartType ? [secondaryYAxis.chartType === seriesName ? 'secondaryYAxis' : 'yAxis'] : getValueAxisNames(optionsUsingYAxis, valueAxisName);
  }

  axisNames.forEach(function (axisName) {
    seriesDataRange[seriesName][axisName] = getLimitSafely(dataRange_toConsumableArray(new Set(values)));
  });
  return seriesDataRange;
}

function getBoxPlotValues(series, seriesName) {
  return series[seriesName].data.flatMap(function (_ref2) {
    var data = _ref2.data,
        _ref2$outliers = _ref2.outliers,
        outliers = _ref2$outliers === void 0 ? [] : _ref2$outliers;
    return [].concat(dataRange_toConsumableArray((data !== null && data !== void 0 ? data : []).flatMap(function (datum) {
      return datum;
    })), dataRange_toConsumableArray((outliers !== null && outliers !== void 0 ? outliers : []).flatMap(function (datum) {
      return datum;
    })));
  });
}

function getBulletValues(series, seriesName) {
  return series[seriesName].data.flatMap(function (_ref3) {
    var data = _ref3.data,
        markers = _ref3.markers,
        ranges = _ref3.ranges;
    return [data].concat(dataRange_toConsumableArray((markers !== null && markers !== void 0 ? markers : []).flatMap(function (datum) {
      return datum;
    })), dataRange_toConsumableArray((ranges !== null && ranges !== void 0 ? ranges : []).flatMap(function (range) {
      return range;
    })));
  });
}

function getCoordinateDataValues(values, categories, hasDateValue) {
  var yAxisValues = values.filter(function (value) {
    return !isNull(value);
  }).map(function (value) {
    return getCoordinateYValue(value);
  });
  var xAxisValues = categories.map(function (value) {
    return hasDateValue ? Number(new Date(value)) : Number(value);
  });
  return {
    xAxisValues: xAxisValues,
    yAxisValues: yAxisValues
  };
}

var dataRange = {
  name: 'dataRange',
  state: function state() {
    return {
      dataRange: {}
    };
  },
  action: {
    setDataRange: function setDataRange(_ref4) {
      var state = _ref4.state,
          initStoreState = _ref4.initStoreState;
      var series = state.series,
          disabledSeries = state.disabledSeries,
          stackSeries = state.stackSeries,
          categories = state.categories,
          options = state.options;
      var seriesDataRange = {};
      var labelAxisOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options,
        categories: categories
      });

      var _getAxisName = getAxisName(labelAxisOnYAxis, series),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      Object.keys(series).forEach(function (seriesName) {
        var _stackSeries$seriesNa;

        seriesDataRange[seriesName] = {};
        var values = series[seriesName].data.flatMap(function (_ref5) {
          var data = _ref5.data,
              name = _ref5.name;
          return disabledSeries.includes(name) ? [] : data;
        });
        var firstExistValue = getFirstValidValue(values);

        if (isCoordinateSeries(initStoreState.series)) {
          var _options$xAxis;

          var hasDateValue = !!((_options$xAxis = options.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.date);

          var _getCoordinateDataVal = getCoordinateDataValues(values, categories, hasDateValue),
              yAxisValues = _getCoordinateDataVal.yAxisValues,
              xAxisValues = _getCoordinateDataVal.xAxisValues;

          values = yAxisValues;
          seriesDataRange[seriesName][labelAxisName] = getLimitSafely(dataRange_toConsumableArray(xAxisValues), true);
        } else if (!series[seriesName].data.length) {
          values = [];
        } else if (isRangeValue(firstExistValue)) {
          values = values.reduce(function (arr, value) {
            if (isNull(value)) {
              return arr;
            }

            return Array.isArray(value) ? [].concat(dataRange_toConsumableArray(arr), dataRange_toConsumableArray(value)) : dataRange_toConsumableArray(value);
          }, []);
        } else if (stackSeries && (_stackSeries$seriesNa = stackSeries[seriesName]) !== null && _stackSeries$seriesNa !== void 0 && _stackSeries$seriesNa.stack) {
          values = stackSeries[seriesName].dataRangeValues;
        } else if (seriesName === 'boxPlot') {
          values = getBoxPlotValues(series, seriesName);
        } else if (seriesName === 'bullet') {
          values = getBulletValues(series, seriesName);
        }

        if (includes(['bar', 'column', 'radar', 'bullet'], seriesName)) {
          values.push(0);
        }

        setSeriesDataRange({
          options: options,
          seriesName: seriesName,
          values: values,
          valueAxisName: valueAxisName,
          seriesDataRange: seriesDataRange
        });
      });
      var newDataRange = getTotalDataRange(seriesDataRange);
      store_extend(state.dataRange, newDataRange);
    }
  },
  observe: {
    updateDataRange: function updateDataRange() {
      this.dispatch('setDataRange');
    }
  }
};
/* harmony default export */ var store_dataRange = (dataRange);
;// CONCATENATED MODULE: ./src/scale/coordinateScaleCalculator.ts
function coordinateScaleCalculator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function coordinateScaleCalculator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { coordinateScaleCalculator_ownKeys(Object(source), true).forEach(function (key) { coordinateScaleCalculator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { coordinateScaleCalculator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function coordinateScaleCalculator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function coordinateScaleCalculator_toConsumableArray(arr) { return coordinateScaleCalculator_arrayWithoutHoles(arr) || coordinateScaleCalculator_iterableToArray(arr) || coordinateScaleCalculator_unsupportedIterableToArray(arr) || coordinateScaleCalculator_nonIterableSpread(); }

function coordinateScaleCalculator_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function coordinateScaleCalculator_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return coordinateScaleCalculator_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return coordinateScaleCalculator_arrayLikeToArray(o, minLen); }

function coordinateScaleCalculator_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function coordinateScaleCalculator_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return coordinateScaleCalculator_arrayLikeToArray(arr); }

function coordinateScaleCalculator_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















var SNAP_VALUES = [1, 2, 5, 10];
var DEFAULT_PIXELS_PER_STEP = 88;

function adjustLimitForOverflow(_ref, stepSize, overflowed) {
  var min = _ref.min,
      max = _ref.max;
  return {
    min: overflowed.min ? min - stepSize : min,
    max: overflowed.max ? max + stepSize : max
  };
}

function isSeriesOverflowed(scaleData, _ref2, scaleOption) {
  var min = _ref2.min,
      max = _ref2.max;
  var scaleDataLimit = scaleData.limit;
  var hasMinOption = isNumber(scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.min);
  var hasMaxOption = isNumber(scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.max);
  var isOverflowedMin = !hasMinOption && scaleDataLimit.min === min && scaleDataLimit.min !== 0;
  var isOverflowedMax = !hasMaxOption && scaleDataLimit.max === max && scaleDataLimit.max !== 0;

  if (!isOverflowedMin && !isOverflowedMax) {
    return null;
  }

  return {
    min: isOverflowedMin,
    max: isOverflowedMax
  };
}

function getDigits(num) {
  var logNumberDividedLN10 = num === 0 ? 1 : Math.log(Math.abs(num)) / Math.LN10;
  return Math.pow(10, Math.floor(logNumberDividedLN10));
}

function getSnappedNumber(num) {
  var snapNumber = 0;

  for (var i = 0, t = SNAP_VALUES.length; i < t; i += 1) {
    snapNumber = SNAP_VALUES[i];
    var guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;

    if (num <= guideValue) {
      break;
    }
  }

  return snapNumber;
}

function getNormalizedStep(stepSize) {
  var placeNumber = getDigits(stepSize);
  var simplifiedStepValue = stepSize / placeNumber;
  return getSnappedNumber(simplifiedStepValue) * placeNumber;
}
/**
 * Get normalized limit values
 * max = 155 and step = 10 ---> max = 160
 */


function getNormalizedLimit(limit, stepSize) {
  var min = limit.min,
      max = limit.max;
  var minNumber = Math.min(getDigits(max), getDigits(stepSize));
  var placeNumber = minNumber > 1 ? 1 : 1 / minNumber;
  var fixedStep = stepSize * placeNumber; // ceil max value step digits

  max = Math.ceil(max * placeNumber / fixedStep) * fixedStep / placeNumber;

  if (min > stepSize) {
    // floor min value to multiples of step
    min = Math.floor(min * placeNumber / fixedStep) * fixedStep / placeNumber;
  } else if (min < 0) {
    min = -(Math.ceil(Math.abs(min) * placeNumber / fixedStep) * fixedStep) / placeNumber;
  } else {
    min = 0;
  }

  return {
    min: min,
    max: max
  };
}

function getNormalizedStepCount(limitSize, stepSize) {
  var multiplier = 1 / Math.min(getDigits(limitSize), getDigits(stepSize));
  return Math.ceil(limitSize * multiplier / (stepSize * multiplier));
}

function hasStepSize(stepSize) {
  return isNumber(stepSize);
}

function getNormalizedScale(scaleData, scale) {
  var stepSize = hasStepSize(scale.stepSize) ? scaleData.stepSize : getNormalizedStep(scaleData.stepSize);
  var edge = getNormalizedLimit(scaleData.limit, stepSize);
  var limitSize = Math.abs(edge.max - edge.min);
  var stepCount = getNormalizedStepCount(limitSize, stepSize);
  return {
    limit: {
      min: edge.min,
      max: edge.max
    },
    stepSize: stepSize,
    stepCount: stepCount
  };
}

function getRoughScale(scale, offsetSize) {
  var minStepSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var min = scale.min,
      max = scale.max;
  var limitSize = Math.abs(max - min);
  var valuePerPixel = limitSize / offsetSize;
  var stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);
  var pixelsPerStep = offsetSize / stepCount;
  var stepSize = valuePerPixel * pixelsPerStep;

  if (hasStepSize(scale.stepSize)) {
    stepSize = scale.stepSize;
    stepCount = limitSize / stepSize;
  } else if (isNumber(minStepSize) && stepSize < minStepSize) {
    stepSize = minStepSize;
    stepCount = limitSize / stepSize;
  }

  return {
    limit: {
      min: min,
      max: max
    },
    stepSize: stepSize,
    stepCount: stepCount
  };
}

function makeScaleOption(dataRange, scaleOptions) {
  var _scaleOptions$max, _scaleOptions$min, _scaleOptions$stepSiz;

  return {
    max: (_scaleOptions$max = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.max) !== null && _scaleOptions$max !== void 0 ? _scaleOptions$max : dataRange.max,
    min: (_scaleOptions$min = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.min) !== null && _scaleOptions$min !== void 0 ? _scaleOptions$min : dataRange.min,
    stepSize: (_scaleOptions$stepSiz = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.stepSize) !== null && _scaleOptions$stepSiz !== void 0 ? _scaleOptions$stepSiz : 'auto'
  };
}
function calculateCoordinateScale(options) {
  var dataRange = options.dataRange,
      scaleOption = options.scaleOption,
      offsetSize = options.offsetSize,
      minStepSize = options.minStepSize,
      useSpectrumLegend = options.useSpectrumLegend;
  var scale = makeScaleOption(dataRange, scaleOption);
  var roughScale = getRoughScale(scale, offsetSize, minStepSize);
  var normalizedScale = getNormalizedScale(roughScale, scale);
  var overflowed = useSpectrumLegend ? null : isSeriesOverflowed(normalizedScale, scale, scaleOption);

  if (overflowed) {
    var stepSize = normalizedScale.stepSize,
        limit = normalizedScale.limit;
    normalizedScale.limit = adjustLimitForOverflow(limit, stepSize, overflowed);
  }

  return normalizedScale;
}
function getStackScaleData(type) {
  if (type === 'minusPercentStack') {
    return {
      limit: {
        min: -100,
        max: 0
      },
      stepSize: 25,
      stepCount: 5
    };
  }

  if (type === 'dualPercentStack') {
    return {
      limit: {
        min: -100,
        max: 100
      },
      stepSize: 25,
      stepCount: 9
    };
  }

  if (type === 'divergingPercentStack') {
    return {
      limit: {
        min: -100,
        max: 100
      },
      stepSize: 25,
      stepCount: 9
    };
  }

  return {
    limit: {
      min: 0,
      max: 100
    },
    stepSize: 25,
    stepCount: 5
  };
}
function calculateXAxisScaleForCoordinateLineType(scale, options, categories) {
  var dateType = isDateType(options, AxisType.X);
  var values = categories.map(function (value) {
    return dateType ? Number(new Date(value)) : Number(value);
  });
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var min = Math.min.apply(Math, coordinateScaleCalculator_toConsumableArray(values));
  var max = Math.max.apply(Math, coordinateScaleCalculator_toConsumableArray(values));

  var newLimit = coordinateScaleCalculator_objectSpread({}, limit);

  var distance = max - min;
  var positionRatio = 0;
  var sizeRatio = 1;

  if (distance) {
    if (limit.min < min) {
      newLimit.min += stepSize;
      positionRatio = (newLimit.min - min) / distance;
      sizeRatio -= positionRatio;
    }

    if (limit.max > max) {
      newLimit.max -= stepSize;
      sizeRatio -= (max - newLimit.max) / distance;
    }
  }

  var limitSize = Math.abs(newLimit.max - newLimit.min);
  var newStepCount = getNormalizedStepCount(limitSize, stepSize);
  return {
    limit: newLimit,
    stepCount: newStepCount,
    stepSize: stepSize,
    positionRatio: positionRatio,
    sizeRatio: sizeRatio
  };
}
;// CONCATENATED MODULE: ./src/scale/datetimeScaleCalculator.ts








function datetimeScaleCalculator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function datetimeScaleCalculator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { datetimeScaleCalculator_ownKeys(Object(source), true).forEach(function (key) { datetimeScaleCalculator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { datetimeScaleCalculator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function datetimeScaleCalculator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var msMap = {
  year: 31536000000,
  month: 2678400000,
  week: 604800000,
  date: 86400000,
  hour: 3600000,
  minute: 60000,
  second: 1000
};
function calculateDatetimeScale(options) {
  var dataRange = options.dataRange,
      rawCategoriesSize = options.rawCategoriesSize,
      scaleOption = options.scaleOption;
  var datetimeInfo = makeDatetimeInfo(dataRange, rawCategoriesSize, scaleOption);
  var minDate = datetimeInfo.minDate,
      divisionNumber = datetimeInfo.divisionNumber,
      limit = datetimeInfo.limit;
  var scale = calculateCoordinateScale(datetimeScaleCalculator_objectSpread(datetimeScaleCalculator_objectSpread({}, omit(options, 'scaleOption')), {}, {
    dataRange: limit,
    minStepSize: 1
  }));
  return restoreScaleToDatetimeType(scale, minDate, divisionNumber);
}
var msTypes = ['year', 'month', 'week', 'date', 'hour', 'minute', 'second'];

function restoreScaleToDatetimeType(scale, minDate, divisionNumber) {
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var min = limit.min,
      max = limit.max;
  return datetimeScaleCalculator_objectSpread(datetimeScaleCalculator_objectSpread({}, scale), {}, {
    stepSize: multiply(stepSize, divisionNumber),
    limit: {
      min: multiply(add(min, minDate), divisionNumber),
      max: multiply(add(max, minDate), divisionNumber)
    }
  });
}

function makeDatetimeInfo(limit, count, scaleOption) {
  var _scaleOption$stepSize;

  var dateType = findDateType(limit, count);
  var divisionNumber = (_scaleOption$stepSize = scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.stepSize) !== null && _scaleOption$stepSize !== void 0 ? _scaleOption$stepSize : msMap[dateType];
  var scale = makeScaleOption(limit, scaleOption);
  var minDate = divide(Number(new Date(scale.min)), divisionNumber);
  var maxDate = divide(Number(new Date(scale.max)), divisionNumber);
  return {
    divisionNumber: divisionNumber,
    minDate: minDate,
    limit: {
      min: 0,
      max: maxDate - minDate
    }
  };
}

function findDateType(_ref, count) {
  var max = _ref.max,
      min = _ref.min;
  var diff = max - min;
  var lastTypeIndex = msTypes.length - 1;
  var foundType;

  if (diff) {
    msTypes.every(function (type, index) {
      var millisecond = msMap[type];
      var dividedCount = Math.floor(diff / millisecond);
      var foundIndex;

      if (dividedCount) {
        foundIndex = index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;
        foundType = msTypes[foundIndex];
      }

      return !isExist(foundIndex);
    });
  } else {
    foundType = 'second';
  }

  return foundType;
}
;// CONCATENATED MODULE: ./src/store/stackSeriesData.ts
function stackSeriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function stackSeriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { stackSeriesData_ownKeys(Object(source), true).forEach(function (key) { stackSeriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { stackSeriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function stackSeriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function stackSeriesData_toConsumableArray(arr) { return stackSeriesData_arrayWithoutHoles(arr) || stackSeriesData_iterableToArray(arr) || stackSeriesData_unsupportedIterableToArray(arr) || stackSeriesData_nonIterableSpread(); }

function stackSeriesData_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function stackSeriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return stackSeriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return stackSeriesData_arrayLikeToArray(o, minLen); }

function stackSeriesData_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function stackSeriesData_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return stackSeriesData_arrayLikeToArray(arr); }

function stackSeriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















function isPercentStack(stack) {
  return !!((stack === null || stack === void 0 ? void 0 : stack.type) === 'percent');
}
function isGroupStack(rawData) {
  return !Array.isArray(rawData);
}
function hasPercentStackSeries(stackSeries) {
  if (!stackSeries) {
    return false;
  }

  return Object.keys(stackSeries).some(function (seriesName) {
    return isPercentStack(stackSeries[seriesName].stack);
  });
}
function pickStackOption(options) {
  return pickProperty(options, ['series', 'stack']) || pickProperty(options, ['series', 'column', 'stack']) || pickProperty(options, ['series', 'area', 'stack']);
}

function makeStackData(seriesData) {
  var seriesCount = seriesData.length;
  var groupCountLengths = seriesData.map(function (_ref) {
    var rawData = _ref.rawData;
    return rawData.length;
  });
  var seriesGroupCount = Math.max.apply(Math, stackSeriesData_toConsumableArray(groupCountLengths));
  var stackData = [];

  for (var i = 0; i < seriesGroupCount; i += 1) {
    var stackValues = [];

    for (var j = 0; j < seriesCount; j += 1) {
      stackValues.push(seriesData[j].rawData[i]);
    }

    stackData[i] = {
      values: stackValues,
      sum: sum(stackValues),
      total: {
        positive: sum(stackValues.filter(function (value) {
          return value >= 0;
        })),
        negative: sum(stackValues.filter(function (value) {
          return value < 0;
        }))
      }
    };
  }

  return stackData;
}

function makeStackGroupData(seriesData) {
  var stackData = {};

  var stackGroupIds = stackSeriesData_toConsumableArray(new Set(seriesData.map(function (_ref2) {
    var stackGroup = _ref2.stackGroup;
    return stackGroup;
  })));

  stackGroupIds.forEach(function (groupId) {
    var filtered = seriesData.filter(function (_ref3) {
      var stackGroup = _ref3.stackGroup;
      return groupId === stackGroup;
    });
    stackData[groupId] = makeStackData(filtered);
  });
  return stackData;
}

function initializeStack(stackOption) {
  if (!stackOption) {
    return;
  }

  var defaultStackOption = {
    type: 'normal',
    connector: false
  };

  if (isStackObject(stackOption)) {
    return stackSeriesData_objectSpread(stackSeriesData_objectSpread({}, defaultStackOption), stackOption);
  }

  return defaultStackOption;
}

function isStackObject(stackOption) {
  return isObject(stackOption);
}

function hasStackGrouped(seriesRawData) {
  return seriesRawData.some(function (rawData) {
    return rawData.hasOwnProperty('stackGroup');
  });
}

function getStackDataRangeValues(stackData) {
  var values = [];

  if (Array.isArray(stackData)) {
    values = [0].concat(stackSeriesData_toConsumableArray(getSumValues(stackData)));
  } else {
    for (var groupId in stackData) {
      if (Object.prototype.hasOwnProperty.call(stackData, groupId)) {
        values = [0].concat(stackSeriesData_toConsumableArray(values), stackSeriesData_toConsumableArray(getSumValues(stackData[groupId])));
      }
    }
  }

  return values;
}

function getSumValues(stackData) {
  var positiveSum = stackData.map(function (_ref4) {
    var total = _ref4.total;
    return total.positive;
  });
  var negativeSum = stackData.map(function (_ref5) {
    var total = _ref5.total;
    return total.negative;
  });
  return [].concat(stackSeriesData_toConsumableArray(negativeSum), stackSeriesData_toConsumableArray(positiveSum));
}

function getStackDataValues(stackData) {
  if (!isGroupStack(stackData)) {
    return stackData;
  }

  var stackDataValues = [];

  if (isGroupStack(stackData)) {
    Object.keys(stackData).forEach(function (groupId) {
      stackDataValues = [].concat(stackSeriesData_toConsumableArray(stackDataValues), stackSeriesData_toConsumableArray(stackData[groupId]));
    });
  }

  return stackDataValues;
}

function checkIfNegativeAndPositiveValues(stackData) {
  return {
    hasNegative: stackData.map(function (_ref6) {
      var total = _ref6.total;
      return total.negative;
    }).some(function (total) {
      return total < 0;
    }),
    hasPositive: stackData.map(function (_ref7) {
      var total = _ref7.total;
      return total.positive;
    }).some(function (total) {
      return total >= 0;
    })
  };
}

function getScaleType(stackData, stackType, diverging) {
  var _checkIfNegativeAndPo = checkIfNegativeAndPositiveValues(stackData),
      hasPositive = _checkIfNegativeAndPo.hasPositive,
      hasNegative = _checkIfNegativeAndPo.hasNegative;

  if (stackType === 'percent') {
    if (diverging) {
      return 'divergingPercentStack';
    }

    if (hasNegative && hasPositive) {
      return 'dualPercentStack';
    }

    if (!hasNegative && hasPositive) {
      return 'percentStack';
    }

    if (hasNegative && !hasPositive) {
      return 'minusPercentStack';
    }
  }
}

function initStackSeries(series, options) {
  var stackSeries = {};
  Object.keys(series).forEach(function (seriesName) {
    var chartType = seriesName;
    var stackOption = pickStackOption(options);

    if (stackOption) {
      if (!stackSeries[chartType]) {
        stackSeries[chartType] = {};
      }

      stackSeries[chartType].stack = initializeStack(stackOption);
    } else if (seriesName === 'radialBar') {
      stackSeries[seriesName] = {
        stack: true
      };
    }
  });
  return stackSeries;
}

var stackSeriesData = {
  name: 'stackSeriesData',
  state: function state(_ref8) {
    var series = _ref8.series,
        options = _ref8.options;
    return {
      stackSeries: initStackSeries(series, options)
    };
  },
  action: {
    setStackSeriesData: function setStackSeriesData(_ref9) {
      var state = _ref9.state;
      var series = state.series,
          stackSeries = state.stackSeries,
          options = state.options;
      var stackOption = pickStackOption(options);
      var newStackSeries = {};
      Object.keys(series).forEach(function (seriesName) {
        var _options$series;

        var seriesData = series[seriesName];
        var data = seriesData.data,
            seriesCount = seriesData.seriesCount,
            seriesGroupCount = seriesData.seriesGroupCount;
        var isRadialBar = seriesName === 'radialBar';

        if (stackOption) {
          if (!stackSeries[seriesName]) {
            stackSeries[seriesName] = {};
          }

          stackSeries[seriesName].stack = initializeStack(stackOption);
        } else if (!isRadialBar) {
          stackSeries[seriesName] = null;
          delete stackSeries[seriesName];
        }

        var _ref10 = stackSeries[seriesName] || {},
            stack = _ref10.stack;

        var diverging = !!((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.diverging);

        if (stack) {
          var _stack$type;

          var stackData = hasStackGrouped(data) ? makeStackGroupData(data) : makeStackData(data);
          var stackType = (_stack$type = stack.type) !== null && _stack$type !== void 0 ? _stack$type : 'normal';
          var dataRangeValues = getStackDataRangeValues(stackData);
          newStackSeries[seriesName] = {
            data: data,
            seriesCount: seriesCount,
            seriesGroupCount: seriesGroupCount,
            stackData: stackData,
            dataRangeValues: dataRangeValues,
            scaleType: getScaleType(getStackDataValues(stackData), stackType, diverging)
          };
          state.stackSeries[seriesName].stackData = stackData;
        }

        store_extend(state.stackSeries, newStackSeries);
      });
    }
  },
  observe: {
    updateStackSeriesData: function updateStackSeriesData() {
      this.dispatch('setStackSeriesData');
    }
  }
};
/* harmony default export */ var store_stackSeriesData = (stackSeriesData);
;// CONCATENATED MODULE: ./src/store/scale.ts








var MIN_OFFSET_SIZE = 1;

function getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName) {
  var _options$xAxis, _xAxis;

  var dataRange = state.dataRange,
      layout = state.layout,
      series = state.series,
      options = state.options;
  var categories = state.categories;
  var rawCategories = state.rawCategories;

  var _getSizeKey = getSizeKey(labelAxisOnYAxis),
      labelSizeKey = _getSizeKey.labelSizeKey;

  var dateTypeLabel = isExist((_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date);
  var labelOptions = {
    dataRange: dataRange[labelAxisName],
    offsetSize: Math.max(layout.plot[labelSizeKey], MIN_OFFSET_SIZE),
    scaleOption: scaleOptions[labelAxisName],
    rawCategoriesSize: rawCategories.length
  };
  var result;

  if (dataRange[labelAxisName]) {
    result = dateTypeLabel ? calculateDatetimeScale(labelOptions) : calculateCoordinateScale(labelOptions);
  }

  if (series.line && categories && !((_xAxis = options.xAxis) !== null && _xAxis !== void 0 && _xAxis.pointOnColumn)) {
    result = calculateXAxisScaleForCoordinateLineType(result, options, categories);
  }

  return result;
}

function getValueScaleData(state, labelAxisOnYAxis, scaleOptions, valueAxisName, isCoordinateTypeChart) {
  var dataRange = state.dataRange,
      layout = state.layout,
      series = state.series,
      stackSeries = state.stackSeries;

  var _getSizeKey2 = getSizeKey(labelAxisOnYAxis),
      valueSizeKey = _getSizeKey2.valueSizeKey;

  var result;

  if (hasPercentStackSeries(stackSeries)) {
    Object.keys(series).forEach(function (seriesName) {
      result = getStackScaleData(stackSeries[seriesName].scaleType);
    });
  } else if (isCoordinateTypeChart) {
    var valueOptions = {
      dataRange: dataRange[valueAxisName],
      offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),
      scaleOption: scaleOptions[valueAxisName]
    };
    result = calculateCoordinateScale(valueOptions);
  } else {
    result = calculateCoordinateScale({
      dataRange: dataRange[valueAxisName],
      offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),
      scaleOption: scaleOptions[valueAxisName]
    });
  }

  return result;
}

function getScaleOptions(options, series, valueAxisName) {
  var scaleOptions = {};

  if (isSeriesUsingRadialAxes(series)) {
    var _options$valueAxisNam;

    scaleOptions[valueAxisName] = options === null || options === void 0 ? void 0 : (_options$valueAxisNam = options[valueAxisName]) === null || _options$valueAxisNam === void 0 ? void 0 : _options$valueAxisNam.scale;
  } else {
    var _options$xAxis2;

    var _getYAxisOption = getYAxisOption(options),
        yAxis = _getYAxisOption.yAxis,
        secondaryYAxis = _getYAxisOption.secondaryYAxis;

    scaleOptions.xAxis = options === null || options === void 0 ? void 0 : (_options$xAxis2 = options.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : _options$xAxis2.scale;
    scaleOptions.yAxis = yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale;

    if (secondaryYAxis) {
      scaleOptions.secondaryYAxis = secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.scale;
    }
  }

  return scaleOptions;
}

var scale = {
  name: 'scale',
  state: function state() {
    return {
      scale: {}
    };
  },
  action: {
    setScale: function setScale(_ref) {
      var state = _ref.state,
          initStoreState = _ref.initStoreState;
      var series = state.series,
          options = state.options,
          categories = state.categories;
      var labelAxisOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options,
        categories: categories
      });

      var _getAxisName = getAxisName(labelAxisOnYAxis, series),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      var scaleOptions = getScaleOptions(options, series, valueAxisName);
      var isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);
      var scaleData = {};
      getValueAxisNames(options, valueAxisName).forEach(function (axisName) {
        scaleData[axisName] = getValueScaleData(state, labelAxisOnYAxis, scaleOptions, axisName, isCoordinateTypeChart);
      });

      if (isCoordinateTypeChart) {
        scaleData[labelAxisName] = getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName);
      }

      state.scale = scaleData;
    }
  },
  observe: {
    updateScale: function updateScale() {
      this.dispatch('setScale');
    }
  }
};
/* harmony default export */ var store_scale = (scale);
;// CONCATENATED MODULE: ./src/helpers/plot.ts

function isExistPlotId(plots, data) {
  return plots.some(function (_ref) {
    var bandId = _ref.id;
    return !isUndefined(bandId) && !isUndefined(data.id) && bandId === data.id;
  });
}
;// CONCATENATED MODULE: ./src/store/plot.ts
function plot_toConsumableArray(arr) { return plot_arrayWithoutHoles(arr) || plot_iterableToArray(arr) || plot_unsupportedIterableToArray(arr) || plot_nonIterableSpread(); }

function plot_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function plot_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function plot_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return plot_arrayLikeToArray(arr); }





















function plot_slicedToArray(arr, i) { return plot_arrayWithHoles(arr) || plot_iterableToArrayLimit(arr, i) || plot_unsupportedIterableToArray(arr, i) || plot_nonIterableRest(); }

function plot_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function plot_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return plot_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return plot_arrayLikeToArray(o, minLen); }

function plot_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function plot_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function plot_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







function getOverlappingRange(ranges) {
  var overlappingRanges = ranges.reduce(function (acc, _ref) {
    var range = _ref.range;

    var _acc = plot_slicedToArray(acc, 2),
        accStart = _acc[0],
        accEnd = _acc[1];

    var _ref2 = range,
        _ref3 = plot_slicedToArray(_ref2, 2),
        start = _ref3[0],
        end = _ref3[1];

    return [Math.min(accStart, start), Math.max(accEnd, end)];
  }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
  return {
    range: overlappingRanges,
    color: ranges[0].color
  };
}

function getCategoryIndex(value, categories) {
  return categories.findIndex(function (category) {
    return category === String(value);
  });
}

function getValidValue(value, categories) {
  var isDateType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (isDateType) {
    return Number(new Date(value));
  }

  if (utils_isString(value)) {
    return getCategoryIndex(value, categories);
  }

  return value;
}

function makePlotLines(categories, isDateType) {
  var plotLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return plotLines.map(function (_ref4) {
    var value = _ref4.value,
        color = _ref4.color,
        opacity = _ref4.opacity;
    return {
      value: getValidValue(value, categories, isDateType),
      color: rgba(color, opacity)
    };
  });
}

function makePlotBands(categories, isDateType) {
  var plotBands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return plotBands.flatMap(function (_ref5) {
    var range = _ref5.range,
        _ref5$mergeOverlappin = _ref5.mergeOverlappingRanges,
        mergeOverlappingRanges = _ref5$mergeOverlappin === void 0 ? false : _ref5$mergeOverlappin,
        bgColor = _ref5.color,
        opacity = _ref5.opacity;
    var color = rgba(bgColor, opacity);
    var rangeArray = isRangeValue(range[0]) ? range : [range];
    var ranges = rangeArray.map(function (rangeData) {
      return {
        range: rangeData.map(function (value) {
          return getValidValue(value, categories, isDateType);
        }),
        color: color
      };
    });
    return mergeOverlappingRanges ? getOverlappingRange(ranges) : ranges;
  });
}

var plot = {
  name: 'plot',
  state: function state(_ref6) {
    var _plot$visible, _plot;

    var options = _ref6.options;
    return {
      plot: {
        visible: (_plot$visible = options === null || options === void 0 ? void 0 : (_plot = options.plot) === null || _plot === void 0 ? void 0 : _plot.visible) !== null && _plot$visible !== void 0 ? _plot$visible : true,
        lines: [],
        bands: []
      }
    };
  },
  action: {
    setPlot: function setPlot(_ref7) {
      var _options$xAxis, _lineAreaOptions$plot, _options$xAxis2, _lineAreaOptions$plot2;

      var state = _ref7.state;
      var series = state.series,
          options = state.options;

      if (!(series.area || series.line)) {
        return;
      }

      var rawCategories = state.rawCategories;
      var lineAreaOptions = options;
      var lines = makePlotLines(rawCategories, !!(options !== null && options !== void 0 && (_options$xAxis = options.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.date), lineAreaOptions === null || lineAreaOptions === void 0 ? void 0 : (_lineAreaOptions$plot = lineAreaOptions.plot) === null || _lineAreaOptions$plot === void 0 ? void 0 : _lineAreaOptions$plot.lines);
      var bands = makePlotBands(rawCategories, !!(options !== null && options !== void 0 && (_options$xAxis2 = options.xAxis) !== null && _options$xAxis2 !== void 0 && _options$xAxis2.date), lineAreaOptions === null || lineAreaOptions === void 0 ? void 0 : (_lineAreaOptions$plot2 = lineAreaOptions.plot) === null || _lineAreaOptions$plot2 === void 0 ? void 0 : _lineAreaOptions$plot2.bands);
      store_extend(state.plot, {
        lines: lines,
        bands: bands
      });
    },
    addPlotLine: function addPlotLine(_ref8, _ref9) {
      var _plot$lines, _state$options, _state$options$plot;

      var state = _ref8.state;
      var data = _ref9.data;
      var lines = (_plot$lines = (_state$options = state.options) === null || _state$options === void 0 ? void 0 : (_state$options$plot = _state$options.plot) === null || _state$options$plot === void 0 ? void 0 : _state$options$plot.lines) !== null && _plot$lines !== void 0 ? _plot$lines : [];

      if (!isExistPlotId(lines, data)) {
        this.dispatch('updateOptions', {
          options: {
            plot: {
              lines: [].concat(plot_toConsumableArray(lines), [data])
            }
          }
        });
      }
    },
    addPlotBand: function addPlotBand(_ref10, _ref11) {
      var _plot$bands, _state$options2, _state$options2$plot;

      var state = _ref10.state;
      var data = _ref11.data;
      var bands = (_plot$bands = (_state$options2 = state.options) === null || _state$options2 === void 0 ? void 0 : (_state$options2$plot = _state$options2.plot) === null || _state$options2$plot === void 0 ? void 0 : _state$options2$plot.bands) !== null && _plot$bands !== void 0 ? _plot$bands : [];

      if (!isExistPlotId(bands, data)) {
        this.dispatch('updateOptions', {
          options: {
            plot: {
              bands: [].concat(plot_toConsumableArray(bands), [data])
            }
          }
        });
      }
    },
    removePlotLine: function removePlotLine(_ref12, _ref13) {
      var _plot$lines2, _state$options3, _state$options3$plot;

      var state = _ref12.state;
      var id = _ref13.id;
      var lines = ((_plot$lines2 = (_state$options3 = state.options) === null || _state$options3 === void 0 ? void 0 : (_state$options3$plot = _state$options3.plot) === null || _state$options3$plot === void 0 ? void 0 : _state$options3$plot.lines) !== null && _plot$lines2 !== void 0 ? _plot$lines2 : []).filter(function (_ref14) {
        var lineId = _ref14.id;
        return lineId !== id;
      });
      this.dispatch('updateOptions', {
        options: {
          plot: {
            lines: lines
          }
        }
      });
    },
    removePlotBand: function removePlotBand(_ref15, _ref16) {
      var _plot$bands2, _state$options4, _state$options4$plot;

      var state = _ref15.state;
      var id = _ref16.id;
      var bands = ((_plot$bands2 = (_state$options4 = state.options) === null || _state$options4 === void 0 ? void 0 : (_state$options4$plot = _state$options4.plot) === null || _state$options4$plot === void 0 ? void 0 : _state$options4$plot.bands) !== null && _plot$bands2 !== void 0 ? _plot$bands2 : []).filter(function (_ref17) {
        var bandId = _ref17.id;
        return bandId !== id;
      });
      this.dispatch('updateOptions', {
        options: {
          plot: {
            bands: bands
          }
        }
      });
    }
  },
  observe: {
    updatePlot: function updatePlot() {
      this.dispatch('setPlot');
    }
  }
};
/* harmony default export */ var store_plot = (plot);
;// CONCATENATED MODULE: ./src/helpers/tooltip.ts




function isBubblePointType(value) {
  return value.hasOwnProperty('r');
}

function getValueString(value) {
  var result = '';

  if (isRangeValue(value)) {
    result = "".concat(value[0], " ~ ").concat(value[1]);
  } else if (isObject(value) && !Array.isArray(value)) {
    result = "(".concat(value.x, ", ").concat(value.y, ")") + (isBubblePointType(value) ? ", r: ".concat(value.r) : '');
  } else {
    result = String(value);
  }

  return result;
}
;// CONCATENATED MODULE: ./src/helpers/tooltipTemplate.ts
function tooltipTemplate_slicedToArray(arr, i) { return tooltipTemplate_arrayWithHoles(arr) || tooltipTemplate_iterableToArrayLimit(arr, i) || tooltipTemplate_unsupportedIterableToArray(arr, i) || tooltipTemplate_nonIterableRest(); }

function tooltipTemplate_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltipTemplate_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function tooltipTemplate_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function tooltipTemplate_toConsumableArray(arr) { return tooltipTemplate_arrayWithoutHoles(arr) || tooltipTemplate_iterableToArray(arr) || tooltipTemplate_unsupportedIterableToArray(arr) || tooltipTemplate_nonIterableSpread(); }

function tooltipTemplate_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltipTemplate_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tooltipTemplate_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tooltipTemplate_arrayLikeToArray(o, minLen); }

function tooltipTemplate_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function tooltipTemplate_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return tooltipTemplate_arrayLikeToArray(arr); }

function tooltipTemplate_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




















function getSeriesNameTemplate(label, color) {
  return "<span class=\"toastui-chart-series-name\">\n    <i class=\"toastui-chart-icon\" style=\"background: ".concat(color, "\"></i>\n    <span class=\"toastui-chart-name\">").concat(label, "</span>\n  </span>");
}

function getTitleValueTemplate(title, value) {
  return "<div class=\"toastui-chart-tooltip-series\">\n    <span class=\"toastui-chart-series-name\">".concat(title, "</span>\n    <span class=\"toastui-chart-series-value\">").concat(value, "</span>\n  </div>");
}

function getColorValueTemplate(color, value) {
  return "<div class=\"toastui-chart-tooltip-series\">\n    <i class=\"toastui-chart-icon\" style=\"background: ".concat(color, "\"></i>\n    <span class=\"toastui-chart-series-value\">").concat(value, "</span>\n  </div>");
}

function makeBulletDataTemplate(data, titleType) {
  return data.filter(function (_ref) {
    var title = _ref.title;
    return title === titleType;
  }).sort(function (a, b) {
    if (isRangeValue(a.value) && isRangeValue(b.value)) {
      return a.value[0] - b.value[0];
    }

    if (isNumber(a.value) && isNumber(b.value)) {
      return a.value - b.value;
    }

    return 0;
  }).map(function (_ref2) {
    var formattedValue = _ref2.formattedValue,
        color = _ref2.color;
    return getColorValueTemplate(color, formattedValue);
  }).join('');
}

function getDefaultTemplate(model, _ref3, theme) {
  var header = _ref3.header,
      body = _ref3.body;
  var borderColor = theme.borderColor,
      borderWidth = theme.borderWidth,
      background = theme.background,
      borderRadius = theme.borderRadius,
      borderStyle = theme.borderStyle;
  var style = "border: ".concat(borderWidth, "px ").concat(borderStyle, " ").concat(borderColor, ";border-radius: ").concat(borderRadius, "px;background: ").concat(background, ";");
  return "<div class=\"toastui-chart-tooltip\" style=\"".concat(style, "\">").concat(header).concat(body, "</div>");
}
function getHeaderTemplate(_ref4, theme) {
  var category = _ref4.category;
  return category ? "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n        ").concat(category, "\n      </div>") : '';
}

function getDefaultBodyTemplate(_ref5, theme) {
  var data = _ref5.data;
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref6) {
    var label = _ref6.label,
        color = _ref6.color,
        formattedValue = _ref6.formattedValue;
    return "<div class=\"toastui-chart-tooltip-series\">\n                ".concat(getSeriesNameTemplate(label, color), "\n                <span class=\"toastui-chart-series-value\">").concat(formattedValue, "</span>\n              </div>");
  }).join(''), "\n    </div>");
}

function getBoxPlotTemplate(_ref7, theme) {
  var data = _ref7.data;
  var groupedData = data.reduce(function (acc, item, index) {
    if (!index) {
      return item;
    }

    if (acc.category === item.category && acc.label === item.label) {
      acc.value = [].concat(tooltipTemplate_toConsumableArray(acc.value), tooltipTemplate_toConsumableArray(item.value));
    }

    return acc;
  }, {});
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat([groupedData].map(function (_ref8) {
    var label = _ref8.label,
        color = _ref8.color,
        values = _ref8.value;
    return "<div class=\"toastui-chart-tooltip-series\">\n              ".concat(getSeriesNameTemplate(label, color), "\n            </div>\n            <div>\n          ").concat(values.map(function (_ref9) {
      var title = _ref9.title,
          formattedValue = _ref9.formattedValue;
      return getTitleValueTemplate(title, formattedValue);
    }).join(''), "\n            </div>");
  }).join(''), "\n    </div>");
}

function getBulletTemplate(_ref10, theme) {
  var data = _ref10.data;
  return data.length > 1 ? getBulletGroupedTemplate(data, theme) : getBulletBasicTemplate(data, theme);
}

function getBulletBasicTemplate(data, theme) {
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref11) {
    var label = _ref11.label,
        color = _ref11.color,
        values = _ref11.value;
    return "<div class=\"toastui-chart-tooltip-series\">".concat(getSeriesNameTemplate(label, color), "</div>\n            ").concat(values.map(function (_ref12) {
      var title = _ref12.title,
          formattedValue = _ref12.formattedValue;
      return getTitleValueTemplate(title, formattedValue);
    }).join(''));
  }).join(''), "\n    </div>");
}

function getBulletGroupedTemplate(data, theme) {
  var bulletData = data.map(function (_ref13) {
    var value = _ref13.value;
    return value[0];
  });

  var _map = ['Actual', 'Range', 'Marker'].map(function (titleType) {
    return makeBulletDataTemplate(bulletData, titleType);
  }),
      _map2 = tooltipTemplate_slicedToArray(_map, 3),
      actual = _map2[0],
      ranges = _map2[1],
      markers = _map2[2];

  return "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n      ").concat(data[0].label, "\n    </div>\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"").concat(getFontStyleString(theme.body), "\">\n      ").concat(actual ? '<div class="toastui-chart-tooltip-title">Actual</div>' : '', " ").concat(actual, "\n      ").concat(ranges ? '<div class="toastui-chart-tooltip-title">Ranges</div>' : '', " ").concat(ranges, "\n      ").concat(markers ? '<div class="toastui-chart-tooltip-title">Markers</div>' : '', " ").concat(markers, "\n    </div>");
}

function getPieTemplate(_ref14, theme) {
  var data = _ref14.data;
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref15) {
    var label = _ref15.label,
        color = _ref15.color,
        formattedValue = _ref15.formattedValue,
        percentValue = _ref15.percentValue;
    return "<div class=\"toastui-chart-tooltip-series\">\n          ".concat(getSeriesNameTemplate(label, color), "\n          <span class=\"toastui-chart-series-value\">").concat(pieTooltipLabelFormatter(percentValue), "&nbsp;&nbsp;(").concat(formattedValue, ")</span>\n        </div>");
  }).join(''), "\n    </div>");
}

function getHeatmapTemplate(_ref16, theme) {
  var data = _ref16.data;
  return "".concat(data.map(function (_ref17) {
    var label = _ref17.label,
        color = _ref17.color,
        formattedValue = _ref17.formattedValue;
    return "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n          ").concat(label, "\n        </div>\n        <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"").concat(getFontStyleString(theme.body), "\">\n          <div class=\"toastui-chart-tooltip-series\">\n            ").concat(getSeriesNameTemplate(formattedValue, color), "\n          </div>\n        </div>");
  }).join(''));
}

var tooltipTemplates = {
  default: getDefaultTemplate,
  defaultHeader: getHeaderTemplate,
  defaultBody: getDefaultBodyTemplate,
  boxPlot: getBoxPlotTemplate,
  bullet: getBulletTemplate,
  pie: getPieTemplate,
  heatmap: getHeatmapTemplate
};
function getBodyTemplate(type) {
  return tooltipTemplates[type || 'defaultBody'];
}
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.regexp.constructor.js
var es_regexp_constructor = __webpack_require__(7368);
;// CONCATENATED MODULE: ./src/helpers/dom.ts
function findNodes(element, selector) {
  return element.querySelectorAll(selector);
}
function removeNode(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
;// CONCATENATED MODULE: ./src/helpers/htmlSanitizer.ts











var HTML_ATTR_LIST_RX = new RegExp('^(abbr|align|alt|axis|bgcolor|border|cellpadding|cellspacing|class|clear|' + 'color|cols|compact|coords|dir|face|headers|height|hreflang|hspace|' + 'ismap|lang|language|nohref|nowrap|rel|rev|rows|rules|' + 'scope|scrolling|shape|size|span|start|summary|tabindex|target|title|type|' + 'valign|value|vspace|width|checked|mathvariant|encoding|id|name|' + 'background|cite|href|longdesc|src|usemap|xlink:href|data-+|checked|style)', 'g');
var SVG_ATTR_LIST_RX = new RegExp('^(accent-height|accumulate|additive|alphabetic|arabic-form|ascent|' + 'baseProfile|bbox|begin|by|calcMode|cap-height|class|color|color-rendering|content|' + 'cx|cy|d|dx|dy|descent|display|dur|end|fill|fill-rule|font-family|font-size|font-stretch|' + 'font-style|font-variant|font-weight|from|fx|fy|g1|g2|glyph-name|gradientUnits|hanging|' + 'height|horiz-adv-x|horiz-origin-x|ideographic|k|keyPoints|keySplines|keyTimes|lang|' + 'marker-end|marker-mid|marker-start|markerHeight|markerUnits|markerWidth|mathematical|' + 'max|min|offset|opacity|orient|origin|overline-position|overline-thickness|panose-1|' + 'path|pathLength|points|preserveAspectRatio|r|refX|refY|repeatCount|repeatDur|' + 'requiredExtensions|requiredFeatures|restart|rotate|rx|ry|slope|stemh|stemv|stop-color|' + 'stop-opacity|strikethrough-position|strikethrough-thickness|stroke|stroke-dasharray|' + 'stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit|stroke-opacity|' + 'stroke-width|systemLanguage|target|text-anchor|to|transform|type|u1|u2|underline-position|' + 'underline-thickness|unicode|unicode-range|units-per-em|values|version|viewBox|visibility|' + 'width|widths|x|x-height|x1|x2|xlink:actuate|xlink:arcrole|xlink:role|xlink:show|xlink:title|' + 'xlink:type|xml:base|xml:lang|xml:space|xmlns|xmlns:xlink|y|y1|y2|zoomAndPan)', 'g');
var DEFAULT_TAG_DENY_LIST = ['script', 'iframe', 'textarea', 'form', 'button', 'select', 'input', 'meta', 'style', 'link', 'title', 'embed', 'object'];
var XSS_ATTR_RX = /href|src|background/gi;
var XSS_VALUE_RX = /((java|vb|live)script|x):/gi;
var ON_EVENT_RX = /^on\S+/;
function sanitizeHTML(html) {
  var root = document.createElement('div');

  if (utils_isString(html)) {
    html = html.replace(/<!--[\s\S]*?-->/g, '');
    root.innerHTML = html;
  } else {
    root.appendChild(html);
  }

  removeUnnecessaryTags(root);
  leaveOnlyWhitelistAttribute(root);
  return root.innerHTML;
}

function removeUnnecessaryTags(html) {
  var removedTags = findNodes(html, DEFAULT_TAG_DENY_LIST.join(','));
  removedTags.forEach(function (node) {
    removeNode(node);
  });
}

function isXSSAttribute(attrName, attrValue) {
  return attrName.match(XSS_ATTR_RX) && attrValue.match(XSS_VALUE_RX);
}

function removeBlacklistAttributes(node, blacklistAttrs) {
  blacklistAttrs.forEach(function (_ref) {
    var name = _ref.name;

    if (ON_EVENT_RX.test(name)) {
      node[name] = null;
    }

    if (node.getAttribute(name)) {
      node.removeAttribute(name);
    }
  });
}

function leaveOnlyWhitelistAttribute(html) {
  findNodes(html, '*').forEach(function (node) {
    var attributes = node.attributes;
    var blacklist = toArray(attributes).filter(function (attr) {
      var name = attr.name,
          value = attr.value;
      var htmlAttr = name.match(HTML_ATTR_LIST_RX);
      var svgAttr = name.match(SVG_ATTR_LIST_RX);
      var xssAttr = htmlAttr && isXSSAttribute(name, value);
      return !htmlAttr && !svgAttr || xssAttr;
    });
    removeBlacklistAttributes(node, blacklist);
  });
}
;// CONCATENATED MODULE: ./src/component/tooltip.ts
function tooltip_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { tooltip_typeof = function _typeof(obj) { return typeof obj; }; } else { tooltip_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return tooltip_typeof(obj); }

function tooltip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function tooltip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tooltip_ownKeys(Object(source), true).forEach(function (key) { tooltip_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tooltip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tooltip_toConsumableArray(arr) { return tooltip_arrayWithoutHoles(arr) || tooltip_iterableToArray(arr) || tooltip_unsupportedIterableToArray(arr) || tooltip_nonIterableSpread(); }

function tooltip_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tooltip_arrayLikeToArray(o, minLen); }

function tooltip_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function tooltip_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return tooltip_arrayLikeToArray(arr); }

function tooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

























function tooltip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function tooltip_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function tooltip_createClass(Constructor, protoProps, staticProps) { if (protoProps) tooltip_defineProperties(Constructor.prototype, protoProps); if (staticProps) tooltip_defineProperties(Constructor, staticProps); return Constructor; }

function tooltip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) tooltip_setPrototypeOf(subClass, superClass); }

function tooltip_setPrototypeOf(o, p) { tooltip_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return tooltip_setPrototypeOf(o, p); }

function tooltip_createSuper(Derived) { var hasNativeReflectConstruct = tooltip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = tooltip_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = tooltip_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return tooltip_possibleConstructorReturn(this, result); }; }

function tooltip_possibleConstructorReturn(self, call) { if (call && (tooltip_typeof(call) === "object" || typeof call === "function")) { return call; } return tooltip_assertThisInitialized(self); }

function tooltip_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function tooltip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function tooltip_getPrototypeOf(o) { tooltip_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return tooltip_getPrototypeOf(o); }

function tooltip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var DEFAULT_TOOLTIP_TRANSITION = 'transform 0.2s ease';

var Tooltip = /*#__PURE__*/function (_Component) {
  tooltip_inherits(Tooltip, _Component);

  var _super = tooltip_createSuper(Tooltip);

  function Tooltip() {
    var _this;

    tooltip_classCallCheck(this, Tooltip);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "chartEl", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "tooltipContainerEl", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "templateFunc", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "theme", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "offsetX", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "offsetY", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "formatter", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "tooltipInfoModels", {});

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "onSeriesPointHovered", function (_ref) {
      var models = _ref.models,
          name = _ref.name;
      _this.tooltipInfoModels[name] = models !== null && models !== void 0 && models.length ? tooltip_toConsumableArray(models) : [];
      var isShow = !!_this.getTooltipInfoModels().length;

      if (isShow) {
        _this.renderTooltip();
      } else {
        _this.removeTooltip();
      }
    });

    return _this;
  }

  tooltip_createClass(Tooltip, [{
    key: "isTooltipContainerOverflow",
    value: function isTooltipContainerOverflow(x, y) {
      var _this$tooltipContaine = this.tooltipContainerEl.getBoundingClientRect(),
          width = _this$tooltipContaine.width,
          height = _this$tooltipContaine.height;

      var _this$rect = this.rect,
          rectX = _this$rect.x,
          rectY = _this$rect.y,
          rectWidth = _this$rect.width,
          rectHeight = _this$rect.height;
      return {
        overflowX: x > rectX + rectWidth || x + width > rectX + rectWidth,
        overflowY: y > rectY + rectHeight || y + height > rectY + rectHeight
      };
    }
  }, {
    key: "getPositionInRect",
    value: function getPositionInRect(model) {
      var target = model.target;
      var startX = this.rect.x + model.x;
      var startY = this.rect.y + model.y;
      var x = startX + target.radius + target.width + this.offsetX;
      var y = startY + this.offsetY;

      var _this$isTooltipContai = this.isTooltipContainerOverflow(x, y),
          overflowX = _this$isTooltipContai.overflowX,
          overflowY = _this$isTooltipContai.overflowY;

      var _this$tooltipContaine2 = this.tooltipContainerEl.getBoundingClientRect(),
          width = _this$tooltipContaine2.width,
          height = _this$tooltipContaine2.height;

      if (overflowX) {
        x = startX - (width + target.radius + this.offsetX) > 0 ? startX - (width + target.radius + this.offsetX) : startX + this.offsetX;
      }

      if (overflowY) {
        y = startY + target.height - (height + this.offsetY) > 0 ? startY + target.height - (height + this.offsetY) : y;
      }

      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "setTooltipPosition",
    value: function setTooltipPosition(model) {
      var _this$getPositionInRe = this.getPositionInRect(model),
          x = _this$getPositionInRe.x,
          y = _this$getPositionInRe.y;

      this.tooltipContainerEl.style.transform = getTranslateString(x, y);
    }
  }, {
    key: "getTooltipInfoModels",
    value: function getTooltipInfoModels() {
      return Object.values(this.tooltipInfoModels).flatMap(function (item) {
        return item;
      });
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      var _this2 = this;

      var model = this.getTooltipInfoModels().reduce(function (acc, item) {
        var data = item.data,
            x = item.x,
            y = item.y,
            radius = item.radius,
            width = item.width,
            height = item.height;
        acc.x = acc.x ? (acc.x + x) / 2 : x;
        acc.y = acc.y ? (acc.y + y) / 2 : y;

        if (isNumber(radius)) {
          acc.target.radius = radius;
        }

        if (width) {
          acc.target.width = width;
        }

        if (height) {
          acc.target.height = height;
        }

        acc.data.push(tooltip_objectSpread(tooltip_objectSpread({}, data), {}, {
          value: Array.isArray(data.value) ? data.value.map(function (titleValue) {
            return tooltip_objectSpread(tooltip_objectSpread({}, titleValue), {}, {
              formattedValue: _this2.getFormattedValue(titleValue.value, data)
            });
          }) : data.value,
          formattedValue: _this2.getFormattedValue(data.value, data)
        }));

        if (!acc.category && data.category) {
          acc.category = data.category;
        }

        if (data.templateType) {
          acc.templateType = data.templateType;
        }

        return acc;
      }, {
        type: 'tooltip',
        x: 0,
        y: 0,
        data: [],
        target: {
          radius: 0,
          width: 0,
          height: 0
        }
      });
      this.tooltipContainerEl.innerHTML = sanitizeHTML(this.templateFunc(model, {
        header: tooltipTemplates.defaultHeader(model, this.theme),
        body: getBodyTemplate(model.templateType)(model, this.theme)
      }, this.theme));
      this.setTooltipPosition(model);
    }
  }, {
    key: "initialize",
    value: function initialize(_ref2) {
      var chartEl = _ref2.chartEl;
      this.type = 'tooltip';
      this.name = 'tooltip';
      this.chartEl = chartEl;
      this.tooltipContainerEl = document.createElement('div');
      this.tooltipContainerEl.classList.add('toastui-chart-tooltip-container');

      var _this$chartEl$getBoun = this.chartEl.getBoundingClientRect(),
          width = _this$chartEl$getBoun.width,
          height = _this$chartEl$getBoun.height,
          top = _this$chartEl$getBoun.top,
          left = _this$chartEl$getBoun.left;

      this.tooltipContainerEl.style.transform = getTranslateString(left + width / 2, top + height / 2);
      this.chartEl.appendChild(this.tooltipContainerEl);
      this.eventBus.on('seriesPointHovered', this.onSeriesPointHovered);
    }
  }, {
    key: "removeTooltip",
    value: function removeTooltip() {
      this.tooltipContainerEl.innerHTML = '';
    }
  }, {
    key: "setTooltipTransition",
    value: function setTooltipTransition(options) {
      var _options$tooltip;

      var transition = (_options$tooltip = options.tooltip) === null || _options$tooltip === void 0 ? void 0 : _options$tooltip.transition;

      if (isBoolean(transition) && transition) {
        this.tooltipContainerEl.style.transition = DEFAULT_TOOLTIP_TRANSITION;
      } else if (utils_isString(transition)) {
        this.tooltipContainerEl.style.transition = transition;
      }
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _options$tooltip$temp, _options$tooltip2, _options$tooltip$offs, _options$tooltip3, _options$tooltip$offs2, _options$tooltip4, _options$tooltip5;

      var layout = _ref3.layout,
          options = _ref3.options,
          theme = _ref3.theme;
      this.setTooltipTransition(options);
      this.rect = layout.plot;
      this.theme = theme.tooltip;
      this.templateFunc = (_options$tooltip$temp = options === null || options === void 0 ? void 0 : (_options$tooltip2 = options.tooltip) === null || _options$tooltip2 === void 0 ? void 0 : _options$tooltip2.template) !== null && _options$tooltip$temp !== void 0 ? _options$tooltip$temp : tooltipTemplates.default;
      this.offsetX = (_options$tooltip$offs = options === null || options === void 0 ? void 0 : (_options$tooltip3 = options.tooltip) === null || _options$tooltip3 === void 0 ? void 0 : _options$tooltip3.offsetX) !== null && _options$tooltip$offs !== void 0 ? _options$tooltip$offs : 10;
      this.offsetY = (_options$tooltip$offs2 = options === null || options === void 0 ? void 0 : (_options$tooltip4 = options.tooltip) === null || _options$tooltip4 === void 0 ? void 0 : _options$tooltip4.offsetY) !== null && _options$tooltip$offs2 !== void 0 ? _options$tooltip$offs2 : 0;
      this.formatter = options === null || options === void 0 ? void 0 : (_options$tooltip5 = options.tooltip) === null || _options$tooltip5 === void 0 ? void 0 : _options$tooltip5.formatter;
    }
  }, {
    key: "getFormattedValue",
    value: function getFormattedValue(value, tooltipDataInfo) {
      return this.formatter ? this.formatter(value, tooltipDataInfo) : getValueString(value);
    }
  }]);

  return Tooltip;
}(Component);


;// CONCATENATED MODULE: ./src/component/plot.ts
function plot_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { plot_typeof = function _typeof(obj) { return typeof obj; }; } else { plot_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return plot_typeof(obj); }

function plot_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function plot_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { plot_ownKeys(Object(source), true).forEach(function (key) { plot_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { plot_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function component_plot_toConsumableArray(arr) { return component_plot_arrayWithoutHoles(arr) || component_plot_iterableToArray(arr) || component_plot_unsupportedIterableToArray(arr) || component_plot_nonIterableSpread(); }

function component_plot_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_plot_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function component_plot_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_plot_arrayLikeToArray(arr); }

function component_plot_slicedToArray(arr, i) { return component_plot_arrayWithHoles(arr) || component_plot_iterableToArrayLimit(arr, i) || component_plot_unsupportedIterableToArray(arr, i) || component_plot_nonIterableRest(); }

function component_plot_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_plot_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_plot_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_plot_arrayLikeToArray(o, minLen); }

function component_plot_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_plot_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function component_plot_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






















function plot_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function plot_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function plot_createClass(Constructor, protoProps, staticProps) { if (protoProps) plot_defineProperties(Constructor.prototype, protoProps); if (staticProps) plot_defineProperties(Constructor, staticProps); return Constructor; }

function plot_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) plot_setPrototypeOf(subClass, superClass); }

function plot_setPrototypeOf(o, p) { plot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return plot_setPrototypeOf(o, p); }

function plot_createSuper(Derived) { var hasNativeReflectConstruct = plot_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = plot_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = plot_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return plot_possibleConstructorReturn(this, result); }; }

function plot_possibleConstructorReturn(self, call) { if (call && (plot_typeof(call) === "object" || typeof call === "function")) { return call; } return plot_assertThisInitialized(self); }

function plot_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function plot_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function plot_getPrototypeOf(o) { plot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return plot_getPrototypeOf(o); }

function plot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function getValidIndex(index) {
  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return ~~index ? index - startIndex : index;
}

function validXPosition(_ref) {
  var axisData = _ref.axisData,
      offsetSize = _ref.offsetSize,
      value = _ref.value,
      _ref$startIndex = _ref.startIndex,
      startIndex = _ref$startIndex === void 0 ? 0 : _ref$startIndex;
  var dataIndex = getValidIndex(value, startIndex);
  var x = getXPosition(axisData, offsetSize, value, dataIndex);
  return x > 0 ? Math.min(offsetSize, x) : 0;
}

function getPlotAxisData(vertical, axes) {
  return vertical ? axes.xAxis : axes.yAxis;
}

var Plot = /*#__PURE__*/function (_Component) {
  plot_inherits(Plot, _Component);

  var _super = plot_createSuper(Plot);

  function Plot() {
    var _this;

    plot_classCallCheck(this, Plot);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    plot_defineProperty(plot_assertThisInitialized(_this), "models", {
      plot: [],
      line: [],
      band: []
    });

    plot_defineProperty(plot_assertThisInitialized(_this), "startIndex", 0);

    plot_defineProperty(plot_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  plot_createClass(Plot, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'plot';
    }
  }, {
    key: "getPlotAxisSize",
    value: function getPlotAxisSize(vertical) {
      return {
        offsetSize: vertical ? this.rect.width : this.rect.height,
        anchorSize: vertical ? this.rect.height : this.rect.width
      };
    }
  }, {
    key: "renderLines",
    value: function renderLines(axes, categories) {
      var _this2 = this;

      var lines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return lines.map(function (_ref2) {
        var value = _ref2.value,
            color = _ref2.color;

        var _this2$getPlotAxisSiz = _this2.getPlotAxisSize(true),
            offsetSize = _this2$getPlotAxisSiz.offsetSize;

        var position = validXPosition({
          axisData: getPlotAxisData(true, axes),
          offsetSize: offsetSize,
          value: value,
          categories: categories,
          startIndex: _this2.startIndex
        });
        return _this2.makeLineModel(true, position, {
          color: color
        });
      });
    }
  }, {
    key: "renderBands",
    value: function renderBands(axes, categories) {
      var _this3 = this;

      var bands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      var _this$getPlotAxisSize = this.getPlotAxisSize(true),
          offsetSize = _this$getPlotAxisSize.offsetSize,
          anchorSize = _this$getPlotAxisSize.anchorSize;

      return bands.map(function (_ref3) {
        var range = _ref3.range,
            color = _ref3.color;

        var _map = range.map(function (value) {
          return validXPosition({
            axisData: getPlotAxisData(true, axes),
            offsetSize: offsetSize,
            value: value,
            categories: categories,
            startIndex: _this3.startIndex
          });
        }),
            _map2 = component_plot_slicedToArray(_map, 2),
            start = _map2[0],
            end = _map2[1];

        return {
          type: 'rect',
          x: crispPixel(start),
          y: crispPixel(0),
          width: end - start,
          height: anchorSize,
          color: color
        };
      });
    }
  }, {
    key: "renderPlotLineModels",
    value: function renderPlotLineModels(relativePositions, vertical) {
      var _ref5,
          _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var size = options.size,
          startPosition = options.startPosition,
          axes = options.axes;
      var _ref4 = this.theme[vertical ? 'vertical' : 'horizontal'],
          color = _ref4.lineColor,
          lineWidth = _ref4.lineWidth,
          dashSegments = _ref4.dashSegments;
      var tickInterval = ((_ref5 = vertical ? axes === null || axes === void 0 ? void 0 : axes.xAxis : axes === null || axes === void 0 ? void 0 : axes.yAxis) === null || _ref5 === void 0 ? void 0 : _ref5.tickInterval) || 1;
      return relativePositions.filter(function (_, idx) {
        return !(idx % tickInterval);
      }).map(function (position) {
        return _this4.makeLineModel(vertical, position, {
          color: color,
          lineWidth: lineWidth,
          dashSegments: dashSegments
        }, size !== null && size !== void 0 ? size : _this4.rect.width, startPosition !== null && startPosition !== void 0 ? startPosition : 0);
      });
    }
  }, {
    key: "renderPlotsForCenterYAxis",
    value: function renderPlotsForCenterYAxis(axes) {
      var _ref6 = axes.centerYAxis,
          xAxisHalfSize = _ref6.xAxisHalfSize,
          secondStartX = _ref6.secondStartX,
          yAxisHeight = _ref6.yAxisHeight; // vertical

      var xAxisTickCount = axes.xAxis.tickCount;
      var verticalLines = [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(makeTickPixelPositions(xAxisHalfSize, xAxisTickCount), true)), component_plot_toConsumableArray(this.renderPlotLineModels(makeTickPixelPositions(xAxisHalfSize, xAxisTickCount, secondStartX), true))); // horizontal

      var yAxisTickCount = axes.yAxis.tickCount;
      var yAxisTickPixelPositions = makeTickPixelPositions(yAxisHeight, yAxisTickCount);
      var horizontalLines = [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(yAxisTickPixelPositions, false, {
        size: xAxisHalfSize
      })), component_plot_toConsumableArray(this.renderPlotLineModels(yAxisTickPixelPositions, false, {
        size: xAxisHalfSize,
        startPosition: secondStartX
      })));
      return [].concat(component_plot_toConsumableArray(verticalLines), component_plot_toConsumableArray(horizontalLines));
    }
  }, {
    key: "renderPlots",
    value: function renderPlots(axes, scale) {
      var vertical = true;
      return axes.centerYAxis ? this.renderPlotsForCenterYAxis(axes) : [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(this.getHorizontalTickPixelPositions(axes), !vertical, {
        axes: axes
      })), component_plot_toConsumableArray(this.renderPlotLineModels(this.getVerticalTickPixelPositions(axes, scale), vertical, {
        axes: axes
      })));
    }
  }, {
    key: "getVerticalTickPixelPositions",
    value: function getVerticalTickPixelPositions(axes, scale) {
      var _this$getPlotAxisSize2 = this.getPlotAxisSize(true),
          offsetSize = _this$getPlotAxisSize2.offsetSize;

      var axisData = getPlotAxisData(true, axes);

      if (axisData !== null && axisData !== void 0 && axisData.labelRange) {
        var _scale$xAxis$sizeRati, _scale$xAxis, _scale$xAxis$position, _scale$xAxis2;

        var sizeRatio = (_scale$xAxis$sizeRati = scale === null || scale === void 0 ? void 0 : (_scale$xAxis = scale.xAxis) === null || _scale$xAxis === void 0 ? void 0 : _scale$xAxis.sizeRatio) !== null && _scale$xAxis$sizeRati !== void 0 ? _scale$xAxis$sizeRati : 1;
        var positionRatio = (_scale$xAxis$position = scale === null || scale === void 0 ? void 0 : (_scale$xAxis2 = scale.xAxis) === null || _scale$xAxis2 === void 0 ? void 0 : _scale$xAxis2.positionRatio) !== null && _scale$xAxis$position !== void 0 ? _scale$xAxis$position : 0;
        var axisSizeAppliedRatio = offsetSize * sizeRatio;
        var additional = offsetSize * positionRatio;
        return makeTickPixelPositions(axisSizeAppliedRatio, axisData.tickCount, additional);
      }

      return makeTickPixelPositions(offsetSize, axisData.tickCount);
    }
  }, {
    key: "getHorizontalTickPixelPositions",
    value: function getHorizontalTickPixelPositions(axes) {
      var _this$getPlotAxisSize3 = this.getPlotAxisSize(false),
          offsetSize = _this$getPlotAxisSize3.offsetSize;

      var axisData = getPlotAxisData(false, axes);
      return makeTickPixelPositions(offsetSize, axisData.tickCount);
    }
  }, {
    key: "renderPlotBackgroundRect",
    value: function renderPlotBackgroundRect() {
      return plot_objectSpread(plot_objectSpread({
        type: 'rect',
        x: 0,
        y: 0
      }, pick(this.rect, 'width', 'height')), {}, {
        color: this.theme.backgroundColor
      });
    }
  }, {
    key: "render",
    value: function render(state) {
      var _zoomRange$, _ref7;

      var layout = state.layout,
          axes = state.axes,
          plot = state.plot,
          zoomRange = state.zoomRange,
          theme = state.theme,
          scale = state.scale;

      if (!plot) {
        return;
      }

      this.rect = layout.plot;
      this.startIndex = (_zoomRange$ = zoomRange === null || zoomRange === void 0 ? void 0 : zoomRange[0]) !== null && _zoomRange$ !== void 0 ? _zoomRange$ : 0;
      this.theme = theme.plot;
      var categories = (_ref7 = state.categories) !== null && _ref7 !== void 0 ? _ref7 : [];
      var lines = plot.lines,
          bands = plot.bands,
          visible = plot.visible;
      this.models.line = this.renderLines(axes, categories, lines);
      this.models.band = this.renderBands(axes, categories, bands);

      if (visible) {
        this.models.plot = [this.renderPlotBackgroundRect()].concat(component_plot_toConsumableArray(this.renderPlots(axes, scale)));
      }
    }
  }, {
    key: "makeLineModel",
    value: function makeLineModel(vertical, position, _ref8, sizeWidth) {
      var color = _ref8.color,
          _ref8$dashSegments = _ref8.dashSegments,
          dashSegments = _ref8$dashSegments === void 0 ? [] : _ref8$dashSegments,
          _ref8$lineWidth = _ref8.lineWidth,
          lineWidth = _ref8$lineWidth === void 0 ? 1 : _ref8$lineWidth;
      var xPos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var x = vertical ? crispPixel(position) : crispPixel(xPos);
      var y = vertical ? crispPixel(0) : crispPixel(position);
      var width = vertical ? 0 : sizeWidth !== null && sizeWidth !== void 0 ? sizeWidth : this.rect.width;
      var height = vertical ? this.rect.height : 0;
      return {
        type: 'line',
        x: x,
        y: y,
        x2: x + width,
        y2: y + height,
        strokeStyle: color,
        lineWidth: lineWidth,
        dashSegments: dashSegments
      };
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(painter) {
      painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
      painter.ctx.lineWidth = 1;
    }
  }]);

  return Plot;
}(Component);


;// CONCATENATED MODULE: ./src/helpers/responders.ts
function responders_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function responders_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { responders_ownKeys(Object(source), true).forEach(function (key) { responders_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { responders_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function responders_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function responders_toConsumableArray(arr) { return responders_arrayWithoutHoles(arr) || responders_iterableToArray(arr) || responders_unsupportedIterableToArray(arr) || responders_nonIterableSpread(); }

function responders_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function responders_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return responders_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return responders_arrayLikeToArray(o, minLen); }

function responders_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function responders_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return responders_arrayLikeToArray(arr); }

function responders_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }























// eslint-disable-next-line complexity
function isSameSeriesResponder(_ref) {
  var models = _ref.models,
      comparisonModel = _ref.comparisonModel,
      name = _ref.name,
      eventDetectType = _ref.eventDetectType;

  switch (name) {
    case 'heatmap':
      return isClickSameNameResponder(models, comparisonModel);

    case 'bullet':
      return eventDetectType === 'grouped' ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameNameResponder(models, comparisonModel);

    case 'radar':
    case 'bubble':
    case 'scatter':
    case 'area':
    case 'line':
      return isClickSameCircleResponder(models, comparisonModel);

    case 'pie':
      return isClickSameDataResponder(models, comparisonModel);

    case 'column':
    case 'bar':
      return eventDetectType === 'grouped' ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameDataResponder(models, comparisonModel);

    case 'boxPlot':
      return eventDetectType === 'grouped' ? isClickSameDataResponder(models, comparisonModel) : isClickSameBoxPlotDataResponder(models, comparisonModel);

    case 'treemap':
      return isClickSameLabelResponder(models, comparisonModel);

    case 'gauge':
      return isClickSameNameResponder(models, comparisonModel);

    default:
      return false;
  }
}
function getNearestResponder(responders, mousePosition, rect) {
  var minDistance = Infinity;
  var result = [];
  responders.forEach(function (responder) {
    var x = responder.x,
        y = responder.y,
        radius = responder.radius;
    var responderPoint = {
      x: x + rect.x,
      y: y + rect.y
    };
    var distance = getDistance(responderPoint, mousePosition);

    if (minDistance > distance) {
      minDistance = distance;
      result = [responder];
    } else if (minDistance === distance) {
      if (result.length && result[0].radius > radius) {
        result = [responder];
      } else {
        result.push(responder);
      }
    }
  });
  return result;
}
function makeRectResponderModel(rect, axis, categories) {
  var vertical = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var pointOnColumn = axis.pointOnColumn,
      tickDistance = axis.tickDistance,
      rectResponderCount = axis.rectResponderCount;
  var width = rect.width,
      height = rect.height;
  var halfDetectAreaIndex = pointOnColumn ? [] : [0, rectResponderCount - 1];
  var halfSize = tickDistance / 2;
  return range(0, rectResponderCount).map(function (index) {
    var half = halfDetectAreaIndex.includes(index);
    var size = half ? halfSize : tickDistance;
    var startPos = 0;

    if (index !== 0) {
      startPos += pointOnColumn ? tickDistance * index : halfSize + tickDistance * (index - 1);
    }

    return {
      type: 'rect',
      y: vertical ? 0 : startPos,
      height: vertical ? height : size,
      x: vertical ? startPos : 0,
      width: vertical ? size : width,
      index: index,
      label: categories[index]
    };
  });
}
function responders_makeRectResponderModelForCoordinateType(responderInfo, rect) {
  var width = rect.width,
      height = rect.height;
  var startPos = 0;
  return responderInfo.sort(function (a, b) {
    return a.x - b.x;
  }).reduce(function (acc, model, index) {
    var x = model.x,
        label = model.label;
    var next = responderInfo[index + 1];
    var endPos = next ? (next.x + x) / 2 : width;
    var rectResponderModel = {
      type: 'rect',
      x: startPos,
      y: 0,
      width: endPos - startPos,
      height: height,
      label: label,
      index: index
    };
    startPos = endPos;
    return [].concat(responders_toConsumableArray(acc), [rectResponderModel]);
  }, []);
}
function makeTooltipCircleMap(seriesCircleModel, tooltipDataArr) {
  var dataMap = tooltipDataArr.reduce(function (acc, cur) {
    var index = cur.index,
        seriesIndex = cur.seriesIndex;

    if (!acc[seriesIndex]) {
      acc[seriesIndex] = [];
    }

    acc[seriesIndex][index] = cur;
    return acc;
  }, []);
  return seriesCircleModel.reduce(function (acc, model) {
    var seriesIndex = model.seriesIndex,
        index = model.index;
    var data = dataMap[seriesIndex][index];
    var category = data.category;

    if (!category) {
      return acc;
    }

    if (!acc[category]) {
      acc[category] = [];
    }

    acc[category].push(responders_objectSpread(responders_objectSpread({}, model), {}, {
      data: data
    }));
    return acc;
  }, {});
}
function getDeepestNode(responders) {
  return responders.reduce(function (acc, responder) {
    if (!acc.length || responder.depth > acc[0].depth) {
      return [responder];
    }

    return acc;
  }, []);
}
function isClickSameNameResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].name === selectedSeries[0].name;
}
function isClickSameCircleResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length && responders.length === selectedSeries.length) {
    same = responders.reduce(function (acc, cur, idx) {
      return acc && cur.seriesIndex === selectedSeries[idx].seriesIndex && cur.index === selectedSeries[idx].index;
    }, true);
  }

  return same;
}
function isClickSameDataResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length && responders.length === selectedSeries.length) {
    same = responders.reduce(function (acc, cur, idx) {
      var _cur$data, _selectedSeries$idx$d, _cur$data2, _selectedSeries$idx$d2;

      return acc && ((_cur$data = cur.data) === null || _cur$data === void 0 ? void 0 : _cur$data.label) === ((_selectedSeries$idx$d = selectedSeries[idx].data) === null || _selectedSeries$idx$d === void 0 ? void 0 : _selectedSeries$idx$d.label) && ((_cur$data2 = cur.data) === null || _cur$data2 === void 0 ? void 0 : _cur$data2.category) === ((_selectedSeries$idx$d2 = selectedSeries[idx].data) === null || _selectedSeries$idx$d2 === void 0 ? void 0 : _selectedSeries$idx$d2.category);
    }, true);
  }

  return same;
}
function isClickSameLabelResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].label === selectedSeries[0].label;
}
function isClickSameGroupedRectResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].index === selectedSeries[0].index;
}
function isClickSameBoxPlotDataResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length) {
    var _selectedSeries$0$dat, _selectedSeries$0$dat2;

    var _responders$ = responders[0],
        type = _responders$.type,
        data = _responders$.data;
    same = type === selectedSeries[0].type && (data === null || data === void 0 ? void 0 : data.label) === ((_selectedSeries$0$dat = selectedSeries[0].data) === null || _selectedSeries$0$dat === void 0 ? void 0 : _selectedSeries$0$dat.label) && (data === null || data === void 0 ? void 0 : data.category) === ((_selectedSeries$0$dat2 = selectedSeries[0].data) === null || _selectedSeries$0$dat2 === void 0 ? void 0 : _selectedSeries$0$dat2.category);
  }

  return same;
}
function makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) {
  var centerX = renderOptions.centerX,
      centerY = renderOptions.centerY,
      _renderOptions$angleR = renderOptions.angleRange,
      start = _renderOptions$angleR.start,
      end = _renderOptions$angleR.end,
      clockwise = renderOptions.clockwise;
  return getRadiusRanges(radiusRanges, 0).map(function (radius, index) {
    return {
      type: 'sector',
      x: centerX,
      y: centerY,
      degree: {
        start: start,
        end: end
      },
      radius: radius,
      name: categories[index],
      clockwise: clockwise,
      index: index
    };
  });
}
;// CONCATENATED MODULE: ./src/helpers/dataLabels.ts
function dataLabels_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function dataLabels_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dataLabels_ownKeys(Object(source), true).forEach(function (key) { dataLabels_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dataLabels_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













var RADIUS_PADDING = 30;
var CALLOUT_LENGTH = 20;

function getDefaultAnchor(type) {
  var withStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var anchor = 'auto';

  switch (type) {
    case 'point':
      anchor = 'center';
      break;

    case 'rect':
      anchor = !withStack ? 'auto' : 'center';
      break;

    case 'sector':
    case 'treemapSeriesName':
      anchor = 'center';
      break;

    case 'stackTotal':
      anchor = 'auto';
      break;
  }

  return anchor;
}

function getAnchor(dataLabelOptions, type) {
  var withStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return type !== 'stackTotal' && includes(['center', 'start', 'end', 'auto', 'outer'], dataLabelOptions.anchor) ? dataLabelOptions.anchor : getDefaultAnchor(type, withStack);
}

function getDefaultDataLabelsOptions(dataLabelOptions, type) {
  var _pieSeriesName;

  var withStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var anchor = getAnchor(dataLabelOptions, type, withStack);
  var _dataLabelOptions$off = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off === void 0 ? 0 : _dataLabelOptions$off,
      _dataLabelOptions$off2 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off2 === void 0 ? 0 : _dataLabelOptions$off2;
  var formatter = isFunction(dataLabelOptions.formatter) ? dataLabelOptions.formatter : function (value) {
    return String(value) || '';
  };
  var options = {
    anchor: anchor,
    offsetX: offsetX,
    offsetY: offsetY,
    formatter: formatter
  };

  if (withStack) {
    var stackTotal = dataLabelOptions.stackTotal;
    options.stackTotal = {
      visible: isBoolean(stackTotal === null || stackTotal === void 0 ? void 0 : stackTotal.visible) ? stackTotal.visible : true,
      formatter: isFunction(stackTotal === null || stackTotal === void 0 ? void 0 : stackTotal.formatter) ? stackTotal.formatter : formatter
    };
  }

  if (type === 'sector' && (_pieSeriesName = dataLabelOptions.pieSeriesName) !== null && _pieSeriesName !== void 0 && _pieSeriesName.visible) {
    options.pieSeriesName = dataLabels_objectSpread(dataLabels_objectSpread({}, {
      anchor: 'center'
    }), dataLabelOptions.pieSeriesName);
  }

  return options;
}
function makePointLabelInfo(point, dataLabelOptions, rect) {
  var width = rect.width,
      height = rect.height;
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off3 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off3 === void 0 ? 0 : _dataLabelOptions$off3,
      _dataLabelOptions$off4 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off4 === void 0 ? 0 : _dataLabelOptions$off4,
      formatter = dataLabelOptions.formatter;
  var name = point.name,
      theme = point.theme;
  var textBaseline = 'middle';

  if (anchor === 'end') {
    textBaseline = 'bottom';
  } else if (anchor === 'start') {
    textBaseline = 'top';
  }

  var xWithOffset = point.x + offsetX;
  var yWithOffset = point.y + offsetY;
  var x = xWithOffset < 0 || xWithOffset > width ? point.x : xWithOffset;
  var y = yWithOffset < 0 || yWithOffset > height ? point.y : yWithOffset;
  return {
    type: 'point',
    x: x,
    y: y,
    text: formatter(point.value, point.data),
    textAlign: 'center',
    textBaseline: textBaseline,
    name: name,
    theme: theme
  };
}

function isHorizontal(direction) {
  return includes(['left', 'right'], direction);
}

function makeHorizontalRectPosition(rect, anchor) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height,
      direction = rect.direction;
  var textBaseline = 'middle';
  var posY = y + height / 2;
  var textAlign = 'center';
  var posX;

  if (direction === 'right') {
    switch (anchor) {
      case 'start':
        textAlign = 'left';
        posX = x;
        break;

      case 'end':
        textAlign = 'right';
        posX = x + width;
        break;

      case 'center':
        textAlign = 'center';
        posX = x + width / 2;
        break;

      default:
        textAlign = 'left';
        posX = x + width;
    }
  } else {
    switch (anchor) {
      case 'start':
        textAlign = 'right';
        posX = x + width;
        break;

      case 'end':
        textAlign = 'left';
        posX = x;
        break;

      case 'center':
        textAlign = 'center';
        posX = x + width / 2;
        break;

      default:
        textAlign = 'right';
        posX = x;
    }
  }

  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: textBaseline
  };
}

function makeVerticalRectPosition(rect, anchor) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height,
      direction = rect.direction;
  var textAlign = 'center';
  var posX = x + width / 2;
  var textBaseline = 'middle';
  var posY = 0;

  if (direction === 'top') {
    switch (anchor) {
      case 'end':
        textBaseline = 'top';
        posY = y;
        break;

      case 'start':
        textBaseline = 'bottom';
        posY = y + height;
        break;

      case 'center':
        textBaseline = 'middle';
        posY = y + height / 2;
        break;

      default:
        textBaseline = 'bottom';
        posY = y;
    }
  } else {
    switch (anchor) {
      case 'end':
        textBaseline = 'bottom';
        posY = y + height;
        break;

      case 'start':
        textBaseline = 'top';
        posY = y;
        break;

      case 'center':
        textBaseline = 'middle';
        posY = y + height / 2;
        break;

      default:
        textBaseline = 'top';
        posY = y + height;
        break;
    }
  }

  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: textBaseline
  };
}

function adjustOverflowHorizontalRect(rect, dataLabelOptions, position) {
  var width = rect.width,
      value = rect.value,
      direction = rect.direction,
      plot = rect.plot,
      theme = rect.theme;
  var formatter = dataLabelOptions.formatter;
  var font = getFont(theme);
  var text = utils_isString(value) ? value : formatter(value);
  var textWidth = getTextWidth(text, font);
  var x = position.x,
      textAlign = position.textAlign;
  var isOverflow = direction === 'left' && x - textWidth < 0 || x + textWidth > plot.size;

  if (isOverflow) {
    x = rect.x + width;
    textAlign = 'right';

    if (direction === 'left' && width >= textWidth) {
      x = rect.x;
      textAlign = 'left';
    }
  }

  return {
    x: x,
    textAlign: textAlign
  };
}

function adjustOverflowVerticalRect(rect, dataLabelOptions, position) {
  var height = rect.height,
      direction = rect.direction,
      plot = rect.plot,
      theme = rect.theme,
      value = rect.value;
  var font = getFont(theme);
  var plotSize = plot.size;
  var textHeight = getTextHeight("".concat(value), font); // @TODO: formatter  

  var y = position.y,
      textBaseline = position.textBaseline;
  var isOverflow = !(direction === 'bottom') && y - textHeight < 0 || y + textHeight > plotSize;

  if (isOverflow) {
    y = rect.y;
    textBaseline = 'top';

    if (y + textHeight > plotSize) {
      y = rect.y;
      textBaseline = 'bottom';
    }

    if (direction === 'bottom') {
      y = rect.y + height;
      textBaseline = 'bottom';
    }
  }

  return {
    y: y,
    textBaseline: textBaseline
  };
}

function makeHorizontalRectLabelInfo(rect, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off5 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off5 === void 0 ? 0 : _dataLabelOptions$off5,
      _dataLabelOptions$off6 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off6 === void 0 ? 0 : _dataLabelOptions$off6;
  var direction = rect.direction,
      _rect$plot = rect.plot,
      _rect$plot$x = _rect$plot.x,
      startOffsetX = _rect$plot$x === void 0 ? 0 : _rect$plot$x,
      _rect$plot$y = _rect$plot.y,
      startOffsetY = _rect$plot$y === void 0 ? 0 : _rect$plot$y;
  var position = makeHorizontalRectPosition(rect, anchor);
  var posX = position.x,
      posY = position.y,
      textAlign = position.textAlign;

  if (anchor === 'auto') {
    var adjustRect = adjustOverflowHorizontalRect(rect, dataLabelOptions, {
      x: posX,
      textAlign: textAlign
    });
    posX = adjustRect.x;
    textAlign = adjustRect.textAlign;
  }

  posY += offsetY;

  if (direction === 'left') {
    posX = posX - offsetX;
  } else {
    posX = posX + offsetX;
  }

  var padding = 10;

  if (textAlign === 'right') {
    posX -= padding;
  } else if (textAlign === 'left') {
    posX += padding;
  }

  posX -= startOffsetX;
  posY -= startOffsetY;
  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: position.textBaseline
  };
}

function makeVerticalRectLabelInfo(rect, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off7 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off7 === void 0 ? 0 : _dataLabelOptions$off7,
      _dataLabelOptions$off8 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off8 === void 0 ? 0 : _dataLabelOptions$off8;
  var direction = rect.direction,
      _rect$plot2 = rect.plot,
      _rect$plot2$x = _rect$plot2.x,
      startOffsetX = _rect$plot2$x === void 0 ? 0 : _rect$plot2$x,
      _rect$plot2$y = _rect$plot2.y,
      startOffsetY = _rect$plot2$y === void 0 ? 0 : _rect$plot2$y;
  var position = makeVerticalRectPosition(rect, anchor);
  var posX = position.x,
      posY = position.y,
      textBaseline = position.textBaseline;

  if (anchor === 'auto') {
    var adjustRect = adjustOverflowVerticalRect(rect, dataLabelOptions, position);
    posY = adjustRect.y;
    textBaseline = adjustRect.textBaseline;
  }

  posX += offsetX;

  if (direction === 'top') {
    posY = posY + offsetY;
  } else if (direction === 'bottom') {
    posY = posY - offsetY;
  }

  var padding = 5;

  if (textBaseline === 'bottom') {
    posY -= padding;
  } else if (textBaseline === 'top') {
    posY += padding;
  }

  posX -= startOffsetX;
  posY -= startOffsetY;
  return {
    x: posX,
    y: posY,
    textAlign: position.textAlign,
    textBaseline: textBaseline
  };
}

function makeRectLabelInfo(rect, dataLabelOptions) {
  var type = rect.type,
      value = rect.value,
      direction = rect.direction,
      name = rect.name,
      theme = rect.theme;
  var horizontal = isHorizontal(direction);
  var labelPosition = horizontal ? makeHorizontalRectLabelInfo(rect, dataLabelOptions) : makeVerticalRectLabelInfo(rect, dataLabelOptions);
  var formatter = type === 'stackTotal' ? dataLabelOptions.stackTotal.formatter : dataLabelOptions.formatter;
  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: type
  }, labelPosition), {}, {
    text: utils_isString(value) ? value : formatter(value),
    name: name,
    seriesColor: rect.color,
    theme: theme
  });
}
function makeSectorLabelPosition(model, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor;
  var position = getRadialAnchorPosition(makeAnchorPositionParam(anchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: anchor === 'outer' ? model.radius.outer + RADIUS_PADDING : model.radius.outer
    })
  })));
  var textAlign = getRadialLabelAlign(model, anchor);
  return dataLabels_objectSpread(dataLabels_objectSpread({}, position), {}, {
    textAlign: textAlign,
    textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'bottom' : 'middle'
  });
}

function makeSectorBarLabelPosition(model, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor;
  var clockwise = model.clockwise,
      _model$degree = model.degree,
      start = _model$degree.start,
      end = _model$degree.end,
      _model$radius = model.radius,
      inner = _model$radius.inner,
      outer = _model$radius.outer;
  var startAngle = start;
  var endAngle = end;
  var textAlign = 'center';
  var rotationDegree = (start + end) / 2;

  if (anchor === 'start') {
    textAlign = clockwise ? 'left' : 'right';
    endAngle = startAngle;
    rotationDegree = start;
  } else if (anchor === 'end') {
    textAlign = clockwise ? 'right' : 'left';
    startAngle = endAngle;
    rotationDegree = end;
  }

  var _getRadialAnchorPosit = getRadialAnchorPosition(makeAnchorPositionParam(anchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    degree: {
      start: startAngle,
      end: endAngle
    },
    radius: {
      inner: inner,
      outer: outer
    }
  }))),
      x = _getRadialAnchorPosit.x,
      y = _getRadialAnchorPosit.y;

  return {
    x: x,
    y: y,
    textAlign: textAlign,
    textBaseline: 'middle',
    radian: calculateDegreeToRadian(rotationDegree, 0)
  };
}

function makeSectorBarLabelInfo(model, dataLabelOptions) {
  var formatter = dataLabelOptions.formatter;
  var labelPosition = makeSectorBarLabelPosition(model, dataLabelOptions);
  var value = model.value,
      name = model.name,
      dataLabelTheme = model.theme;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, dataLabelTheme), {}, {
    color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color
  });

  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: 'sector'
  }, labelPosition), {}, {
    text: formatter(value),
    name: name,
    theme: theme
  });
}
function makeSectorLabelInfo(model, dataLabelOptions) {
  var formatter = dataLabelOptions.formatter;
  var labelPosition = makeSectorLabelPosition(model, dataLabelOptions);
  var value = model.value,
      name = model.name,
      dataLabelTheme = model.theme;
  var anchor = dataLabelOptions.anchor;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, dataLabelTheme), {}, {
    color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color
  });

  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: 'sector'
  }, labelPosition), {}, {
    text: formatter(value),
    name: name,
    callout: hasSectorCallout(dataLabelOptions) ? getPieDataLabelCallout(model, anchor) : null,
    theme: theme
  });
}
function makePieSeriesNameLabelInfo(model, dataLabelOptions) {
  var _dataLabelOptions$pie;

  var seriesNameAnchor = (_dataLabelOptions$pie = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie === void 0 ? void 0 : _dataLabelOptions$pie.anchor;
  var hasOuterAnchor = seriesNameAnchor === 'outer';
  var position = getRadialAnchorPosition(makeAnchorPositionParam(seriesNameAnchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: hasOuterAnchor ? model.radius.outer + RADIUS_PADDING : model.radius.outer
    })
  })));
  var textAlign = getRadialLabelAlign(model, seriesNameAnchor);
  var pieSeriesNameTheme = model.theme.pieSeriesName;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, pieSeriesNameTheme), {}, {
    color: pieSeriesNameTheme.useSeriesColor ? model.color : pieSeriesNameTheme.color
  });

  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: 'pieSeriesName'
  }, position), {}, {
    text: model.name,
    callout: hasPieSeriesNameCallout(dataLabelOptions) ? getPieDataLabelCallout(model, seriesNameAnchor) : null,
    textAlign: textAlign,
    textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'top' : 'middle',
    theme: theme
  });
}
function getDataLabelsOptions(options, name) {
  var _options$series, _options$series$name, _options$series2;

  return (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : (_options$series$name = _options$series[name]) === null || _options$series$name === void 0 ? void 0 : _options$series$name.dataLabels) || (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.dataLabels) || {};
}
function makeLineLabelInfo(model, dataLabelOptions) {
  var value = model.value,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline;
  var formatter = dataLabelOptions.formatter;
  return dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    x: model.x,
    y: (model.y + model.y2) / 2,
    textAlign: textAlign !== null && textAlign !== void 0 ? textAlign : 'center',
    textBaseline: textBaseline !== null && textBaseline !== void 0 ? textBaseline : 'middle',
    text: utils_isString(value) ? value : formatter(value)
  });
}

function hasSameAnchorPieDataLabel(dataLabelOptions) {
  var _dataLabelOptions$pie2;

  return dataLabelOptions.anchor === ((_dataLabelOptions$pie2 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie2 === void 0 ? void 0 : _dataLabelOptions$pie2.anchor);
}

function hasSectorCallout(dataLabelOptions) {
  var _dataLabelOptions$pie3;

  return dataLabelOptions.anchor === 'outer' || ((_dataLabelOptions$pie3 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie3 === void 0 ? void 0 : _dataLabelOptions$pie3.anchor) !== 'outer';
}

function hasPieSeriesNameCallout(dataLabelOptions) {
  var _dataLabelOptions$pie4;

  return dataLabelOptions.anchor !== 'outer' || ((_dataLabelOptions$pie4 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie4 === void 0 ? void 0 : _dataLabelOptions$pie4.anchor) === 'outer';
}

function getPieDataLabelCallout(model, anchor) {
  if (anchor !== 'outer') {
    return null;
  }

  var _getRadialAnchorPosit2 = getRadialAnchorPosition(makeAnchorPositionParam('outer', dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: model.radius.outer + CALLOUT_LENGTH
    })
  }))),
      x = _getRadialAnchorPosit2.x,
      y = _getRadialAnchorPosit2.y;

  var _getRadialAnchorPosit3 = getRadialAnchorPosition(makeAnchorPositionParam('outer', dataLabels_objectSpread({}, model))),
      x2 = _getRadialAnchorPosit3.x,
      y2 = _getRadialAnchorPosit3.y;

  var callout = model.theme.callout;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, callout), {}, {
    lineColor: callout.useSeriesColor ? model.color : callout.lineColor
  });

  return {
    x: x,
    y: y,
    x2: x2,
    y2: y2,
    theme: theme
  };
}
;// CONCATENATED MODULE: ./src/component/lineSeries.ts
function lineSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { lineSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineSeries_typeof(obj); }

function lineSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function lineSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineSeries_ownKeys(Object(source), true).forEach(function (key) { lineSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
























function lineSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineSeries_defineProperties(Constructor, staticProps); return Constructor; }

function lineSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineSeries_setPrototypeOf(subClass, superClass); }

function lineSeries_setPrototypeOf(o, p) { lineSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineSeries_setPrototypeOf(o, p); }

function lineSeries_createSuper(Derived) { var hasNativeReflectConstruct = lineSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineSeries_possibleConstructorReturn(this, result); }; }

function lineSeries_possibleConstructorReturn(self, call) { if (call && (lineSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return lineSeries_assertThisInitialized(self); }

function lineSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function lineSeries_getPrototypeOf(o) { lineSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineSeries_getPrototypeOf(o); }

function lineSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













var LineSeries = /*#__PURE__*/function (_Component) {
  lineSeries_inherits(LineSeries, _Component);

  var _super = lineSeries_createSuper(LineSeries);

  function LineSeries() {
    var _this;

    lineSeries_classCallCheck(this, LineSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "models", {
      rect: [],
      series: [],
      dot: []
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "drawModels", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "responders", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "theme", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "activatedResponders", []);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "eventDetectType", 'nearest');

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "tooltipCircleMap", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "startIndex", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "yAxisName", 'yAxis');

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'line')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var model = _this.tooltipCircleMap[category][seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var models = _this.getResponderSeriesWithTheme([model], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'line')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.tooltipCircleMap[category] : [_this.tooltipCircleMap[category][seriesIndex]];

      if (!(models !== null && models !== void 0 && models.length)) {
        return;
      }

      _this.onMousemoveNearType(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  lineSeries_createClass(LineSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'line';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.drawModels.rect[0].width = this.models.rect[0].width * delta;
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (series.area || series.column) {
        this.eventDetectType = 'grouped';
      }

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      if (series.scatter) {
        this.eventDetectType = 'near';
      }
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref, _ref2, _options$series2, _viewRange$;

      var viewRange = computed.viewRange;
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          legend = chartState.legend,
          theme = chartState.theme;

      if (!series.line) {
        throw new Error(message.noDataError(this.name));
      }

      var categories = (_ref = chartState.categories) !== null && _ref !== void 0 ? _ref : [];
      var rawCategories = (_ref2 = chartState.rawCategories) !== null && _ref2 !== void 0 ? _ref2 : [];

      var options = lineSeries_objectSpread({}, chartState.options);

      if (options !== null && options !== void 0 && options.series && 'line' in options.series) {
        options.series = lineSeries_objectSpread(lineSeries_objectSpread({}, options.series), options.series.line);
      }

      this.setEventDetectType(series, options);
      var labelAxisData = axes.xAxis;
      var seriesOptions = (_options$series2 = options.series) !== null && _options$series2 !== void 0 ? _options$series2 : {};
      var lineSeriesData = series.line.data;
      this.theme = theme.series.line;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
      this.selectable = this.getSelectableOption(options);
      this.yAxisName = getValueAxisName(options, this.name, 'yAxis');
      var lineSeriesModel = this.renderLinePointsModel(lineSeriesData, scale, labelAxisData, seriesOptions, categories);

      var _this$renderCircleMod = this.renderCircleModel(lineSeriesModel, seriesOptions),
          dotSeriesModel = _this$renderCircleMod.dotSeriesModel,
          responderModel = _this$renderCircleMod.responderModel;

      var tooltipDataArr = this.makeTooltipData(lineSeriesData, categories);
      this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);
      this.models = {
        rect: [this.renderClipRectAreaModel()],
        series: lineSeriesModel,
        dot: dotSeriesModel
      };

      if (!this.drawModels) {
        this.drawModels = lineSeries_objectSpread(lineSeries_objectSpread({}, this.models), {}, {
          rect: [this.renderClipRectAreaModel(true)]
        });
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels(lineSeriesModel));
      }

      var coordinateType = isCoordinateSeries(series);
      this.responders = this.getResponders({
        labelAxisData: labelAxisData,
        responderModel: responderModel,
        tooltipDataArr: tooltipDataArr,
        categories: categories,
        rawCategories: rawCategories,
        coordinateType: coordinateType
      });
    }
  }, {
    key: "getResponders",
    value: function getResponders(_ref3) {
      var labelAxisData = _ref3.labelAxisData,
          responderModel = _ref3.responderModel,
          tooltipDataArr = _ref3.tooltipDataArr,
          categories = _ref3.categories,
          rawCategories = _ref3.rawCategories,
          coordinateType = _ref3.coordinateType;

      if (this.eventDetectType === 'near') {
        return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories);
      }

      if (this.eventDetectType === 'point') {
        return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories, 0);
      }

      if (coordinateType) {
        var rectResponderInfo = this.getRectResponderInfoForCoordinateType(responderModel, rawCategories);
        return responders_makeRectResponderModelForCoordinateType(rectResponderInfo, this.rect);
      }

      return makeRectResponderModel(this.rect, labelAxisData, categories);
    }
  }, {
    key: "makeNearTypeResponderModel",
    value: function makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, categories, detectionSize) {
      return seriesCircleModel.map(function (m, index) {
        return lineSeries_objectSpread(lineSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[index],
          detectionSize: detectionSize,
          label: categories[m.index]
        });
      });
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(lineSeriesData, categories) {
      var _this2 = this;

      return lineSeriesData.flatMap(function (_ref4, seriesIndex) {
        var rawData = _ref4.rawData,
            name = _ref4.name,
            color = _ref4.color;
        return rawData.map(function (datum, index) {
          return isNull(datum) ? {} : {
            label: name,
            color: color,
            value: getCoordinateYValue(datum),
            category: categories[getCoordinateDataIndex(datum, categories, index, _this2.startIndex)],
            seriesIndex: seriesIndex,
            index: index
          };
        });
      });
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel(isDrawModel) {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: isDrawModel ? 0 : this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "renderLinePointsModel",
    value: function renderLinePointsModel(seriesRawData, scale, axisData, options, categories) {
      var _this3 = this;

      var spline = options.spline;
      var yAxisLimit = scale[this.yAxisName].limit;
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      return seriesRawData.map(function (_ref5, seriesIndex) {
        var rawData = _ref5.rawData,
            name = _ref5.name,
            seriesColor = _ref5.color;
        var points = [];
        var active = _this3.activeSeriesMap[name];
        rawData.forEach(function (datum, idx) {
          if (isNull(datum)) {
            return points.push(null);
          }

          var value = getCoordinateYValue(datum);
          var yValueRatio = getValueRatio(value, yAxisLimit);
          var y = (1 - yValueRatio) * _this3.rect.height;
          var x = getXPosition(axisData, _this3.rect.width, getCoordinateXValue(datum), getCoordinateDataIndex(datum, categories, idx, _this3.startIndex));
          points.push({
            x: x,
            y: y,
            value: value
          });
        });

        if (spline) {
          setSplineControlPoint(points);
        }

        return {
          type: 'linePoints',
          points: points,
          seriesIndex: seriesIndex,
          name: name,
          color: getRGBA(seriesColor, active ? 1 : 0.3),
          lineWidth: lineWidth,
          dashSegments: dashSegments
        };
      });
    }
  }, {
    key: "getRectResponderInfoForCoordinateType",
    value: function getRectResponderInfoForCoordinateType(circleModel, categories) {
      var _this4 = this;

      var duplicateCheckMap = {};
      var modelInRange = circleModel.filter(function (_ref6) {
        var x = _ref6.x;
        return x >= 0 && x <= _this4.rect.width;
      });
      return modelInRange.reduce(function (acc, model) {
        var index = model.index,
            x = model.x;

        if (!duplicateCheckMap[x]) {
          var label = categories[index];
          duplicateCheckMap[x] = true;
          acc.push({
            x: x,
            label: label
          });
        }

        return acc;
      }, []);
    }
  }, {
    key: "renderCircleModel",
    value: function renderCircleModel(lineSeriesModel, options) {
      var _this5 = this;

      var dotSeriesModel = [];
      var responderModel = [];
      var showDot = !!options.showDot;
      var _this$theme2 = this.theme,
          hover = _this$theme2.hover,
          dotTheme = _this$theme2.dot;
      var hoverDotTheme = hover.dot;
      lineSeriesModel.forEach(function (_ref7, seriesIndex) {
        var color = _ref7.color,
            name = _ref7.name,
            points = _ref7.points;
        var active = _this5.activeSeriesMap[name];
        points.forEach(function (point, index) {
          var _hoverDotTheme$color;

          if (isNull(point)) {
            return;
          }

          var x = point.x,
              y = point.y;
          var model = {
            type: 'circle',
            x: x,
            y: y,
            seriesIndex: seriesIndex,
            name: name,
            index: index
          };

          if (showDot) {
            var _dotTheme$borderColor;

            dotSeriesModel.push(lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
              radius: dotTheme.radius,
              color: getRGBA(color, active ? 1 : 0.3),
              style: [{
                lineWidth: dotTheme.borderWidth,
                strokeStyle: (_dotTheme$borderColor = dotTheme.borderColor) !== null && _dotTheme$borderColor !== void 0 ? _dotTheme$borderColor : color
              }]
            }));
          }

          responderModel.push(lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
            radius: hoverDotTheme.radius,
            color: (_hoverDotTheme$color = hoverDotTheme.color) !== null && _hoverDotTheme$color !== void 0 ? _hoverDotTheme$color : getRGBA(color, 1),
            style: ['default']
          }));
        });
      });
      return {
        dotSeriesModel: dotSeriesModel,
        responderModel: responderModel
      };
    }
  }, {
    key: "getCircleModelsFromRectResponders",
    value: function getCircleModelsFromRectResponders(responders, mousePositions) {
      var _this$tooltipCircleMa, _responders$;

      if (!responders.length || !responders[0].label) {
        return [];
      }

      var models = (_this$tooltipCircleMa = this.tooltipCircleMap[(_responders$ = responders[0]) === null || _responders$ === void 0 ? void 0 : _responders$.label]) !== null && _this$tooltipCircleMa !== void 0 ? _this$tooltipCircleMa : [];
      return this.eventDetectType === 'grouped' ? models : getNearestResponder(models, mousePositions, this.rect);
    }
  }, {
    key: "onMousemoveNearType",
    value: function onMousemoveNearType(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getResponderSeriesWithTheme(responders, 'hover'),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = responders;
    }
  }, {
    key: "onMousemoveNearestType",
    value: function onMousemoveNearestType(responders, mousePositions) {
      var circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var circleModels = this.getCircleModelsFromRectResponders(responders);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref8) {
      var responders = _ref8.responders,
          mousePosition = _ref8.mousePosition;

      if (this.eventDetectType === 'nearest') {
        this.onMousemoveNearestType(responders, mousePosition);
      } else if (includes(['near', 'point'], this.eventDetectType)) {
        this.onMousemoveNearType(responders);
      } else {
        this.onMousemoveGroupedType(responders);
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels) {
      var dataLabelTheme = this.theme.dataLabels;
      return seriesModels.flatMap(function (_ref9) {
        var points = _ref9.points,
            name = _ref9.name,
            color = _ref9.color;
        return points.map(function (point) {
          return isNull(point) ? {} : lineSeries_objectSpread(lineSeries_objectSpread({
            type: 'point'
          }, point), {}, {
            name: name,
            theme: lineSeries_objectSpread(lineSeries_objectSpread({}, dataLabelTheme), {}, {
              color: dataLabelTheme.useSeriesColor ? color : dataLabelTheme.color
            })
          });
        });
      });
    }
  }, {
    key: "getResponderSeriesWithTheme",
    value: function getResponderSeriesWithTheme(models, type) {
      var _ref10 = this.theme[type].dot,
          radius = _ref10.radius,
          color = _ref10.color,
          borderWidth = _ref10.borderWidth,
          borderColor = _ref10.borderColor;
      return models.map(function (model) {
        var modelColor = color !== null && color !== void 0 ? color : model.color;
        return lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
          radius: radius,
          color: modelColor,
          style: [{
            lineWidth: borderWidth,
            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
          }]
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref11) {
      var responders = _ref11.responders,
          mousePosition = _ref11.mousePosition;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'near') {
          models = responders;
        } else {
          models = this.getCircleModelsFromRectResponders(responders, mousePosition);
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: this.getResponderSeriesWithTheme(models, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderCategoryByIndex",
    value: function getResponderCategoryByIndex(index) {
      var _responder$data;

      var responder = Object.values(this.tooltipCircleMap).flatMap(function (val) {
        return val;
      }).find(function (model) {
        return model.index === index;
      });
      return responder === null || responder === void 0 ? void 0 : (_responder$data = responder.data) === null || _responder$data === void 0 ? void 0 : _responder$data.category;
    }
  }]);

  return LineSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/legend.ts
function legend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { legend_typeof = function _typeof(obj) { return typeof obj; }; } else { legend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return legend_typeof(obj); }

function component_legend_toConsumableArray(arr) { return component_legend_arrayWithoutHoles(arr) || component_legend_iterableToArray(arr) || component_legend_unsupportedIterableToArray(arr) || component_legend_nonIterableSpread(); }

function component_legend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_legend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_legend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_legend_arrayLikeToArray(o, minLen); }

function component_legend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function component_legend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_legend_arrayLikeToArray(arr); }

function component_legend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function component_legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_legend_ownKeys(Object(source), true).forEach(function (key) { component_legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






















function legend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function legend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function legend_createClass(Constructor, protoProps, staticProps) { if (protoProps) legend_defineProperties(Constructor.prototype, protoProps); if (staticProps) legend_defineProperties(Constructor, staticProps); return Constructor; }

function legend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) legend_setPrototypeOf(subClass, superClass); }

function legend_setPrototypeOf(o, p) { legend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return legend_setPrototypeOf(o, p); }

function legend_createSuper(Derived) { var hasNativeReflectConstruct = legend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = legend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = legend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return legend_possibleConstructorReturn(this, result); }; }

function legend_possibleConstructorReturn(self, call) { if (call && (legend_typeof(call) === "object" || typeof call === "function")) { return call; } return legend_assertThisInitialized(self); }

function legend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function legend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function legend_getPrototypeOf(o) { legend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return legend_getPrototypeOf(o); }

function component_legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var Legend = /*#__PURE__*/function (_Component) {
  legend_inherits(Legend, _Component);

  var _super = legend_createSuper(Legend);

  function Legend() {
    var _this;

    legend_classCallCheck(this, Legend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_legend_defineProperty(legend_assertThisInitialized(_this), "models", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "responders", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "theme", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "activatedResponders", []);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "seriesColorMap", {});

    component_legend_defineProperty(legend_assertThisInitialized(_this), "seriesIconTypeMap", {});

    component_legend_defineProperty(legend_assertThisInitialized(_this), "onClickCheckbox", function (responders) {
      var _responders$ = responders[0],
          label = _responders$.label,
          checked = _responders$.checked;

      _this.store.dispatch('setAllLegendActiveState', true);

      _this.store.dispatch('setLegendCheckedState', {
        name: label,
        checked: !checked
      });

      if (checked) {
        _this.store.dispatch('disableSeries', label);
      } else {
        _this.store.dispatch('enableSeries', label);
      }

      _this.eventBus.emit('needDraw');
    });

    component_legend_defineProperty(legend_assertThisInitialized(_this), "onClickLabel", function (responders) {
      var label = responders[0].label;

      _this.eventBus.emit('resetSelectedSeries');

      if (_this.activatedResponders.length && _this.activatedResponders[0].label === label) {
        _this.store.dispatch('setAllLegendActiveState', true);

        _this.activatedResponders = [];
      } else {
        _this.store.dispatch('setAllLegendActiveState', false);

        _this.store.dispatch('setLegendActiveState', {
          name: label,
          active: true
        });

        _this.activatedResponders = responders;
      }

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  legend_createClass(Legend, [{
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        var data = responders[0].data;

        if ((data === null || data === void 0 ? void 0 : data.name) === 'checkbox') {
          this.eventBus.emit('clickLegendCheckbox', makeObservableObjectToNormal(responders));
        } else {
          this.eventBus.emit('clickLegendLabel', makeObservableObjectToNormal(responders));
        }
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'legend';
      this.name = 'legend';
      this.eventBus.on('clickLegendCheckbox', this.onClickCheckbox);
      this.eventBus.on('clickLegendLabel', this.onClickLabel);
    }
  }, {
    key: "initColorAndIconTypeMap",
    value: function initColorAndIconTypeMap(legendData) {
      var _this2 = this;

      this.seriesColorMap = {};
      this.seriesIconTypeMap = {};
      legendData.forEach(function (_ref2) {
        var label = _ref2.label,
            color = _ref2.color,
            iconType = _ref2.iconType;
        _this2.seriesColorMap[label] = color;
        _this2.seriesIconTypeMap[label] = iconType;
      });
    }
  }, {
    key: "getXPositionWhenVerticalAlign",
    value: function getXPositionWhenVerticalAlign(data) {
      var _data$reduce = data.reduce(function (acc, datum) {
        var rowIndex = datum.rowIndex,
            columnIndex = datum.columnIndex,
            width = datum.width;

        if (isUndefined(acc.rowWidths[rowIndex])) {
          acc.rowWidths[rowIndex] = 0;
          acc.offset[rowIndex] = [0];
        }

        acc.rowWidths[rowIndex] += width + (columnIndex ? LEGEND_ITEM_MARGIN_X : 0);
        acc.offset[rowIndex][columnIndex + 1] = acc.offset[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + width;
        return acc;
      }, {
        offset: [],
        rowWidths: []
      }),
          offset = _data$reduce.offset,
          rowWidths = _data$reduce.rowWidths;

      var width = this.rect.width;
      rowWidths.forEach(function (rowWidth, rowIndex) {
        var xMargin = (width - rowWidth) / 2;
        offset[rowIndex] = offset[rowIndex].map(function (xOffset) {
          return xOffset + xMargin;
        });
      });
      return offset;
    }
  }, {
    key: "getXPositionWhenHorizontalAlign",
    value: function getXPositionWhenHorizontalAlign(data) {
      var maxWidths = data.reduce(function (acc, datum) {
        var columnIndex = datum.columnIndex,
            width = datum.width;

        if (isUndefined(acc[columnIndex])) {
          acc[columnIndex] = 0;
        }

        acc[columnIndex] = Math.max(acc[columnIndex], width);
        return acc;
      }, []);
      return data.reduce(function (acc, datum) {
        var rowIndex = datum.rowIndex,
            columnIndex = datum.columnIndex;

        if (isUndefined(acc[rowIndex])) {
          acc[rowIndex] = [0];
        }

        acc[rowIndex][columnIndex + 1] = acc[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + maxWidths[columnIndex];
        return acc;
      }, []);
    }
  }, {
    key: "renderLegendModel",
    value: function renderLegendModel(legend) {
      var _this3 = this;

      var data = legend.data,
          showCheckbox = legend.showCheckbox,
          align = legend.align,
          useScatterChartIcon = legend.useScatterChartIcon;
      var verticalAlign = isVerticalAlign(align);
      var itemHeight = getLegendItemHeight(this.theme.label.fontSize);
      var xPosition = verticalAlign ? this.getXPositionWhenVerticalAlign(data) : this.getXPositionWhenHorizontalAlign(data);
      return [component_legend_objectSpread({
        type: 'legend',
        align: align,
        showCheckbox: showCheckbox,
        data: data.map(function (datum) {
          var _this3$seriesIconType;

          var label = datum.label,
              iconType = datum.iconType,
              rowIndex = datum.rowIndex,
              columnIndex = datum.columnIndex;
          return component_legend_objectSpread(component_legend_objectSpread({}, datum), {}, {
            iconType: (_this3$seriesIconType = _this3.seriesIconTypeMap[label]) !== null && _this3$seriesIconType !== void 0 ? _this3$seriesIconType : iconType,
            color: _this3.seriesColorMap[label],
            x: xPosition[rowIndex][columnIndex],
            y: padding.Y + itemHeight * rowIndex,
            useScatterChartIcon: useScatterChartIcon
          });
        })
      }, this.theme.label)];
    }
  }, {
    key: "makeCheckboxResponder",
    value: function makeCheckboxResponder(data, showCheckbox) {
      return showCheckbox ? data.map(function (m) {
        return component_legend_objectSpread(component_legend_objectSpread({}, m), {}, {
          type: 'rect',
          x: m.x,
          y: m.y,
          width: LEGEND_CHECKBOX_SIZE,
          height: LEGEND_CHECKBOX_SIZE,
          data: {
            name: 'checkbox'
          }
        });
      }) : [];
    }
  }, {
    key: "makeLabelResponder",
    value: function makeLabelResponder(data, showCheckbox) {
      var font = getTitleFontString(this.theme.label);
      return data.map(function (m) {
        return component_legend_objectSpread(component_legend_objectSpread({}, m), {}, {
          type: 'rect',
          x: m.x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X,
          y: m.y,
          width: getTextWidth(m.label, font),
          data: {
            name: 'label'
          },
          height: LEGEND_CHECKBOX_SIZE
        });
      });
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var layout = _ref3.layout,
          legend = _ref3.legend,
          theme = _ref3.theme;
      this.isShow = legend.visible && !!legend.data.length;

      if (!this.isShow) {
        return;
      } // @TODO: stack     (  ) 


      var showCheckbox = legend.showCheckbox,
          legendData = legend.data;
      this.rect = layout.legend;
      this.theme = theme.legend;
      this.initColorAndIconTypeMap(legendData);
      this.models = this.renderLegendModel(legend);
      var data = this.models[0].data;
      var checkboxResponder = this.makeCheckboxResponder(data, showCheckbox);
      var labelResponder = this.makeLabelResponder(data, showCheckbox);
      this.responders = [].concat(component_legend_toConsumableArray(checkboxResponder), component_legend_toConsumableArray(labelResponder));
    }
  }]);

  return Legend;
}(Component);


;// CONCATENATED MODULE: ./src/component/dataLabels.ts
function dataLabels_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { dataLabels_typeof = function _typeof(obj) { return typeof obj; }; } else { dataLabels_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return dataLabels_typeof(obj); }

function component_dataLabels_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function component_dataLabels_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_dataLabels_ownKeys(Object(source), true).forEach(function (key) { component_dataLabels_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_dataLabels_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabels_toConsumableArray(arr) { return dataLabels_arrayWithoutHoles(arr) || dataLabels_iterableToArray(arr) || dataLabels_unsupportedIterableToArray(arr) || dataLabels_nonIterableSpread(); }

function dataLabels_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataLabels_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataLabels_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataLabels_arrayLikeToArray(o, minLen); }

function dataLabels_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function dataLabels_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return dataLabels_arrayLikeToArray(arr); }

function dataLabels_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }























function dataLabels_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dataLabels_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function dataLabels_createClass(Constructor, protoProps, staticProps) { if (protoProps) dataLabels_defineProperties(Constructor.prototype, protoProps); if (staticProps) dataLabels_defineProperties(Constructor, staticProps); return Constructor; }

function dataLabels_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) dataLabels_setPrototypeOf(subClass, superClass); }

function dataLabels_setPrototypeOf(o, p) { dataLabels_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return dataLabels_setPrototypeOf(o, p); }

function dataLabels_createSuper(Derived) { var hasNativeReflectConstruct = dataLabels_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = dataLabels_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = dataLabels_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return dataLabels_possibleConstructorReturn(this, result); }; }

function dataLabels_possibleConstructorReturn(self, call) { if (call && (dataLabels_typeof(call) === "object" || typeof call === "function")) { return call; } return dataLabels_assertThisInitialized(self); }

function dataLabels_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function dataLabels_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function dataLabels_getPrototypeOf(o) { dataLabels_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return dataLabels_getPrototypeOf(o); }

function component_dataLabels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function getLabelInfo(model, labelOptions, rect, name) {
  var type = model.type;
  var dataLabel = [];

  if (type === 'point') {
    dataLabel.push(makePointLabelInfo(model, labelOptions, rect));
  } else if (type === 'sector') {
    if (name === 'radialBar') {
      dataLabel.push(makeSectorBarLabelInfo(model, labelOptions));
    } else {
      var _labelOptions$pieSeri;

      dataLabel.push(makeSectorLabelInfo(model, labelOptions));

      if ((_labelOptions$pieSeri = labelOptions.pieSeriesName) !== null && _labelOptions$pieSeri !== void 0 && _labelOptions$pieSeri.visible) {
        var seriesNameLabel = makePieSeriesNameLabelInfo(model, labelOptions);
        dataLabel.push(seriesNameLabel);
      }
    }
  } else if (type === 'line') {
    dataLabel.push(makeLineLabelInfo(model, labelOptions));
  } else {
    dataLabel.push(makeRectLabelInfo(model, labelOptions));
  }

  return dataLabel;
}

var DataLabels = /*#__PURE__*/function (_Component) {
  dataLabels_inherits(DataLabels, _Component);

  var _super = dataLabels_createSuper(DataLabels);

  function DataLabels() {
    var _this;

    dataLabels_classCallCheck(this, DataLabels);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "models", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "drawModels", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "options", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "dataLabelsMap", {});

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "renderSeriesDataLabels", function (seriesDataLabel) {
      _this.appendDataLabels(seriesDataLabel);

      _this.models = _this.renderLabelModel();

      if (!_this.drawModels) {
        _this.drawModels = _this.getDrawModelsAppliedOpacity(0);
      } else {
        _this.sync();
      }
    });

    return _this;
  }

  dataLabels_createClass(DataLabels, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'dataLabels';
      this.name = 'dataLabels';
      this.eventBus.on('renderDataLabels', this.renderSeriesDataLabels);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      this.drawModels = this.getDrawModelsAppliedOpacity(delta);
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          options = _ref.options,
          series = _ref.series,
          nestedPieSeries = _ref.nestedPieSeries;
      this.rect = layout.plot;
      this.options = options;
      this.isShow = this.visibleDataLabels(series, nestedPieSeries);
    }
  }, {
    key: "visibleDataLabels",
    value: function visibleDataLabels(series, nestedPieSeries) {
      var _this$options$series,
          _this$options$series$,
          _this2 = this;

      var visibleCommonSeriesDataLabels = !!((_this$options$series = this.options.series) !== null && _this$options$series !== void 0 && (_this$options$series$ = _this$options$series.dataLabels) !== null && _this$options$series$ !== void 0 && _this$options$series$.visible);
      var visibleComboSeriesDataLabels = Object.keys(series).some(function (seriesName) {
        var _this2$options$series, _this2$options$series2, _this2$options$series3;

        return !!((_this2$options$series = _this2.options.series) !== null && _this2$options$series !== void 0 && (_this2$options$series2 = _this2$options$series[seriesName]) !== null && _this2$options$series2 !== void 0 && (_this2$options$series3 = _this2$options$series2.dataLabels) !== null && _this2$options$series3 !== void 0 && _this2$options$series3.visible);
      });
      var visibleNestedPieSeriesDataLabels = !!(nestedPieSeries && Object.keys(nestedPieSeries).some(function (alias) {
        var _this2$options$series4, _this2$options$series5, _this2$options$series6;

        return !!((_this2$options$series4 = _this2.options.series) !== null && _this2$options$series4 !== void 0 && (_this2$options$series5 = _this2$options$series4[alias]) !== null && _this2$options$series5 !== void 0 && (_this2$options$series6 = _this2$options$series5.dataLabels) !== null && _this2$options$series6 !== void 0 && _this2$options$series6.visible);
      }));
      return visibleCommonSeriesDataLabels || visibleComboSeriesDataLabels || visibleNestedPieSeriesDataLabels;
    }
  }, {
    key: "appendDataLabels",
    value: function appendDataLabels(_ref2) {
      var _this3 = this;

      var name = _ref2.name,
          data = _ref2.data;
      var dataLabelOptions = getDataLabelsOptions(this.options, name);
      var withStack = !!pickStackOption(this.options);
      var labels = [];
      data.forEach(function (model) {
        var _labelOptions$stackTo;

        var type = model.type,
            value = model.value;
        var labelOptions = getDefaultDataLabelsOptions(dataLabelOptions, type, withStack);
        var disableStackTotal = type === 'stackTotal' && !((_labelOptions$stackTo = labelOptions.stackTotal) !== null && _labelOptions$stackTo !== void 0 && _labelOptions$stackTo.visible);

        if (disableStackTotal || isUndefined(value)) {
          return;
        }

        labels.splice.apply(labels, [labels.length, 0].concat(dataLabels_toConsumableArray(getLabelInfo(model, labelOptions, _this3.rect, name))));
      });
      this.dataLabelsMap[name] = {
        data: labels,
        options: dataLabelOptions
      };
    }
  }, {
    key: "getDrawModelsAppliedOpacity",
    value: function getDrawModelsAppliedOpacity(opacity) {
      var _this4 = this;

      return Object.keys(this.models).reduce(function (acc, key) {
        return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, acc), {}, component_dataLabels_defineProperty({}, key, _this4.models[key].map(function (m) {
          return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, m), {}, {
            opacity: opacity
          });
        })));
      }, {
        series: [],
        total: []
      });
    }
  }, {
    key: "renderLabelModel",
    value: function renderLabelModel() {
      var _this5 = this;

      return Object.keys(this.dataLabelsMap).map(function (seriesName) {
        var data = _this5.dataLabelsMap[seriesName].data;
        return _this5.makeLabelModel(data);
      }).reduce(function (acc, cur) {
        return {
          series: [].concat(dataLabels_toConsumableArray(acc.series), dataLabels_toConsumableArray(cur.series)),
          total: [].concat(dataLabels_toConsumableArray(acc.total), dataLabels_toConsumableArray(cur.total))
        };
      }, {
        series: [],
        total: []
      });
    }
  }, {
    key: "makeLabelModel",
    value: function makeLabelModel(dataLabels) {
      var _this6 = this;

      return dataLabels.reduce(function (acc, dataLabel) {
        var _acc$modelName;

        var type = dataLabel.type,
            x = dataLabel.x,
            y = dataLabel.y,
            text = dataLabel.text,
            textAlign = dataLabel.textAlign,
            textBaseline = dataLabel.textBaseline,
            name = dataLabel.name,
            callout = dataLabel.callout,
            theme = dataLabel.theme,
            radian = dataLabel.radian;

        if (!isModelExistingInRect(_this6.rect, {
          x: x,
          y: y
        })) {
          return acc;
        }

        var modelName = type === 'stackTotal' ? 'total' : 'series';
        return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, acc), {}, component_dataLabels_defineProperty({}, modelName, [].concat(dataLabels_toConsumableArray((_acc$modelName = acc[modelName]) !== null && _acc$modelName !== void 0 ? _acc$modelName : []), [{
          type: 'dataLabel',
          dataLabelType: type,
          text: text,
          x: x,
          y: y,
          textAlign: textAlign,
          textBaseline: textBaseline,
          opacity: 1,
          name: name,
          callout: callout,
          theme: theme,
          radian: radian
        }])));
      }, {
        series: [],
        total: []
      });
    }
  }]);

  return DataLabels;
}(Component);


;// CONCATENATED MODULE: ./src/component/axisTitle.ts
function axisTitle_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axisTitle_typeof = function _typeof(obj) { return typeof obj; }; } else { axisTitle_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axisTitle_typeof(obj); }

function axisTitle_slicedToArray(arr, i) { return axisTitle_arrayWithHoles(arr) || axisTitle_iterableToArrayLimit(arr, i) || axisTitle_unsupportedIterableToArray(arr, i) || axisTitle_nonIterableRest(); }

function axisTitle_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axisTitle_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axisTitle_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axisTitle_arrayLikeToArray(o, minLen); }

function axisTitle_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axisTitle_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function axisTitle_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
















function axisTitle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axisTitle_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axisTitle_createClass(Constructor, protoProps, staticProps) { if (protoProps) axisTitle_defineProperties(Constructor.prototype, protoProps); if (staticProps) axisTitle_defineProperties(Constructor, staticProps); return Constructor; }

function axisTitle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) axisTitle_setPrototypeOf(subClass, superClass); }

function axisTitle_setPrototypeOf(o, p) { axisTitle_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return axisTitle_setPrototypeOf(o, p); }

function axisTitle_createSuper(Derived) { var hasNativeReflectConstruct = axisTitle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = axisTitle_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = axisTitle_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return axisTitle_possibleConstructorReturn(this, result); }; }

function axisTitle_possibleConstructorReturn(self, call) { if (call && (axisTitle_typeof(call) === "object" || typeof call === "function")) { return call; } return axisTitle_assertThisInitialized(self); }

function axisTitle_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function axisTitle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function axisTitle_getPrototypeOf(o) { axisTitle_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return axisTitle_getPrototypeOf(o); }

function axisTitle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var AxisTitle = /*#__PURE__*/function (_Component) {
  axisTitle_inherits(AxisTitle, _Component);

  var _super = axisTitle_createSuper(AxisTitle);

  function AxisTitle() {
    var _this;

    axisTitle_classCallCheck(this, AxisTitle);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "models", void 0);

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "isYAxis", void 0);

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "isCircularAxis", void 0);

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  axisTitle_createClass(AxisTitle, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axisTitle';
      this.name = name;
      this.isYAxis = includes([AxisType.Y, AxisType.SECONDARY_Y], name);
      this.isCircularAxis = this.name === AxisType.CIRCULAR;
    }
  }, {
    key: "getTitlePosition",
    value: function getTitlePosition(offsetX, offsetY) {
      if (this.isCircularAxis) {
        return [this.rect.width / 2 + offsetX, this.rect.height / 2 + offsetY];
      }

      return this.isYAxis ? [this.name === AxisType.Y ? offsetX : this.rect.width + offsetX, offsetY] : [this.rect.width + offsetX, offsetY];
    }
  }, {
    key: "renderAxisTitle",
    value: function renderAxisTitle(option, textAlign) {
      var text = option.text,
          offsetX = option.offsetX,
          offsetY = option.offsetY;

      var _this$getTitlePositio = this.getTitlePosition(offsetX, offsetY),
          _this$getTitlePositio2 = axisTitle_slicedToArray(_this$getTitlePositio, 2),
          x = _this$getTitlePositio2[0],
          y = _this$getTitlePositio2[1];

      var font = getTitleFontString(this.theme);
      var fillStyle = this.theme.color;
      return [{
        type: 'label',
        text: text,
        x: x,
        y: y,
        style: ['axisTitle', {
          textAlign: textAlign,
          fillStyle: fillStyle,
          font: font
        }]
      }];
    }
  }, {
    key: "getTextAlign",
    value: function getTextAlign() {
      var hasCenterYAxis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.name === AxisType.Y) {
        return hasCenterYAxis ? 'center' : 'left';
      }

      if (this.isCircularAxis) {
        return 'center';
      }

      return 'right';
    }
  }, {
    key: "getCircularAxisTitleRect",
    value: function getCircularAxisTitleRect(option, plotRect, circularAxisData) {
      var x = plotRect.x,
          y = plotRect.y;
      var centerX = circularAxisData.centerX,
          centerY = circularAxisData.centerY,
          axisSize = circularAxisData.axisSize,
          outerRadius = circularAxisData.radius.outer;
      var offsetY = option.offsetY;
      return {
        x: centerX + x - axisSize / 2,
        y: centerY + y - outerRadius / 2,
        width: axisSize,
        height: this.theme.fontSize + offsetY
      };
    }
  }, {
    key: "render",
    value: function render(_ref2) {
      var _radialAxes$this$name, _axes$this$name;

      var axes = _ref2.axes,
          radialAxes = _ref2.radialAxes,
          layout = _ref2.layout,
          theme = _ref2.theme;
      var titleOption = this.isCircularAxis ? (_radialAxes$this$name = radialAxes[this.name]) === null || _radialAxes$this$name === void 0 ? void 0 : _radialAxes$this$name.title : (_axes$this$name = axes[this.name]) === null || _axes$this$name === void 0 ? void 0 : _axes$this$name.title;
      this.isShow = !!titleOption;

      if (!this.isShow) {
        return;
      }

      this.theme = getAxisTheme(theme, this.name).title;
      this.rect = layout["".concat(this.name, "Title")];
      this.models = this.renderAxisTitle(titleOption, this.getTextAlign(!!(axes !== null && axes !== void 0 && axes.centerYAxis)));
    }
  }]);

  return AxisTitle;
}(Component);


;// CONCATENATED MODULE: ./src/component/title.ts
function title_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { title_typeof = function _typeof(obj) { return typeof obj; }; } else { title_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return title_typeof(obj); }














function title_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function title_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function title_createClass(Constructor, protoProps, staticProps) { if (protoProps) title_defineProperties(Constructor.prototype, protoProps); if (staticProps) title_defineProperties(Constructor, staticProps); return Constructor; }

function title_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) title_setPrototypeOf(subClass, superClass); }

function title_setPrototypeOf(o, p) { title_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return title_setPrototypeOf(o, p); }

function title_createSuper(Derived) { var hasNativeReflectConstruct = title_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = title_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = title_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return title_possibleConstructorReturn(this, result); }; }

function title_possibleConstructorReturn(self, call) { if (call && (title_typeof(call) === "object" || typeof call === "function")) { return call; } return title_assertThisInitialized(self); }

function title_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function title_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function title_getPrototypeOf(o) { title_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return title_getPrototypeOf(o); }

function title_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var Title = /*#__PURE__*/function (_Component) {
  title_inherits(Title, _Component);

  var _super = title_createSuper(Title);

  function Title() {
    var _this;

    title_classCallCheck(this, Title);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    title_defineProperty(title_assertThisInitialized(_this), "models", void 0);

    title_defineProperty(title_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  title_createClass(Title, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'title';
      this.name = 'title';
    }
  }, {
    key: "renderTitle",
    value: function renderTitle(options) {
      var text = '';
      var x = 0;
      var y = 0;
      var align = 'left';

      if (utils_isString(options)) {
        text = options;
      } else {
        var _options$align, _options$offsetX, _options$offsetY;

        text = options.text;
        align = (_options$align = options.align) !== null && _options$align !== void 0 ? _options$align : 'left';
        x += (_options$offsetX = options.offsetX) !== null && _options$offsetX !== void 0 ? _options$offsetX : 0;
        y += (_options$offsetY = options.offsetY) !== null && _options$offsetY !== void 0 ? _options$offsetY : 0;
      }

      var font = getTitleFontString(this.theme);
      var textWidth = getTextWidth(text, font);

      if (align === 'center') {
        x += (this.rect.width - textWidth) / 2;
      } else if (align === 'right') {
        x += this.rect.width - textWidth;
      }

      return [{
        type: 'label',
        x: x,
        y: y,
        text: text,
        style: ['title', {
          font: font,
          fillStyle: this.theme.color
        }]
      }];
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var _options$chart;

      var options = _ref.options,
          layout = _ref.layout,
          theme = _ref.theme;
      this.isShow = !!((_options$chart = options.chart) !== null && _options$chart !== void 0 && _options$chart.title);

      if (!this.isShow) {
        return;
      }

      this.theme = theme.title;
      this.rect = layout.title;
      this.models = this.renderTitle(options.chart.title);
    }
  }]);

  return Title;
}(Component);


;// CONCATENATED MODULE: ./src/component/hoveredSeries.ts
function hoveredSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { hoveredSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { hoveredSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return hoveredSeries_typeof(obj); }

function hoveredSeries_slicedToArray(arr, i) { return hoveredSeries_arrayWithHoles(arr) || hoveredSeries_iterableToArrayLimit(arr, i) || hoveredSeries_unsupportedIterableToArray(arr, i) || hoveredSeries_nonIterableRest(); }

function hoveredSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hoveredSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function hoveredSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function hoveredSeries_toConsumableArray(arr) { return hoveredSeries_arrayWithoutHoles(arr) || hoveredSeries_iterableToArray(arr) || hoveredSeries_unsupportedIterableToArray(arr) || hoveredSeries_nonIterableSpread(); }

function hoveredSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hoveredSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return hoveredSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hoveredSeries_arrayLikeToArray(o, minLen); }

function hoveredSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function hoveredSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return hoveredSeries_arrayLikeToArray(arr); }

function hoveredSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















function hoveredSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function hoveredSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function hoveredSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) hoveredSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) hoveredSeries_defineProperties(Constructor, staticProps); return Constructor; }

function hoveredSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) hoveredSeries_setPrototypeOf(subClass, superClass); }

function hoveredSeries_setPrototypeOf(o, p) { hoveredSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return hoveredSeries_setPrototypeOf(o, p); }

function hoveredSeries_createSuper(Derived) { var hasNativeReflectConstruct = hoveredSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = hoveredSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = hoveredSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return hoveredSeries_possibleConstructorReturn(this, result); }; }

function hoveredSeries_possibleConstructorReturn(self, call) { if (call && (hoveredSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return hoveredSeries_assertThisInitialized(self); }

function hoveredSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function hoveredSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function hoveredSeries_getPrototypeOf(o) { hoveredSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return hoveredSeries_getPrototypeOf(o); }

function hoveredSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var guideLineType = {
  line: 'circle',
  area: 'circle',
  boxPlot: 'boxPlot'
};

var HoveredSeries = /*#__PURE__*/function (_Component) {
  hoveredSeries_inherits(HoveredSeries, _Component);

  var _super = hoveredSeries_createSuper(HoveredSeries);

  function HoveredSeries() {
    var _this;

    hoveredSeries_classCallCheck(this, HoveredSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "models", {
      guideLine: []
    });

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "isShow", false);

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "modelForGuideLine", void 0);

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "renderHoveredSeries", function (_ref) {
      var models = _ref.models,
          name = _ref.name,
          eventDetectType = _ref.eventDetectType;

      var prevModels = _this.getSeriesModels(name);

      _this.models[name] = hoveredSeries_toConsumableArray(models);
      _this.isShow = !!_this.getSeriesModels().length;
      var isSame = !!(prevModels !== null && prevModels !== void 0 && prevModels.length) && !!models.length && isSameSeriesResponder({
        models: models,
        comparisonModel: prevModels,
        eventDetectType: eventDetectType,
        name: name
      });

      if (prevModels !== null && prevModels !== void 0 && prevModels.length && !models.length) {
        _this.eventBus.emit('unhoverSeries', makeObservableObjectToNormal(prevModels));
      } else if (models.length && !isSame) {
        _this.eventBus.emit('hoverSeries', makeObservableObjectToNormal(models));
      }

      _this.modelForGuideLine = _this.getModelForGuideLine(name);

      if (eventDetectType === 'grouped') {
        _this.renderGroupedModels(name);
      }
    });

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "resetHoveredSeries", function () {
      _this.models = {
        guideLine: []
      };
    });

    return _this;
  }

  hoveredSeries_createClass(HoveredSeries, [{
    key: "getSeriesModels",
    value: function getSeriesModels(type) {
      var _ref2;

      var _this$models = this.models,
          guideLine = _this$models.guideLine,
          models = _objectWithoutProperties(_this$models, ["guideLine"]);

      return (_ref2 = type ? models[type] : Object.values(models)) === null || _ref2 === void 0 ? void 0 : _ref2.flatMap(function (val) {
        return val;
      });
    }
  }, {
    key: "hasGuideLine",
    value: function hasGuideLine() {
      var _this$getSeriesModels = this.getSeriesModels().filter(function (_ref3) {
        var type = _ref3.type;
        return type === 'rect';
      }),
          _this$getSeriesModels2 = hoveredSeries_slicedToArray(_this$getSeriesModels, 1),
          rectModel = _this$getSeriesModels2[0];

      return !isUndefined(this.modelForGuideLine) && isUndefined(rectModel);
    }
  }, {
    key: "getModelForGuideLine",
    value: function getModelForGuideLine(name) {
      return this.getSeriesModels().filter(function (_ref4) {
        var type = _ref4.type;
        return type === guideLineType[name];
      })[0];
    }
  }, {
    key: "renderGroupedModels",
    value: function renderGroupedModels(name) {
      if (includes(Object.keys(guideLineType), name)) {
        if (this.isShow && this.hasGuideLine()) {
          this.models.guideLine = [this.renderGuideLineModel(this.modelForGuideLine)];
        } else {
          this.models.guideLine = [];
        }
      }
    }
  }, {
    key: "renderGuideLineModel",
    value: function renderGuideLineModel(model) {
      var x = crispPixel(model.type === 'boxPlot' && model.boxPlotDetection ? model.boxPlotDetection.x + model.boxPlotDetection.width / 2 : model.x);
      return {
        type: 'line',
        x: x,
        y: 0,
        x2: x,
        y2: this.rect.height,
        strokeStyle: '#ddd',
        lineWidth: 1
      };
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'hoveredSeries';
      this.name = 'hoveredSeries';
      this.eventBus.on('renderHoveredSeries', this.renderHoveredSeries);
      this.eventBus.on('resetHoveredSeries', this.resetHoveredSeries);
    }
  }, {
    key: "render",
    value: function render(_ref5) {
      var layout = _ref5.layout;
      this.rect = layout.plot;
    }
  }]);

  return HoveredSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/zoom.ts
function zoom_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { zoom_typeof = function _typeof(obj) { return typeof obj; }; } else { zoom_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return zoom_typeof(obj); }

function zoom_toConsumableArray(arr) { return zoom_arrayWithoutHoles(arr) || zoom_iterableToArray(arr) || zoom_unsupportedIterableToArray(arr) || zoom_nonIterableSpread(); }

function zoom_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function zoom_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function zoom_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return zoom_arrayLikeToArray(arr); }

function zoom_slicedToArray(arr, i) { return zoom_arrayWithHoles(arr) || zoom_iterableToArrayLimit(arr, i) || zoom_unsupportedIterableToArray(arr, i) || zoom_nonIterableRest(); }

function zoom_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function zoom_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return zoom_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return zoom_arrayLikeToArray(o, minLen); }

function zoom_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function zoom_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function zoom_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function zoom_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function zoom_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { zoom_ownKeys(Object(source), true).forEach(function (key) { zoom_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { zoom_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

























function zoom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function zoom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function zoom_createClass(Constructor, protoProps, staticProps) { if (protoProps) zoom_defineProperties(Constructor.prototype, protoProps); if (staticProps) zoom_defineProperties(Constructor, staticProps); return Constructor; }

function zoom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) zoom_setPrototypeOf(subClass, superClass); }

function zoom_setPrototypeOf(o, p) { zoom_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return zoom_setPrototypeOf(o, p); }

function zoom_createSuper(Derived) { var hasNativeReflectConstruct = zoom_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = zoom_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = zoom_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return zoom_possibleConstructorReturn(this, result); }; }

function zoom_possibleConstructorReturn(self, call) { if (call && (zoom_typeof(call) === "object" || typeof call === "function")) { return call; } return zoom_assertThisInitialized(self); }

function zoom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function zoom_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function zoom_getPrototypeOf(o) { zoom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return zoom_getPrototypeOf(o); }

function zoom_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var DRAG_MIN_WIDTH = 15;

var Zoom = /*#__PURE__*/function (_Component) {
  zoom_inherits(Zoom, _Component);

  var _super = zoom_createSuper(Zoom);

  function Zoom() {
    var _this;

    zoom_classCallCheck(this, Zoom);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    zoom_defineProperty(zoom_assertThisInitialized(_this), "models", {
      selectionArea: []
    });

    zoom_defineProperty(zoom_assertThisInitialized(_this), "responders", void 0);

    zoom_defineProperty(zoom_assertThisInitialized(_this), "startIndex", void 0);

    zoom_defineProperty(zoom_assertThisInitialized(_this), "dragStartPosition", null);

    zoom_defineProperty(zoom_assertThisInitialized(_this), "dragStartPoint", null);

    zoom_defineProperty(zoom_assertThisInitialized(_this), "isDragging", false);

    return _this;
  }

  zoom_createClass(Zoom, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'zoom';
    }
  }, {
    key: "render",
    value: function render(state, computed) {
      var _viewRange$;

      if (!state.zoomRange) {
        return;
      }

      this.resetSelectionArea();
      var viewRange = computed.viewRange;
      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          scale = state.scale;
      var categories = state.categories;
      this.rect = layout.plot;
      this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
      var coordinateChart = isCoordinateSeries(series);

      if (coordinateChart) {
        var responderInfo = this.getRectResponderInfoForCoordinateType(series, scale, axes.xAxis, categories);
        this.responders = this.makeRectResponderModelForCoordinateType(responderInfo, categories);
      } else {
        this.responders = this.makeRectResponderModel(categories, axes.xAxis);
      }
    }
  }, {
    key: "getRectResponderInfoForCoordinateType",
    value: function getRectResponderInfoForCoordinateType(series, scale, axisData, categories) {
      var _this2 = this;

      var points = [];
      var duplicateCheckMap = {};
      Object.keys(series).forEach(function (seriesName) {
        var data = series[seriesName].data;
        data.forEach(function (_ref) {
          var rawData = _ref.rawData;
          rawData.forEach(function (datum, idx) {
            if (isNull(datum)) {
              return;
            }

            var dataIndex = getCoordinateDataIndex(datum, categories, idx, _this2.startIndex);
            var x = getXPosition(axisData, _this2.rect.width, getCoordinateXValue(datum), dataIndex);
            var xWithinRect = x >= 0 && x <= _this2.rect.width;

            if (!duplicateCheckMap[x] && xWithinRect) {
              duplicateCheckMap[x] = true;
              points.push({
                x: x,
                label: categories[dataIndex]
              });
            }
          });
        });
      });
      return points;
    }
  }, {
    key: "resetSelectionArea",
    value: function resetSelectionArea() {
      this.dragStartPosition = null;
      this.dragStartPoint = null;
      this.models.selectionArea = [];
      this.isDragging = false;
    }
  }, {
    key: "onMousedown",
    value: function onMousedown(_ref2) {
      var responders = _ref2.responders,
          mousePosition = _ref2.mousePosition;

      if (responders.length) {
        this.dragStartPoint = responders.find(function (responder) {
          return responder.data.name === 'selectionArea';
        });
        this.dragStartPosition = mousePosition;
      }
    }
  }, {
    key: "onMouseup",
    value: function onMouseup(_ref3) {
      var _this3 = this;

      var responders = _ref3.responders;

      if (this.isDragging && this.dragStartPoint && responders.length) {
        var dragRange = [this.dragStartPoint, responders[0]].sort(function (a, b) {
          return a.index - b.index;
        }).map(function (m) {
          var _m$data;

          return (_m$data = m.data) === null || _m$data === void 0 ? void 0 : _m$data.value;
        });
        this.store.dispatch('zoom', dragRange);
        this.eventBus.emit('zoom', makeObservableObjectToNormal(dragRange));
        this.eventBus.emit('resetHoveredSeries');
        this.eventBus.emit('hideTooltip'); // @TODO: Should occur after the series' click event
        // Additional logic to control the sequence of events with each other is required.

        setTimeout(function () {
          _this3.eventBus.emit('resetSelectedSeries');
        });
      }

      this.resetSelectionArea();
    }
  }, {
    key: "makeRectResponderModel",
    value: function makeRectResponderModel(categories, axisData) {
      var categorySize = categories.length;
      var pointOnColumn = axisData.pointOnColumn,
          tickDistance = axisData.tickDistance;
      var height = this.rect.height;
      var halfDetectAreaIndex = pointOnColumn ? [] : [0, categorySize - 1];
      var halfWidth = tickDistance / 2;
      return range(0, categorySize).map(function (index) {
        var half = halfDetectAreaIndex.includes(index);
        var width = half ? halfWidth : tickDistance;
        var startX = 0;

        if (index !== 0) {
          startX += pointOnColumn ? tickDistance * index : halfWidth + tickDistance * (index - 1);
        }

        return {
          type: 'rect',
          x: startX,
          y: 0,
          height: height,
          width: width,
          index: index,
          data: {
            name: 'selectionArea',
            value: categories[index]
          }
        };
      });
    }
  }, {
    key: "makeRectResponderModelForCoordinateType",
    value: function makeRectResponderModelForCoordinateType(responderInfo, categories) {
      var responders = responders_makeRectResponderModelForCoordinateType(responderInfo, this.rect);

      return responders.map(function (m, idx) {
        return zoom_objectSpread(zoom_objectSpread({}, m), {}, {
          data: {
            name: 'selectionArea',
            value: categories[idx]
          }
        });
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders,
          mousePosition = _ref4.mousePosition;

      if (!responders.length) {
        return;
      }

      if (this.dragStartPosition && !this.isDragging) {
        var x = mousePosition.x;
        var startX = this.dragStartPosition.x;
        this.isDragging = Math.abs(startX - x) > DRAG_MIN_WIDTH;
      }

      if (this.isDragging) {
        var startIndex = this.dragStartPoint.index;
        var endIndex = responders[0].index;

        var _sort = [startIndex, endIndex].sort(sortNumber),
            _sort2 = zoom_slicedToArray(_sort, 2),
            start = _sort2[0],
            end = _sort2[1];

        var includedResponders = this.responders.slice(start, end + 1);
        this.models.selectionArea = zoom_toConsumableArray(includedResponders.map(function (m) {
          return zoom_objectSpread(zoom_objectSpread({}, m), {}, {
            x: m.x,
            y: 0,
            type: 'rect',
            color: 'rgba(0, 0, 0, 0.2)'
          });
        }));
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMouseoutComponent",
    value: function onMouseoutComponent() {
      this.resetSelectionArea();
    }
  }]);

  return Zoom;
}(Component);


;// CONCATENATED MODULE: ./src/component/resetButton.ts
function resetButton_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { resetButton_typeof = function _typeof(obj) { return typeof obj; }; } else { resetButton_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return resetButton_typeof(obj); }














function resetButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function resetButton_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function resetButton_createClass(Constructor, protoProps, staticProps) { if (protoProps) resetButton_defineProperties(Constructor.prototype, protoProps); if (staticProps) resetButton_defineProperties(Constructor, staticProps); return Constructor; }

function resetButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) resetButton_setPrototypeOf(subClass, superClass); }

function resetButton_setPrototypeOf(o, p) { resetButton_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return resetButton_setPrototypeOf(o, p); }

function resetButton_createSuper(Derived) { var hasNativeReflectConstruct = resetButton_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = resetButton_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = resetButton_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return resetButton_possibleConstructorReturn(this, result); }; }

function resetButton_possibleConstructorReturn(self, call) { if (call && (resetButton_typeof(call) === "object" || typeof call === "function")) { return call; } return resetButton_assertThisInitialized(self); }

function resetButton_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function resetButton_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function resetButton_getPrototypeOf(o) { resetButton_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return resetButton_getPrototypeOf(o); }

function resetButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var ResetButton = /*#__PURE__*/function (_Component) {
  resetButton_inherits(ResetButton, _Component);

  var _super = resetButton_createSuper(ResetButton);

  function ResetButton() {
    var _this;

    resetButton_classCallCheck(this, ResetButton);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    resetButton_defineProperty(resetButton_assertThisInitialized(_this), "responders", void 0);

    resetButton_defineProperty(resetButton_assertThisInitialized(_this), "models", void 0);

    return _this;
  }

  resetButton_createClass(ResetButton, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'resetButton';
      this.name = 'resetButton';
    }
  }, {
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        this.eventBus.emit('resetZoom');
        this.store.dispatch('resetZoom');
      }
    }
  }, {
    key: "render",
    value: function render(_ref2, computed) {
      var options = _ref2.options,
          layout = _ref2.layout;

      if (!isUsingResetButton(options)) {
        return;
      }

      this.rect = layout.resetButton;
      this.isShow = computed.isLineTypeSeriesZooming;
      this.models = this.isShow ? [{
        type: 'resetButton',
        x: 0,
        y: 0
      }] : [];
      this.responders = this.isShow ? [{
        type: 'rect',
        x: 0,
        y: 0,
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE
      }] : [];
    }
  }]);

  return ResetButton;
}(Component);


;// CONCATENATED MODULE: ./src/component/selectedSeries.ts
function selectedSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { selectedSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { selectedSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return selectedSeries_typeof(obj); }

function selectedSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function selectedSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { selectedSeries_ownKeys(Object(source), true).forEach(function (key) { selectedSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { selectedSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






















function selectedSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function selectedSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function selectedSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) selectedSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) selectedSeries_defineProperties(Constructor, staticProps); return Constructor; }

function selectedSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) selectedSeries_setPrototypeOf(subClass, superClass); }

function selectedSeries_setPrototypeOf(o, p) { selectedSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return selectedSeries_setPrototypeOf(o, p); }

function selectedSeries_createSuper(Derived) { var hasNativeReflectConstruct = selectedSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = selectedSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = selectedSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return selectedSeries_possibleConstructorReturn(this, result); }; }

function selectedSeries_possibleConstructorReturn(self, call) { if (call && (selectedSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return selectedSeries_assertThisInitialized(self); }

function selectedSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function selectedSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function selectedSeries_getPrototypeOf(o) { selectedSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return selectedSeries_getPrototypeOf(o); }

function selectedSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var SelectedSeries = /*#__PURE__*/function (_Component) {
  selectedSeries_inherits(SelectedSeries, _Component);

  var _super = selectedSeries_createSuper(SelectedSeries);

  function SelectedSeries() {
    var _this;

    selectedSeries_classCallCheck(this, SelectedSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "models", {});

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "seriesModels", {});

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "activeSeriesNames", {});

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "isShow", false);

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "renderSelectedSeries", function (selectedSeriesEventModel) {
      var name = selectedSeriesEventModel.name,
          alias = selectedSeriesEventModel.alias;

      var models = _this.getSelectedSeriesModelsForRendering(selectedSeriesEventModel);

      _this.models[alias || name] = isSameSeriesResponder(selectedSeries_objectSpread(selectedSeries_objectSpread({}, selectedSeriesEventModel), {}, {
        models: models,
        comparisonModel: _this.models[alias || name]
      })) ? [] : models;
      _this.seriesModels[alias || name] = _this.getSelectedSeriesModels(selectedSeriesEventModel);
      _this.isShow = !!Object.values(_this.models).flatMap(function (value) {
        return value;
      }).length;

      _this.eventBus.emit(_this.isShow ? 'selectSeries' : 'unselectSeries', makeObservableObjectToNormal(_this.seriesModels));

      _this.activeSeriesNames[name] = _this.getSeriesNames(selectedSeriesEventModel.models, name);

      _this.setActiveState();
    });

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "resetSelectedSeries", function () {
      _this.models = {};

      _this.store.dispatch('setAllLegendActiveState', true);
    });

    return _this;
  }

  selectedSeries_createClass(SelectedSeries, [{
    key: "getSeriesNames",
    value: function getSeriesNames(selectedSeries, name) {
      var _this2 = this;

      var names = [];

      if (includes(['line', 'area', 'radar', 'bubble', 'scatter', 'bullet', 'boxPlot'], name)) {
        selectedSeries.forEach(function (model) {
          var label = model.name;

          if (label) {
            names.push(label);
          }
        });
      } else if (includes(['bar', 'column', 'radialBar'], name)) {
        selectedSeries.forEach(function (model) {
          var _data;

          var label = (_data = model.data) === null || _data === void 0 ? void 0 : _data.label;

          if (label) {
            names.push(label);
          }
        });
      } else if (name === 'pie') {
        Object.keys(this.models).flatMap(function (key) {
          return _this2.models[key];
        }).forEach(function (model) {
          var _data2, _data3;

          var label = ((_data2 = model.data) === null || _data2 === void 0 ? void 0 : _data2.rootParentName) || ((_data3 = model.data) === null || _data3 === void 0 ? void 0 : _data3.label);

          if (label) {
            names.push(label);
          }
        });
      }

      return names;
    }
  }, {
    key: "getSelectedSeriesModelsForRendering",
    value: function getSelectedSeriesModelsForRendering(selectedSeriesEventModel) {
      var models = selectedSeriesEventModel.models,
          eventDetectType = selectedSeriesEventModel.eventDetectType,
          name = selectedSeriesEventModel.name;
      var renderingModels = models;

      if ((name === 'column' || name === 'bar' || name === 'bullet') && eventDetectType === 'grouped') {
        renderingModels = models.filter(function (model) {
          return !model.data;
        });
      } else if (name === 'radialBar' && eventDetectType === 'grouped') {
        renderingModels = models.filter(function (model) {
          return !model.data;
        });
      }

      return renderingModels;
    }
  }, {
    key: "getSelectedSeriesModels",
    value: function getSelectedSeriesModels(selectedSeriesEventModel) {
      var models = selectedSeriesEventModel.models,
          eventDetectType = selectedSeriesEventModel.eventDetectType,
          name = selectedSeriesEventModel.name;
      var selectedSeriesModels = models;

      if ((name === 'column' || name === 'bar' || name === 'bullet') && eventDetectType === 'grouped') {
        selectedSeriesModels = models.filter(function (model) {
          return model.data;
        });
      } else if (name === 'radialBar' && eventDetectType === 'grouped') {
        selectedSeriesModels = models.filter(function (model) {
          return model.data;
        });
      }

      return selectedSeriesModels;
    }
  }, {
    key: "setActiveState",
    value: function setActiveState() {
      var _this3 = this;

      if (this.isShow) {
        this.store.dispatch('setAllLegendActiveState', false);
        Object.values(this.activeSeriesNames).forEach(function (names) {
          names.forEach(function (name) {
            _this3.store.dispatch('setLegendActiveState', {
              name: name,
              active: true
            });
          });
        });
      } else {
        this.store.dispatch('setAllLegendActiveState', true);
      }

      this.eventBus.emit('needDraw');
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'selectedSeries';
      this.name = 'selectedSeries';
      this.eventBus.on('renderSelectedSeries', this.renderSelectedSeries);
      this.eventBus.on('resetSelectedSeries', this.resetSelectedSeries);
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout;
      this.rect = layout.plot;
    }
  }]);

  return SelectedSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/background.ts
function background_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { background_typeof = function _typeof(obj) { return typeof obj; }; } else { background_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return background_typeof(obj); }

function background_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function background_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { background_ownKeys(Object(source), true).forEach(function (key) { background_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { background_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



















function background_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function background_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function background_createClass(Constructor, protoProps, staticProps) { if (protoProps) background_defineProperties(Constructor.prototype, protoProps); if (staticProps) background_defineProperties(Constructor, staticProps); return Constructor; }

function background_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) background_setPrototypeOf(subClass, superClass); }

function background_setPrototypeOf(o, p) { background_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return background_setPrototypeOf(o, p); }

function background_createSuper(Derived) { var hasNativeReflectConstruct = background_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = background_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = background_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return background_possibleConstructorReturn(this, result); }; }

function background_possibleConstructorReturn(self, call) { if (call && (background_typeof(call) === "object" || typeof call === "function")) { return call; } return background_assertThisInitialized(self); }

function background_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function background_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function background_getPrototypeOf(o) { background_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return background_getPrototypeOf(o); }

function background_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Background = /*#__PURE__*/function (_Component) {
  background_inherits(Background, _Component);

  var _super = background_createSuper(Background);

  function Background() {
    var _this;

    background_classCallCheck(this, Background);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    background_defineProperty(background_assertThisInitialized(_this), "models", void 0);

    background_defineProperty(background_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  background_createClass(Background, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'background';
      this.name = 'background';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          theme = _ref.theme;
      var _layout$chart = layout.chart,
          width = _layout$chart.width,
          height = _layout$chart.height;
      this.theme = theme.chart;
      this.rect = {
        x: 0,
        y: 0,
        width: width,
        height: height
      };
      this.models = [background_objectSpread(background_objectSpread({
        type: 'rect'
      }, this.rect), {}, {
        color: this.theme.backgroundColor
      })];
    }
  }]);

  return Background;
}(Component);


;// CONCATENATED MODULE: ./src/component/noDataText.ts
function noDataText_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { noDataText_typeof = function _typeof(obj) { return typeof obj; }; } else { noDataText_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return noDataText_typeof(obj); }

function noDataText_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function noDataText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { noDataText_ownKeys(Object(source), true).forEach(function (key) { noDataText_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { noDataText_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



















function noDataText_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function noDataText_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function noDataText_createClass(Constructor, protoProps, staticProps) { if (protoProps) noDataText_defineProperties(Constructor.prototype, protoProps); if (staticProps) noDataText_defineProperties(Constructor, staticProps); return Constructor; }

function noDataText_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) noDataText_setPrototypeOf(subClass, superClass); }

function noDataText_setPrototypeOf(o, p) { noDataText_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return noDataText_setPrototypeOf(o, p); }

function noDataText_createSuper(Derived) { var hasNativeReflectConstruct = noDataText_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = noDataText_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = noDataText_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return noDataText_possibleConstructorReturn(this, result); }; }

function noDataText_possibleConstructorReturn(self, call) { if (call && (noDataText_typeof(call) === "object" || typeof call === "function")) { return call; } return noDataText_assertThisInitialized(self); }

function noDataText_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function noDataText_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function noDataText_getPrototypeOf(o) { noDataText_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return noDataText_getPrototypeOf(o); }

function noDataText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var DEFAULT_NO_DATA_TEXT = 'No data to display';

var NoDataText = /*#__PURE__*/function (_Component) {
  noDataText_inherits(NoDataText, _Component);

  var _super = noDataText_createSuper(NoDataText);

  function NoDataText() {
    var _this;

    noDataText_classCallCheck(this, NoDataText);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    noDataText_defineProperty(noDataText_assertThisInitialized(_this), "models", void 0);

    return _this;
  }

  noDataText_createClass(NoDataText, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'noDataText';
      this.name = 'noDataText';
    }
  }, {
    key: "getCenterPosition",
    value: function getCenterPosition(text, font) {
      var textWidth = getTextWidth(text, font);
      var textHeight = getTextHeight(text, font);
      return {
        x: (this.rect.width - textWidth) / 2,
        y: (this.rect.height - textHeight) / 2
      };
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var _options$lang$noData, _options$lang;

      var layout = _ref.layout,
          series = _ref.series,
          options = _ref.options,
          theme = _ref.theme;
      var text = (_options$lang$noData = options === null || options === void 0 ? void 0 : (_options$lang = options.lang) === null || _options$lang === void 0 ? void 0 : _options$lang.noData) !== null && _options$lang$noData !== void 0 ? _options$lang$noData : DEFAULT_NO_DATA_TEXT;
      var labelTheme = theme.noData;
      var font = getTitleFontString(labelTheme);
      var fillStyle = labelTheme.color;
      this.isShow = isNoData(series);
      this.rect = layout.plot;
      this.models = [noDataText_objectSpread(noDataText_objectSpread({
        type: 'label'
      }, this.getCenterPosition(text, font)), {}, {
        text: text,
        style: [{
          font: font,
          fillStyle: fillStyle
        }]
      })];
    }
  }]);

  return NoDataText;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/lineSeries.ts



function linePoints(ctx, pointsModel) {
  var strokeStyle = pointsModel.color,
      lineWidth = pointsModel.lineWidth,
      points = pointsModel.points,
      _pointsModel$dashSegm = pointsModel.dashSegments,
      dashSegments = _pointsModel$dashSegm === void 0 ? [] : _pointsModel$dashSegm;
  ctx.lineCap = 'round';
  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  var start = false;
  points.forEach(function (point, idx) {
    var _points, _points$controlPoint;

    if (isNull(point)) {
      start = false;
      return;
    }

    if (!start) {
      ctx.moveTo(point.x, point.y);
      start = true;
      return;
    }

    if (point.controlPoint && (_points = points[idx - 1]) !== null && _points !== void 0 && (_points$controlPoint = _points.controlPoint) !== null && _points$controlPoint !== void 0 && _points$controlPoint.next) {
      var _next = points[idx - 1].controlPoint.next,
          prevX = _next.x,
          prevY = _next.y;
      var controlPoint = point.controlPoint,
          x = point.x,
          y = point.y;
      ctx.bezierCurveTo(prevX, prevY, controlPoint.prev.x, controlPoint.prev.y, x, y);
    } else {
      ctx.lineTo(point.x, point.y);
    }
  });
  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
  setLineDash(ctx, []);
}
function areaPoints(ctx, areaPointsModel) {
  var fillColor = areaPointsModel.fillColor;
  ctx.beginPath();
  linePoints(ctx, areaPointsModel);
  fillStyle(ctx, fillColor);
  ctx.closePath();
}
;// CONCATENATED MODULE: ./src/brushes/exportMenu.ts
function exportMenu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function exportMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { exportMenu_ownKeys(Object(source), true).forEach(function (key) { brushes_exportMenu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { exportMenu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function brushes_exportMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










function drawXIcon(ctx, icon, rectSize) {
  var startX = icon.x,
      startY = icon.y,
      _icon$theme = icon.theme,
      strokeStyle = _icon$theme.color,
      lineWidth = _icon$theme.lineWidth;
  var offset = rectSize / 3;
  var x = startX + offset;
  var y = startY + offset;
  var x2 = startX + offset * 2;
  var y2 = startY + offset * 2;
  var points = [{
    x: x,
    y: y,
    x2: x2,
    y2: y2
  }, {
    x: x,
    y: y2,
    x2: x2,
    y2: y
  }];
  points.forEach(function (p) {
    line(ctx, exportMenu_objectSpread(exportMenu_objectSpread({
      type: 'line'
    }, p), {}, {
      strokeStyle: strokeStyle,
      lineWidth: lineWidth
    }));
  });
}

function drawMoreIcon(ctx, icon, rectSize) {
  var x = icon.x,
      y = icon.y,
      _icon$theme2 = icon.theme,
      color = _icon$theme2.color,
      width = _icon$theme2.width,
      height = _icon$theme2.height,
      gap = _icon$theme2.gap;
  var paddingX = (rectSize - width) / 2;
  var paddingY = (rectSize - (height * 3 + gap * 2)) / 2;
  var centerX = x + paddingX;
  var points = [{
    x: centerX,
    y: y + paddingY
  }, {
    x: centerX,
    y: y + paddingY + height + gap
  }, {
    x: centerX,
    y: y + paddingY + (height + gap) * 2
  }];
  points.forEach(function (p) {
    rect(ctx, exportMenu_objectSpread(exportMenu_objectSpread({
      type: 'rect'
    }, p), {}, {
      color: color,
      width: width,
      height: height
    }));
  });
}

function exportMenuButton(ctx, exportMenuButtonModel) {
  var opened = exportMenuButtonModel.opened,
      xPos = exportMenuButtonModel.x,
      yPos = exportMenuButtonModel.y,
      theme = exportMenuButtonModel.theme;
  var _ref = theme,
      borderColor = _ref.borderColor,
      backgroundColor = _ref.backgroundColor,
      borderWidth = _ref.borderWidth,
      borderRadius = _ref.borderRadius,
      xIcon = _ref.xIcon,
      dotIcon = _ref.dotIcon;
  var x = xPos + borderWidth;
  var y = yPos + borderWidth;
  var rectSize = BUTTON_RECT_SIZE - 2 * borderWidth;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: backgroundColor,
    stroke: borderColor,
    width: rectSize,
    height: rectSize,
    radius: borderRadius,
    lineWidth: borderWidth
  });

  if (opened) {
    drawXIcon(ctx, {
      x: x,
      y: y,
      theme: xIcon
    }, rectSize);
  } else {
    drawMoreIcon(ctx, {
      x: x,
      y: y,
      theme: dotIcon
    }, rectSize);
  }
}
;// CONCATENATED MODULE: ./src/brushes/resetButton.ts



var ARROW_HEIGHT = 3;
var ARROW_WIDTH = 6;

function drawResetIcon(ctx, point) {
  var x = point.x,
      y = point.y;
  var centerX = x + BUTTON_RECT_SIZE / 2;
  var centerY = y + BUTTON_RECT_SIZE / 2;
  var tickSize = BUTTON_RECT_SIZE / 10;
  var color = '#545454';
  circle(ctx, {
    type: 'circle',
    x: centerX,
    y: centerY,
    radius: tickSize * 2,
    angle: {
      start: 0,
      end: Math.PI / 2
    },
    color: 'transparent',
    style: [{
      lineWidth: 2,
      strokeStyle: color
    }]
  });
  var pointStartX = centerX + tickSize * 2;
  var pointStartY = centerY;
  var points = [{
    x: pointStartX - ARROW_WIDTH / 2,
    y: pointStartY
  }, {
    x: pointStartX + ARROW_WIDTH / 2,
    y: pointStartY
  }, {
    x: pointStartX,
    y: pointStartY + ARROW_HEIGHT
  }];
  areaPoints(ctx, {
    type: 'areaPoints',
    points: points,
    lineWidth: 1,
    color: color,
    fillColor: color
  });
}

function drawBackIcon(ctx, point) {
  var barWidth = 4;
  var radius = BUTTON_RECT_SIZE / 7;
  var x = point.x,
      y = point.y;
  var centerX = x + BUTTON_RECT_SIZE / 2;
  var centerY = y + BUTTON_RECT_SIZE / 2;
  var color = '#545454';
  line(ctx, {
    type: 'line',
    lineWidth: 2,
    x: centerX - barWidth / 2,
    y: centerY + radius,
    x2: centerX + barWidth / 2,
    y2: centerY + radius,
    strokeStyle: color
  });
  line(ctx, {
    type: 'line',
    lineWidth: 2,
    x: centerX - barWidth / 2,
    y: centerY - radius,
    x2: centerX + barWidth / 2,
    y2: centerY - radius,
    strokeStyle: color
  });
  circle(ctx, {
    type: 'circle',
    x: centerX + barWidth / 2,
    y: centerY,
    radius: radius,
    angle: {
      start: Math.PI / 2,
      end: Math.PI * 3 / 2
    },
    color: 'transparent',
    style: [{
      lineWidth: 2,
      strokeStyle: color
    }]
  });
  var pointStartX = centerX - barWidth / 2;
  var pointStartY = centerY - radius;
  var points = [{
    x: pointStartX - ARROW_HEIGHT,
    y: pointStartY
  }, {
    x: pointStartX,
    y: pointStartY - ARROW_WIDTH / 2
  }, {
    x: pointStartX,
    y: pointStartY + ARROW_WIDTH / 2
  }];
  areaPoints(ctx, {
    type: 'areaPoints',
    points: points,
    lineWidth: 1,
    color: color,
    fillColor: color
  });
}

function backButton(ctx, backButtonModel) {
  var x = backButtonModel.x,
      y = backButtonModel.y;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: '#f4f4f4',
    stroke: '#f4f4f4',
    width: BUTTON_RECT_SIZE,
    height: BUTTON_RECT_SIZE,
    radius: 5
  });
  drawBackIcon(ctx, {
    x: x,
    y: y
  });
}
function resetButton(ctx, resetButtonModel) {
  var x = resetButtonModel.x,
      y = resetButtonModel.y;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: '#f4f4f4',
    stroke: '#f4f4f4',
    width: BUTTON_RECT_SIZE,
    height: BUTTON_RECT_SIZE,
    radius: 5
  });
  drawResetIcon(ctx, {
    x: x,
    y: y
  });
}
;// CONCATENATED MODULE: ./src/charts/lineChart.ts
function lineChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineChart_typeof(obj); }


















function lineChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function lineChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineChart_ownKeys(Object(source), true).forEach(function (key) { lineChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function lineChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineChart_defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineChart_setPrototypeOf(subClass, superClass); }

function lineChart_setPrototypeOf(o, p) { lineChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineChart_setPrototypeOf(o, p); }

function lineChart_createSuper(Derived) { var hasNativeReflectConstruct = lineChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineChart_possibleConstructorReturn(this, result); }; }

function lineChart_possibleConstructorReturn(self, call) { if (call && (lineChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineChart_assertThisInitialized(self); }

function lineChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function lineChart_getPrototypeOf(o) { lineChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineChart_getPrototypeOf(o); }






























/**
 * @class
 * @classdesc Line Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Line Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Object|Array>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Line Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var LineChart = /*#__PURE__*/function (_Chart) {
  lineChart_inherits(LineChart, _Chart);

  var _super = lineChart_createSuper(LineChart);

  function LineChart(props) {
    var _props$data;

    lineChart_classCallCheck(this, LineChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        line: props.data.series
      },
      categories: (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  lineChart_createClass(LineChart, [{
    key: "initialize",
    value: function initialize() {
      _get(lineChart_getPrototypeOf(LineChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(LineSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(DataLabels);
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(Zoom);
      this.componentManager.add(ResetButton);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number|Object|Array>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      var _this$store$state$opt;

      if ((_this$store$state$opt = this.store.state.options.series) !== null && _this$store$state$opt !== void 0 && _this$store$state$opt.showDot) {
        this.animationControlFlag.updating = true;
      }

      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Object|Array>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          line: series
        },
        categories: categories
      });
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *    @param {string|number} data.value - The value where the plot line will be drawn.
     *    @param {string} data.color - Plot line color.
     *    @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     *   @param {Array<string|number>} data.range - The range to be drawn.
     *   @param {string} data.color - Plot band color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', lineChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return LineChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/pieSeries.ts
function pieSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { pieSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { pieSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return pieSeries_typeof(obj); }

function pieSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function pieSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pieSeries_ownKeys(Object(source), true).forEach(function (key) { pieSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pieSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function pieSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function pieSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function pieSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) pieSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) pieSeries_defineProperties(Constructor, staticProps); return Constructor; }

function pieSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) pieSeries_setPrototypeOf(subClass, superClass); }

function pieSeries_setPrototypeOf(o, p) { pieSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return pieSeries_setPrototypeOf(o, p); }

function pieSeries_createSuper(Derived) { var hasNativeReflectConstruct = pieSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = pieSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = pieSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return pieSeries_possibleConstructorReturn(this, result); }; }

function pieSeries_possibleConstructorReturn(self, call) { if (call && (pieSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return pieSeries_assertThisInitialized(self); }

function pieSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function pieSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function pieSeries_getPrototypeOf(o) { pieSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return pieSeries_getPrototypeOf(o); }

function pieSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




































function getCalculatedRadiusRange(_ref) {
  var alias = _ref.alias,
      renderOptions = _ref.renderOptions,
      radiusRangeMap = _ref.radiusRangeMap,
      pieIndex = _ref.pieIndex,
      radiusRanges = _ref.radiusRanges,
      totalPieAliasCount = _ref.totalPieAliasCount;
  var radiusRangeLength = Object.keys(radiusRangeMap).length;
  var _renderOptions$defaul = renderOptions.defaultRadius,
      defaultRadius = _renderOptions$defaul === void 0 ? 0 : _renderOptions$defaul;
  var _renderOptions$radius = renderOptions.radiusRange,
      inner = _renderOptions$radius.inner,
      outer = _renderOptions$radius.outer;

  if (!radiusRangeMap[alias]) {
    if (!radiusRangeLength) {
      var radius = defaultRadius / totalPieAliasCount;
      inner = pieIndex * radius;
      outer = (pieIndex + 1) * radius;
    } else {
      var _radiusRanges;

      if (pieIndex && radiusRanges[pieIndex - 1].outer) {
        inner = radiusRanges[pieIndex - 1].outer;
      }

      if ((_radiusRanges = radiusRanges[pieIndex + 1]) !== null && _radiusRanges !== void 0 && _radiusRanges.inner) {
        outer = radiusRanges[pieIndex + 1].inner;
      } else if (pieIndex === totalPieAliasCount - 1) {
        outer = defaultRadius;
      } else {
        var _radiusRanges$outer, _radiusRanges2, _radiusRanges$inner, _radiusRanges3;

        var _radius = (defaultRadius - ((_radiusRanges$outer = (_radiusRanges2 = radiusRanges[pieIndex - 1]) === null || _radiusRanges2 === void 0 ? void 0 : _radiusRanges2.outer) !== null && _radiusRanges$outer !== void 0 ? _radiusRanges$outer : 0) - ((_radiusRanges$inner = (_radiusRanges3 = radiusRanges[pieIndex + 1]) === null || _radiusRanges3 === void 0 ? void 0 : _radiusRanges3.inner) !== null && _radiusRanges$inner !== void 0 ? _radiusRanges$inner : 0)) / (totalPieAliasCount - radiusRangeLength);

        outer = inner + _radius;
      }
    }
  }

  return {
    inner: inner,
    outer: outer
  };
}

function getPieSeriesOpacityByDepth(originAlpha, depth, indexOfGroup) {
  var brightness = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.85;
  var depthAlpha = Number((originAlpha * Math.pow(brightness, depth)).toFixed(2));
  return Number(Math.pow(depthAlpha, indexOfGroup + 1).toFixed(2));
}

function getMaxDataLabelSize(seriesNameLabels, options, dataLabelTheme) {
  var _options$pieSeriesNam, _options$pieSeriesNam2;

  var outerLabels = [{
    hasOuterLabel: options.visible && options.anchor === 'outer',
    labels: ['00.00%'],
    // up to 5 digits
    theme: dataLabelTheme
  }, {
    hasOuterLabel: ((_options$pieSeriesNam = options.pieSeriesName) === null || _options$pieSeriesNam === void 0 ? void 0 : _options$pieSeriesNam.visible) && ((_options$pieSeriesNam2 = options.pieSeriesName) === null || _options$pieSeriesNam2 === void 0 ? void 0 : _options$pieSeriesNam2.anchor) === 'outer',
    labels: seriesNameLabels,
    theme: dataLabelTheme.pieSeriesName
  }];
  return outerLabels.reduce(function (acc, cur) {
    var width = acc.width,
        height = acc.height;
    var hasOuterLabel = cur.hasOuterLabel,
        labels = cur.labels,
        theme = cur.theme;

    if (hasOuterLabel) {
      var _getMaxLabelSize = getMaxLabelSize(labels, 0, getFont(theme)),
          maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
          maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

      return {
        width: Math.max(maxLabelWidth + RADIUS_PADDING, width),
        height: Math.max(maxLabelHeight + RADIUS_PADDING, height)
      };
    }

    return acc;
  }, {
    width: 0,
    height: 0
  });
}

var PieSeries = /*#__PURE__*/function (_Component) {
  pieSeries_inherits(PieSeries, _Component);

  var _super = pieSeries_createSuper(PieSeries);

  function PieSeries() {
    var _this;

    pieSeries_classCallCheck(this, PieSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "drawModels", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "responders", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "activatedResponders", []);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "alias", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "theme", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "selectSeries", function (_ref2) {
      var seriesIndex = _ref2.seriesIndex,
          name = _ref2.name;

      if (!isNumber(seriesIndex) || !isUndefined(name) && name !== _this.alias) {
        return;
      }

      var model = _this.responders[seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getResponderModelsWithTheme([model], 'select'),
        name: _this.name,
        alias: _this.alias
      });

      _this.eventBus.emit('needDraw');
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var seriesIndex = _ref3.seriesIndex,
          name = _ref3.name;

      if (!isNumber(seriesIndex) || !isUndefined(name) && name !== _this.alias) {
        return;
      }

      var models = [_this.responders[seriesIndex]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: _this.getResponderModelsWithTheme(models, 'hover'),
        name: _this.name,
        alias: _this.alias
      });

      _this.activatedResponders = _this.makeTooltipResponder(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  pieSeries_createClass(PieSeries, [{
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      var currentDegree;
      var index = this.models.series.findIndex(function (_ref4) {
        var clockwise = _ref4.clockwise,
            _ref4$degree = _ref4.degree,
            start = _ref4$degree.start,
            end = _ref4$degree.end,
            totalAngle = _ref4.totalAngle;
        currentDegree = clockwise ? totalAngle * delta : DEGREE_360 - totalAngle * delta;
        return withinRadian(clockwise, start, end, currentDegree);
      });
      this.syncEndAngle(index < 0 ? this.models.series.length : index);

      if (~index) {
        this.drawModels.series[index].degree.end = currentDegree;
      }
    }
  }, {
    key: "syncEndAngle",
    value: function syncEndAngle(index) {
      if (index < 1) {
        return;
      }

      for (var i = 0; i < index; i += 1) {
        var prevTargetEndDegree = this.models.series[i].degree.end;

        if (this.drawModels.series[i].degree.end !== prevTargetEndDegree) {
          this.drawModels.series[i].degree.end = prevTargetEndDegree;
        }
      }
    }
  }, {
    key: "initialize",
    value: function initialize(param) {
      var _param$alias;

      this.type = 'series';
      this.name = 'pie';
      this.alias = (_param$alias = param === null || param === void 0 ? void 0 : param.alias) !== null && _param$alias !== void 0 ? _param$alias : '';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _ref5,
          _this2 = this;

      var layout = chartState.layout,
          series = chartState.series,
          legend = chartState.legend,
          options = chartState.options,
          nestedPieSeries = chartState.nestedPieSeries,
          theme = chartState.theme;
      var categories = (_ref5 = chartState.categories) !== null && _ref5 !== void 0 ? _ref5 : [];

      if (!series.pie) {
        throw new Error(message.noDataError(this.name));
      }

      var pieTheme = theme.series.pie;
      this.theme = this.alias ? pieTheme[this.alias] : pieTheme;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var seriesModel, tooltipDataModel;
      var dataLabelsOptions = getDataLabelsOptions(options, this.alias);

      if (nestedPieSeries) {
        var data = nestedPieSeries[this.alias].data;
        var pieAlias = Object.keys(nestedPieSeries);
        var pieIndex = pieAlias.findIndex(function (alias) {
          return alias === _this2.alias;
        }); // check the data label of the last Pie series

        var lastAlias = last(pieAlias);
        var lastSeries = nestedPieSeries[lastAlias];
        var maxPieDataLabelSize = getMaxDataLabelSize(lastSeries.data.map(function (_ref6) {
          var name = _ref6.name;
          return name;
        }), getDataLabelsOptions(options, lastAlias), this.theme.dataLabels);
        var renderOptionsMap = this.getRenderOptionsMap(options, pieAlias, maxPieDataLabelSize);
        seriesModel = this.renderPieModel(data, renderOptionsMap[this.alias], pieIndex);
        tooltipDataModel = makePieTooltipData(data, categories === null || categories === void 0 ? void 0 : categories[pieIndex]);
      } else {
        var _series$pie;

        var pieData = (_series$pie = series.pie) === null || _series$pie === void 0 ? void 0 : _series$pie.data;

        var _getMaxDataLabelSize = getMaxDataLabelSize(pieData.map(function (_ref7) {
          var name = _ref7.name;
          return name;
        }), dataLabelsOptions, this.theme.dataLabels),
            width = _getMaxDataLabelSize.width,
            height = _getMaxDataLabelSize.height;

        var renderOptions = this.makeRenderOptions(options, width, height);
        seriesModel = this.renderPieModel(pieData, renderOptions);
        tooltipDataModel = makePieTooltipData(pieData, categories === null || categories === void 0 ? void 0 : categories[0]);
      }

      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = {
          series: this.models.series.map(function (m) {
            return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
              degree: pieSeries_objectSpread(pieSeries_objectSpread({}, m.degree), {}, {
                end: m.degree.start
              })
            });
          })
        };
      }

      if (dataLabelsOptions.visible) {
        var dataLabelData = seriesModel.map(function (m) {
          return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
            value: "".concat(pieTooltipLabelFormatter(m.percentValue)),
            theme: _this2.theme.dataLabels
          });
        });
        this.renderDataLabels(dataLabelData, this.alias);
      }

      this.responders = seriesModel.map(function (m, index) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
          type: 'sector',
          radius: m.radius,
          seriesIndex: index,
          data: pieSeries_objectSpread(pieSeries_objectSpread({}, tooltipDataModel[index]), {}, {
            percentValue: m.percentValue
          }),
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "getRadiusRangeMap",
    value: function getRadiusRangeMap(options, pieAlias) {
      var _this3 = this;

      return pieAlias.reduce(function (acc, alias) {
        var seriesOptions = _this3.getOptions(options, alias).series;

        if (seriesOptions !== null && seriesOptions !== void 0 && seriesOptions.radiusRange) {
          acc[alias] = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.radiusRange;
        }

        return acc;
      }, {});
    }
  }, {
    key: "getRenderOptionsMap",
    value: function getRenderOptionsMap(options, pieAlias, maxPieDataLabelSize) {
      var renderOptionsMap = this.initRenderOptionsMap(options, pieAlias, maxPieDataLabelSize);
      var radiusRangeMap = this.getRadiusRangeMap(options, pieAlias);
      pieAlias.forEach(function (alias, pieIndex) {
        var radiusRanges = Object.values(renderOptionsMap).map(function (_ref8) {
          var radiusRange = _ref8.radiusRange;
          return radiusRange;
        });
        renderOptionsMap[alias].radiusRange = getCalculatedRadiusRange({
          alias: alias,
          renderOptions: renderOptionsMap[alias],
          radiusRangeMap: radiusRangeMap,
          pieIndex: pieIndex,
          radiusRanges: radiusRanges,
          totalPieAliasCount: pieAlias.length
        });
      });
      return renderOptionsMap;
    }
  }, {
    key: "initRenderOptionsMap",
    value: function initRenderOptionsMap(options, pieAlias, _ref9) {
      var _this4 = this;

      var width = _ref9.width,
          height = _ref9.height;
      return pieAlias.reduce(function (acc, alias) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, acc), {}, pieSeries_defineProperty({}, alias, _this4.makeRenderOptions(_this4.getOptions(options, alias), width, height)));
      }, {});
    }
  }, {
    key: "getOptions",
    value: function getOptions(chartOptions, alias) {
      var options = pieSeries_objectSpread({}, chartOptions);

      if (options !== null && options !== void 0 && options.series && alias) {
        options.series = pieSeries_objectSpread(pieSeries_objectSpread({}, options.series), options.series[alias]);
      }

      return options;
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(options) {
      var _seriesOptions$clockw, _seriesOptions$angleR, _seriesOptions$angleR2, _seriesOptions$angleR3, _seriesOptions$angleR4, _seriesOptions$radius, _seriesOptions$radius2, _seriesOptions$radius3, _seriesOptions$radius4;

      var maxDataLabelWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var maxDataLabelHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var seriesOptions = options.series;
      var clockwise = (_seriesOptions$clockw = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.clockwise) !== null && _seriesOptions$clockw !== void 0 ? _seriesOptions$clockw : true;
      var startAngle = (_seriesOptions$angleR = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$angleR2 = seriesOptions.angleRange) === null || _seriesOptions$angleR2 === void 0 ? void 0 : _seriesOptions$angleR2.start) !== null && _seriesOptions$angleR !== void 0 ? _seriesOptions$angleR : DEGREE_0;
      var endAngle = (_seriesOptions$angleR3 = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$angleR4 = seriesOptions.angleRange) === null || _seriesOptions$angleR4 === void 0 ? void 0 : _seriesOptions$angleR4.end) !== null && _seriesOptions$angleR3 !== void 0 ? _seriesOptions$angleR3 : DEGREE_360;
      var totalAngle = getTotalAngle(clockwise, startAngle, endAngle);
      var isSemiCircular = isSemiCircle(clockwise, startAngle, endAngle);
      var _this$rect = this.rect,
          width = _this$rect.width,
          height = _this$rect.height;
      var defaultRadius = getDefaultRadius(this.rect, isSemiCircular, maxDataLabelWidth, maxDataLabelHeight);
      var innerRadius = calculateSizeWithPercentString(defaultRadius, (_seriesOptions$radius = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$radius2 = seriesOptions.radiusRange) === null || _seriesOptions$radius2 === void 0 ? void 0 : _seriesOptions$radius2.inner) !== null && _seriesOptions$radius !== void 0 ? _seriesOptions$radius : 0);
      var outerRadius = calculateSizeWithPercentString(defaultRadius, (_seriesOptions$radius3 = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$radius4 = seriesOptions.radiusRange) === null || _seriesOptions$radius4 === void 0 ? void 0 : _seriesOptions$radius4.outer) !== null && _seriesOptions$radius3 !== void 0 ? _seriesOptions$radius3 : this.alias ? 0 : defaultRadius);
      var cx = width / 2;
      var cy = isSemiCircular ? getSemiCircleCenterY(this.rect.height, clockwise) : height / 2;
      return {
        clockwise: clockwise,
        cx: cx,
        cy: cy,
        drawingStartAngle: startAngle - DEGREE_90,
        radiusRange: {
          inner: innerRadius,
          outer: outerRadius
        },
        angleRange: {
          start: startAngle,
          end: endAngle
        },
        totalAngle: totalAngle,
        defaultRadius: defaultRadius
      };
    }
  }, {
    key: "renderPieModel",
    value: function renderPieModel(seriesRawData, renderOptions, pieIndex) {
      var _this5 = this;

      var sectorModels = [];
      var total = seriesRawData.reduce(function (sum, _ref10) {
        var data = _ref10.data;
        return sum + (data !== null && data !== void 0 ? data : 0);
      }, 0);
      var clockwise = renderOptions.clockwise,
          cx = renderOptions.cx,
          cy = renderOptions.cy,
          drawingStartAngle = renderOptions.drawingStartAngle,
          _renderOptions$radius2 = renderOptions.radiusRange,
          inner = _renderOptions$radius2.inner,
          outer = _renderOptions$radius2.outer,
          totalAngle = renderOptions.totalAngle;
      var defaultStartDegree = clockwise ? DEGREE_0 : DEGREE_360;
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          strokeStyle = _this$theme.strokeStyle;
      seriesRawData.forEach(function (rawData, seriesIndex) {
        var color = _this5.alias ? _this5.getAliasSeriesColor(rawData, seriesRawData, pieIndex) : _this5.getSeriesColor(rawData);
        var data = rawData.data,
            name = rawData.name;

        if (!isNull(data)) {
          var degree = Math.max(data / total * totalAngle, 1) * (clockwise ? 1 : -1);
          var percentValue = data / total * 100;
          var prevModel = sectorModels[sectorModels.length - 1];
          var startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
          var endDegree = clockwise ? Math.min(startDegree + degree, DEGREE_360) : Math.max(startDegree + degree, DEGREE_0);
          sectorModels.push({
            type: 'sector',
            name: name,
            color: color,
            x: cx,
            y: cy,
            degree: {
              start: startDegree,
              end: endDegree
            },
            radius: {
              inner: inner,
              outer: outer
            },
            value: data,
            style: [{
              strokeStyle: strokeStyle
            }],
            lineWidth: lineWidth,
            clockwise: clockwise,
            drawingStartAngle: drawingStartAngle,
            totalAngle: totalAngle,
            percentValue: percentValue
          });
        }
      });
      return sectorModels;
    }
  }, {
    key: "makeTooltipResponder",
    value: function makeTooltipResponder(responders) {
      var _this6 = this;

      return responders.map(function (responder) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, responder), getRadialAnchorPosition(makeAnchorPositionParam('center', _this6.models.series[responder.seriesIndex])));
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref11) {
      var responders = _ref11.responders;
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getResponderModelsWithTheme(responders, 'hover'),
        name: this.alias || this.name
      });
      this.activatedResponders = this.makeTooltipResponder(responders);
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.alias || this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref12) {
      var responders = _ref12.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getResponderModelsWithTheme(responders, 'select'),
          name: this.name,
          alias: this.alias
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderModelsWithTheme",
    value: function getResponderModelsWithTheme(responders, type) {
      var theme = this.theme[type];
      var lineWidth = theme.lineWidth;
      var isSameLineWidth = this.theme.lineWidth === lineWidth;
      var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
      return responders.map(function (m) {
        var _theme$color;

        return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
          color: (_theme$color = theme === null || theme === void 0 ? void 0 : theme.color) !== null && _theme$color !== void 0 ? _theme$color : m.color,
          lineWidth: lineWidth,
          style: [pick(theme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')],
          radius: {
            inner: Math.max(m.radius.inner - thickness, 0),
            outer: m.radius.outer + thickness
          }
        });
      });
    }
  }, {
    key: "getOpacity",
    value: function getOpacity(active, selectedState) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var _ref13 = select,
          selectedAreaOpacity = _ref13.areaOpacity,
          restAreaOpacity = _ref13.restSeries.areaOpacity;
      var selectThemeOpacity = active ? selectedAreaOpacity : restAreaOpacity;
      return selectedState ? selectThemeOpacity : areaOpacity;
    }
  }, {
    key: "getIndexOfGroup",
    value: function getIndexOfGroup(seriesRawData, parentName, name) {
      return seriesRawData.filter(function (datum) {
        return parentName === datum.parentName;
      }).findIndex(function (datum) {
        return name === datum.name;
      });
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(rawData) {
      var color = rawData.color,
          name = rawData.name;
      var active = this.activeSeriesMap[name];
      var opacity = this.getOpacity(active, this.hasActiveSeries());
      return getRGBA(color, opacity);
    }
  }, {
    key: "getAliasSeriesColor",
    value: function getAliasSeriesColor(rawData, seriesRawData, pieIndex) {
      var color = rawData.color,
          name = rawData.name;
      var selectedColor = this.theme.select.color;
      var rootParentName = rawData.rootParentName,
          parentName = rawData.parentName;
      var indexOfGroup = this.getIndexOfGroup(seriesRawData, parentName, name);
      var opacity = this.getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name);
      var active = this.activeSeriesMap[rootParentName !== null && rootParentName !== void 0 ? rootParentName : name];
      var seriesColor = active ? selectedColor !== null && selectedColor !== void 0 ? selectedColor : color : color;
      return getRGBA(seriesColor, opacity);
    }
  }, {
    key: "getAliasSeriesOpacity",
    value: function getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name) {
      var active = this.activeSeriesMap[rootParentName !== null && rootParentName !== void 0 ? rootParentName : name];
      var opacity = this.getOpacity(active, this.hasActiveSeries());
      return pieIndex && parentName ? getPieSeriesOpacityByDepth(opacity, pieIndex, indexOfGroup) : opacity;
    }
  }, {
    key: "hasActiveSeries",
    value: function hasActiveSeries() {
      return Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
    }
  }]);

  return PieSeries;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/sector.ts




function sector(ctx, sectorModel) {
  var _sectorModel$degree = sectorModel.degree,
      start = _sectorModel$degree.start,
      end = _sectorModel$degree.end,
      color = sectorModel.color,
      style = sectorModel.style,
      lineWidth = sectorModel.lineWidth;

  if (start === end) {
    return;
  }

  var isCircle = Math.abs(start - end) === DEGREE_360;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, {});
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (isCircle) {
    drawCircle(ctx, sectorModel);
  } else {
    drawSector(ctx, sectorModel);
  }

  ctx.closePath();
  fillStyle(ctx, color);

  if (lineWidth) {
    ctx.lineWidth = lineWidth;
    ctx.stroke();
  }
}

function drawSector(ctx, sectorModel) {
  var x = sectorModel.x,
      y = sectorModel.y,
      _sectorModel$radius = sectorModel.radius,
      inner = _sectorModel$radius.inner,
      outer = _sectorModel$radius.outer,
      _sectorModel$degree2 = sectorModel.degree,
      start = _sectorModel$degree2.start,
      end = _sectorModel$degree2.end,
      clockwise = sectorModel.clockwise,
      drawingStartAngle = sectorModel.drawingStartAngle;

  if (inner < 0 || outer < 0) {
    return;
  }

  var startRadian = calculateDegreeToRadian(start, drawingStartAngle);
  var endRadian = calculateDegreeToRadian(end, drawingStartAngle);

  if (!inner) {
    ctx.moveTo(x, y);
  }

  ctx.arc(x, y, outer, startRadian, endRadian, !clockwise);

  if (inner) {
    ctx.arc(x, y, inner, endRadian, startRadian, clockwise);
  }
}

function drawCircle(ctx, sectorModel) {
  var x = sectorModel.x,
      y = sectorModel.y,
      _sectorModel$radius2 = sectorModel.radius,
      inner = _sectorModel$radius2.inner,
      outer = _sectorModel$radius2.outer,
      clockwise = sectorModel.clockwise;
  ctx.arc(x, y, outer, 0, 2 * Math.PI, !clockwise);

  if (inner) {
    var _getRadialPosition = getRadialPosition(x, y, inner, 0),
        innerStartPosX = _getRadialPosition.x,
        innerStartPosY = _getRadialPosition.y;

    var startX = inner ? innerStartPosX : x;
    var startY = inner ? innerStartPosY : y;
    ctx.moveTo(startX, startY);
    ctx.arc(x, y, inner, 0, 2 * Math.PI, clockwise);
  }
}
;// CONCATENATED MODULE: ./src/charts/pieChart.ts
function pieChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { pieChart_typeof = function _typeof(obj) { return typeof obj; }; } else { pieChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return pieChart_typeof(obj); }


















function pieChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function pieChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pieChart_ownKeys(Object(source), true).forEach(function (key) { pieChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pieChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function pieChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function pieChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function pieChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function pieChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) pieChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) pieChart_defineProperties(Constructor, staticProps); return Constructor; }

function pieChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { pieChart_get = Reflect.get; } else { pieChart_get = function _get(target, property, receiver) { var base = pieChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return pieChart_get(target, property, receiver || target); }

function pieChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = pieChart_getPrototypeOf(object); if (object === null) break; } return object; }

function pieChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) pieChart_setPrototypeOf(subClass, superClass); }

function pieChart_setPrototypeOf(o, p) { pieChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return pieChart_setPrototypeOf(o, p); }

function pieChart_createSuper(Derived) { var hasNativeReflectConstruct = pieChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = pieChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = pieChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return pieChart_possibleConstructorReturn(this, result); }; }

function pieChart_possibleConstructorReturn(self, call) { if (call && (pieChart_typeof(call) === "object" || typeof call === "function")) { return call; } return pieChart_assertThisInitialized(self); }

function pieChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function pieChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function pieChart_getPrototypeOf(o) { pieChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return pieChart_getPrototypeOf(o); }



















/**
 * @class
 * @classdesc Pie Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Pie Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Pie Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Array<number>|Array<string>} [props.options.series.radiusRange] - Specifies the radius of the circle drawn. It is specified by entering a number or percent string value in start and end.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Pie Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var PieChart = /*#__PURE__*/function (_Chart) {
  pieChart_inherits(PieChart, _Chart);

  var _super = pieChart_createSuper(PieChart);

  function PieChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    pieChart_classCallCheck(this, PieChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        pie: data.series
      },
      categories: data.categories
    });
  }

  pieChart_createClass(PieChart, [{
    key: "initialize",
    value: function initialize() {
      pieChart_get(pieChart_getPrototypeOf(PieChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Legend);
      this.componentManager.add(PieSeries);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: 10,
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['A'],
     *   series: [
     *     {name: 'a', data: 10},
     *     {name: 'b', data: 20},
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          pie: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.alias - alias name.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1, alias: 'name'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', pieChart_objectSpread(pieChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return PieChart;
}(Chart);


;// CONCATENATED MODULE: ./src/store/heatmapAxes.ts







function heatmapAxes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function heatmapAxes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapAxes_ownKeys(Object(source), true).forEach(function (key) { heatmapAxes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapAxes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapAxes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function getHeatmapAxisData(stateProp, axisType) {
  var _options$axisType$tic, _options$axisType, _options$axisType$tic2, _options$axisType$lab, _options$axisType2, _options$axisType2$la, _options$axisType3;

  var categories = stateProp.categories,
      axisSize = stateProp.axisSize,
      options = stateProp.options,
      theme = stateProp.theme;
  var isLabelAxis = axisType === AxisType.X;
  var axisName = isLabelAxis ? 'x' : 'y';
  var dateType = isDateType(options, axisType);
  var labels = getLabelsAppliedFormatter(categories[axisName], options, dateType, axisType);
  var tickIntervalCount = labels.length;
  var tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
  var labelDistance = axisSize / tickIntervalCount;
  var pointOnColumn = true;
  var tickCount = tickIntervalCount + 1;
  var tickInterval = (_options$axisType$tic = (_options$axisType = options[axisType]) === null || _options$axisType === void 0 ? void 0 : (_options$axisType$tic2 = _options$axisType.tick) === null || _options$axisType$tic2 === void 0 ? void 0 : _options$axisType$tic2.interval) !== null && _options$axisType$tic !== void 0 ? _options$axisType$tic : 1;
  var labelInterval = (_options$axisType$lab = (_options$axisType2 = options[axisType]) === null || _options$axisType2 === void 0 ? void 0 : (_options$axisType2$la = _options$axisType2.label) === null || _options$axisType2$la === void 0 ? void 0 : _options$axisType2$la.interval) !== null && _options$axisType$lab !== void 0 ? _options$axisType$lab : 1;
  var viewLabels = getViewAxisLabels({
    labels: labels,
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount,
    tickInterval: tickInterval,
    labelInterval: labelInterval
  }, axisSize);
  var labelXMargin = getLabelXMargin(axisType, options);

  var _getMaxLabelSize = getMaxLabelSize(labels, labelXMargin, getTitleFontString(theme.label)),
      maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

  var axisData = {
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    isLabelAxis: isLabelAxis,
    tickCount: tickCount,
    tickDistance: tickDistance,
    labelDistance: labelDistance,
    tickInterval: tickInterval,
    labelInterval: labelInterval,
    title: makeTitleOption((_options$axisType3 = options[axisType]) === null || _options$axisType3 === void 0 ? void 0 : _options$axisType3.title),
    maxLabelWidth: maxLabelWidth,
    maxLabelHeight: maxLabelHeight
  };

  if (axisType === AxisType.X) {
    var _options$xAxis$label$, _options$xAxis, _options$xAxis$label;

    var labelMargin = (_options$xAxis$label$ = (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : (_options$xAxis$label = _options$xAxis.label) === null || _options$xAxis$label === void 0 ? void 0 : _options$xAxis$label.margin) !== null && _options$xAxis$label$ !== void 0 ? _options$xAxis$label$ : 0;
    var offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;
    var distance = axisSize / viewLabels.length;
    var rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, getRotatableOption(options));
    var needRotateLabel = rotationData.needRotateLabel,
        rotationHeight = rotationData.rotationHeight;
    var maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
    return heatmapAxes_objectSpread(heatmapAxes_objectSpread(heatmapAxes_objectSpread({}, axisData), rotationData), {}, {
      maxHeight: maxHeight,
      offsetY: offsetY
    });
  }

  return axisData;
}

var heatmapAxes_axes = {
  name: 'axes',
  state: function state() {
    return {
      axes: {
        xAxis: {},
        yAxis: {}
      }
    };
  },
  action: {
    setAxesData: function setAxesData(_ref) {
      var state = _ref.state;
      var layout = state.layout,
          theme = state.theme;
      var _layout$plot = layout.plot,
          width = _layout$plot.width,
          height = _layout$plot.height;
      var categories = state.categories;
      var options = state.options;
      var xAxisData = getHeatmapAxisData({
        axisSize: width,
        categories: categories,
        options: options,
        theme: getAxisTheme(theme, AxisType.X)
      }, AxisType.X);
      var yAxisData = getHeatmapAxisData({
        axisSize: height,
        categories: categories,
        options: options,
        theme: getAxisTheme(theme, AxisType.Y)
      }, AxisType.Y);
      var axesState = {
        xAxis: xAxisData,
        yAxis: yAxisData
      };

      if (hasAxesLayoutChanged(state.axes, axesState)) {
        this.notify(state, 'layout');
      }

      state.axes = axesState;
    }
  },
  computed: {},
  observe: {
    updateAxes: function updateAxes() {
      this.dispatch('setAxesData');
    }
  }
};
/* harmony default export */ var heatmapAxes = (heatmapAxes_axes);
;// CONCATENATED MODULE: ./src/store/heatmapSeriesData.ts



function makeHeatmapSeries(series, categories, viewRange) {
  if (!series.heatmap) {
    return [];
  }

  return series.heatmap.data.map(function (rowSeries, y) {
    var yCategory = rowSeries.yCategory,
        data = rowSeries.data;
    return getDataInRange(data, viewRange).map(function (colorValue, x) {
      return {
        colorValue: colorValue,
        category: {
          x: categories.x[x],
          y: yCategory
        },
        indexes: [x, y]
      };
    });
  });
}

var heatmapSeriesData = {
  name: 'heatmapSeriesData',
  state: function state() {
    return {
      heatmapSeries: []
    };
  },
  action: {
    setHeatmapSeriesData: function setHeatmapSeriesData(_ref) {
      var state = _ref.state,
          computed = _ref.computed;
      state.heatmapSeries = makeHeatmapSeries(state.series, state.categories, computed.viewRange);
    }
  },
  observe: {
    updateTreemapSeriesData: function updateTreemapSeriesData() {
      this.dispatch('setHeatmapSeriesData');
    }
  }
};
/* harmony default export */ var store_heatmapSeriesData = (heatmapSeriesData);
;// CONCATENATED MODULE: ./src/store/treemapSeriesData.ts
function treemapSeriesData_toConsumableArray(arr) { return treemapSeriesData_arrayWithoutHoles(arr) || treemapSeriesData_iterableToArray(arr) || treemapSeriesData_unsupportedIterableToArray(arr) || treemapSeriesData_nonIterableSpread(); }

function treemapSeriesData_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function treemapSeriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return treemapSeriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return treemapSeriesData_arrayLikeToArray(o, minLen); }

function treemapSeriesData_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function treemapSeriesData_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return treemapSeriesData_arrayLikeToArray(arr); }

function treemapSeriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



















var TREEMAP_ID_PREFIX = '__TOAST_UI_TREEMAP';
var TREEMAP_ROOT_ID = "".concat(TREEMAP_ID_PREFIX, "_ROOT");

function makeTreeModel(series, indexes, depth, parentId) {
  var _series$data;

  var idx = last(indexes);
  var id = parentId ? "".concat(parentId, "_").concat(idx) : "".concat(TREEMAP_ID_PREFIX, "_").concat(idx);
  var colorValue = series.colorValue;
  var models = [{
    label: series.label,
    hasChild: !!series.children,
    id: id,
    indexes: indexes,
    parentId: parentId ? parentId : TREEMAP_ROOT_ID,
    depth: depth,
    data: (_series$data = series.data) !== null && _series$data !== void 0 ? _series$data : 0,
    colorValue: colorValue
  }];

  if (series.children) {
    series.children.forEach(function (child, childIdx) {
      if (!isNull(child.data)) {
        models.push.apply(models, treemapSeriesData_toConsumableArray(makeTreeModel(child, [].concat(treemapSeriesData_toConsumableArray(indexes), [childIdx]), depth + 1, id)));
      }
    });
  }

  return models;
}

function setParentSeriesData(treemapSeries) {
  treemapSeries.forEach(function (_ref) {
    var parentId = _ref.parentId,
        data = _ref.data;

    if (parentId !== TREEMAP_ROOT_ID) {
      treemapSeries.find(function (_ref2) {
        var id = _ref2.id;
        return id === parentId;
      }).data += data;
    }
  });
}

function setParentColorValue(treemapSeries) {
  treemapSeries.forEach(function (datum) {
    var id = datum.id,
        colorValue = datum.colorValue;

    if (isUndefined(colorValue)) {
      var series = treemapSeries.filter(function (_ref3) {
        var parentId = _ref3.parentId;
        return parentId === id;
      });
      var totalColorValue = series.reduce(function (acc, cur) {
        return acc + (isUndefined(cur.colorValue) ? 0 : cur.colorValue);
      }, 0);
      datum.colorValue = totalColorValue / series.length;
    }
  });
}

function setRatio(treemapSeries) {
  var rootTotal = treemapSeries.filter(function (_ref4) {
    var parentId = _ref4.parentId;
    return parentId === TREEMAP_ROOT_ID;
  }).reduce(function (acc, _ref5) {
    var data = _ref5.data;
    return acc + data;
  }, 0);
  treemapSeries.forEach(function (series) {
    var total = series.parentId === TREEMAP_ROOT_ID ? rootTotal : treemapSeries.find(function (_ref6) {
      var id = _ref6.id;
      return id === series.parentId;
    }).data;
    series.ratio = series.data / total;
  });
}

function makeTreemapSeries(series, options) {
  var _options$series;

  if (!series.treemap) {
    return [];
  }

  var treemapSeries = series.treemap.data.filter(function (datum) {
    return !isNull(datum.data);
  }).map(function (datum, idx) {
    return makeTreeModel(datum, [idx], 0);
  }).flatMap(function (s) {
    return s;
  }).sort(function (a, b) {
    return b.depth - a.depth;
  });
  setParentSeriesData(treemapSeries);
  setRatio(treemapSeries);

  if ((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.useColorValue) {
    setParentColorValue(treemapSeries);
  }

  return treemapSeries;
}

var treemapSeriesData = {
  name: 'treemapSeriesData',
  state: function state() {
    return {
      treemapSeries: []
    };
  },
  action: {
    setTreemapSeriesData: function setTreemapSeriesData(_ref7) {
      var state = _ref7.state;
      state.treemapSeries = makeTreemapSeries(state.series, state.options);
    }
  },
  observe: {
    updateTreemapSeriesData: function updateTreemapSeriesData() {
      this.dispatch('setTreemapSeriesData');
    }
  }
};
/* harmony default export */ var store_treemapSeriesData = (treemapSeriesData);
;// CONCATENATED MODULE: ./src/store/colorValueScale.ts
function colorValueScale_toConsumableArray(arr) { return colorValueScale_arrayWithoutHoles(arr) || colorValueScale_iterableToArray(arr) || colorValueScale_unsupportedIterableToArray(arr) || colorValueScale_nonIterableSpread(); }

function colorValueScale_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function colorValueScale_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return colorValueScale_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return colorValueScale_arrayLikeToArray(o, minLen); }

function colorValueScale_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function colorValueScale_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return colorValueScale_arrayLikeToArray(arr); }

function colorValueScale_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















var colorValueScale = {
  name: 'colorValueScale',
  state: function state() {
    return {
      treemapZoomId: {
        prev: TREEMAP_ROOT_ID,
        cur: TREEMAP_ROOT_ID
      },
      colorValueScale: {}
    };
  },
  action: {
    setColorValueScale: function setColorValueScale(_ref) {
      var state = _ref.state;
      var layout = state.layout,
          treemapSeries = state.treemapSeries,
          legend = state.legend,
          heatmapSeries = state.heatmapSeries;

      if (!legend.useSpectrumLegend) {
        return;
      }

      var series = treemapSeries !== null && treemapSeries !== void 0 ? treemapSeries : heatmapSeries.flatMap(function (value) {
        return value;
      });
      var values = series.reduce(function (acc, _ref2) {
        var colorValue = _ref2.colorValue;
        return colorValue ? [].concat(colorValueScale_toConsumableArray(acc), [colorValue]) : acc;
      }, []);
      var dataRange = getLimitSafely(colorValueScale_toConsumableArray(new Set(values)));
      var offsetSize = isVerticalAlign(legend.align) ? layout.plot.width / 2 : layout.plot.height;
      store_extend(state.colorValueScale, calculateCoordinateScale({
        dataRange: dataRange,
        offsetSize: offsetSize,
        useSpectrumLegend: true,
        scaleOption: {}
      }));
    },
    setTreemapZoomId: function setTreemapZoomId(_ref3, id) {
      var state = _ref3.state;
      state.treemapZoomId.prev = state.treemapZoomId.cur;
      state.treemapZoomId.cur = id;
    },
    zoomBack: function zoomBack(_ref4) {
      var _prevSeries$parentId;

      var state = _ref4.state;
      var treemapSeries = state.treemapSeries,
          treemapZoomId = state.treemapZoomId;
      var prev = treemapZoomId.prev;
      var prevSeries = treemapSeries.find(function (_ref5) {
        var id = _ref5.id;
        return id === prev;
      });
      state.treemapZoomId.prev = (_prevSeries$parentId = prevSeries === null || prevSeries === void 0 ? void 0 : prevSeries.parentId) !== null && _prevSeries$parentId !== void 0 ? _prevSeries$parentId : TREEMAP_ROOT_ID;
      state.treemapZoomId.cur = prev;
    }
  },
  observe: {
    updateColorValueScale: function updateColorValueScale() {
      this.dispatch('setColorValueScale');
    }
  },
  computed: {
    isTreemapSeriesZooming: function isTreemapSeriesZooming(_ref6) {
      var treemapZoomId = _ref6.treemapZoomId;
      return treemapZoomId && treemapZoomId.cur !== treemapZoomId.prev;
    }
  }
};
/* harmony default export */ var store_colorValueScale = (colorValueScale);
;// CONCATENATED MODULE: ./src/component/spectrumLegend.ts
function spectrumLegend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { spectrumLegend_typeof = function _typeof(obj) { return typeof obj; }; } else { spectrumLegend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return spectrumLegend_typeof(obj); }

function spectrumLegend_toConsumableArray(arr) { return spectrumLegend_arrayWithoutHoles(arr) || spectrumLegend_iterableToArray(arr) || spectrumLegend_unsupportedIterableToArray(arr) || spectrumLegend_nonIterableSpread(); }

function spectrumLegend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function spectrumLegend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function spectrumLegend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return spectrumLegend_arrayLikeToArray(arr); }

function spectrumLegend_slicedToArray(arr, i) { return spectrumLegend_arrayWithHoles(arr) || spectrumLegend_iterableToArrayLimit(arr, i) || spectrumLegend_unsupportedIterableToArray(arr, i) || spectrumLegend_nonIterableRest(); }

function spectrumLegend_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function spectrumLegend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return spectrumLegend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return spectrumLegend_arrayLikeToArray(o, minLen); }

function spectrumLegend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function spectrumLegend_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function spectrumLegend_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
















function spectrumLegend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function spectrumLegend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function spectrumLegend_createClass(Constructor, protoProps, staticProps) { if (protoProps) spectrumLegend_defineProperties(Constructor.prototype, protoProps); if (staticProps) spectrumLegend_defineProperties(Constructor, staticProps); return Constructor; }

function spectrumLegend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) spectrumLegend_setPrototypeOf(subClass, superClass); }

function spectrumLegend_setPrototypeOf(o, p) { spectrumLegend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return spectrumLegend_setPrototypeOf(o, p); }

function spectrumLegend_createSuper(Derived) { var hasNativeReflectConstruct = spectrumLegend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = spectrumLegend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = spectrumLegend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return spectrumLegend_possibleConstructorReturn(this, result); }; }

function spectrumLegend_possibleConstructorReturn(self, call) { if (call && (spectrumLegend_typeof(call) === "object" || typeof call === "function")) { return call; } return spectrumLegend_assertThisInitialized(self); }

function spectrumLegend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function spectrumLegend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function spectrumLegend_getPrototypeOf(o) { spectrumLegend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return spectrumLegend_getPrototypeOf(o); }

function component_spectrumLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var SpectrumLegend = /*#__PURE__*/function (_Component) {
  spectrumLegend_inherits(SpectrumLegend, _Component);

  var _super = spectrumLegend_createSuper(SpectrumLegend);

  function SpectrumLegend() {
    var _this;

    spectrumLegend_classCallCheck(this, SpectrumLegend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "models", void 0);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "labels", []);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "align", void 0);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "renderSpectrumTooltip", function (_ref) {
      var _ref2 = spectrumLegend_slicedToArray(_ref, 1),
          responderData = _ref2[0];

      if (responderData) {
        var _assertThisInitialize = spectrumLegend_assertThisInitialized(_this),
            labels = _assertThisInitialize.labels,
            align = _assertThisInitialize.align;

        var colorValue = responderData.colorValue,
            color = responderData.color;
        var _this$rect = _this.rect,
            width = _this$rect.width,
            height = _this$rect.height;
        _this.models.tooltip = [{
          type: 'spectrumTooltip',
          width: width,
          height: height,
          x: 0,
          y: 0,
          labels: labels,
          align: align,
          colorRatio: responderData.colorRatio,
          color: color,
          text: String(colorValue),
          verticalAlign: isVerticalAlign(align)
        }];
      } else {
        _this.models.tooltip = [];
      }
    });

    return _this;
  }

  spectrumLegend_createClass(SpectrumLegend, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'spectrumLegend';
      this.name = 'spectrumLegend';
    }
  }, {
    key: "makeLabels",
    value: function makeLabels(scale) {
      var stepCount = scale.stepCount,
          limit = scale.limit,
          stepSize = scale.stepSize;
      var minValue = limit.min;
      return range(0, stepCount + 1).reduce(function (labels, value) {
        return [].concat(spectrumLegend_toConsumableArray(labels), [String(minValue + stepSize * value)]);
      }, []);
    }
  }, {
    key: "renderSpectrumLegendModel",
    value: function renderSpectrumLegendModel(startColor, endColor) {
      var labels = this.labels,
          align = this.align;
      var _this$rect2 = this.rect,
          width = _this$rect2.width,
          height = _this$rect2.height;
      return [{
        type: 'spectrumLegend',
        width: width,
        height: height,
        x: 0,
        y: 0,
        labels: labels,
        align: align,
        startColor: startColor,
        endColor: endColor,
        verticalAlign: isVerticalAlign(this.align)
      }];
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _theme$series, _theme$series2;

      var layout = _ref3.layout,
          legend = _ref3.legend,
          colorValueScale = _ref3.colorValueScale,
          theme = _ref3.theme;
      this.rect = layout.legend;
      this.align = legend.align;
      this.isShow = legend.visible && !!legend.data.length;

      if (!this.isShow) {
        return;
      }

      this.labels = this.makeLabels(colorValueScale);

      var _ref4 = ((_theme$series = theme.series) === null || _theme$series === void 0 ? void 0 : _theme$series.heatmap) || ((_theme$series2 = theme.series) === null || _theme$series2 === void 0 ? void 0 : _theme$series2.treemap),
          startColor = _ref4.startColor,
          endColor = _ref4.endColor;

      this.models = {
        legend: this.renderSpectrumLegendModel(startColor, endColor),
        tooltip: []
      };
      this.eventBus.on('renderSpectrumTooltip', this.renderSpectrumTooltip);
    }
  }]);

  return SpectrumLegend;
}(Component);


;// CONCATENATED MODULE: ./src/helpers/colorSpectrum.ts
function colorSpectrum_toConsumableArray(arr) { return colorSpectrum_arrayWithoutHoles(arr) || colorSpectrum_iterableToArray(arr) || colorSpectrum_unsupportedIterableToArray(arr) || colorSpectrum_nonIterableSpread(); }

function colorSpectrum_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function colorSpectrum_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return colorSpectrum_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return colorSpectrum_arrayLikeToArray(o, minLen); }

function colorSpectrum_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function colorSpectrum_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return colorSpectrum_arrayLikeToArray(arr); }

function colorSpectrum_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }














function makeDistances(startRGB, endRGB) {
  return startRGB.map(function (value, index) {
    return endRGB[index] - value;
  });
}
function getColorRatio(limit, value) {
  if (isUndefined(value)) {
    return;
  }

  var divNumber = Math.abs(limit.max - limit.min);
  return divNumber && !isNull(value) ? (value - limit.min) / divNumber : 0;
}
function getSpectrumColor(ratio, distances, startRGB) {
  var rgbColor = startRGB.map(function (start, index) {
    return start + parseInt(String(distances[index] * ratio), 10);
  });
  var color = rgbToHEX.apply(void 0, colorSpectrum_toConsumableArray(rgbColor));
  return utils_isString(color) ? color : '';
}
;// CONCATENATED MODULE: ./src/component/heatmapSeries.ts
function heatmapSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { heatmapSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { heatmapSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return heatmapSeries_typeof(obj); }

function heatmapSeries_slicedToArray(arr, i) { return heatmapSeries_arrayWithHoles(arr) || heatmapSeries_iterableToArrayLimit(arr, i) || heatmapSeries_unsupportedIterableToArray(arr, i) || heatmapSeries_nonIterableRest(); }

function heatmapSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function heatmapSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function heatmapSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function heatmapSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function heatmapSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapSeries_ownKeys(Object(source), true).forEach(function (key) { heatmapSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapSeries_toConsumableArray(arr) { return heatmapSeries_arrayWithoutHoles(arr) || heatmapSeries_iterableToArray(arr) || heatmapSeries_unsupportedIterableToArray(arr) || heatmapSeries_nonIterableSpread(); }

function heatmapSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function heatmapSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return heatmapSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return heatmapSeries_arrayLikeToArray(o, minLen); }

function heatmapSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function heatmapSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return heatmapSeries_arrayLikeToArray(arr); }

function heatmapSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
























function heatmapSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function heatmapSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function heatmapSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) heatmapSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) heatmapSeries_defineProperties(Constructor, staticProps); return Constructor; }

function heatmapSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) heatmapSeries_setPrototypeOf(subClass, superClass); }

function heatmapSeries_setPrototypeOf(o, p) { heatmapSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return heatmapSeries_setPrototypeOf(o, p); }

function heatmapSeries_createSuper(Derived) { var hasNativeReflectConstruct = heatmapSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = heatmapSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = heatmapSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return heatmapSeries_possibleConstructorReturn(this, result); }; }

function heatmapSeries_possibleConstructorReturn(self, call) { if (call && (heatmapSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return heatmapSeries_assertThisInitialized(self); }

function heatmapSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function heatmapSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function heatmapSeries_getPrototypeOf(o) { heatmapSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return heatmapSeries_getPrototypeOf(o); }

function heatmapSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var HeatmapSeries = /*#__PURE__*/function (_Component) {
  heatmapSeries_inherits(HeatmapSeries, _Component);

  var _super = heatmapSeries_createSuper(HeatmapSeries);

  function HeatmapSeries() {
    var _this;

    heatmapSeries_classCallCheck(this, HeatmapSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "models", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "responders", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "theme", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "activatedResponders", []);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.emitMouseEvent([]);
    });

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var _state$series$heatmap;

      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var dataSize = (_state$series$heatmap = state.series.heatmap) === null || _state$series$heatmap === void 0 ? void 0 : _state$series$heatmap[0].data.length;
      var responderIndex = seriesIndex * dataSize + index;
      var model = _this.responders[responderIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "showTooltip", function (_ref2) {
      var _state$series$heatmap2;

      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var dataSize = (_state$series$heatmap2 = state.series.heatmap) === null || _state$series$heatmap2 === void 0 ? void 0 : _state$series$heatmap2[0].data.length;
      var responderIndex = seriesIndex * dataSize + index;
      var model = _this.responders[responderIndex];

      if (model) {
        _this.emitMouseEvent([model]);
      }
    });

    return _this;
  }

  heatmapSeries_createClass(HeatmapSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'heatmap';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var layout = chartState.layout,
          heatmapSeries = chartState.heatmapSeries,
          axes = chartState.axes,
          theme = chartState.theme,
          colorValueScale = chartState.colorValueScale,
          options = chartState.options;

      if (!heatmapSeries) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.heatmap;
      this.selectable = this.getSelectableOption(options);
      this.rect = layout.plot;
      var cellSize = {
        height: axes.yAxis.tickDistance,
        width: axes.xAxis.tickDistance
      };
      this.models = {
        series: this.renderHeatmapSeries(heatmapSeries, cellSize, colorValueScale)
      };

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.makeDataLabels());
      }

      this.responders = this.makeHeatmapSeriesResponder();
    }
  }, {
    key: "makeDataLabels",
    value: function makeDataLabels() {
      var dataLabelTheme = this.theme.dataLabels;
      return this.models.series.reduce(function (acc, m) {
        return isNull(m.colorValue) ? acc : [].concat(heatmapSeries_toConsumableArray(acc), [heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, m), {}, {
          type: 'treemapSeriesName',
          value: m.colorValue,
          direction: 'left',
          plot: {
            x: 0,
            y: 0,
            size: 0
          },
          theme: heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, dataLabelTheme), {}, {
            color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color
          })
        })]);
      }, []);
    }
  }, {
    key: "makeHeatmapSeriesResponder",
    value: function makeHeatmapSeriesResponder() {
      return this.models.series.reduce(function (acc, model) {
        return isNull(model.colorValue) ? acc : [].concat(heatmapSeries_toConsumableArray(acc), [heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, model), {}, {
          data: heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, model), {}, {
            label: model.name,
            value: model.colorValue,
            templateType: 'heatmap'
          }),
          thickness: boxDefault.HOVER_THICKNESS,
          style: ['shadow']
        })]);
      }, []);
    }
  }, {
    key: "renderHeatmapSeries",
    value: function renderHeatmapSeries(seriesData, cellSize, colorValueScale) {
      var _this$theme = this.theme,
          startColor = _this$theme.startColor,
          endColor = _this$theme.endColor,
          borderColor = _this$theme.borderColor,
          borderWidth = _this$theme.borderWidth;
      var startRGB = hexToRGB(startColor);
      var distances = makeDistances(startRGB, hexToRGB(endColor));
      var height = cellSize.height,
          width = cellSize.width;
      return seriesData.flatMap(function (data) {
        return data.flatMap(function (datum) {
          var indexes = datum.indexes,
              colorValue = datum.colorValue,
              category = datum.category;
          var name = "".concat(category.x, ", ").concat(category.y);

          var _indexes = heatmapSeries_slicedToArray(indexes, 2),
              xIndex = _indexes[0],
              yIndex = _indexes[1];

          var colorRatio = getColorRatio(colorValueScale.limit, colorValue);
          var color = isNull(colorValue) ? 'rgba(0, 0, 0, 0)' : getSpectrumColor(colorRatio, distances, startRGB);
          var thickness = borderWidth;
          return {
            type: 'rect',
            name: name,
            width: width - thickness * 2,
            height: height - thickness * 2,
            x: width * xIndex + thickness,
            y: height * yIndex + thickness,
            colorValue: colorValue,
            colorRatio: colorRatio,
            color: color,
            thickness: thickness,
            borderColor: borderColor
          };
        });
      });
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this2 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, _this2.theme[type]), {}, {
          style: ['shadow']
        }));
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref3) {
      var responders = _ref3.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getRespondersWithTheme(responders, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders;
      this.activatedResponders = responders;
      this.emitMouseEvent(responders);
    }
  }, {
    key: "emitMouseEvent",
    value: function emitMouseEvent(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.eventBus.emit('seriesPointHovered', {
        models: responders,
        name: this.name
      });
      this.eventBus.emit('renderSpectrumTooltip', responders);
      this.eventBus.emit('needDraw');
    }
  }]);

  return HeatmapSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/heatmapChart.ts
function heatmapChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { heatmapChart_typeof = function _typeof(obj) { return typeof obj; }; } else { heatmapChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return heatmapChart_typeof(obj); }

function heatmapChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function heatmapChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapChart_ownKeys(Object(source), true).forEach(function (key) { heatmapChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function heatmapChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function heatmapChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function heatmapChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) heatmapChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) heatmapChart_defineProperties(Constructor, staticProps); return Constructor; }

function heatmapChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { heatmapChart_get = Reflect.get; } else { heatmapChart_get = function _get(target, property, receiver) { var base = heatmapChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return heatmapChart_get(target, property, receiver || target); }

function heatmapChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = heatmapChart_getPrototypeOf(object); if (object === null) break; } return object; }

function heatmapChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) heatmapChart_setPrototypeOf(subClass, superClass); }

function heatmapChart_setPrototypeOf(o, p) { heatmapChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return heatmapChart_setPrototypeOf(o, p); }

function heatmapChart_createSuper(Derived) { var hasNativeReflectConstruct = heatmapChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = heatmapChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = heatmapChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return heatmapChart_possibleConstructorReturn(this, result); }; }

function heatmapChart_possibleConstructorReturn(self, call) { if (call && (heatmapChart_typeof(call) === "object" || typeof call === "function")) { return call; } return heatmapChart_assertThisInitialized(self); }

function heatmapChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function heatmapChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function heatmapChart_getPrototypeOf(o) { heatmapChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return heatmapChart_getPrototypeOf(o); }










































function getSeriesWithYCategory(series, categories) {
  return series.map(function (rowSeries, y) {
    return {
      data: rowSeries,
      yCategory: categories.y[y]
    };
  });
}
/**
 * @class
 * @classdesc Heatmap Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Heatmap Chart.
 *     @param {Object} props.data.categories
 *       @param {Array<string>} props.data.categories.x - X Categories.
 *       @param {Array<string>} props.data.categories.y - Y Categories.
 *     @param {Array<Array<number>>} props.data.series - Series data.
 *   @param {Object} [props.options] - Options for making Heatmap Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {boolean|Object} [props.options.yAxis.date] - Whether the y axis label is of date type. Format option used for date type. Whether the y axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Heatmap Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var HeatmapChart = /*#__PURE__*/function (_Chart) {
  heatmapChart_inherits(HeatmapChart, _Chart);

  var _super = heatmapChart_createSuper(HeatmapChart);

  function HeatmapChart(props) {
    heatmapChart_classCallCheck(this, HeatmapChart);

    return _super.call(this, {
      el: props.el,
      categories: props.data.categories,
      options: props.options,
      series: {
        heatmap: getSeriesWithYCategory(props.data.series, props.data.categories)
      },
      modules: [store_heatmapSeriesData, store_colorValueScale, heatmapAxes]
    });
  }

  heatmapChart_createClass(HeatmapChart, [{
    key: "initialize",
    value: function initialize() {
      heatmapChart_get(heatmapChart_getPrototypeOf(HeatmapChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(SpectrumLegend);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HeatmapSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, spectrumLegend_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Category information of the series.
     *   @param {Object} dataInfo.category - Y category.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addHeatmapSeries', heatmapChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     *   @param {Array<string>} data.categories.x - X Categories.
     *   @param {Array<string>} data.categories.y - Y Categories.
     * @param {Array<Array<number>>} data.series - Series data.
     * @api
     * @example
     * chart.setData({
     *   categories: {
     *     x: ['1', '2', '3' ],
     *     y: ['A', 'B'],
     *   },
     *   series: [
     *     [1, 2, 3],
     *     [4, 5, 6],
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          heatmap: getSeriesWithYCategory(series, categories)
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', heatmapChart_objectSpread(heatmapChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return HeatmapChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/areaSeries.ts
function areaSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { areaSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { areaSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return areaSeries_typeof(obj); }

function areaSeries_toConsumableArray(arr) { return areaSeries_arrayWithoutHoles(arr) || areaSeries_iterableToArray(arr) || areaSeries_unsupportedIterableToArray(arr) || areaSeries_nonIterableSpread(); }

function areaSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function areaSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return areaSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return areaSeries_arrayLikeToArray(o, minLen); }

function areaSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function areaSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return areaSeries_arrayLikeToArray(arr); }

function areaSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function areaSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function areaSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { areaSeries_ownKeys(Object(source), true).forEach(function (key) { areaSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { areaSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



























function areaSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function areaSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function areaSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) areaSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) areaSeries_defineProperties(Constructor, staticProps); return Constructor; }

function areaSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) areaSeries_setPrototypeOf(subClass, superClass); }

function areaSeries_setPrototypeOf(o, p) { areaSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return areaSeries_setPrototypeOf(o, p); }

function areaSeries_createSuper(Derived) { var hasNativeReflectConstruct = areaSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = areaSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = areaSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return areaSeries_possibleConstructorReturn(this, result); }; }

function areaSeries_possibleConstructorReturn(self, call) { if (call && (areaSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return areaSeries_assertThisInitialized(self); }

function areaSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function areaSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function areaSeries_getPrototypeOf(o) { areaSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return areaSeries_getPrototypeOf(o); }

function areaSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var seriesOpacity = {
  INACTIVE: 0.06,
  ACTIVE: 1
};

var AreaSeries = /*#__PURE__*/function (_Component) {
  areaSeries_inherits(AreaSeries, _Component);

  var _super = areaSeries_createSuper(AreaSeries);

  function AreaSeries() {
    var _this;

    areaSeries_classCallCheck(this, AreaSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "models", {
      rect: [],
      series: [],
      dot: []
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "drawModels", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "theme", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "responders", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "activatedResponders", []);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "eventDetectType", 'nearest');

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "tooltipCircleMap", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "linePointsModel", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "baseYPosition", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isStackChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isRangeChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isSplineChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "startIndex", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'area')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var model = _this.tooltipCircleMap[category][seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var models = _this.getResponderSeriesWithTheme([model], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'area')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.tooltipCircleMap[category] : [_this.tooltipCircleMap[category][seriesIndex]];

      if (!models.length) {
        return;
      }

      _this.onMousemoveNearType(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  areaSeries_createClass(AreaSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'area';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      this.drawModels.rect[0].width = this.models.rect[0].width * delta;
    }
  }, {
    key: "getBaseYPosition",
    value: function getBaseYPosition(limit) {
      var baseValue = limit.min >= 0 ? limit.min : Math.min(limit.max, 0);
      var intervalSize = this.rect.height / (limit.max - limit.min);
      return (limit.max - baseValue) * intervalSize;
    }
  }, {
    key: "getStackValue",
    value: function getStackValue(areaStackSeries, seriesIndex, index) {
      var type = areaStackSeries.stack.type;
      var _areaStackSeries$stac = areaStackSeries.stackData[index],
          values = _areaStackSeries$stac.values,
          sumValue = _areaStackSeries$stac.sum;
      var stackedValue = sum(values.slice(0, seriesIndex + 1));
      return type === 'percent' ? stackedValue * 100 / sumValue : stackedValue;
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      if (series.line || this.isStackChart) {
        this.eventDetectType = 'grouped';
      }
    }
  }, {
    key: "getAreaOptions",
    value: function getAreaOptions(options) {
      var _newOptions$series;

      var newOptions = areaSeries_objectSpread({}, options);

      if ((_newOptions$series = newOptions.series) !== null && _newOptions$series !== void 0 && _newOptions$series.area) {
        newOptions.series = areaSeries_objectSpread(areaSeries_objectSpread({}, newOptions.series), newOptions.series.area);
      }

      return newOptions;
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref, _viewRange$, _options$series$splin, _options$series2, _getFirstValidValue, _options$series3;

      var viewRange = computed.viewRange;
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          legend = chartState.legend,
          stackSeries = chartState.stackSeries,
          theme = chartState.theme;

      if (!series.area) {
        throw new Error(message.noDataError(this.name));
      }

      var areaStackSeries;
      var options = this.getAreaOptions(chartState.options);
      var categories = chartState.categories;
      var rawCategories = (_ref = chartState.rawCategories) !== null && _ref !== void 0 ? _ref : [];
      this.theme = theme.series.area;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
      this.selectable = this.getSelectableOption(options);
      this.isSplineChart = (_options$series$splin = (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.spline) !== null && _options$series$splin !== void 0 ? _options$series$splin : false;
      var limit = scale[getValueAxisName(options, this.name, 'yAxis')].limit;
      var _ref2 = axes.xAxis,
          tickDistance = _ref2.tickDistance,
          pointOnColumn = _ref2.pointOnColumn,
          tickCount = _ref2.tickCount;
      var areaData = series.area.data;
      this.baseYPosition = this.getBaseYPosition(limit);

      if (stackSeries !== null && stackSeries !== void 0 && stackSeries.area) {
        this.isStackChart = true;
        areaStackSeries = stackSeries.area;
      } else if (isRangeData((_getFirstValidValue = getFirstValidValue(areaData)) === null || _getFirstValidValue === void 0 ? void 0 : _getFirstValidValue.data)) {
        this.isRangeChart = true;
      }

      this.setEventDetectType(series, options);
      var renderOptions = {
        pointOnColumn: pointOnColumn,
        options: options.series || {},
        tickDistance: tickDistance,
        tickCount: tickCount,
        areaStackSeries: areaStackSeries
      };
      this.linePointsModel = this.renderLinePointsModel(areaData, limit, renderOptions);
      var areaSeriesModel = this.renderAreaPointsModel();
      var showDot = !!((_options$series3 = options.series) !== null && _options$series3 !== void 0 && _options$series3.showDot);

      var _this$renderCircleMod = this.renderCircleModel(showDot),
          dotSeriesModel = _this$renderCircleMod.dotSeriesModel,
          responderModel = _this$renderCircleMod.responderModel;

      var tooltipDataArr = this.makeTooltipData(areaData, rawCategories);
      this.models = deepCopy({
        rect: [this.renderClipRectAreaModel()],
        series: [].concat(areaSeries_toConsumableArray(this.linePointsModel), areaSeries_toConsumableArray(areaSeriesModel)),
        dot: dotSeriesModel
      });

      if (!this.drawModels) {
        this.drawModels = areaSeries_objectSpread(areaSeries_objectSpread({}, this.models), {}, {
          rect: [this.renderClipRectAreaModel(true)]
        });
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels(areaSeriesModel));
      }

      this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);
      this.responders = this.getResponders(responderModel, tooltipDataArr, categories, rawCategories, axes.xAxis);
    }
  }, {
    key: "getResponders",
    value: function getResponders(responderModel, tooltipDataArr, categories, rawCategories, axisData) {
      if (this.eventDetectType === 'near') {
        return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories);
      }

      if (this.eventDetectType === 'point') {
        return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories, 0);
      }

      return makeRectResponderModel(this.rect, axisData, categories);
    }
  }, {
    key: "makeNearTypeResponderModel",
    value: function makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, categories, detectionSize) {
      var tooltipDataLength = tooltipDataArr.length;
      return seriesCircleModel.map(function (m, dataIndex) {
        return areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[dataIndex % tooltipDataLength],
          detectionSize: detectionSize,
          label: categories[m.index]
        });
      });
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel(isDrawModel) {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: isDrawModel ? 0 : this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(areaData, categories) {
      var _this2 = this;

      return areaData.flatMap(function (_ref3, seriesIndex) {
        var rawData = _ref3.rawData,
            name = _ref3.name,
            color = _ref3.color;
        var tooltipData = [];
        rawData.forEach(function (datum, index) {
          if (!isNull(datum)) {
            var value = _this2.isRangeChart ? "".concat(datum[0], " ~ ").concat(datum[1]) : datum;
            tooltipData.push({
              label: name,
              color: color,
              value: value,
              category: categories[index],
              seriesIndex: seriesIndex,
              index: index
            });
          }
        });
        return tooltipData;
      });
    }
  }, {
    key: "getLinePointModelValue",
    value: function getLinePointModelValue(datum, pairModel) {
      if (this.isRangeChart) {
        return pairModel ? datum[0] : datum[1];
      }

      return datum;
    }
  }, {
    key: "getLinePointModel",
    value: function getLinePointModel(series, seriesIndex, limit, renderOptions) {
      var _this3 = this;

      var pointOnColumn = renderOptions.pointOnColumn,
          tickDistance = renderOptions.tickDistance,
          pairModel = renderOptions.pairModel,
          areaStackSeries = renderOptions.areaStackSeries;
      var rawData = series.rawData,
          name = series.name,
          seriesColor = series.color;
      var active = this.activeSeriesMap[name];
      var points = [];
      var color = getRGBA(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      rawData.forEach(function (datum, idx) {
        if (isNull(datum)) {
          points.push(null);
          return;
        }

        var value = _this3.getLinePointModelValue(datum, pairModel);

        var stackedValue = _this3.isStackChart ? _this3.getStackValue(areaStackSeries, seriesIndex, idx) : value;
        var valueRatio = getValueRatio(stackedValue, limit);
        var x = tickDistance * (idx - _this3.startIndex) + (pointOnColumn ? tickDistance / 2 : 0);
        var y = (1 - valueRatio) * _this3.rect.height;
        points.push({
          x: x,
          y: y,
          value: value
        });
      });

      if (pairModel) {
        points.reverse(); // for range spline
      }

      if (this.isSplineChart) {
        setSplineControlPoint(points);
      }

      return {
        type: 'linePoints',
        lineWidth: lineWidth,
        dashSegments: dashSegments,
        color: color,
        points: points,
        seriesIndex: seriesIndex,
        name: name
      };
    }
  }, {
    key: "renderLinePointsModel",
    value: function renderLinePointsModel(seriesRawData, limit, renderOptions) {
      var _this4 = this;

      var linePointsModels = seriesRawData.map(function (series, seriesIndex) {
        return _this4.getLinePointModel(series, seriesIndex, limit, renderOptions);
      });

      if (this.isRangeChart) {
        var renderOptionsForPair = deepMergedCopy(renderOptions, {
          pairModel: true
        });
        var pair = seriesRawData.map(function (series, seriesIndex) {
          return _this4.getLinePointModel(series, seriesIndex, limit, renderOptionsForPair);
        });
        linePointsModels.push.apply(linePointsModels, areaSeries_toConsumableArray(pair));
      }

      return linePointsModels;
    }
  }, {
    key: "getCombinedPoints",
    value: function getCombinedPoints(start, end) {
      var startPoints = start >= 0 ? this.linePointsModel[start].points : [];

      var reversedEndPoints = areaSeries_toConsumableArray(this.linePointsModel[end].points).reverse();

      return [].concat(areaSeries_toConsumableArray(startPoints), areaSeries_toConsumableArray(reversedEndPoints));
    }
  }, {
    key: "renderRangeAreaSeries",
    value: function renderRangeAreaSeries(linePointsModel) {
      var _this5 = this;

      var model = [];
      linePointsModel.forEach(function (m) {
        var areaPoints = [];
        var points = m.points;
        points.slice(0, points.length / 2 + 1).forEach(function (point, i) {
          var lastPoint = i === points.length / 2 - 1;
          var nullPoint = isNull(point);

          if (!nullPoint) {
            areaPoints.push(point);
          }

          if (areaPoints.length && (lastPoint || nullPoint)) {
            var pairPoints = areaPoints.map(function (areaPoint, idx) {
              var curIdx = points.length / 2 + i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);
              return points[curIdx];
            }).reverse();
            model.push(areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
              type: 'areaPoints',
              lineWidth: 0,
              color: 'rgba(0, 0, 0, 0)',
              // make area border transparent
              fillColor: _this5.getAreaOpacity(m.name, m.color),
              points: [].concat(areaSeries_toConsumableArray(areaPoints), areaSeries_toConsumableArray(pairPoints))
            }));
            areaPoints = [];
          }
        });
      });
      return model;
    }
  }, {
    key: "renderAreaSeries",
    value: function renderAreaSeries(linePointsModel) {
      var _this6 = this;

      var model = [];
      var bottomYPoint = [];
      linePointsModel.forEach(function (m) {
        var areaPoints = [];
        var curBottomYPoint = [].concat(bottomYPoint);
        var points = m.points;
        points.forEach(function (point, i) {
          var lastPoint = i === points.length - 1;
          var nullPoint = isNull(point);

          if (!isNull(point)) {
            areaPoints.push(point);
          }

          if (areaPoints.length && (nullPoint || lastPoint)) {
            var pairPoints = areaPoints.map(function (areaPoint, idx) {
              var curIdx = i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);
              var bottom = isUndefined(curBottomYPoint[curIdx]) ? _this6.baseYPosition : curBottomYPoint[curIdx];

              if (_this6.isStackChart) {
                bottomYPoint[curIdx] = areaPoint.y;
              }

              return {
                x: areaPoint.x,
                y: bottom
              };
            }).reverse();

            if (_this6.isStackChart && _this6.isSplineChart) {
              setSplineControlPoint(pairPoints); // set spline for new stack pair points
            }

            model.push(areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
              type: 'areaPoints',
              lineWidth: 0,
              color: 'rgba(0, 0, 0, 0)',
              // make area border transparent
              fillColor: _this6.getAreaOpacity(m.name, m.color),
              points: [].concat(areaSeries_toConsumableArray(areaPoints), areaSeries_toConsumableArray(pairPoints))
            }));
            areaPoints = [];
          }
        });
      });
      return model;
    }
  }, {
    key: "getCombinedLinePointsModel",
    value: function getCombinedLinePointsModel() {
      var _this7 = this;

      if (!this.isRangeChart) {
        return this.linePointsModel;
      }

      var len = this.linePointsModel.length / 2;
      return range(0, len).reduce(function (acc, i) {
        var start = i;
        var end = len + i;

        var points = _this7.getCombinedPoints(start, end);

        return [].concat(areaSeries_toConsumableArray(acc), [areaSeries_objectSpread(areaSeries_objectSpread({}, _this7.linePointsModel[i]), {}, {
          points: points
        })]);
      }, []);
    }
  }, {
    key: "getAreaOpacity",
    value: function getAreaOpacity(name, color) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }, {
    key: "renderAreaPointsModel",
    value: function renderAreaPointsModel() {
      var combinedLinePointsModel = this.getCombinedLinePointsModel();
      return this.isRangeChart ? this.renderRangeAreaSeries(combinedLinePointsModel) : this.renderAreaSeries(combinedLinePointsModel);
    }
  }, {
    key: "renderCircleModel",
    value: function renderCircleModel(showDot) {
      var _this8 = this;

      var dotSeriesModel = [];
      var responderModel = [];
      var dotTheme = this.theme.dot;
      this.linePointsModel.forEach(function (_ref4, modelIndex) {
        var points = _ref4.points,
            color = _ref4.color,
            seriesIndex = _ref4.seriesIndex,
            name = _ref4.name;
        var isPairLinePointsModel = _this8.isRangeChart && modelIndex >= _this8.linePointsModel.length / 2;
        var active = _this8.activeSeriesMap[name];
        points.forEach(function (point, index) {
          if (isNull(point)) {
            return;
          }

          var model = areaSeries_objectSpread(areaSeries_objectSpread({
            type: 'circle'
          }, point), {}, {
            seriesIndex: seriesIndex,
            name: name,
            index: isPairLinePointsModel ? points.length - index - 1 : index
          });

          if (showDot) {
            var _dotTheme$borderColor;

            dotSeriesModel.push(areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
              radius: dotTheme.radius,
              color: getRGBA(color, active ? 1 : 0.3),
              style: [{
                lineWidth: dotTheme.borderWidth,
                strokeStyle: (_dotTheme$borderColor = dotTheme.borderColor) !== null && _dotTheme$borderColor !== void 0 ? _dotTheme$borderColor : color
              }]
            }));
          }

          responderModel.push.apply(responderModel, areaSeries_toConsumableArray(_this8.getResponderSeriesWithTheme([model], 'hover', color)));
        });
      });
      return {
        dotSeriesModel: dotSeriesModel,
        responderModel: responderModel
      };
    }
  }, {
    key: "getPairCircleModel",
    value: function getPairCircleModel(circleModels) {
      var _this9 = this;

      var pairCircleModels = [];
      circleModels.forEach(function (circle) {
        var seriesIndex = circle.seriesIndex,
            y = circle.y,
            data = circle.data;
        var category = data.category;

        var pairCircleModel = _this9.tooltipCircleMap[category].find(function (model) {
          return model.seriesIndex === seriesIndex && model.y !== y;
        });

        pairCircleModels.push(pairCircleModel);
      });
      return pairCircleModels;
    }
  }, {
    key: "getCircleModelsFromRectResponders",
    value: function getCircleModelsFromRectResponders(responders, mousePositions) {
      var _this$tooltipCircleMa;

      if (!responders.length || !responders[0].label) {
        return [];
      }

      var models = (_this$tooltipCircleMa = this.tooltipCircleMap[responders[0].label]) !== null && _this$tooltipCircleMa !== void 0 ? _this$tooltipCircleMa : [];
      return this.eventDetectType === 'grouped' ? models : getNearestResponder(models, mousePositions, this.rect);
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var circleModels = this.getCircleModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: circleModels,
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = this.isRangeChart ? circleModels.slice(0, circleModels.length / 2) // for rendering unique tooltip data
      : circleModels;
    }
  }, {
    key: "onMousemoveNearestType",
    value: function onMousemoveNearestType(responders, mousePositions) {
      var circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemoveNearType",
    value: function onMousemoveNearType(responders) {
      var pairCircleModels = [];

      if (this.isRangeChart) {
        pairCircleModels = this.getPairCircleModel(responders);
      }

      var hoveredSeries = [].concat(areaSeries_toConsumableArray(responders), areaSeries_toConsumableArray(pairCircleModels));
      this.eventBus.emit('renderHoveredSeries', {
        models: hoveredSeries,
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = responders;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref5) {
      var responders = _ref5.responders,
          mousePosition = _ref5.mousePosition;

      if (this.eventDetectType === 'nearest') {
        this.onMousemoveNearestType(responders, mousePosition);
      } else if (['near', 'point'].includes(this.eventDetectType)) {
        this.onMousemoveNearType(responders);
      } else {
        this.onMousemoveGroupedType(responders);
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels) {
      var dataLabelTheme = this.theme.dataLabels;
      return seriesModels.flatMap(function (_ref6) {
        var points = _ref6.points,
            name = _ref6.name,
            fillColor = _ref6.fillColor;
        return points.map(function (point) {
          return isNull(point) ? {} : areaSeries_objectSpread(areaSeries_objectSpread({
            type: 'point'
          }, point), {}, {
            name: name,
            theme: areaSeries_objectSpread(areaSeries_objectSpread({}, dataLabelTheme), {}, {
              color: dataLabelTheme.useSeriesColor ? getRGBA(fillColor, 1) : dataLabelTheme.color
            })
          });
        });
      });
    }
  }, {
    key: "getResponderSeriesWithTheme",
    value: function getResponderSeriesWithTheme(models, type, seriesColor) {
      var _ref7 = this.theme[type].dot,
          radius = _ref7.radius,
          color = _ref7.color,
          borderWidth = _ref7.borderWidth,
          borderColor = _ref7.borderColor;
      return models.map(function (model) {
        var _ref8;

        var modelColor = (_ref8 = color !== null && color !== void 0 ? color : model.color) !== null && _ref8 !== void 0 ? _ref8 : seriesColor;
        return areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
          radius: radius,
          color: modelColor,
          style: [{
            lineWidth: borderWidth,
            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
          }]
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders,
          mousePosition = _ref9.mousePosition;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'near') {
          models = responders;
        } else {
          models = this.getCircleModelsFromRectResponders(responders, mousePosition);
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: this.getResponderSeriesWithTheme(models, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderCategoryByIndex",
    value: function getResponderCategoryByIndex(index) {
      var _responder$data;

      var responder = Object.values(this.tooltipCircleMap).flatMap(function (val) {
        return val;
      }).find(function (model) {
        return model.index === index;
      });
      return responder === null || responder === void 0 ? void 0 : (_responder$data = responder.data) === null || _responder$data === void 0 ? void 0 : _responder$data.category;
    }
  }]);

  return AreaSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/areaChart.ts
function areaChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { areaChart_typeof = function _typeof(obj) { return typeof obj; }; } else { areaChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return areaChart_typeof(obj); }


















function areaChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function areaChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { areaChart_ownKeys(Object(source), true).forEach(function (key) { areaChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { areaChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function areaChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function areaChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function areaChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function areaChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) areaChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) areaChart_defineProperties(Constructor, staticProps); return Constructor; }

function areaChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { areaChart_get = Reflect.get; } else { areaChart_get = function _get(target, property, receiver) { var base = areaChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return areaChart_get(target, property, receiver || target); }

function areaChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = areaChart_getPrototypeOf(object); if (object === null) break; } return object; }

function areaChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) areaChart_setPrototypeOf(subClass, superClass); }

function areaChart_setPrototypeOf(o, p) { areaChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return areaChart_setPrototypeOf(o, p); }

function areaChart_createSuper(Derived) { var hasNativeReflectConstruct = areaChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = areaChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = areaChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return areaChart_possibleConstructorReturn(this, result); }; }

function areaChart_possibleConstructorReturn(self, call) { if (call && (areaChart_typeof(call) === "object" || typeof call === "function")) { return call; } return areaChart_assertThisInitialized(self); }

function areaChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function areaChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function areaChart_getPrototypeOf(o) { areaChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return areaChart_getPrototypeOf(o); }































/**
 * @class
 * @classdesc Area Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Area Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Area Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {boolean|Object} [props.options.series.stack] - Option to decide whether to use stack chart and type of stack chart. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var AreaChart = /*#__PURE__*/function (_Chart) {
  areaChart_inherits(AreaChart, _Chart);

  var _super = areaChart_createSuper(AreaChart);

  function AreaChart(props) {
    areaChart_classCallCheck(this, AreaChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        area: props.data.series
      },
      categories: props.data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  areaChart_createClass(AreaChart, [{
    key: "initialize",
    value: function initialize() {
      areaChart_get(areaChart_getPrototypeOf(AreaChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(AreaSeries);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(DataLabels);
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(Zoom);
      this.componentManager.add(ResetButton);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.resetSeries();
      this.animationControlFlag.updating = true;
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          area: series
        },
        categories: categories
      });
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     * @param {Array<string|number>} data.range - The range to be drawn.
     * @param {string} data.color - Plot band color.
     * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed.
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', areaChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return AreaChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/scatterSeries.ts
function scatterSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { scatterSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { scatterSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return scatterSeries_typeof(obj); }

function scatterSeries_toConsumableArray(arr) { return scatterSeries_arrayWithoutHoles(arr) || scatterSeries_iterableToArray(arr) || scatterSeries_unsupportedIterableToArray(arr) || scatterSeries_nonIterableSpread(); }

function scatterSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function scatterSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scatterSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scatterSeries_arrayLikeToArray(o, minLen); }

function scatterSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function scatterSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return scatterSeries_arrayLikeToArray(arr); }

function scatterSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_scatterSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function component_scatterSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_scatterSeries_ownKeys(Object(source), true).forEach(function (key) { component_scatterSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_scatterSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }


























function scatterSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function scatterSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function scatterSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) scatterSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) scatterSeries_defineProperties(Constructor, staticProps); return Constructor; }

function scatterSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) scatterSeries_setPrototypeOf(subClass, superClass); }

function scatterSeries_setPrototypeOf(o, p) { scatterSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scatterSeries_setPrototypeOf(o, p); }

function scatterSeries_createSuper(Derived) { var hasNativeReflectConstruct = scatterSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scatterSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scatterSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scatterSeries_possibleConstructorReturn(this, result); }; }

function scatterSeries_possibleConstructorReturn(self, call) { if (call && (scatterSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return scatterSeries_assertThisInitialized(self); }

function scatterSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function scatterSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function scatterSeries_getPrototypeOf(o) { scatterSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scatterSeries_getPrototypeOf(o); }

function component_scatterSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var ScatterSeries = /*#__PURE__*/function (_Component) {
  scatterSeries_inherits(ScatterSeries, _Component);

  var _super = scatterSeries_createSuper(ScatterSeries);

  function ScatterSeries() {
    var _this;

    scatterSeries_classCallCheck(this, ScatterSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "theme", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "drawModels", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "responders", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "activatedResponders", []);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "rect", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "getModelsForSelectInfo", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex,
          state = info.state;

      if (!isNumber(index) || !isNumber(seriesIndex) || !isAvailableSelectSeries(info, 'scatter')) {
        return;
      }

      var name = state.series.scatter.data[seriesIndex].name;
      return [_this.responders.filter(function (_ref) {
        var dataName = _ref.name;
        return dataName === name;
      })[index]];
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var models = _this.getModelsForSelectInfo(info);

      if (!models) {
        return;
      }

      if (!models.length) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getResponderAppliedTheme(models, 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var models = _this.getModelsForSelectInfo(info);

      if (!models) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  scatterSeries_createClass(ScatterSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'scatter';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      this.drawModels.series.forEach(function (model, index) {
        model.size = _this2.models.series[index].size * delta;
      });
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _labelRange,
          _axes$xAxis,
          _this3 = this;

      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme,
          axes = chartState.axes;

      if (!series.scatter) {
        throw new Error(message.noDataError(this.name));
      }

      var scatterData = series.scatter.data;
      this.theme = theme.series.scatter;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var limit = (_labelRange = (_axes$xAxis = axes.xAxis) === null || _axes$xAxis === void 0 ? void 0 : _axes$xAxis.labelRange) !== null && _labelRange !== void 0 ? _labelRange : scale.xAxis.limit; // labelRange is created only for line scatter charts

      var seriesModel = this.renderScatterPointsModel(scatterData, limit, scale[getValueAxisName(options, this.name, 'yAxis')].limit);
      var tooltipModel = this.makeTooltipModel(scatterData);
      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = deepCopy(this.models);
      }

      this.responders = seriesModel.map(function (m, index) {
        return component_scatterSeries_objectSpread(component_scatterSeries_objectSpread({}, m), {}, {
          type: 'circle',
          detectionSize: 0,
          radius: _this3.theme.size / 2,
          color: m.fillColor,
          style: [{
            strokeStyle: m.borderColor,
            lineWidth: m.borderWidth
          }],
          data: tooltipModel[index]
        });
      });
    }
  }, {
    key: "renderScatterPointsModel",
    value: function renderScatterPointsModel(seriesRawData, xAxisLimit, yAxisLimit) {
      var _this4 = this;

      return seriesRawData.flatMap(function (_ref2, seriesIndex) {
        var data = _ref2.data,
            name = _ref2.name,
            seriesColor = _ref2.color,
            iconType = _ref2.iconType;
        var models = [];
        var active = _this4.activeSeriesMap[name];
        var color = getRGBA(seriesColor, active ? 1 : 0.3);
        data.forEach(function (datum, index) {
          var rawXValue = getCoordinateXValue(datum);
          var xValue = utils_isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
          var yValue = getCoordinateYValue(datum);
          var xValueRatio = getValueRatio(xValue, xAxisLimit);
          var yValueRatio = getValueRatio(yValue, yAxisLimit);
          var x = xValueRatio * _this4.rect.width;
          var y = (1 - yValueRatio) * _this4.rect.height;
          models.push(component_scatterSeries_objectSpread({
            x: x,
            y: y,
            type: 'scatterSeries',
            iconType: iconType,
            seriesIndex: seriesIndex,
            name: name,
            borderColor: color,
            index: index
          }, pick(_this4.theme, 'borderWidth', 'size', 'fillColor')));
        });
        return models;
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleData) {
      return scatterSeries_toConsumableArray(circleData).flatMap(function (_ref3) {
        var data = _ref3.data,
            name = _ref3.name,
            color = _ref3.color;
        var tooltipData = [];
        data.forEach(function (datum) {
          var value = {
            x: getCoordinateXValue(datum),
            y: getCoordinateYValue(datum)
          };
          tooltipData.push({
            label: name,
            color: color,
            value: value
          });
        });
        return tooltipData;
      });
    }
  }, {
    key: "getClosestModel",
    value: function getClosestModel(closestResponder) {
      if (!closestResponder.length) {
        return [];
      }

      var model = this.models.series.find(function (_ref4) {
        var index = _ref4.index,
            seriesIndex = _ref4.seriesIndex;
        return isNumber(index) && isNumber(seriesIndex) && index === closestResponder[0].index && seriesIndex === closestResponder[0].seriesIndex;
      });
      return model ? [model] : [];
    }
  }, {
    key: "getResponderAppliedTheme",
    value: function getResponderAppliedTheme(closestModel, type) {
      var _this5 = this;

      var _this$theme$type = this.theme[type],
          fillColor = _this$theme$type.fillColor,
          size = _this$theme$type.size;
      return closestModel.map(function (m) {
        return deepMergedCopy(m, component_scatterSeries_objectSpread(component_scatterSeries_objectSpread({}, _this5.theme[type]), {}, {
          color: fillColor,
          radius: size / 2
        }));
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref5) {
      var responders = _ref5.responders,
          mousePosition = _ref5.mousePosition;
      var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
      var closestModel = this.getClosestModel(closestResponder);
      closestModel = this.getResponderAppliedTheme(closestModel, 'hover');
      this.eventBus.emit('renderHoveredSeries', {
        models: closestModel,
        name: this.name
      });
      this.activatedResponders = closestResponder;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref6) {
      var responders = _ref6.responders,
          mousePosition = _ref6.mousePosition;

      if (this.selectable) {
        var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
        var closestModel = this.getClosestModel(closestResponder);
        closestModel = this.getResponderAppliedTheme(closestModel, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: closestModel,
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }]);

  return ScatterSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/lineScatterChart.ts
function lineScatterChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineScatterChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineScatterChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineScatterChart_typeof(obj); }


















function lineScatterChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function lineScatterChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineScatterChart_ownKeys(Object(source), true).forEach(function (key) { lineScatterChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineScatterChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineScatterChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function lineScatterChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineScatterChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineScatterChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineScatterChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineScatterChart_defineProperties(Constructor, staticProps); return Constructor; }

function lineScatterChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { lineScatterChart_get = Reflect.get; } else { lineScatterChart_get = function _get(target, property, receiver) { var base = lineScatterChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return lineScatterChart_get(target, property, receiver || target); }

function lineScatterChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineScatterChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineScatterChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineScatterChart_setPrototypeOf(subClass, superClass); }

function lineScatterChart_setPrototypeOf(o, p) { lineScatterChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineScatterChart_setPrototypeOf(o, p); }

function lineScatterChart_createSuper(Derived) { var hasNativeReflectConstruct = lineScatterChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineScatterChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineScatterChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineScatterChart_possibleConstructorReturn(this, result); }; }

function lineScatterChart_possibleConstructorReturn(self, call) { if (call && (lineScatterChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineScatterChart_assertThisInitialized(self); }

function lineScatterChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineScatterChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function lineScatterChart_getPrototypeOf(o) { lineScatterChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineScatterChart_getPrototypeOf(o); }































/**
 * @class
 * @classdesc LineScatter Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making LineArea Chart.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Only coordinate type data is possible.
 *       @param {Array<Object>} props.data.series.scatter - Scatter series data.
 *   @param {Object} [props.options] - Options for making LineScatter Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|LineScatter Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var LineScatterChart = /*#__PURE__*/function (_Chart) {
  lineScatterChart_inherits(LineScatterChart, _Chart);

  var _super = lineScatterChart_createSuper(LineScatterChart);

  function LineScatterChart(props) {
    lineScatterChart_classCallCheck(this, LineScatterChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: props.data.series,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  lineScatterChart_createClass(LineScatterChart, [{
    key: "initialize",
    value: function initialize() {
      lineScatterChart_get(lineScatterChart_getPrototypeOf(LineScatterChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(LineSeries);
      this.componentManager.add(ScatterSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(DataLabels);
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(Zoom);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject, scatterSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([{x: 10, y: 20}, {x: 30, y: 40}], 'line');
     */

  }, {
    key: "addData",
    value: function addData(data, chartType) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        chartType: chartType
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     *   @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [{x: 10, y: 20}, {x: 30, y: 40}],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', lineScatterChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   series: {
     *     line: [
     *       {
     *         name: 'A',
     *         data: [{x: 10, y: 20}, {x: 30, y: 40}],
     *       }
     *     ],
     *     scatter: [
     *       {
     *         name: 'B',
     *         data: [{x: 30, y: 20}, {x: 40, y: 40}],
     *       }
     *     ]
     *   }
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed
     *      @param {number} seriesInfo.seriesIndex - Index of series
     *      @param {number} seriesInfo.index - Index of data within series
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'scatter'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', lineScatterChart_objectSpread(lineScatterChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return LineScatterChart;
}(Chart);


;// CONCATENATED MODULE: ./src/charts/lineAreaChart.ts
function lineAreaChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineAreaChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineAreaChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineAreaChart_typeof(obj); }


















function lineAreaChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function lineAreaChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineAreaChart_ownKeys(Object(source), true).forEach(function (key) { lineAreaChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineAreaChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineAreaChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function lineAreaChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineAreaChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineAreaChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineAreaChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineAreaChart_defineProperties(Constructor, staticProps); return Constructor; }

function lineAreaChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { lineAreaChart_get = Reflect.get; } else { lineAreaChart_get = function _get(target, property, receiver) { var base = lineAreaChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return lineAreaChart_get(target, property, receiver || target); }

function lineAreaChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineAreaChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineAreaChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineAreaChart_setPrototypeOf(subClass, superClass); }

function lineAreaChart_setPrototypeOf(o, p) { lineAreaChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineAreaChart_setPrototypeOf(o, p); }

function lineAreaChart_createSuper(Derived) { var hasNativeReflectConstruct = lineAreaChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineAreaChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineAreaChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineAreaChart_possibleConstructorReturn(this, result); }; }

function lineAreaChart_possibleConstructorReturn(self, call) { if (call && (lineAreaChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineAreaChart_assertThisInitialized(self); }

function lineAreaChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineAreaChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function lineAreaChart_getPrototypeOf(o) { lineAreaChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineAreaChart_getPrototypeOf(o); }
































/**
 * @class
 * @classdesc LineArea Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making LineArea Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Coordinate types data is not possible.
 *       @param {Array<Object>} props.data.series.area - Area series data.
 *   @param {Object} [props.options] - Options for making LineArea Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.series.area] - Options to be applied to the area chart. 'stack', 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|LineArea Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var LineAreaChart = /*#__PURE__*/function (_Chart) {
  lineAreaChart_inherits(LineAreaChart, _Chart);

  var _super = lineAreaChart_createSuper(LineAreaChart);

  function LineAreaChart(props) {
    lineAreaChart_classCallCheck(this, LineAreaChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: props.data.series,
      categories: props.data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  lineAreaChart_createClass(LineAreaChart, [{
    key: "initialize",
    value: function initialize() {
      lineAreaChart_get(lineAreaChart_getPrototypeOf(LineAreaChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(AreaSeries);
      this.componentManager.add(LineSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(DataLabels);
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(Zoom);
      this.componentManager.add(ResetButton);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([10, 20], '6', 'line');
     */

  }, {
    key: "addData",
    value: function addData(data, category, chartType) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category,
        chartType: chartType
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     *   @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', lineAreaChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: {
     *     line: [
     *       {
     *         name: 'A',
     *         data: [1, 2, 3],
     *       }
     *     ],
     *     area: [
     *       {
     *         name: 'B',
     *         data: [4, 5, 6],
     *       }
     *     ]
     *   }
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Add plot line.
     * @param {Object} data - plot info
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     * @param {Array<string|number>} data.range - The range to be drawn.
     * @param {string} data.color - Plot band color.
     * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - Id of the plot band to be removed.
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'line'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', lineAreaChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return LineAreaChart;
}(Chart);


;// CONCATENATED MODULE: ./src/helpers/boxSeries.ts
function limitNegative(value, min, max) {
  var result = value;

  if (result >= max) {
    return 0;
  }

  if (max < 0) {
    result = Math.min(value - max, 0);
  }

  if (value < min) {
    result -= value - min;
  }

  return result;
}

function limitPositive(value, min, max) {
  var result = value;

  if (min > 0) {
    result = Math.max(value - min, 0);
  }

  if (value > max) {
    result -= value - max;
  }

  return result;
}

function calibrateDrawingValue(value, min, max) {
  return value < 0 ? limitNegative(value, min, max) : limitPositive(value, min, max);
}
function sumValuesBeforeIndex(values, targetIndex) {
  var includeTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var target = values[targetIndex];
  return values.reduce(function (total, value, idx) {
    var isBefore = includeTarget ? idx <= targetIndex : idx < targetIndex;
    var isSameSign = value * target >= 0;
    return isBefore && isSameSign ? total + value : total;
  }, 0);
}
function outsideRange(values, currentIndex, min, max) {
  var value = values[currentIndex];
  var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
  var positive = value >= 0;
  var negative = value < 0;
  return positive && totalOfIndexBefore >= max || negative && totalOfIndexBefore <= min || currentIndex === 0 && positive && value < min || currentIndex === 0 && negative && value > max;
}
function calibrateBoxStackDrawingValue(values, currentIndex, min, max) {
  var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
  var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);

  if (outsideRange(values, currentIndex, min, max)) {
    return null;
  }

  if (currentIndex === 0) {
    return calibrateDrawingValue(values[currentIndex], min, max);
  }

  if (totalOfIndexBefore < min && totalOfValues > max) {
    return max - min;
  }

  var result = values[currentIndex];

  if (totalOfValues > max) {
    result = max - totalOfIndexBefore;
  } else if (totalOfValues < min) {
    result = min - totalOfIndexBefore;
  } else if (totalOfIndexBefore < min) {
    result = totalOfValues - min;
  } else if (totalOfIndexBefore > max) {
    result = totalOfValues - max;
  }

  return result;
}
;// CONCATENATED MODULE: ./src/component/boxSeries.ts
function boxSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxSeries_typeof(obj); }

function boxSeries_toConsumableArray(arr) { return boxSeries_arrayWithoutHoles(arr) || boxSeries_iterableToArray(arr) || boxSeries_unsupportedIterableToArray(arr) || boxSeries_nonIterableSpread(); }

function boxSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function boxSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxSeries_arrayLikeToArray(arr); }

function boxSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxSeries_ownKeys(Object(source), true).forEach(function (key) { boxSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
























function boxSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxSeries_setPrototypeOf(subClass, superClass); }

function boxSeries_setPrototypeOf(o, p) { boxSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxSeries_setPrototypeOf(o, p); }

function boxSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxSeries_possibleConstructorReturn(this, result); }; }

function boxSeries_possibleConstructorReturn(self, call) { if (call && (boxSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxSeries_assertThisInitialized(self); }

function boxSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function boxSeries_getPrototypeOf(o) { boxSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxSeries_getPrototypeOf(o); }

function boxSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function boxSeries_slicedToArray(arr, i) { return boxSeries_arrayWithHoles(arr) || boxSeries_iterableToArrayLimit(arr, i) || boxSeries_unsupportedIterableToArray(arr, i) || boxSeries_nonIterableRest(); }

function boxSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxSeries_arrayLikeToArray(o, minLen); }

function boxSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }














var SeriesDirection;

(function (SeriesDirection) {
  SeriesDirection[SeriesDirection["POSITIVE"] = 0] = "POSITIVE";
  SeriesDirection[SeriesDirection["NEGATIVE"] = 1] = "NEGATIVE";
  SeriesDirection[SeriesDirection["BOTH"] = 2] = "BOTH";
})(SeriesDirection || (SeriesDirection = {}));

var BOX = {
  BAR: 'bar',
  COLUMN: 'column'
};
function isLeftBottomSide(seriesIndex) {
  return !!(seriesIndex % 2);
}

function calculateBarLength(value, min, max) {
  if (isRangeValue(value)) {
    var _value = boxSeries_slicedToArray(value, 2),
        start = _value[0],
        end = _value[1];

    if (start < min) {
      start = min;
    }

    if (end > max) {
      end = max;
    }

    return end - start;
  }

  return calibrateDrawingValue(value, min, max);
}

var BoxSeries = /*#__PURE__*/function (_Component) {
  boxSeries_inherits(BoxSeries, _Component);

  var _super = boxSeries_createSuper(BoxSeries);

  function BoxSeries() {
    var _this;

    boxSeries_classCallCheck(this, BoxSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "drawModels", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "responders", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "activatedResponders", []);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "isBar", true);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "valueAxis", 'xAxis');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "labelAxis", 'yAxis');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "anchorSizeKey", 'height');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "offsetSizeKey", 'width');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "basePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "leftBasePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "rightBasePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "isRangeData", false);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "offsetKey", 'x');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "theme", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'column')) {
        return;
      }

      var model = _this.tooltipRectMap[seriesIndex][index];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'column')) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.getGroupedRect([_this.responders[index]], 'hover') : _this.getRespondersWithTheme([_this.tooltipRectMap[index][seriesIndex]], 'hover');

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.activatedResponders = _this.eventDetectType === 'grouped' ? _this.tooltipRectMap[index] : models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxSeries_createClass(BoxSeries, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name,
          stackChart = _ref.stackChart;
      this.initializeFields(name);

      if (!stackChart) {
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
      }
    }
  }, {
    key: "initializeFields",
    value: function initializeFields(name) {
      this.type = 'series';
      this.name = name;
      this.isBar = name === BOX.BAR;
      this.offsetKey = this.isBar ? 'x' : 'y';
      this.valueAxis = this.isBar ? 'xAxis' : 'yAxis';
      this.labelAxis = this.isBar ? 'yAxis' : 'xAxis';
      this.anchorSizeKey = this.isBar ? 'height' : 'width';
      this.offsetSizeKey = this.isBar ? 'width' : 'height';
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      if (this.isRangeData) {
        this.initUpdateRangeData(delta);
        return;
      }

      this.initUpdateClipRect(delta);
      this.initUpdateConnector(delta);
    }
  }, {
    key: "initUpdateRangeData",
    value: function initUpdateRangeData(delta) {
      var _this2 = this;

      var series = this.drawModels.series;
      this.drawModels.clipRect = this.models.clipRect;
      var target = this.models.series;
      series.forEach(function (current, index) {
        var targetModel = target[index];

        if (delta === 0) {
          current[_this2.offsetSizeKey] = 0;
        }

        var offsetSize = current[_this2.offsetSizeKey] + (targetModel[_this2.offsetSizeKey] - current[_this2.offsetSizeKey]) * delta;
        current[_this2.offsetSizeKey] = offsetSize;

        if (!_this2.isBar) {
          current[_this2.offsetKey] = targetModel[_this2.offsetKey] + targetModel[_this2.offsetSizeKey] - offsetSize;
        }
      });
    }
  }, {
    key: "initUpdateClipRect",
    value: function initUpdateClipRect(delta) {
      var clipRect = this.drawModels.clipRect;

      if (!clipRect) {
        return;
      }

      var current = clipRect[0];
      var key = this.offsetSizeKey;
      var target = this.models.clipRect[0];
      var offsetSize = current[key] + (target[key] - current[key]) * delta;
      current[key] = offsetSize;
      current[this.offsetKey] = Math.max(this.basePosition - offsetSize * this.basePosition / target[key], 0);
    }
  }, {
    key: "initUpdateConnector",
    value: function initUpdateConnector(delta) {
      var connector = this.drawModels.connector;

      if (!connector) {
        return;
      }

      var target = this.models.connector;
      connector.forEach(function (current, index) {
        var alpha = getAlpha(target[index].strokeStyle) * delta;
        current.strokeStyle = getRGBA(current.strokeStyle, alpha);
      });
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (series.line) {
        this.eventDetectType = 'grouped';
      }

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }
    }
  }, {
    key: "getOptions",
    value: function getOptions(chartOptions) {
      var options = boxSeries_objectSpread({}, chartOptions);

      if (options !== null && options !== void 0 && options.series && options.series.column) {
        options.series = boxSeries_objectSpread(boxSeries_objectSpread({}, options.series), options.series.column);
      }

      return options;
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref2,
          _options$series2,
          _this3 = this;

      var layout = chartState.layout,
          series = chartState.series,
          axes = chartState.axes,
          stackSeries = chartState.stackSeries,
          legend = chartState.legend,
          theme = chartState.theme,
          scale = chartState.scale;
      this.isShow = !(stackSeries && stackSeries[this.name]);

      if (!this.isShow) {
        return;
      }

      var categories = (_ref2 = chartState.categories) !== null && _ref2 !== void 0 ? _ref2 : [];
      var options = this.getOptions(chartState.options);
      this.setEventDetectType(series, options);
      this.theme = theme.series[this.name];
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      this.valueAxis = getValueAxisName(options, this.name, this.isBar ? 'xAxis' : 'yAxis');
      var seriesData = series[this.name].data.map(function (seriesDatum) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, seriesDatum), {}, {
          data: getDataInRange(seriesDatum.data, computed.viewRange)
        });
      });

      if (axes.centerYAxis) {
        this.valueAxis = 'centerYAxis';
      }

      var tickDistance = axes[this.labelAxis].tickDistance;
      var diverging = !!((_options$series2 = options.series) !== null && _options$series2 !== void 0 && _options$series2.diverging);

      var _this$getScaleData = this.getScaleData(scale),
          limit = _this$getScaleData.limit,
          stepSize = _this$getScaleData.stepSize;

      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      this.basePosition = this.getBasePosition(axes[this.valueAxis]);
      var offsetSize = this.getOffsetSize();
      var centerYAxis = axes.centerYAxis;

      if (diverging) {
        var _this$getDivergingBas = this.getDivergingBasePosition(centerYAxis),
            _this$getDivergingBas2 = boxSeries_slicedToArray(_this$getDivergingBas, 2),
            left = _this$getDivergingBas2[0],
            right = _this$getDivergingBas2[1];

        this.basePosition = this.getOffsetSize() / 2;
        this.leftBasePosition = left;
        this.rightBasePosition = right;
        offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
      }

      var renderOptions = {
        min: min,
        max: max,
        tickDistance: tickDistance,
        diverging: diverging,
        ratio: this.getValueRatio(min, max, offsetSize),
        hasNegativeValue: hasNegative(labels),
        seriesDirection: this.getSeriesDirection(labels),
        defaultPadding: getBoxTypeSeriesPadding(tickDistance)
      };
      var seriesModels = this.renderSeriesModel(seriesData, renderOptions);
      var tooltipData = this.makeTooltipData(seriesData, renderOptions, categories);
      var clipRect = this.renderClipRectAreaModel();
      this.models = {
        clipRect: [clipRect],
        series: seriesModels
      };

      if (!this.drawModels) {
        this.drawModels = {
          clipRect: [this.initClipRect(clipRect)],
          series: deepCopyArray(seriesModels)
        };
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var dataLabelData = seriesModels.reduce(function (acc, data) {
          return isRangeValue(data.value) ? [].concat(boxSeries_toConsumableArray(acc), boxSeries_toConsumableArray(_this3.makeDataLabelRangeData(data))) : [].concat(boxSeries_toConsumableArray(acc), [_this3.makeDataLabel(data, centerYAxis)]);
        }, []);
        this.renderDataLabels(dataLabelData);
      }

      this.tooltipRectMap = this.makeTooltipRectMap(seriesModels, tooltipData);
      this.responders = this.getBoxSeriesResponders(seriesModels, tooltipData, axes, categories);
    }
  }, {
    key: "getScaleData",
    value: function getScaleData(scale) {
      return scale[this.valueAxis === 'centerYAxis' ? 'xAxis' : this.valueAxis];
    }
  }, {
    key: "getBoxSeriesResponders",
    value: function getBoxSeriesResponders(seriesModels, tooltipData, axes, categories) {
      var hoveredSeries = this.renderHoveredSeriesModel(seriesModels);
      return this.eventDetectType === 'grouped' ? makeRectResponderModel(this.rect, this.isBar ? axes.yAxis : axes.xAxis, categories, !this.isBar) : hoveredSeries.map(function (m, index) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, m), {}, {
          data: tooltipData[index]
        });
      });
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(seriesModels, tooltipDataArr) {
      return seriesModels.reduce(function (acc, cur, dataIndex) {
        var index = cur.index;

        var tooltipModel = boxSeries_objectSpread(boxSeries_objectSpread({}, cur), {}, {
          data: tooltipDataArr[dataIndex]
        });

        if (!acc[index]) {
          acc[index] = [];
        }

        acc[index].push(tooltipModel);
        return acc;
      }, []);
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel() {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "initClipRect",
    value: function initClipRect(clipRect) {
      return {
        type: 'clipRectArea',
        width: this.isBar ? 0 : clipRect.width,
        height: this.isBar ? clipRect.height : 0,
        x: this.isBar ? 0 : clipRect.x,
        y: this.isBar ? clipRect.y : 0
      };
    }
  }, {
    key: "renderSeriesModel",
    value: function renderSeriesModel(seriesData, renderOptions) {
      var _this4 = this;

      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging;
      var seriesLength = seriesData.length;
      var validDiverging = diverging && seriesData.length === 2;
      var columnWidth = this.getColumnWidth(renderOptions, seriesLength, validDiverging);
      var seriesModels = [];
      var padding = (tickDistance - columnWidth * (validDiverging ? 1 : seriesLength)) / 2;
      seriesData.forEach(function (_ref3, seriesIndex) {
        var data = _ref3.data,
            seriesColor = _ref3.color,
            name = _ref3.name;
        var seriesPos = (diverging ? 0 : seriesIndex) * columnWidth + padding;
        var isLBSideWithDiverging = diverging && isLeftBottomSide(seriesIndex);
        _this4.isRangeData = isRangeData(data);
        data.forEach(function (value, index) {
          var dataStart = seriesPos + index * tickDistance;

          var barLength = _this4.makeBarLength(value, renderOptions);

          var color = _this4.getSeriesColor(name, seriesColor);

          if (isNumber(barLength)) {
            var startPosition = _this4.getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging);

            seriesModels.push(boxSeries_objectSpread(boxSeries_objectSpread({
              type: 'rect',
              color: color,
              value: value
            }, _this4.getAdjustedRect(dataStart, startPosition, barLength, columnWidth)), {}, {
              name: name,
              index: index
            }));
          }
        });
      });
      return seriesModels;
    }
  }, {
    key: "renderHoveredSeriesModel",
    value: function renderHoveredSeriesModel(seriesModel) {
      var _this5 = this;

      return seriesModel.map(function (data) {
        return _this5.makeHoveredSeriesModel(data);
      });
    }
  }, {
    key: "makeHoveredSeriesModel",
    value: function makeHoveredSeriesModel(data) {
      var _ref4 = data,
          x = _ref4.x,
          y = _ref4.y,
          width = _ref4.width,
          height = _ref4.height,
          color = _ref4.color,
          index = _ref4.index;
      return {
        type: 'rect',
        color: getRGBA(color, 1),
        x: x,
        y: y,
        width: width,
        height: height,
        index: index
      };
    }
  }, {
    key: "getRectModelsFromRectResponders",
    value: function getRectModelsFromRectResponders(responders) {
      var _this$tooltipRectMap;

      if (!responders.length) {
        return [];
      }

      return (_this$tooltipRectMap = this.tooltipRectMap[responders[0].index]) !== null && _this$tooltipRectMap !== void 0 ? _this$tooltipRectMap : [];
    }
  }, {
    key: "getGroupedRect",
    value: function getGroupedRect(responders, type) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      var _ref5 = this.theme[type].groupedRect,
          color = _ref5.color,
          opacity = _ref5.opacity;
      return rectModels.length ? responders.map(function (m) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, m), {}, {
          color: getRGBA(color, opacity)
        });
      }) : [];
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getGroupedRect(responders, 'hover'),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = rectModels;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref6) {
      var responders = _ref6.responders;

      if (this.eventDetectType === 'grouped') {
        this.onMousemoveGroupedType(responders);
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = responders;
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(seriesData, renderOptions, categories) {
      var _this6 = this;

      var tooltipData = [];
      seriesData.forEach(function (_ref7) {
        var data = _ref7.data,
            name = _ref7.name,
            color = _ref7.color;
        data.forEach(function (value, dataIndex) {
          if (!isNull(value)) {
            var barLength = _this6.makeBarLength(value, renderOptions);

            if (isNumber(barLength)) {
              tooltipData.push({
                label: name,
                color: color,
                value: _this6.getTooltipValue(value),
                category: categories.length ? categories[dataIndex] : ''
              });
            }
          }
        });
      });
      return tooltipData;
    }
  }, {
    key: "getTooltipValue",
    value: function getTooltipValue(value) {
      return isRangeValue(value) ? "".concat(value[0], " ~ ").concat(value[1]) : value;
    }
  }, {
    key: "getBasePosition",
    value: function getBasePosition(_ref8) {
      var labels = _ref8.labels,
          tickCount = _ref8.tickCount,
          zeroPosition = _ref8.zeroPosition;
      var valueLabels = this.isBar ? labels : boxSeries_toConsumableArray(labels).reverse();
      var tickPositions = makeTickPixelPositions(this.getOffsetSize(), tickCount);
      var seriesDirection = this.getSeriesDirection(valueLabels);
      return zeroPosition ? zeroPosition : this.getTickPositionIfNotZero(tickPositions, seriesDirection);
    }
  }, {
    key: "getDivergingBasePosition",
    value: function getDivergingBasePosition(centerYAxis) {
      var leftZeroPosition, rightZeroPosition;

      if (centerYAxis) {
        leftZeroPosition = centerYAxis.xAxisHalfSize;
        rightZeroPosition = centerYAxis.secondStartX;
      } else {
        var divergingZeroPosition = this.getOffsetSize() / 2;
        leftZeroPosition = rightZeroPosition = divergingZeroPosition;
      }

      return [leftZeroPosition, rightZeroPosition];
    }
  }, {
    key: "getOffsetSize",
    value: function getOffsetSize() {
      return this.rect[this.offsetSizeKey];
    }
  }, {
    key: "getValueRatio",
    value: function getValueRatio(min, max, size) {
      return size / (max - min);
    }
  }, {
    key: "makeBarLength",
    value: function makeBarLength(value, renderOptions) {
      if (isNull(value)) {
        return null;
      }

      var min = renderOptions.min,
          max = renderOptions.max,
          ratio = renderOptions.ratio;
      var calculatedValue = calculateBarLength(value, min, max);
      return Math.max(this.getBarLength(calculatedValue, ratio), 2);
    }
  }, {
    key: "getBarLength",
    value: function getBarLength(value, ratio) {
      return value < 0 ? Math.abs(value) * ratio : value * ratio;
    }
  }, {
    key: "getStartPositionWithRangeValue",
    value: function getStartPositionWithRangeValue(value, barLength, renderOptions) {
      var min = renderOptions.min,
          ratio = renderOptions.ratio;

      var _value2 = boxSeries_slicedToArray(value, 1),
          start = _value2[0];

      if (start < min) {
        start = min;
      }

      var startPosition = (start - min) * ratio;
      return this.isBar ? startPosition : this.getOffsetSize() - startPosition - barLength;
    }
  }, {
    key: "getStartPosition",
    value: function getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging) {
      var diverging = renderOptions.diverging,
          seriesDirection = renderOptions.seriesDirection;
      var startPos;

      if (isRangeValue(value)) {
        startPos = this.getStartPositionWithRangeValue(value, barLength, renderOptions);
      } else if (diverging) {
        startPos = isLBSideWithDiverging ? this.getStartPosOnLeftBottomSide(barLength, diverging) : this.getStartPosOnRightTopSide(barLength, diverging);
      } else if (seriesDirection === SeriesDirection.POSITIVE) {
        startPos = this.getStartPosOnRightTopSide(barLength);
      } else if (seriesDirection === SeriesDirection.NEGATIVE) {
        startPos = this.getStartPosOnLeftBottomSide(barLength);
      } else {
        startPos = value < 0 ? this.getStartPosOnLeftBottomSide(barLength) : this.getStartPosOnRightTopSide(barLength);
      }

      return startPos;
    }
  }, {
    key: "getStartPosOnRightTopSide",
    value: function getStartPosOnRightTopSide(barLength) {
      var diverging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var pos;

      if (diverging) {
        pos = this.isBar ? this.rightBasePosition : this.rightBasePosition - barLength;
      } else {
        pos = this.isBar ? this.basePosition : this.basePosition - barLength;
      }

      return pos;
    }
  }, {
    key: "getStartPosOnLeftBottomSide",
    value: function getStartPosOnLeftBottomSide(barLength) {
      var diverging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var pos;

      if (diverging) {
        pos = this.isBar ? this.leftBasePosition - barLength : this.leftBasePosition;
      } else {
        pos = this.isBar ? this.basePosition - barLength : this.basePosition;
      }

      return pos;
    }
  }, {
    key: "getAdjustedRect",
    value: function getAdjustedRect(seriesPosition, dataPosition, barLength, columnWidth) {
      return {
        x: this.isBar ? dataPosition : seriesPosition,
        y: this.isBar ? seriesPosition : dataPosition,
        width: this.isBar ? barLength : columnWidth,
        height: this.isBar ? columnWidth : barLength
      };
    }
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(renderOptions, seriesLength) {
      var validDiverging = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tickDistance = renderOptions.tickDistance,
          defaultPadding = renderOptions.defaultPadding;
      seriesLength = validDiverging ? 1 : seriesLength;
      var themeBarWidth = this.theme.barWidth;
      return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / seriesLength;
    }
  }, {
    key: "getSeriesDirection",
    value: function getSeriesDirection(labels) {
      var result = SeriesDirection.BOTH;

      if (hasPositiveOnly(labels)) {
        result = SeriesDirection.POSITIVE;
      } else if (hasNegativeOnly(labels)) {
        result = SeriesDirection.NEGATIVE;
      }

      return result;
    }
  }, {
    key: "getTickPositionIfNotZero",
    value: function getTickPositionIfNotZero(tickPositions, direction) {
      if (!tickPositions.length) {
        return 0;
      }

      var firstTickPosition = Number(first(tickPositions));
      var lastTickPosition = Number(last(tickPositions));

      if (direction === SeriesDirection.POSITIVE) {
        return this.isBar ? firstTickPosition : lastTickPosition;
      }

      if (direction === SeriesDirection.NEGATIVE) {
        return this.isBar ? lastTickPosition : firstTickPosition;
      }

      return 0;
    }
  }, {
    key: "makeDataLabel",
    value: function makeDataLabel(rect, centerYAxis) {
      return boxSeries_objectSpread(boxSeries_objectSpread({}, rect), {}, {
        direction: this.getDataLabelDirection(rect, centerYAxis),
        plot: {
          x: 0,
          y: 0,
          size: this.getOffsetSize()
        },
        theme: omit(this.theme.dataLabels, 'stackTotal')
      });
    }
  }, {
    key: "makeDataLabelRangeData",
    value: function makeDataLabelRangeData(rect) {
      var _this7 = this;

      return rect.value.reduce(function (acc, value, index) {
        return [].concat(boxSeries_toConsumableArray(acc), [boxSeries_objectSpread(boxSeries_objectSpread({}, rect), {}, {
          value: value,
          direction: _this7.getDataLabelRangeDataDirection(index % 2 === 0),
          plot: {
            x: 0,
            y: 0,
            size: _this7.getOffsetSize()
          },
          theme: omit(_this7.theme.dataLabels, 'stackTotal')
        })]);
      }, []);
    }
  }, {
    key: "getDataLabelRangeDataDirection",
    value: function getDataLabelRangeDataDirection(isEven) {
      var direction;

      if (this.isBar) {
        direction = isEven ? 'left' : 'right';
      } else {
        direction = isEven ? 'bottom' : 'top';
      }

      return direction;
    }
  }, {
    key: "getDataLabelDirection",
    value: function getDataLabelDirection(rect, centerYAxis) {
      var direction;

      if (this.isBar) {
        var basePos = centerYAxis ? this.leftBasePosition : this.basePosition;
        direction = rect.x < basePos ? 'left' : 'right';
      } else {
        direction = rect.y >= this.basePosition ? 'bottom' : 'top';
      }

      return direction;
    }
  }, {
    key: "getOffsetSizeWithDiverging",
    value: function getOffsetSizeWithDiverging(centerYAxis) {
      return centerYAxis ? centerYAxis.xAxisHalfSize : this.getOffsetSize() / 2;
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'grouped') {
          models = [].concat(boxSeries_toConsumableArray(this.getGroupedRect(responders, 'select')), boxSeries_toConsumableArray(this.getRectModelsFromRectResponders(responders)));
        } else {
          models = this.getRespondersWithTheme(responders, 'select');
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          borderColor = _this$theme$type.borderColor,
          borderWidth = _this$theme$type.borderWidth,
          shadowBlur = _this$theme$type.shadowBlur,
          shadowColor = _this$theme$type.shadowColor,
          shadowOffsetX = _this$theme$type.shadowOffsetX,
          shadowOffsetY = _this$theme$type.shadowOffsetY;
      return responders.map(function (model) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, model), {}, {
          color: color !== null && color !== void 0 ? color : model.color,
          thickness: borderWidth,
          borderColor: borderColor,
          style: [{
            shadowBlur: shadowBlur,
            shadowColor: shadowColor,
            shadowOffsetX: shadowOffsetX,
            shadowOffsetY: shadowOffsetY
          }]
        });
      });
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(name, color) {
      var _this$theme = this.theme,
          select = _this$theme.select,
          areaOpacity = _this$theme.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }]);

  return BoxSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/boxStackSeries.ts
function boxStackSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxStackSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxStackSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxStackSeries_typeof(obj); }

function boxStackSeries_toConsumableArray(arr) { return boxStackSeries_arrayWithoutHoles(arr) || boxStackSeries_iterableToArray(arr) || boxStackSeries_unsupportedIterableToArray(arr) || boxStackSeries_nonIterableSpread(); }

function boxStackSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxStackSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function boxStackSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxStackSeries_arrayLikeToArray(arr); }

function boxStackSeries_slicedToArray(arr, i) { return boxStackSeries_arrayWithHoles(arr) || boxStackSeries_iterableToArrayLimit(arr, i) || boxStackSeries_unsupportedIterableToArray(arr, i) || boxStackSeries_nonIterableRest(); }

function boxStackSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxStackSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxStackSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxStackSeries_arrayLikeToArray(o, minLen); }

function boxStackSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxStackSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxStackSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function boxStackSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxStackSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxStackSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxStackSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxStackSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxStackSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxStackSeries_setPrototypeOf(subClass, superClass); }

function boxStackSeries_setPrototypeOf(o, p) { boxStackSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxStackSeries_setPrototypeOf(o, p); }

function boxStackSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxStackSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxStackSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxStackSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxStackSeries_possibleConstructorReturn(this, result); }; }

function boxStackSeries_possibleConstructorReturn(self, call) { if (call && (boxStackSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxStackSeries_assertThisInitialized(self); }

function boxStackSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxStackSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function boxStackSeries_getPrototypeOf(o) { boxStackSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxStackSeries_getPrototypeOf(o); }

























function boxStackSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxStackSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxStackSeries_ownKeys(Object(source), true).forEach(function (key) { boxStackSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxStackSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxStackSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














function boxStackSeries_calibrateDrawingValue(values, seriesIndex, renderOptions) {
  var stack = renderOptions.stack,
      min = renderOptions.min,
      max = renderOptions.max;
  return isPercentStack(stack) ? values[seriesIndex] : calibrateBoxStackDrawingValue(values, seriesIndex, min, max);
}

function getDivisorForPercent(total, scaleType) {
  var positive = total.positive,
      negative = total.negative;
  var divisor = positive + Math.abs(negative);

  if (includes(['dualPercentStack', 'divergingPercentStack'], scaleType)) {
    divisor *= 2;
  }

  return divisor;
}

function getDirectionKeys(seriesDirection) {
  var result = ['positive', 'negative'];

  if (seriesDirection === SeriesDirection.POSITIVE) {
    result = ['positive'];
  } else if (seriesDirection === SeriesDirection.NEGATIVE) {
    result = ['negative'];
  }

  return result;
}

function getStackSeriesDataInViewRange(stackSeriesData, viewRange) {
  if (!viewRange) {
    return stackSeriesData;
  }

  var stackData = Array.isArray(stackSeriesData.stackData) ? getDataInRange(stackSeriesData.stackData, viewRange) : boxStackSeries_objectSpread({}, Object.keys(stackSeriesData.stackData).reduce(function (acc, name) {
    return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, acc), {}, boxStackSeries_defineProperty({}, name, getDataInRange(stackSeriesData.stackData[name], viewRange)));
  }, {}));
  var data = stackSeriesData.data.map(function (seriesDatum) {
    return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, seriesDatum), {}, {
      data: getDataInRange(seriesDatum.data, viewRange)
    });
  });
  return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, stackSeriesData), {}, {
    data: data,
    stackData: stackData
  });
}

var BoxStackSeries = /*#__PURE__*/function (_BoxSeries) {
  boxStackSeries_inherits(BoxStackSeries, _BoxSeries);

  var _super = boxStackSeries_createSuper(BoxStackSeries);

  function BoxStackSeries() {
    var _this;

    boxStackSeries_classCallCheck(this, BoxStackSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxStackSeries_defineProperty(boxStackSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var stackSeries = state.stackSeries;
      var stackSeriesData = stackSeries[_this.name];
      var name = stackSeriesData.data[seriesIndex].name;

      var model = _this.tooltipRectMap[index].find(function (_ref2) {
        var seriesName = _ref2.name;
        return seriesName === name;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxStackSeries_createClass(BoxStackSeries, [{
    key: "initialize",
    value: function initialize(_ref3) {
      var name = _ref3.name,
          stackChart = _ref3.stackChart;
      this.initializeFields(name);

      if (stackChart) {
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
      }
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref4, _options$series;

      var layout = chartState.layout,
          seriesData = chartState.series,
          axes = chartState.axes,
          stackSeries = chartState.stackSeries,
          legend = chartState.legend,
          theme = chartState.theme,
          scale = chartState.scale;
      var viewRange = computed.viewRange;
      this.isShow = !!stackSeries[this.name];

      if (!this.isShow) {
        return;
      }

      var categories = (_ref4 = chartState.categories) !== null && _ref4 !== void 0 ? _ref4 : [];
      var options = this.getOptions(chartState.options);
      this.setEventDetectType(seriesData, options);
      this.theme = theme.series[this.name];
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var stackSeriesData = getStackSeriesDataInViewRange(stackSeries[this.name], viewRange);
      var tickDistance = axes[this.labelAxis].tickDistance;
      var diverging = !!((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.diverging);

      var _this$getScaleData = this.getScaleData(scale),
          limit = _this$getScaleData.limit,
          stepSize = _this$getScaleData.stepSize;

      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      var stack = stackSeriesData.stack,
          scaleType = stackSeriesData.scaleType;
      this.basePosition = this.getBasePosition(axes[this.valueAxis]);
      var offsetSize = this.getOffsetSize();
      var centerYAxis = axes.centerYAxis;

      if (diverging) {
        var _this$getDivergingBas = this.getDivergingBasePosition(centerYAxis),
            _this$getDivergingBas2 = boxStackSeries_slicedToArray(_this$getDivergingBas, 2),
            left = _this$getDivergingBas2[0],
            right = _this$getDivergingBas2[1];

        this.basePosition = this.getOffsetSize() / 2;
        this.leftBasePosition = left;
        this.rightBasePosition = right;
        offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
      }

      var renderOptions = {
        stack: stack,
        scaleType: scaleType,
        tickDistance: tickDistance,
        min: min,
        max: max,
        diverging: diverging,
        hasNegativeValue: hasNegative(labels),
        seriesDirection: this.getSeriesDirection(labels),
        defaultPadding: getBoxTypeSeriesPadding(tickDistance),
        offsetSize: offsetSize,
        centerYAxis: centerYAxis
      };

      var _this$renderStackSeri = this.renderStackSeriesModel(stackSeriesData, renderOptions),
          series = _this$renderStackSeri.series,
          connector = _this$renderStackSeri.connector;

      var clipRect = this.renderClipRectAreaModel();
      var tooltipData = this.getTooltipData(stackSeriesData, categories);
      this.models = {
        clipRect: [clipRect],
        series: series,
        connector: connector
      };

      if (!this.drawModels) {
        this.drawModels = {
          clipRect: [this.initClipRect(clipRect)],
          series: deepCopyArray(series),
          connector: deepCopyArray(connector)
        };
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var dataLabelData = this.getDataLabels(series, renderOptions);
        var stackTotalData = this.getTotalDataLabels(stackSeriesData, renderOptions);
        this.renderDataLabels([].concat(boxStackSeries_toConsumableArray(dataLabelData), boxStackSeries_toConsumableArray(stackTotalData)));
      }

      this.tooltipRectMap = this.makeTooltipRectMap(series, tooltipData);
      this.responders = this.getBoxSeriesResponders(series, tooltipData, axes, categories);
    }
  }, {
    key: "renderStackSeriesModel",
    value: function renderStackSeriesModel(seriesData, renderOptions) {
      var stackData = seriesData.stackData;
      return isGroupStack(stackData) ? this.makeStackGroupSeriesModel(seriesData, renderOptions) : this.makeStackSeriesModel(stackData, renderOptions, seriesData.data);
    }
  }, {
    key: "makeStackSeriesModel",
    value: function makeStackSeriesModel(stackData, renderOptions, seriesRawData) {
      var _this2 = this;

      var stackGroupCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var stackGroupIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var seriesModels = [];
      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      var diverging = renderOptions.diverging;
      var isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);
      stackData.forEach(function (_ref5, dataIndex) {
        var values = _ref5.values,
            total = _ref5.total;

        var seriesPos = _this2.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);

        var ratio = _this2.getStackValueRatio(total, renderOptions);

        values.forEach(function (value, seriesIndex) {
          var _this2$getStackRectIn = _this2.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging),
              barLength = _this2$getStackRectIn.barLength,
              dataPosition = _this2$getStackRectIn.dataPosition;

          var name = seriesRawData[seriesIndex].name;
          var active = _this2.activeSeriesMap[name];
          var color = getRGBA(seriesRawData[seriesIndex].color, active ? 1 : 0.2);
          seriesModels.push(boxStackSeries_objectSpread(boxStackSeries_objectSpread({
            type: 'rect',
            color: color,
            name: name,
            value: value
          }, _this2.getAdjustedRect(seriesPos, dataPosition, barLength !== null && barLength !== void 0 ? barLength : 0, columnWidth)), {}, {
            index: dataIndex
          }));
        });
      });
      return {
        series: seriesModels,
        connector: this.makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount, stackGroupIndex)
      };
    }
  }, {
    key: "makeStackGroupSeriesModel",
    value: function makeStackGroupSeriesModel(stackSeries, renderOptions) {
      var _this3 = this;

      var stack = renderOptions.stack;
      var stackGroupData = stackSeries.stackData;
      var seriesRawData = stackSeries.data;
      var stackGroupIds = Object.keys(stackGroupData);
      var seriesModels = [];
      var connectorModels = [];
      stackGroupIds.forEach(function (groupId, groupIndex) {
        var filtered = seriesRawData.filter(function (_ref6) {
          var stackGroup = _ref6.stackGroup;
          return stackGroup === groupId;
        });

        var _this3$makeStackSerie = _this3.makeStackSeriesModel(stackGroupData[groupId], renderOptions, filtered, stackGroupIds.length, groupIndex),
            series = _this3$makeStackSerie.series,
            connector = _this3$makeStackSerie.connector;

        seriesModels = [].concat(boxStackSeries_toConsumableArray(seriesModels), boxStackSeries_toConsumableArray(series));

        if (stack.connector) {
          connectorModels = [].concat(boxStackSeries_toConsumableArray(connectorModels), boxStackSeries_toConsumableArray(connector));
        }
      });
      return {
        series: seriesModels,
        connector: connectorModels
      };
    }
  }, {
    key: "makeConnectorSeriesModel",
    value: function makeConnectorSeriesModel(stackData, renderOptions) {
      var _this4 = this;

      var stackGroupCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var stackGroupIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var diverging = renderOptions.diverging,
          connector = renderOptions.stack.connector;

      if (!connector) {
        return [];
      }

      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      var isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);
      var connectorPoints = [];
      stackData.forEach(function (_ref7, index) {
        var values = _ref7.values,
            total = _ref7.total;

        var seriesPos = _this4.getSeriesPosition(renderOptions, columnWidth, index, stackGroupIndex, stackGroupCount);

        var points = [];

        var ratio = _this4.getStackValueRatio(total, renderOptions);

        values.forEach(function (value, seriesIndex) {
          var _this4$getStackRectIn = _this4.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging),
              barLength = _this4$getStackRectIn.barLength,
              dataPosition = _this4$getStackRectIn.dataPosition;

          var _this4$getAdjustedRec = _this4.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth),
              x = _this4$getAdjustedRec.x,
              y = _this4$getAdjustedRec.y;

          var xPos = !isLBSideWithDiverging && _this4.isBar ? x + barLength : x;
          var yPos = isLBSideWithDiverging && !_this4.isBar ? y + barLength : y;
          points.push({
            x: xPos,
            y: yPos
          });
        });
        connectorPoints.push(points);
      });
      return this.makeConnectorModel(connectorPoints, connector, columnWidth);
    }
  }, {
    key: "getTooltipData",
    value: function getTooltipData(seriesData, categories) {
      var seriesRawData = seriesData.data;
      var stackData = seriesData.stackData;
      var colors = seriesRawData.map(function (_ref8) {
        var color = _ref8.color;
        return color;
      });
      return isGroupStack(stackData) ? this.makeGroupStackTooltipData(seriesRawData, stackData, categories) : this.makeStackTooltipData(seriesRawData, stackData, colors, categories);
    }
  }, {
    key: "makeGroupStackTooltipData",
    value: function makeGroupStackTooltipData(seriesRawData, stackData, categories) {
      var _this5 = this;

      return Object.keys(stackData).flatMap(function (groupId) {
        var rawDataWithSameGroupId = seriesRawData.filter(function (_ref9) {
          var stackGroup = _ref9.stackGroup;
          return stackGroup === groupId;
        });
        var colors = rawDataWithSameGroupId.map(function (_ref10) {
          var color = _ref10.color;
          return color;
        });
        return _this5.makeStackTooltipData(rawDataWithSameGroupId, stackData[groupId], colors, categories);
      });
    }
  }, {
    key: "makeStackTooltipData",
    value: function makeStackTooltipData(seriesRawData, stackData, colors, categories) {
      var tooltipData = [];
      stackData.forEach(function (_ref11, dataIndex) {
        var values = _ref11.values;
        values.forEach(function (value, seriesIndex) {
          tooltipData.push({
            label: seriesRawData[seriesIndex].name,
            color: colors[seriesIndex],
            value: value,
            category: categories.length ? categories[dataIndex] : ''
          });
        });
      });
      return tooltipData;
    }
  }, {
    key: "makeConnectorModel",
    value: function makeConnectorModel(pointsForConnector, connector, columnWidth) {
      var _this6 = this;

      if (!connector || !pointsForConnector.length) {
        return [];
      }

      var _this$theme$connector = this.theme.connector,
          color = _this$theme$connector.color,
          lineWidth = _this$theme$connector.lineWidth,
          dashSegments = _this$theme$connector.dashSegments;
      var connectorModels = [];
      var seriesDataCount = pointsForConnector.length;
      var seriesCount = pointsForConnector[0].length;

      var _loop = function _loop(seriesIndex) {
        var points = [];

        for (var dataIndex = 0; dataIndex < seriesDataCount; dataIndex += 1) {
          points.push(pointsForConnector[dataIndex][seriesIndex]);
        }

        points.forEach(function (point, index) {
          var x = point.x,
              y = point.y;

          if (index < points.length - 1) {
            var _points = points[index + 1],
                nextX = _points.x,
                nextY = _points.y;
            connectorModels.push({
              type: 'line',
              x: _this6.isBar ? x : x + columnWidth,
              y: _this6.isBar ? y + columnWidth : y,
              x2: nextX,
              y2: nextY,
              dashSegments: dashSegments,
              strokeStyle: color,
              lineWidth: lineWidth
            });
          }
        });
      };

      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex += 1) {
        _loop(seriesIndex);
      }

      return connectorModels;
    }
  }, {
    key: "getStackValueRatio",
    value: function getStackValueRatio(total, renderOptions) {
      var stackType = renderOptions.stack.type,
          scaleType = renderOptions.scaleType,
          min = renderOptions.min,
          max = renderOptions.max,
          offsetSize = renderOptions.offsetSize;

      if (stackType === 'percent') {
        return offsetSize / getDivisorForPercent(total, scaleType);
      }

      return this.getValueRatio(min, max, offsetSize);
    }
  }, {
    key: "getStackBarLength",
    value: function getStackBarLength(values, seriesIndex, ratio, renderOptions) {
      var value = boxStackSeries_calibrateDrawingValue(values, seriesIndex, renderOptions);
      return isNumber(value) ? this.getBarLength(value, ratio) : null;
    }
  }, {
    key: "getStackColumnWidth",
    value: function getStackColumnWidth(renderOptions, stackGroupCount) {
      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging,
          defaultPadding = renderOptions.defaultPadding;
      var divisor = diverging ? 1 : stackGroupCount;
      var themeBarWidth = this.theme.barWidth;
      return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / divisor;
    }
  }, {
    key: "getSeriesPosition",
    value: function getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount) {
      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging;
      var groupIndex = diverging ? 0 : stackGroupIndex;
      var groupCount = diverging ? 1 : stackGroupCount;
      var padding = (tickDistance - columnWidth * groupCount) / 2;
      return dataIndex * tickDistance + padding + columnWidth * groupIndex;
    }
  }, {
    key: "getStackStartPosition",
    value: function getStackStartPosition(values, currentIndex, ratio, renderOptions, isLBSideWithDiverging) {
      var stack = renderOptions.stack,
          diverging = renderOptions.diverging,
          seriesDirection = renderOptions.seriesDirection;
      var startPos;

      if (diverging) {
        startPos = isLBSideWithDiverging ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
      } else if (isPercentStack(stack)) {
        startPos = this.calcStartPositionWithPercent(values, currentIndex, ratio);
      } else if (seriesDirection === SeriesDirection.POSITIVE) {
        startPos = this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
      } else if (seriesDirection === SeriesDirection.NEGATIVE) {
        startPos = this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio);
      } else {
        startPos = this.calcStartPositionWithStack(values, currentIndex, renderOptions, ratio);
      }

      return startPos;
    }
  }, {
    key: "calcStartPosOnLeftBottomSide",
    value: function calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) {
      var min = renderOptions.min,
          max = renderOptions.max,
          diverging = renderOptions.diverging;
      var basePosition = diverging ? this.leftBasePosition : this.basePosition;
      var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
      var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
      var collideEdge = totalOfValues < min;
      var usingValue = this.isBar ? totalOfValues : totalOfIndexBefore;
      var result = max < 0 ? Math.min(usingValue - max, 0) : usingValue;
      var pos;

      if (this.isBar) {
        pos = collideEdge ? 0 : basePosition - Math.abs(result) * ratio;
      } else {
        pos = basePosition + Math.abs(result) * ratio;
      }

      return pos;
    }
  }, {
    key: "calcStartPosOnRightTopSide",
    value: function calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio) {
      var min = renderOptions.min,
          max = renderOptions.max,
          diverging = renderOptions.diverging;
      var basePosition = diverging ? this.rightBasePosition : this.basePosition;
      var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
      var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
      var collideEdge = totalOfValues > max;
      var usingValue = this.isBar ? totalOfIndexBefore : totalOfValues;
      var result = min > 0 ? Math.max(usingValue - min, 0) : usingValue;
      var barLength = result * ratio;
      var pos;

      if (this.isBar) {
        pos = basePosition + barLength;
      } else {
        pos = collideEdge ? 0 : basePosition - barLength;
      }

      return pos;
    }
  }, {
    key: "calcStartPositionWithStack",
    value: function calcStartPositionWithStack(values, currentIndex, renderOptions, ratio) {
      return values[currentIndex] < 0 ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
    }
  }, {
    key: "calcStartPositionWithPercent",
    value: function calcStartPositionWithPercent(values, currentIndex, ratio) {
      var basePosition = this.basePosition;
      var totalPrevValues = sumValuesBeforeIndex(values, currentIndex, this.isBar ? values[currentIndex] < 0 : values[currentIndex] > 0);
      return this.isBar ? totalPrevValues * ratio + basePosition : basePosition - totalPrevValues * ratio;
    }
  }, {
    key: "getStackRectInfo",
    value: function getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging) {
      var barLength = this.getStackBarLength(values, seriesIndex, ratio, renderOptions);
      var dataPosition = this.getStackStartPosition(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);
      return {
        barLength: barLength,
        dataPosition: dataPosition
      };
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels, renderOptions) {
      var _this7 = this;

      return seriesModels.map(function (data) {
        return _this7.makeDataLabel(data, renderOptions.centerYAxis);
      });
    }
  }, {
    key: "getTotalDataLabels",
    value: function getTotalDataLabels(seriesData, renderOptions) {
      var stackData = seriesData.stackData,
          stack = seriesData.stack;

      if (isPercentStack(stack)) {
        return [];
      }

      return isGroupStack(stackData) ? this.makeGroupTotalDataLabels(seriesData, renderOptions) : this.makeTotalDataLabels(stackData, renderOptions);
    }
  }, {
    key: "makeGroupTotalDataLabels",
    value: function makeGroupTotalDataLabels(stackSeries, renderOptions) {
      var _this8 = this;

      var dataLabels = [];
      var stackGroupData = stackSeries.stackData;
      var stackGroupIds = Object.keys(stackGroupData);
      stackGroupIds.forEach(function (groupId, groupIndex) {
        var totalDataLabels = _this8.makeTotalDataLabels(stackGroupData[groupId], renderOptions, stackGroupIds.length, groupIndex);

        dataLabels = [].concat(boxStackSeries_toConsumableArray(dataLabels), boxStackSeries_toConsumableArray(totalDataLabels));
      });
      return dataLabels;
    }
  }, {
    key: "makeTotalDataLabels",
    value: function makeTotalDataLabels(stackData, renderOptions) {
      var _this9 = this;

      var stackGroupCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var stackGroupIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var dataLabels = [];
      var min = renderOptions.min,
          max = renderOptions.max,
          seriesDirection = renderOptions.seriesDirection,
          diverging = renderOptions.diverging,
          centerYAxis = renderOptions.centerYAxis;
      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      stackData.forEach(function (data, dataIndex) {
        var total = data.total;

        var seriesPos = _this9.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);

        var ratio = _this9.getStackValueRatio(total, renderOptions);

        var directionKeys = getDirectionKeys(seriesDirection);
        directionKeys.forEach(function (key) {
          var value = total[key];

          if (!value) {
            return;
          }

          var barLength = _this9.makeBarLength(value, {
            min: min,
            max: max,
            ratio: ratio
          });

          var dataPosition = _this9.getStartPosition(barLength, value, renderOptions, diverging && isLeftBottomSide(stackGroupIndex));

          var stackTotal = boxStackSeries_objectSpread({
            type: 'stackTotal',
            value: value,
            name: "totalLabel-".concat(key),
            theme: _this9.theme.dataLabels.stackTotal
          }, _this9.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth));

          dataLabels.push(_this9.makeTotalDataLabel(stackTotal, centerYAxis));
        });
      });
      return dataLabels;
    }
  }, {
    key: "makeTotalDataLabel",
    value: function makeTotalDataLabel(totalLabel, centerYAxis) {
      return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, totalLabel), {}, {
        direction: this.getDataLabelDirection(totalLabel, centerYAxis),
        plot: {
          x: 0,
          y: 0,
          size: this.getOffsetSize()
        }
      });
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: [].concat(boxStackSeries_toConsumableArray(rectModels), boxStackSeries_toConsumableArray(this.getGroupedRect(responders, 'hover'))),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = rectModels;
    }
  }]);

  return BoxStackSeries;
}(BoxSeries);


;// CONCATENATED MODULE: ./src/component/zeroAxis.ts
function zeroAxis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { zeroAxis_typeof = function _typeof(obj) { return typeof obj; }; } else { zeroAxis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return zeroAxis_typeof(obj); }














function zeroAxis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function zeroAxis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function zeroAxis_createClass(Constructor, protoProps, staticProps) { if (protoProps) zeroAxis_defineProperties(Constructor.prototype, protoProps); if (staticProps) zeroAxis_defineProperties(Constructor, staticProps); return Constructor; }

function zeroAxis_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) zeroAxis_setPrototypeOf(subClass, superClass); }

function zeroAxis_setPrototypeOf(o, p) { zeroAxis_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return zeroAxis_setPrototypeOf(o, p); }

function zeroAxis_createSuper(Derived) { var hasNativeReflectConstruct = zeroAxis_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = zeroAxis_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = zeroAxis_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return zeroAxis_possibleConstructorReturn(this, result); }; }

function zeroAxis_possibleConstructorReturn(self, call) { if (call && (zeroAxis_typeof(call) === "object" || typeof call === "function")) { return call; } return zeroAxis_assertThisInitialized(self); }

function zeroAxis_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function zeroAxis_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function zeroAxis_getPrototypeOf(o) { zeroAxis_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return zeroAxis_getPrototypeOf(o); }

function zeroAxis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var ZeroAxis = /*#__PURE__*/function (_Component) {
  zeroAxis_inherits(ZeroAxis, _Component);

  var _super = zeroAxis_createSuper(ZeroAxis);

  function ZeroAxis() {
    var _this;

    zeroAxis_classCallCheck(this, ZeroAxis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    zeroAxis_defineProperty(zeroAxis_assertThisInitialized(_this), "models", []);

    return _this;
  }

  zeroAxis_createClass(ZeroAxis, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'zeroAxis';
      this.name = 'zeroAxis';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          axes = _ref.axes,
          series = _ref.series,
          options = _ref.options;
      this.rect = layout.plot;
      var labelAxisOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options
      });
      var valueAxisName = labelAxisOnYAxis ? 'xAxis' : 'yAxis';
      var _ref2 = axes[valueAxisName],
          zeroPosition = _ref2.zeroPosition;

      if (isNumber(zeroPosition)) {
        this.models = this.renderZeroModel(zeroPosition, labelAxisOnYAxis);
      }
    }
  }, {
    key: "renderZeroModel",
    value: function renderZeroModel(zeroPosition, vertical) {
      var zeroPixel = crispPixel(0);
      var position = crispPixel(zeroPosition);
      var model;

      if (vertical) {
        model = {
          type: 'line',
          x: position,
          y: zeroPixel,
          x2: position,
          y2: crispPixel(this.rect.height),
          strokeStyle: 'rgba(0, 0, 0, 0.5)'
        };
      } else {
        model = {
          type: 'line',
          x: zeroPixel,
          y: position,
          x2: crispPixel(this.rect.width),
          y2: position,
          strokeStyle: 'rgba(0, 0, 0, 0.5)'
        };
      }

      return [model];
    }
  }]);

  return ZeroAxis;
}(Component);


;// CONCATENATED MODULE: ./src/component/axisUsingCenterY.ts
function axisUsingCenterY_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axisUsingCenterY_typeof = function _typeof(obj) { return typeof obj; }; } else { axisUsingCenterY_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axisUsingCenterY_typeof(obj); }

function axisUsingCenterY_toConsumableArray(arr) { return axisUsingCenterY_arrayWithoutHoles(arr) || axisUsingCenterY_iterableToArray(arr) || axisUsingCenterY_unsupportedIterableToArray(arr) || axisUsingCenterY_nonIterableSpread(); }

function axisUsingCenterY_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axisUsingCenterY_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axisUsingCenterY_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axisUsingCenterY_arrayLikeToArray(o, minLen); }

function axisUsingCenterY_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function axisUsingCenterY_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axisUsingCenterY_arrayLikeToArray(arr); }

function axisUsingCenterY_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axisUsingCenterY_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function axisUsingCenterY_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axisUsingCenterY_ownKeys(Object(source), true).forEach(function (key) { axisUsingCenterY_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axisUsingCenterY_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






















function axisUsingCenterY_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axisUsingCenterY_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axisUsingCenterY_createClass(Constructor, protoProps, staticProps) { if (protoProps) axisUsingCenterY_defineProperties(Constructor.prototype, protoProps); if (staticProps) axisUsingCenterY_defineProperties(Constructor, staticProps); return Constructor; }

function axisUsingCenterY_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) axisUsingCenterY_setPrototypeOf(subClass, superClass); }

function axisUsingCenterY_setPrototypeOf(o, p) { axisUsingCenterY_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return axisUsingCenterY_setPrototypeOf(o, p); }

function axisUsingCenterY_createSuper(Derived) { var hasNativeReflectConstruct = axisUsingCenterY_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = axisUsingCenterY_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = axisUsingCenterY_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return axisUsingCenterY_possibleConstructorReturn(this, result); }; }

function axisUsingCenterY_possibleConstructorReturn(self, call) { if (call && (axisUsingCenterY_typeof(call) === "object" || typeof call === "function")) { return call; } return axisUsingCenterY_assertThisInitialized(self); }

function axisUsingCenterY_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function axisUsingCenterY_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function axisUsingCenterY_getPrototypeOf(o) { axisUsingCenterY_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return axisUsingCenterY_getPrototypeOf(o); }

function axisUsingCenterY_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var AxisUsingCenterY = /*#__PURE__*/function (_Component) {
  axisUsingCenterY_inherits(AxisUsingCenterY, _Component);

  var _super = axisUsingCenterY_createSuper(AxisUsingCenterY);

  function AxisUsingCenterY() {
    var _this;

    axisUsingCenterY_classCallCheck(this, AxisUsingCenterY);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "name", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "models", {
      label: [],
      tick: [],
      axisLine: []
    });

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "drawModels", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "yAxisComponent", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  axisUsingCenterY_createClass(AxisUsingCenterY, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axis';
      this.name = name;
      this.yAxisComponent = name === AxisType.Y;
    }
  }, {
    key: "render",
    value: function render(_ref2) {
      var _this2 = this;

      var layout = _ref2.layout,
          axes = _ref2.axes,
          theme = _ref2.theme;
      var centerYAxis = axes.centerYAxis;

      if (!centerYAxis) {
        return;
      }

      this.theme = getAxisTheme(theme, this.name);
      this.rect = layout[this.name];

      if (this.name === 'yAxis') {
        this.rect = axisUsingCenterY_objectSpread(axisUsingCenterY_objectSpread({}, this.rect), {}, {
          x: centerYAxis.x
        });
      }

      var _ref3 = axes[this.name],
          viewLabels = _ref3.viewLabels,
          tickCount = _ref3.tickCount,
          tickInterval = _ref3.tickInterval,
          needRotateLabel = _ref3.needRotateLabel,
          radian = _ref3.radian,
          offsetY = _ref3.offsetY;
      var renderOptions = {
        tickInterval: tickInterval,
        centerYAxis: centerYAxis,
        needRotateLabel: needRotateLabel,
        radian: radian,
        offsetY: offsetY,
        relativePositions: makeTickPixelPositions(this.axisSize(centerYAxis), tickCount)
      };
      var offsetKey = this.yAxisComponent ? 'y' : 'x';
      var anchorKey = this.yAxisComponent ? 'x' : 'y';
      this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
      this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
      this.models.axisLine = this.renderAxisLineModel(centerYAxis);

      if (!this.drawModels) {
        this.drawModels = {
          tick: [],
          label: [],
          axisLine: this.models.axisLine
        };
        ['tick', 'label'].forEach(function (type) {
          _this2.drawModels[type] = _this2.models[type].map(function (m) {
            var drawModel = axisUsingCenterY_objectSpread({}, m);

            if (_this2.yAxisComponent) {
              drawModel.y = 0;
            } else {
              drawModel.x = 0;
            }

            return drawModel;
          });
        });
      }
    }
  }, {
    key: "renderAxisLineModel",
    value: function renderAxisLineModel(_ref4) {
      var xAxisHalfSize = _ref4.xAxisHalfSize,
          secondStartX = _ref4.secondStartX;
      var zeroPixel = crispPixel(0);
      var widthPixel = crispPixel(this.rect.width);
      var axisLine;

      if (this.yAxisComponent) {
        var heightPixel = crispPixel(this.rect.height);
        axisLine = [{
          type: 'line',
          x: widthPixel,
          y: zeroPixel,
          x2: widthPixel,
          y2: heightPixel
        }, {
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: zeroPixel,
          y2: heightPixel
        }];
      } else {
        axisLine = [{
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: crispPixel(xAxisHalfSize),
          y2: zeroPixel
        }, {
          type: 'line',
          x: crispPixel(secondStartX),
          y: zeroPixel,
          x2: widthPixel,
          y2: zeroPixel
        }];
      }

      return axisLine;
    }
  }, {
    key: "renderTickModels",
    value: function renderTickModels(offsetKey, anchorKey, renderOptions) {
      var _this3 = this;

      var tickAnchorPoint = this.yAxisComponent ? crispPixel(this.rect.width) : crispPixel(0);
      var tickInterval = renderOptions.tickInterval,
          secondStartX = renderOptions.centerYAxis.secondStartX,
          relativePositions = renderOptions.relativePositions;
      return relativePositions.reduce(function (positions, position, index) {
        var _model;

        if (index % tickInterval) {
          return positions;
        }

        var model = (_model = {
          type: 'tick',
          isYAxis: _this3.yAxisComponent,
          tickSize: _this3.yAxisComponent ? -5 : 5
        }, axisUsingCenterY_defineProperty(_model, offsetKey, crispPixel(position)), axisUsingCenterY_defineProperty(_model, anchorKey, tickAnchorPoint), _model);

        var addedTickModel = axisUsingCenterY_objectSpread({}, model);

        if (_this3.yAxisComponent) {
          addedTickModel[anchorKey] = crispPixel(0);
          addedTickModel.tickSize = 5;
        } else {
          addedTickModel[offsetKey] = crispPixel(position + secondStartX);
        }

        return [].concat(axisUsingCenterY_toConsumableArray(positions), [model, addedTickModel]);
      }, []);
    }
  }, {
    key: "renderLabelModels",
    value: function renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
      var _this4 = this;

      var _renderOptions$center = renderOptions.centerYAxis,
          secondStartX = _renderOptions$center.secondStartX,
          yAxisLabelAnchorPoint = _renderOptions$center.yAxisLabelAnchorPoint,
          offsetY = renderOptions.offsetY,
          needRotateLabel = renderOptions.needRotateLabel,
          radian = renderOptions.radian;
      var labelTheme = this.theme.label;
      var font = getTitleFontString(labelTheme);
      var labelAnchorPoint, textAlign, textLabels;

      if (this.yAxisComponent) {
        labelAnchorPoint = crispPixel(yAxisLabelAnchorPoint);
        textAlign = 'center';
        textLabels = labels;
      } else {
        labelAnchorPoint = offsetY;
        textLabels = axisUsingCenterY_toConsumableArray(labels).reverse();
        textAlign = needRotateLabel ? 'left' : 'center';
      }

      var style = ['default', {
        textAlign: textAlign,
        font: font,
        fillStyle: labelTheme.color
      }];
      return textLabels.reduce(function (positions, _ref5, index) {
        var _model2;

        var text = _ref5.text,
            offsetPos = _ref5.offsetPos;
        var model = (_model2 = {
          type: 'label',
          text: text,
          style: style
        }, axisUsingCenterY_defineProperty(_model2, offsetKey, crispPixel(offsetPos) + (_this4.yAxisComponent ? 0 : secondStartX)), axisUsingCenterY_defineProperty(_model2, anchorKey, labelAnchorPoint), axisUsingCenterY_defineProperty(_model2, "radian", radian), _model2);
        var models = [model];

        if (!_this4.yAxisComponent) {
          var addedLabelModel = axisUsingCenterY_objectSpread(axisUsingCenterY_objectSpread({}, model), {}, axisUsingCenterY_defineProperty({
            text: labels[index].text
          }, offsetKey, crispPixel(model[offsetKey] - secondStartX)));

          models.push(addedLabelModel);
        }

        return [].concat(axisUsingCenterY_toConsumableArray(positions), models);
      }, []);
    }
  }, {
    key: "axisSize",
    value: function axisSize(centerYAxis) {
      var size;

      if (this.yAxisComponent) {
        size = this.rect.height;
      } else {
        size = centerYAxis.xAxisHalfSize;
      }

      return size;
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(painter) {
      painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      painter.ctx.lineWidth = 1;
    }
  }]);

  return AxisUsingCenterY;
}(Component);


;// CONCATENATED MODULE: ./src/charts/barChart.ts
function barChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { barChart_typeof = function _typeof(obj) { return typeof obj; }; } else { barChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return barChart_typeof(obj); }


















function barChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function barChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { barChart_ownKeys(Object(source), true).forEach(function (key) { barChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { barChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function barChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function barChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function barChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function barChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) barChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) barChart_defineProperties(Constructor, staticProps); return Constructor; }

function barChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { barChart_get = Reflect.get; } else { barChart_get = function _get(target, property, receiver) { var base = barChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return barChart_get(target, property, receiver || target); }

function barChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = barChart_getPrototypeOf(object); if (object === null) break; } return object; }

function barChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) barChart_setPrototypeOf(subClass, superClass); }

function barChart_setPrototypeOf(o, p) { barChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return barChart_setPrototypeOf(o, p); }

function barChart_createSuper(Derived) { var hasNativeReflectConstruct = barChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = barChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = barChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return barChart_possibleConstructorReturn(this, result); }; }

function barChart_possibleConstructorReturn(self, call) { if (call && (barChart_typeof(call) === "object" || typeof call === "function")) { return call; } return barChart_assertThisInitialized(self); }

function barChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function barChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function barChart_getPrototypeOf(o) { barChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return barChart_getPrototypeOf(o); }






























/**
 * @class
 * @classdesc Bar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bar Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Bar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.barWidth] - Bar width.
 *       @param {boolean} [props.options.series.diverging] - Whether to use diverging chart or not.
 *       @param {boolean} [props.options.series.colorByPoint] - Whether to use color feature or not.
 *       @param {Object} [props.options.series.stack] - Option to use the stack chart or, if so, what type of stack to use.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var BarChart = /*#__PURE__*/function (_Chart) {
  barChart_inherits(BarChart, _Chart);

  var _super = barChart_createSuper(BarChart);

  function BarChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    barChart_classCallCheck(this, BarChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        bar: data.series
      },
      categories: data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  barChart_createClass(BarChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore;

      barChart_get(barChart_getPrototypeOf(BarChart.prototype), "initialize", this).call(this);

      var stackChart = !!((_this$store$initStore = this.store.initStoreState.options.series) !== null && _this$store$initStore !== void 0 && _this$store$initStore.stack);
      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BoxSeries, {
        name: 'bar',
        stackChart: stackChart
      });
      this.componentManager.add(BoxStackSeries, {
        name: 'bar',
        stackChart: stackChart
      });
      this.componentManager.add(ZeroAxis);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(AxisUsingCenterY, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisUsingCenterY, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bar: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *   @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *   @param {number} [seriesInfo.seriesIndex] - Index of series
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', barChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return BarChart;
}(Chart);


;// CONCATENATED MODULE: ./src/charts/columnChart.ts
function columnChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { columnChart_typeof = function _typeof(obj) { return typeof obj; }; } else { columnChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return columnChart_typeof(obj); }


















function columnChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function columnChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { columnChart_ownKeys(Object(source), true).forEach(function (key) { columnChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { columnChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function columnChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function columnChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function columnChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function columnChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) columnChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) columnChart_defineProperties(Constructor, staticProps); return Constructor; }

function columnChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { columnChart_get = Reflect.get; } else { columnChart_get = function _get(target, property, receiver) { var base = columnChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return columnChart_get(target, property, receiver || target); }

function columnChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = columnChart_getPrototypeOf(object); if (object === null) break; } return object; }

function columnChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) columnChart_setPrototypeOf(subClass, superClass); }

function columnChart_setPrototypeOf(o, p) { columnChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return columnChart_setPrototypeOf(o, p); }

function columnChart_createSuper(Derived) { var hasNativeReflectConstruct = columnChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = columnChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = columnChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return columnChart_possibleConstructorReturn(this, result); }; }

function columnChart_possibleConstructorReturn(self, call) { if (call && (columnChart_typeof(call) === "object" || typeof call === "function")) { return call; } return columnChart_assertThisInitialized(self); }

function columnChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function columnChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function columnChart_getPrototypeOf(o) { columnChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return columnChart_getPrototypeOf(o); }





























/**
 * @class
 * @classdesc Column Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Column Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Column Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.barWidth] - Bar width.
 *       @param {boolean} [props.options.series.diverging] - Whether to use diverging chart or not.
 *       @param {boolean} [props.options.series.colorByPoint] - Whether to use color feature or not.
 *       @param {Object} [props.options.series.stack] - Option to use the stack chart or, if so, what type of stack to use.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var ColumnChart = /*#__PURE__*/function (_Chart) {
  columnChart_inherits(ColumnChart, _Chart);

  var _super = columnChart_createSuper(ColumnChart);

  function ColumnChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    columnChart_classCallCheck(this, ColumnChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        column: data.series
      },
      categories: data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  columnChart_createClass(ColumnChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore;

      columnChart_get(columnChart_getPrototypeOf(ColumnChart.prototype), "initialize", this).call(this);

      var stackChart = !!((_this$store$initStore = this.store.initStoreState.options.series) !== null && _this$store$initStore !== void 0 && _this$store$initStore.stack);
      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BoxStackSeries, {
        name: 'column',
        stackChart: stackChart
      });
      this.componentManager.add(BoxSeries, {
        name: 'column',
        stackChart: stackChart
      });
      this.componentManager.add(ZeroAxis);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number|Array<number>>} data - Array of data to be added
     * @param {string} category - Category to be added
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added
     *   @param {string} data.name - Series name
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          column: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', columnChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return ColumnChart;
}(Chart);


;// CONCATENATED MODULE: ./src/charts/columnLineChart.ts
function columnLineChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { columnLineChart_typeof = function _typeof(obj) { return typeof obj; }; } else { columnLineChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return columnLineChart_typeof(obj); }

function columnLineChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function columnLineChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { columnLineChart_ownKeys(Object(source), true).forEach(function (key) { columnLineChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { columnLineChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function columnLineChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function columnLineChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function columnLineChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function columnLineChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) columnLineChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) columnLineChart_defineProperties(Constructor, staticProps); return Constructor; }

function columnLineChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { columnLineChart_get = Reflect.get; } else { columnLineChart_get = function _get(target, property, receiver) { var base = columnLineChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return columnLineChart_get(target, property, receiver || target); }

function columnLineChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = columnLineChart_getPrototypeOf(object); if (object === null) break; } return object; }

function columnLineChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) columnLineChart_setPrototypeOf(subClass, superClass); }

function columnLineChart_setPrototypeOf(o, p) { columnLineChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return columnLineChart_setPrototypeOf(o, p); }

function columnLineChart_createSuper(Derived) { var hasNativeReflectConstruct = columnLineChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = columnLineChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = columnLineChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return columnLineChart_possibleConstructorReturn(this, result); }; }

function columnLineChart_possibleConstructorReturn(self, call) { if (call && (columnLineChart_typeof(call) === "object" || typeof call === "function")) { return call; } return columnLineChart_assertThisInitialized(self); }

function columnLineChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function columnLineChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function columnLineChart_getPrototypeOf(o) { columnLineChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return columnLineChart_getPrototypeOf(o); }


















































function hasPointEventType(respondersModel, name) {
  return respondersModel.find(function (_ref) {
    var component = _ref.component;
    return component.name === name && component.eventDetectType === 'point';
  });
}

function hasColumnLineUsingPointEventType(respondersModel) {
  return isExist(hasPointEventType(respondersModel, 'column')) && isExist(hasPointEventType(respondersModel, 'line'));
}
/**
 * @class
 * @classdesc ColumnLine Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making ColumnLine Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Coordinate types data is not possible.
 *       @param {Array<Object>} props.data.series.column - Column series data.
 *   @param {Object} [props.options] - Options for making ColumnLine Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.series.column] - Options to be applied to the column chart. 'barWidth', 'stack', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Column Chart guide} on github.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|ColumnLine Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var ColumnLineChart = /*#__PURE__*/function (_Chart) {
  columnLineChart_inherits(ColumnLineChart, _Chart);

  var _super = columnLineChart_createSuper(ColumnLineChart);

  function ColumnLineChart(_ref2) {
    var el = _ref2.el,
        options = _ref2.options,
        _ref2$data = _ref2.data,
        series = _ref2$data.series,
        categories = _ref2$data.categories;

    columnLineChart_classCallCheck(this, ColumnLineChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: series,
      categories: categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  columnLineChart_createClass(ColumnLineChart, [{
    key: "initialize",
    value: function initialize() {
      columnLineChart_get(columnLineChart_getPrototypeOf(ColumnLineChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BoxStackSeries, {
        name: 'column'
      });
      this.componentManager.add(BoxSeries, {
        name: 'column'
      });
      this.componentManager.add(LineSeries);
      this.componentManager.add(ZeroAxis);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_lineSeries_namespaceObject]);
    }
  }, {
    key: "handleEventForAllResponders",
    value: function handleEventForAllResponders(event, responderModels, delegationMethod, mousePosition) {
      if (hasColumnLineUsingPointEventType(responderModels)) {
        var columnSeries = responderModels.find(function (_ref3) {
          var component = _ref3.component;
          return component.name === 'column';
        });
        columnSeries.component[delegationMethod]({
          mousePosition: mousePosition,
          responders: []
        }, event);
      }
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([10, 20], '6', 'line');
     */

  }, {
    key: "addData",
    value: function addData(data, category, chartType) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category,
        chartType: chartType
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     * @param {string} data.name - Series name.
     * @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     * @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', columnLineChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: {
     *     column: [
     *       {
     *         name: 'A',
     *         data: [1, 2, 3],
     *       }
     *     ],
     *     line: [
     *       {
     *         name: 'B',
     *         data: [4, 5, 6],
     *       }
     *     ]
     *   }
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - plot info
     *   @param {Array<string|number>} data.range - The range to be drawn
     *   @param {string} data.color - Plot band color
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'column'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', columnLineChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return ColumnLineChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/bubbleSeries.ts
function bubbleSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bubbleSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { bubbleSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bubbleSeries_typeof(obj); }

function bubbleSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function bubbleSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bubbleSeries_ownKeys(Object(source), true).forEach(function (key) { bubbleSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bubbleSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bubbleSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bubbleSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bubbleSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) bubbleSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) bubbleSeries_defineProperties(Constructor, staticProps); return Constructor; }

function bubbleSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bubbleSeries_setPrototypeOf(subClass, superClass); }

function bubbleSeries_setPrototypeOf(o, p) { bubbleSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bubbleSeries_setPrototypeOf(o, p); }

function bubbleSeries_createSuper(Derived) { var hasNativeReflectConstruct = bubbleSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bubbleSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bubbleSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bubbleSeries_possibleConstructorReturn(this, result); }; }

function bubbleSeries_possibleConstructorReturn(self, call) { if (call && (bubbleSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return bubbleSeries_assertThisInitialized(self); }

function bubbleSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bubbleSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function bubbleSeries_getPrototypeOf(o) { bubbleSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bubbleSeries_getPrototypeOf(o); }

function bubbleSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function bubbleSeries_toConsumableArray(arr) { return bubbleSeries_arrayWithoutHoles(arr) || bubbleSeries_iterableToArray(arr) || bubbleSeries_unsupportedIterableToArray(arr) || bubbleSeries_nonIterableSpread(); }

function bubbleSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bubbleSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bubbleSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bubbleSeries_arrayLikeToArray(o, minLen); }

function bubbleSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function bubbleSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bubbleSeries_arrayLikeToArray(arr); }

function bubbleSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
































var bubbleSeries_MINIMUM_RADIUS = 0.5;
var MINIMUM_DETECTING_AREA_RADIUS = 1;
function getMaxRadius(bubbleData) {
  return bubbleData.reduce(function (acc, cur) {
    var NonNullData = cur.data.filter(function (datum) {
      return !isNull(datum);
    });
    return Math.max.apply(Math, [acc].concat(bubbleSeries_toConsumableArray(NonNullData.map(function (_ref) {
      var r = _ref.r;
      return r;
    }))));
  }, 0);
}

var BubbleSeries = /*#__PURE__*/function (_Component) {
  bubbleSeries_inherits(BubbleSeries, _Component);

  var _super = bubbleSeries_createSuper(BubbleSeries);

  function BubbleSeries() {
    var _this;

    bubbleSeries_classCallCheck(this, BubbleSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "drawModels", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "responders", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "activatedResponders", []);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "theme", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "rect", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "maxRadius", -1);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "maxValue", -1);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "selectSeries", function (_ref2) {
      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.bubble.data[index].name;

      var model = _this.responders.filter(function (_ref3) {
        var dataName = _ref3.name;
        return dataName === name;
      })[seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var models = _this.getResponderAppliedTheme([model], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex,
          state = info.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.bubble.data[seriesIndex].name;
      var models = [_this.responders.filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      })[index]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  bubbleSeries_createClass(BubbleSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'bubble';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      this.drawModels.series.forEach(function (model, index) {
        model.radius = _this2.models.series[index].radius * delta;
      });
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          circleLegend = chartState.circleLegend,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme;
      var plot = layout.plot;

      if (!series.bubble) {
        throw new Error(message.noDataError(this.name));
      }

      var xAxis = axes.xAxis,
          yAxis = axes.yAxis;
      var bubbleData = series.bubble.data;
      this.theme = theme.series.bubble;
      this.rect = plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var xAxisTickSize = this.rect.width / xAxis.tickCount;
      var yAxisTickSize = this.rect.height / yAxis.tickCount;
      this.maxRadius = circleLegend.radius ? circleLegend.radius : Math.min(xAxisTickSize, yAxisTickSize);
      this.maxValue = getMaxRadius(bubbleData);
      var seriesModel = this.renderBubblePointsModel(bubbleData, scale);
      var tooltipModel = this.makeTooltipModel(bubbleData);
      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = deepCopy(this.models);
      }

      this.responders = seriesModel.map(function (m, index) {
        return bubbleSeries_objectSpread(bubbleSeries_objectSpread({}, m), {}, {
          type: 'circle',
          detectionSize: 0,
          radius: m.radius + MINIMUM_DETECTING_AREA_RADIUS,
          color: getRGBA(m.color, 0.85),
          data: tooltipModel[index],
          index: index
        });
      });
    }
  }, {
    key: "renderBubblePointsModel",
    value: function renderBubblePointsModel(seriesRawData, scale) {
      var _this3 = this;

      var xAxisLimit = scale.xAxis.limit;
      var yAxisLimit = scale.yAxis.limit;
      var _this$theme = this.theme,
          borderWidth = _this$theme.borderWidth,
          borderColor = _this$theme.borderColor;
      return seriesRawData.flatMap(function (_ref5, seriesIndex) {
        var data = _ref5.data,
            name = _ref5.name,
            seriesColor = _ref5.color;
        var circleModels = [];
        var active = _this3.activeSeriesMap[name];
        var color = getRGBA(seriesColor, active ? 0.8 : 0.1);
        var nonNullData = data.filter(function (datum) {
          return !isNull(datum);
        });
        nonNullData.forEach(function (datum) {
          var rawXValue = getCoordinateXValue(datum);
          var xValue = utils_isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
          var yValue = getCoordinateYValue(datum);
          var xValueRatio = getValueRatio(xValue, xAxisLimit);
          var yValueRatio = getValueRatio(yValue, yAxisLimit);
          var x = xValueRatio * _this3.rect.width;
          var y = (1 - yValueRatio) * _this3.rect.height;
          var radius = Math.max(bubbleSeries_MINIMUM_RADIUS, datum.r / _this3.maxValue * _this3.maxRadius);
          circleModels.push({
            x: x,
            y: y,
            type: 'circle',
            radius: radius,
            color: color,
            style: ['default'],
            seriesIndex: seriesIndex,
            name: name,
            borderWidth: borderWidth,
            borderColor: borderColor
          });
        });
        return circleModels;
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleData) {
      return bubbleSeries_toConsumableArray(circleData).flatMap(function (_ref6) {
        var data = _ref6.data,
            name = _ref6.name,
            color = _ref6.color;
        var tooltipData = [];
        var nonNullData = data.filter(function (datum) {
          return !isNull(datum);
        });
        nonNullData.forEach(function (datum) {
          var r = datum.r,
              label = datum.label;
          tooltipData.push({
            label: "".concat(name, "/").concat(label),
            color: color,
            value: {
              x: getCoordinateXValue(datum),
              y: getCoordinateYValue(datum),
              r: r
            }
          });
        });
        return tooltipData;
      });
    }
  }, {
    key: "getResponderAppliedTheme",
    value: function getResponderAppliedTheme(responders, type) {
      var _this4 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, _this4.theme[type]);
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref7) {
      var responders = _ref7.responders,
          mousePosition = _ref7.mousePosition;
      var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
      var responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'hover');
      this.eventBus.emit('renderHoveredSeries', {
        models: responderWithTheme,
        name: this.name
      });
      this.activatedResponders = closestResponder;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref8) {
      var responders = _ref8.responders,
          mousePosition = _ref8.mousePosition;

      if (this.selectable) {
        var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
        var responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: responderWithTheme,
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }]);

  return BubbleSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/circleLegend.ts
function circleLegend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { circleLegend_typeof = function _typeof(obj) { return typeof obj; }; } else { circleLegend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return circleLegend_typeof(obj); }













function circleLegend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function circleLegend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function circleLegend_createClass(Constructor, protoProps, staticProps) { if (protoProps) circleLegend_defineProperties(Constructor.prototype, protoProps); if (staticProps) circleLegend_defineProperties(Constructor, staticProps); return Constructor; }

function circleLegend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) circleLegend_setPrototypeOf(subClass, superClass); }

function circleLegend_setPrototypeOf(o, p) { circleLegend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return circleLegend_setPrototypeOf(o, p); }

function circleLegend_createSuper(Derived) { var hasNativeReflectConstruct = circleLegend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = circleLegend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = circleLegend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return circleLegend_possibleConstructorReturn(this, result); }; }

function circleLegend_possibleConstructorReturn(self, call) { if (call && (circleLegend_typeof(call) === "object" || typeof call === "function")) { return call; } return circleLegend_assertThisInitialized(self); }

function circleLegend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function circleLegend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function circleLegend_getPrototypeOf(o) { circleLegend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return circleLegend_getPrototypeOf(o); }

function circleLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var CircleLegend = /*#__PURE__*/function (_Component) {
  circleLegend_inherits(CircleLegend, _Component);

  var _super = circleLegend_createSuper(CircleLegend);

  function CircleLegend() {
    var _this;

    circleLegend_classCallCheck(this, CircleLegend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    circleLegend_defineProperty(circleLegend_assertThisInitialized(_this), "models", {
      circleLegend: []
    });

    return _this;
  }

  circleLegend_createClass(CircleLegend, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'circleLegend';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          series = _ref.series,
          circleLegend = _ref.circleLegend;

      if (!series.bubble) {
        throw new Error(message.CIRCLE_LEGEND_RENDER_ERROR);
      }

      this.isShow = circleLegend.visible;

      if (!this.isShow) {
        return;
      }

      var bubbleData = series.bubble.data;
      this.rect = layout.circleLegend;
      this.renderCircleLegend(bubbleData, circleLegend);
    }
  }, {
    key: "renderCircleLegend",
    value: function renderCircleLegend(bubbleData, circleLegend) {
      var value = getMaxRadius(bubbleData);
      var radius = circleLegend.radius;
      this.models.circleLegend = [{
        type: 'circleLegend',
        radius: radius,
        value: value,
        x: radius,
        y: this.rect.height - radius
      }];
    }
  }]);

  return CircleLegend;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/circleLegend.ts


function circleLegend(ctx, circleLegendModel) {
  var x = circleLegendModel.x,
      y = circleLegendModel.y,
      radius = circleLegendModel.radius,
      value = circleLegendModel.value;
  var ratioArray = [1, 0.5, 0.25];
  ratioArray.forEach(function (ratio, idx) {
    var circleRadius = ratio * radius;
    var circleY = y + (idx ? (1 - ratio) * radius : 0);
    circle(ctx, {
      type: 'circle',
      x: x,
      y: circleY,
      radius: circleRadius,
      color: '#fff',
      seriesIndex: 0,
      style: ['default', {
        strokeStyle: '#888',
        lineWidth: 1
      }]
    });
    label(ctx, {
      type: 'label',
      x: x,
      y: circleY - circleRadius,
      text: String(value * ratio),
      style: ['default', {
        textAlign: 'center',
        textBaseline: 'bottom'
      }]
    });
  });
}
;// CONCATENATED MODULE: ./src/charts/bubbleChart.ts
function bubbleChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bubbleChart_typeof = function _typeof(obj) { return typeof obj; }; } else { bubbleChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bubbleChart_typeof(obj); }


















function bubbleChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function bubbleChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bubbleChart_ownKeys(Object(source), true).forEach(function (key) { bubbleChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bubbleChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bubbleChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function bubbleChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bubbleChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bubbleChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) bubbleChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) bubbleChart_defineProperties(Constructor, staticProps); return Constructor; }

function bubbleChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { bubbleChart_get = Reflect.get; } else { bubbleChart_get = function _get(target, property, receiver) { var base = bubbleChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return bubbleChart_get(target, property, receiver || target); }

function bubbleChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = bubbleChart_getPrototypeOf(object); if (object === null) break; } return object; }

function bubbleChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bubbleChart_setPrototypeOf(subClass, superClass); }

function bubbleChart_setPrototypeOf(o, p) { bubbleChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bubbleChart_setPrototypeOf(o, p); }

function bubbleChart_createSuper(Derived) { var hasNativeReflectConstruct = bubbleChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bubbleChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bubbleChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bubbleChart_possibleConstructorReturn(this, result); }; }

function bubbleChart_possibleConstructorReturn(self, call) { if (call && (bubbleChart_typeof(call) === "object" || typeof call === "function")) { return call; } return bubbleChart_assertThisInitialized(self); }

function bubbleChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bubbleChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function bubbleChart_getPrototypeOf(o) { bubbleChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bubbleChart_getPrototypeOf(o); }


























/**
 * @class
 * @classdesc Bubble Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bubble Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Object>} props.data.series.data - Series data. Coordinates x, y values, radius r, and label values are required.
 *   @param {Object} [props.options] - Options for making Bubble Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.circleLegend]
 *       @param {boolean} [props.options.circleLegend.visible] - Whether to show circle legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bubble Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var BubbleChart = /*#__PURE__*/function (_Chart) {
  bubbleChart_inherits(BubbleChart, _Chart);

  var _super = bubbleChart_createSuper(BubbleChart);

  function BubbleChart(props) {
    bubbleChart_classCallCheck(this, BubbleChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        bubble: props.data.series
      },
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  bubbleChart_createClass(BubbleChart, [{
    key: "initialize",
    value: function initialize() {
      bubbleChart_get(bubbleChart_getPrototypeOf(BubbleChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BubbleSeries);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(CircleLegend);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_circleLegend_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<Object>} data - Array of data to be added.
     * @api
     * @example
     * chart.addData([
     *   {x: 10, y: 20, r: 10, label: 'label1'},
     *   {x: 30, y: 40, r: 10, label: 'label2'},
     * ]);
     */

  }, {
    key: "addData",
    value: function addData(data) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     {x: 10, y: 20, r: 10, label: 'label1'},
     *     {x: 30, y: 40, r: 10, label: 'label2'},
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'name'
     *       data: [
     *         {x: 10, y: 20, r: 10, label: 'label1'},
     *         {x: 30, y: 40, r: 10, label: 'label2'},
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bubble: data.series
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', bubbleChart_objectSpread(bubbleChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return BubbleChart;
}(Chart);


;// CONCATENATED MODULE: ./src/charts/scatterChart.ts
function scatterChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { scatterChart_typeof = function _typeof(obj) { return typeof obj; }; } else { scatterChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return scatterChart_typeof(obj); }

function scatterChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function scatterChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function scatterChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) scatterChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) scatterChart_defineProperties(Constructor, staticProps); return Constructor; }

function scatterChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { scatterChart_get = Reflect.get; } else { scatterChart_get = function _get(target, property, receiver) { var base = scatterChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return scatterChart_get(target, property, receiver || target); }

function scatterChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = scatterChart_getPrototypeOf(object); if (object === null) break; } return object; }

function scatterChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) scatterChart_setPrototypeOf(subClass, superClass); }

function scatterChart_setPrototypeOf(o, p) { scatterChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scatterChart_setPrototypeOf(o, p); }

function scatterChart_createSuper(Derived) { var hasNativeReflectConstruct = scatterChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scatterChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scatterChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scatterChart_possibleConstructorReturn(this, result); }; }

function scatterChart_possibleConstructorReturn(self, call) { if (call && (scatterChart_typeof(call) === "object" || typeof call === "function")) { return call; } return scatterChart_assertThisInitialized(self); }

function scatterChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function scatterChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function scatterChart_getPrototypeOf(o) { scatterChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scatterChart_getPrototypeOf(o); }

function scatterChart_toConsumableArray(arr) { return scatterChart_arrayWithoutHoles(arr) || scatterChart_iterableToArray(arr) || scatterChart_unsupportedIterableToArray(arr) || scatterChart_nonIterableSpread(); }

function scatterChart_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function scatterChart_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scatterChart_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scatterChart_arrayLikeToArray(o, minLen); }

function scatterChart_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function scatterChart_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return scatterChart_arrayLikeToArray(arr); }

function scatterChart_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function scatterChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function scatterChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { scatterChart_ownKeys(Object(source), true).forEach(function (key) { scatterChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { scatterChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function scatterChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
















































function clearUnnecessaryData(scatterSeries) {
  return scatterSeries.map(function (series) {
    var exist = {};
    return scatterChart_objectSpread(scatterChart_objectSpread({}, series), {}, {
      data: series.data.filter(function (datum) {
        return !isNull(datum);
      }).reduce(function (acc, cur) {
        var x = getCoordinateXValue(cur);
        var y = getCoordinateYValue(cur);
        var key = "".concat(x, "-").concat(y);

        if (!exist[key]) {
          exist[key] = true;
          return [].concat(scatterChart_toConsumableArray(acc), [cur]);
        }

        return acc;
      }, [])
    });
  });
}
/**
 * @class
 * @classdesc Scatter Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Scatter Chart.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Object|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Scatter Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Scattter Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var ScatterChart = /*#__PURE__*/function (_Chart) {
  scatterChart_inherits(ScatterChart, _Chart);

  var _super = scatterChart_createSuper(ScatterChart);

  function ScatterChart(props) {
    var _props$data;

    scatterChart_classCallCheck(this, ScatterChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        scatter: clearUnnecessaryData(props.data.series)
      },
      categories: (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  scatterChart_createClass(ScatterChart, [{
    key: "initialize",
    value: function initialize() {
      scatterChart_get(scatterChart_getPrototypeOf(ScatterChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(ScatterSeries);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, scatterSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<Object>} data - Array of data to be added.
     * @api
     * @example
     * chart.addData([
     *   {x: 10, y: 20},
     *   {x: 30, y: 40},
     * ]);
     */

  }, {
    key: "addData",
    value: function addData(data) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     {x: 10, y: 20},
     *     {x: 30, y: 40},
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'name'
     *       data: [
     *         {x: 10, y: 20},
     *         {x: 30, y: 40},
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          scatter: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', scatterChart_objectSpread(scatterChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return ScatterChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/bulletSeries.ts
function bulletSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bulletSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { bulletSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bulletSeries_typeof(obj); }

function bulletSeries_slicedToArray(arr, i) { return bulletSeries_arrayWithHoles(arr) || bulletSeries_iterableToArrayLimit(arr, i) || bulletSeries_unsupportedIterableToArray(arr, i) || bulletSeries_nonIterableRest(); }

function bulletSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bulletSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function bulletSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function bulletSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bulletSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bulletSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) bulletSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) bulletSeries_defineProperties(Constructor, staticProps); return Constructor; }

function bulletSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bulletSeries_setPrototypeOf(subClass, superClass); }

function bulletSeries_setPrototypeOf(o, p) { bulletSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bulletSeries_setPrototypeOf(o, p); }

function bulletSeries_createSuper(Derived) { var hasNativeReflectConstruct = bulletSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bulletSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bulletSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bulletSeries_possibleConstructorReturn(this, result); }; }

function bulletSeries_possibleConstructorReturn(self, call) { if (call && (bulletSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return bulletSeries_assertThisInitialized(self); }

function bulletSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bulletSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function bulletSeries_getPrototypeOf(o) { bulletSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bulletSeries_getPrototypeOf(o); }

function bulletSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function bulletSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bulletSeries_ownKeys(Object(source), true).forEach(function (key) { bulletSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bulletSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bulletSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }























function bulletSeries_toConsumableArray(arr) { return bulletSeries_arrayWithoutHoles(arr) || bulletSeries_iterableToArray(arr) || bulletSeries_unsupportedIterableToArray(arr) || bulletSeries_nonIterableSpread(); }

function bulletSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bulletSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bulletSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bulletSeries_arrayLikeToArray(o, minLen); }

function bulletSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function bulletSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bulletSeries_arrayLikeToArray(arr); }

function bulletSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }










var DEFAULT_WIDTH_RATIO = 0.6;
var MARKER_LINE_DETECTION_SIZE = 5;

function getRectSize(vertical, barWidth, barLength) {
  return {
    width: vertical ? barWidth : barLength,
    height: vertical ? barLength : barWidth
  };
}

function getStartX(seriesIndex, tickDistance, barWidth) {
  return seriesIndex * tickDistance + (tickDistance - barWidth) / 2;
}

function makeBulletResponderModel(models, tooltipData) {
  var range = models.range,
      marker = models.marker,
      bullet = models.bullet;
  var tooltipRange = tooltipData.range,
      tooltipMarker = tooltipData.marker,
      tooltipBullet = tooltipData.bullet;
  return [].concat(bulletSeries_toConsumableArray(range.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      data: tooltipRange[index]
    });
  })), bulletSeries_toConsumableArray(bullet.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      data: tooltipBullet[index]
    });
  })), bulletSeries_toConsumableArray(marker.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      detectionSize: MARKER_LINE_DETECTION_SIZE,
      data: tooltipMarker[index]
    });
  })));
}

var BulletSeries = /*#__PURE__*/function (_Component) {
  bulletSeries_inherits(BulletSeries, _Component);

  var _super = bulletSeries_createSuper(BulletSeries);

  function BulletSeries() {
    var _this;

    bulletSeries_classCallCheck(this, BulletSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "models", {
      range: [],
      bullet: [],
      marker: []
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "drawModels", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "responders", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "activatedResponders", []);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "theme", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "vertical", false);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "basePosition", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var _state$series$bullet;

      var seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var _state$series$bullet$ = (_state$series$bullet = state.series.bullet) === null || _state$series$bullet === void 0 ? void 0 : _state$series$bullet[seriesIndex],
          name = _state$series$bullet$.name;

      var model = _this.filterBulletResponder(_this.responders).filter(function (_ref2) {
        var dataName = _ref2.name;
        return dataName === name;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme(model, 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var _state$series$bullet2;

      var seriesIndex = _ref3.seriesIndex,
          state = _ref3.state;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var _state$series$bullet$2 = (_state$series$bullet2 = state.series.bullet) === null || _state$series$bullet2 === void 0 ? void 0 : _state$series$bullet2[seriesIndex],
          name = _state$series$bullet$2.name;

      var models = _this.filterBulletResponder(_this.responders).filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      });

      if (!models.length) {
        return;
      }

      _this.onMousemove({
        responders: models
      });
    });

    return _this;
  }

  bulletSeries_createClass(BulletSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'bullet';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      var clipRect = this.drawModels.clipRect;

      if (!clipRect) {
        return;
      }

      var offsetKey = this.vertical ? 'y' : 'x';
      var key = this.vertical ? 'height' : 'width';
      var current = clipRect[0];
      var target = this.models.clipRect[0];
      var offsetSize = current[key] + (target[key] - current[key]) * delta;
      current[key] = offsetSize;
      current[offsetKey] = Math.max(this.basePosition - offsetSize * this.basePosition / target[key], 0);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series;

      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          scale = state.scale,
          legend = state.legend,
          options = state.options,
          theme = state.theme,
          categories = state.categories;

      if (!series.bullet) {
        throw new Error(message.noDataError(this.name));
      }

      this.setEventDetectType(series, options);
      this.theme = theme.series.bullet;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      this.vertical = !!(options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.vertical);
      var labelAxisOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options
      });

      var _getAxisName = getAxisName(labelAxisOnYAxis, series),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      var _getSizeKey = getSizeKey(labelAxisOnYAxis),
          valueSizeKey = _getSizeKey.valueSizeKey;

      var tickDistance = axes[labelAxisName].tickDistance;
      var zeroPosition = axes[valueAxisName].zeroPosition;
      var _scale$valueAxisName$ = scale[valueAxisName].limit,
          min = _scale$valueAxisName$.min,
          max = _scale$valueAxisName$.max;
      var bulletData = series.bullet.data;
      this.basePosition = zeroPosition !== null && zeroPosition !== void 0 ? zeroPosition : 0;

      var renderOptions = bulletSeries_objectSpread({
        ratio: this.rect[valueSizeKey] / (max - min),
        tickDistance: tickDistance,
        zeroPosition: zeroPosition
      }, this.getBulletBarWidths(tickDistance));

      var rangeModels = this.renderRanges(bulletData, renderOptions);
      var bulletModels = this.renderBullet(bulletData, renderOptions);
      var markerModels = this.renderMarkers(bulletData, renderOptions);
      var clipRect = this.renderClipRectArea();
      this.models.clipRect = [clipRect];
      this.models.range = rangeModels;
      this.models.bullet = bulletModels;
      this.models.marker = markerModels;

      if (!this.drawModels) {
        this.drawModels = {
          clipRect: [this.makeInitialClipRectModel(clipRect)],
          range: deepCopyArray(rangeModels),
          bullet: deepCopyArray(bulletModels),
          marker: deepCopyArray(markerModels)
        };
      }

      var models = {
        range: rangeModels,
        bullet: bulletModels,
        marker: markerModels
      };
      var tooltipData = this.makeTooltipModel(models);
      this.tooltipRectMap = this.makeTooltipRectMap(models, tooltipData);
      this.responders = this.getBulletSeriesResponders(models, tooltipData, axes, categories);

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels([].concat(bulletSeries_toConsumableArray(rangeModels), bulletSeries_toConsumableArray(bulletModels), bulletSeries_toConsumableArray(markerModels)), this.vertical, this.rect[valueSizeKey]));
      }
    }
  }, {
    key: "renderClipRectArea",
    value: function renderClipRectArea() {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "makeInitialClipRectModel",
    value: function makeInitialClipRectModel(clipRect) {
      var width = this.vertical ? clipRect.width : 0;
      var height = this.vertical ? 0 : clipRect.height;
      var x = this.vertical ? clipRect.x : 0;
      var y = this.vertical ? 0 : clipRect.y;
      return {
        type: 'clipRectArea',
        width: width,
        height: height,
        x: x,
        y: y
      };
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels, vertical, size) {
      var dataLabelTheme = this.theme.dataLabels;
      var bulletLabelTheme = omit(dataLabelTheme, 'marker');
      var useSeriesColor = bulletLabelTheme.useSeriesColor,
          color = bulletLabelTheme.color;
      var marker = dataLabelTheme.marker;
      return seriesModels.filter(function (m) {
        return m.type === 'line' || m.modelType !== 'range';
      }).map(function (m) {
        if (m.type === 'line') {
          return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
            x: vertical ? (m.x + m.x2) / 2 : m.x,
            theme: bulletSeries_objectSpread(bulletSeries_objectSpread({}, marker), {}, {
              color: marker.useSeriesColor ? m.strokeStyle : marker.color
            })
          });
        }

        var isValueNegative = isNumber(m.value) && (m === null || m === void 0 ? void 0 : m.value) < 0;
        var direction = vertical ? 'top' : 'right';

        if (isValueNegative) {
          direction = vertical ? 'bottom' : 'left';
        }

        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
          direction: direction,
          plot: {
            x: 0,
            y: 0,
            size: size
          },
          theme: bulletSeries_objectSpread(bulletSeries_objectSpread({}, bulletLabelTheme), {}, {
            color: useSeriesColor ? m.color : color
          })
        });
      });
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series2;

      if (options !== null && options !== void 0 && (_options$series2 = options.series) !== null && _options$series2 !== void 0 && _options$series2.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }
    }
  }, {
    key: "getBulletSeriesResponders",
    value: function getBulletSeriesResponders(models, tooltipData, axes, categories) {
      return this.eventDetectType === 'grouped' ? makeRectResponderModel(this.rect, this.vertical ? axes.xAxis : axes.yAxis, categories, this.vertical) : makeBulletResponderModel(models, tooltipData);
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(models, tooltipData) {
      var result = {};
      Object.keys(models).forEach(function (seriesType) {
        models[seriesType].forEach(function (m, index) {
          var label = m.name;

          if (!result[label]) {
            result[label] = [];
          }

          var tooltipModel = bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
            data: tooltipData[seriesType][index]
          });

          result[label].push(tooltipModel);
        });
      });
      return result;
    }
  }, {
    key: "getBulletSeriesModelsFromRectResponders",
    value: function getBulletSeriesModelsFromRectResponders(responders) {
      var _this$tooltipRectMap;

      if (!responders.length) {
        return [];
      }

      return (_this$tooltipRectMap = this.tooltipRectMap[responders[0].label]) !== null && _this$tooltipRectMap !== void 0 ? _this$tooltipRectMap : [];
    }
  }, {
    key: "getGroupedRect",
    value: function getGroupedRect(responders, type) {
      var bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
      var _ref5 = this.theme[type].groupedRect,
          color = _ref5.color,
          opacity = _ref5.opacity;
      return bulletSeriesModels.length ? responders.map(function (m) {
        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
          color: getRGBA(color, opacity)
        });
      }) : [];
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: [].concat(bulletSeries_toConsumableArray(this.getGroupedRect(responders, 'hover')), bulletSeries_toConsumableArray(this.getRespondersWithTheme(bulletSeriesModels, 'hover'))),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = bulletSeriesModels;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref6) {
      var responders = _ref6.responders;

      if (this.eventDetectType === 'grouped') {
        this.onMousemoveGroupedType(responders);
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name
        });
        this.activatedResponders = responders.length ? [responders[responders.length - 1]] : [];
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref7) {
      var responders = _ref7.responders;

      if (this.selectable) {
        var models = this.eventDetectType === 'grouped' ? [].concat(bulletSeries_toConsumableArray(this.getGroupedRect(responders, 'select')), bulletSeries_toConsumableArray(this.getRespondersWithTheme(this.getBulletSeriesModelsFromRectResponders(responders), 'select'))) : this.getRespondersWithTheme(responders, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "filterBulletResponder",
    value: function filterBulletResponder(responders) {
      return responders.filter(function (model) {
        return (model === null || model === void 0 ? void 0 : model.modelType) === 'bullet';
      });
    }
  }, {
    key: "renderRanges",
    value: function renderRanges(bulletData, _ref8) {
      var _this2 = this;

      var tickDistance = _ref8.tickDistance,
          ratio = _ref8.ratio,
          zeroPosition = _ref8.zeroPosition,
          rangeWidth = _ref8.rangeWidth;
      var rangeModels = [];
      bulletData.forEach(function (_ref9, seriesIndex) {
        var ranges = _ref9.ranges,
            color = _ref9.color,
            name = _ref9.name;
        (ranges !== null && ranges !== void 0 ? ranges : []).forEach(function (range, rangeIndex) {
          if (!isNull(range)) {
            var _range = bulletSeries_slicedToArray(range, 2),
                start = _range[0],
                end = _range[1];

            var barLength = (end - start) * ratio;
            var rangeStartX = getStartX(seriesIndex, tickDistance, rangeWidth);
            rangeModels.push(bulletSeries_objectSpread(bulletSeries_objectSpread({
              type: 'rect',
              name: name,
              color: _this2.getRangeColor(getRGBA(color, _this2.getSeriesOpacity(name)), rangeIndex, name),
              x: _this2.vertical ? rangeStartX : start * ratio + zeroPosition,
              y: _this2.vertical ? zeroPosition - end * ratio : rangeStartX
            }, getRectSize(_this2.vertical, rangeWidth, barLength)), {}, {
              modelType: 'range',
              seriesColor: color,
              tooltipColor: _this2.getRangeColor(color, rangeIndex, name, true),
              value: range
            }));
          }
        });
      });
      return rangeModels;
    }
  }, {
    key: "renderBullet",
    value: function renderBullet(bulletData, _ref10) {
      var _this3 = this;

      var tickDistance = _ref10.tickDistance,
          ratio = _ref10.ratio,
          zeroPosition = _ref10.zeroPosition,
          bulletWidth = _ref10.bulletWidth;
      var _this$theme = this.theme,
          borderColor = _this$theme.borderColor,
          thickness = _this$theme.borderWidth;
      return bulletData.reduce(function (acc, _ref11, seriesIndex) {
        var data = _ref11.data,
            color = _ref11.color,
            name = _ref11.name;

        if (isNull(data)) {
          return bulletSeries_toConsumableArray(acc);
        }

        var bulletLength = Math.max(Math.abs(data * ratio), 2);
        var bulletStartX = getStartX(seriesIndex, tickDistance, bulletWidth);
        var x = _this3.vertical ? bulletStartX : zeroPosition - (data < 0 ? bulletLength : 0);
        var y = _this3.vertical ? zeroPosition - bulletLength + (data < 0 ? bulletLength : 0) : bulletStartX;

        var bullet = bulletSeries_objectSpread({
          type: 'rect',
          name: name,
          color: getRGBA(color, _this3.getSeriesOpacity(name)),
          x: x,
          y: y,
          thickness: thickness,
          borderColor: borderColor,
          modelType: 'bullet',
          seriesColor: color,
          tooltipColor: color,
          value: data
        }, getRectSize(_this3.vertical, bulletWidth, bulletLength));

        return [].concat(bulletSeries_toConsumableArray(acc), [bullet]);
      }, []);
    }
  }, {
    key: "renderMarkers",
    value: function renderMarkers(bulletData, _ref12) {
      var _this4 = this;

      var tickDistance = _ref12.tickDistance,
          ratio = _ref12.ratio,
          zeroPosition = _ref12.zeroPosition,
          markerWidth = _ref12.markerWidth;
      var markerLineWidth = this.theme.markerLineWidth;
      var markerModels = [];
      bulletData.forEach(function (_ref13, seriesIndex) {
        var markers = _ref13.markers,
            color = _ref13.color,
            name = _ref13.name;
        var markerStartX = getStartX(seriesIndex, tickDistance, markerWidth);
        (markers !== null && markers !== void 0 ? markers : []).forEach(function (marker) {
          if (!isNull(marker)) {
            var dataPosition = marker * ratio;
            var x = _this4.vertical ? markerStartX : dataPosition + zeroPosition;
            var y = _this4.vertical ? zeroPosition - dataPosition : markerStartX;
            markerModels.push({
              type: 'line',
              name: name,
              x: x,
              y: y,
              x2: _this4.vertical ? x + markerWidth : x,
              y2: _this4.vertical ? y : y + markerWidth,
              strokeStyle: getRGBA(color, _this4.getSeriesOpacity(name)),
              lineWidth: markerLineWidth,
              seriesColor: color,
              tooltipColor: color,
              value: marker
            });
          }
        });
      });
      return markerModels;
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(seriesModels) {
      var range = seriesModels.range,
          bullet = seriesModels.bullet,
          marker = seriesModels.marker;
      return {
        range: this.makeTooltipData(range, 'Range'),
        bullet: this.makeTooltipData(bullet, 'Actual'),
        marker: this.makeTooltipData(marker, 'Marker')
      };
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(data, title) {
      return data.map(function (m) {
        var name = m.name,
            seriesColor = m.seriesColor,
            tooltipColor = m.tooltipColor,
            value = m.value;
        return {
          label: name,
          color: getRGBA(seriesColor, 1),
          value: [{
            title: title,
            value: value,
            color: tooltipColor
          }],
          templateType: 'bullet'
        };
      });
    }
  }, {
    key: "getBulletBarWidths",
    value: function getBulletBarWidths(tickDistance) {
      var _this$theme2 = this.theme,
          barThemeWidth = _this$theme2.barWidth,
          barWidthRatios = _this$theme2.barWidthRatios;
      var rangeRatio = barWidthRatios.rangeRatio,
          bulletRatio = barWidthRatios.bulletRatio,
          markerRatio = barWidthRatios.markerRatio;
      var barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance, barThemeWidth) : tickDistance * DEFAULT_WIDTH_RATIO;
      return {
        rangeWidth: barWidth * rangeRatio,
        bulletWidth: barWidth * bulletRatio,
        markerWidth: barWidth * markerRatio
      };
    }
  }, {
    key: "getRangeColor",
    value: function getRangeColor(seriesColor, rangeIndex, seriesName) {
      var ignoreRestSeriesOpacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var rangeColors = this.theme.rangeColors;
      var hasThemeRangeColor = Array.isArray(rangeColors) && rangeColors[rangeIndex];
      var color = hasThemeRangeColor ? rangeColors[rangeIndex] : seriesColor;
      var opacity = hasThemeRangeColor ? getAlpha(rangeColors[rangeIndex]) : DEFAULT_BULLET_RANGE_OPACITY[rangeIndex];
      return getRGBA(color, opacity * this.getSeriesOpacity(seriesName, ignoreRestSeriesOpacity));
    }
  }, {
    key: "getSeriesOpacity",
    value: function getSeriesOpacity(seriesName) {
      var ignoreRestSeriesOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _this$theme3 = this.theme,
          select = _this$theme3.select,
          areaOpacity = _this$theme3.areaOpacity;
      var active = this.activeSeriesMap[seriesName];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var restOpacity = ignoreRestSeriesOpacity ? areaOpacity : select.restSeries.areaOpacity;
      var selectedOpacity = active ? select.areaOpacity : restOpacity;
      return selected ? selectedOpacity : areaOpacity;
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this5 = this;

      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          borderColor = _this$theme$type.borderColor,
          thickness = _this$theme$type.borderWidth;
      return this.filterBulletResponder(responders).map(function (model) {
        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, model), {}, {
          color: color !== null && color !== void 0 ? color : model.tooltipColor,
          thickness: thickness,
          borderColor: borderColor,
          style: [bulletSeries_objectSpread({}, pick(_this5.theme[type], 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY'))]
        });
      });
    }
  }]);

  return BulletSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/bulletChart.ts
function bulletChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bulletChart_typeof = function _typeof(obj) { return typeof obj; }; } else { bulletChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bulletChart_typeof(obj); }


















function bulletChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function bulletChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bulletChart_ownKeys(Object(source), true).forEach(function (key) { bulletChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bulletChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bulletChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bulletChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bulletChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) bulletChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) bulletChart_defineProperties(Constructor, staticProps); return Constructor; }

function bulletChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { bulletChart_get = Reflect.get; } else { bulletChart_get = function _get(target, property, receiver) { var base = bulletChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return bulletChart_get(target, property, receiver || target); }

function bulletChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = bulletChart_getPrototypeOf(object); if (object === null) break; } return object; }

function bulletChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bulletChart_setPrototypeOf(subClass, superClass); }

function bulletChart_setPrototypeOf(o, p) { bulletChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bulletChart_setPrototypeOf(o, p); }

function bulletChart_createSuper(Derived) { var hasNativeReflectConstruct = bulletChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bulletChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bulletChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bulletChart_possibleConstructorReturn(this, result); }; }

function bulletChart_possibleConstructorReturn(self, call) { if (call && (bulletChart_typeof(call) === "object" || typeof call === "function")) { return call; } return bulletChart_assertThisInitialized(self); }

function bulletChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bulletChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function bulletChart_getPrototypeOf(o) { bulletChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bulletChart_getPrototypeOf(o); }

function bulletChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


























/**
 * @class
 * @classdesc Bullet Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bullet Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *       @param {Array<number>} props.data.series.markers - Series markers. It specifies the marker for comparing.
 *       @param {Array<Array<number>>} props.data.series.ranges - Series ranges. It specifies the range of values that can be compared.
 *   @param {Object} [props.options] - Options for making Bullet Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.vertical] - Whether to use vertical bullet series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bullets Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var BulletChart = /*#__PURE__*/function (_Chart) {
  bulletChart_inherits(BulletChart, _Chart);

  var _super = bulletChart_createSuper(BulletChart);

  function BulletChart(_ref) {
    var _this;

    var el = _ref.el,
        options = _ref.options,
        series = _ref.data.series;

    bulletChart_classCallCheck(this, BulletChart);

    _this = _super.call(this, {
      el: el,
      options: options,
      series: {
        bullet: series
      },
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });

    bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  bulletChart_createClass(BulletChart, [{
    key: "initialize",
    value: function initialize() {
      bulletChart_get(bulletChart_getPrototypeOf(BulletChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BulletSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added
     *   @param {string} data.name - Series name
     *   @param {Array<<Array<number>>} data.data - Array of data to be added
     *   @param {Array<number>} data.markers - Series markers. It specifies the marker for comparing.
     *   @param {Array<Array<number>>} data.ranges - Series ranges. It specifies the range of values that can be compared.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: 20,
     *   markers: [28, 2, 15],
     *   ranges: [
     *     [-1, 10],
     *     [10, 20],
     *     [20, 30],
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'newSeries',
     *       data: 20,
     *       markers: [28, 2, 15],
     *       ranges: [
     *         [-1, 10],
     *         [10, 20],
     *         [20, 30],
     *       ],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bullet: data.series
        }
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', bulletChart_objectSpread(bulletChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }]);

  return BulletChart;
}(Chart);


;// CONCATENATED MODULE: ./src/store/nestedPieSeriesData.ts
function nestedPieSeriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function nestedPieSeriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { nestedPieSeriesData_ownKeys(Object(source), true).forEach(function (key) { nestedPieSeriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { nestedPieSeriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function nestedPieSeriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













function findRootName(rawSeries, seriesIndex, parentName) {
  var _rawSeries$pie;

  var item = (_rawSeries$pie = rawSeries.pie) === null || _rawSeries$pie === void 0 ? void 0 : _rawSeries$pie[seriesIndex].data.find(function (_ref) {
    var name = _ref.name;
    return name === parentName;
  });
  return item !== null && item !== void 0 && item.parentName ? findRootName(rawSeries, seriesIndex - 1, item.parentName) : parentName;
}

var nestedPieSeriesData = {
  name: 'seriesData',
  state: function state() {
    return {
      nestedPieSeries: {}
    };
  },
  action: {
    setNestedPieSeriesData: function setNestedPieSeriesData(_ref2) {
      var state = _ref2.state,
          initStoreState = _ref2.initStoreState;
      var theme = state.theme,
          disabledSeries = state.disabledSeries;
      var rawSeries = initStoreState.series;
      var newSeriesData = {};
      var colorMap = {};
      rawSeries.pie.forEach(function (_ref3, seriesIndex) {
        var alias = _ref3.name,
            data = _ref3.data;
        var colors = theme.series.pie[alias].colors;
        var colorList = [];
        var originSeriesData = data.map(function (m, index) {
          var parentName = m.parentName,
              dataName = m.name;
          var color = parentName && seriesIndex ? colorMap[parentName] : colors === null || colors === void 0 ? void 0 : colors[index];
          colorList.push(color);
          colorMap[dataName] = color;
          var rootParentName = parentName && seriesIndex ? findRootName(rawSeries, seriesIndex - 1, parentName) : dataName;
          return nestedPieSeriesData_objectSpread(nestedPieSeriesData_objectSpread({}, m), {}, {
            data: m.data,
            rootParentName: rootParentName,
            color: color
          });
        });
        newSeriesData[alias] = {
          data: originSeriesData.filter(function (_ref4) {
            var rootParentName = _ref4.rootParentName;
            return !disabledSeries.includes(rootParentName);
          }),
          colors: colorList
        };
      });
      state.nestedPieSeries = newSeriesData;
      this.dispatch('updateNestedPieChartLegend');
    }
  },
  observe: {
    updateNestedPieSeriesData: function updateNestedPieSeriesData() {
      this.dispatch('setNestedPieSeriesData');
    }
  }
};
/* harmony default export */ var store_nestedPieSeriesData = (nestedPieSeriesData);
;// CONCATENATED MODULE: ./src/charts/nestedPieChart.ts
function nestedPieChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { nestedPieChart_typeof = function _typeof(obj) { return typeof obj; }; } else { nestedPieChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return nestedPieChart_typeof(obj); }

function nestedPieChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function nestedPieChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { nestedPieChart_ownKeys(Object(source), true).forEach(function (key) { nestedPieChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { nestedPieChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function nestedPieChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



















function nestedPieChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function nestedPieChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function nestedPieChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) nestedPieChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) nestedPieChart_defineProperties(Constructor, staticProps); return Constructor; }

function nestedPieChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { nestedPieChart_get = Reflect.get; } else { nestedPieChart_get = function _get(target, property, receiver) { var base = nestedPieChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return nestedPieChart_get(target, property, receiver || target); }

function nestedPieChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = nestedPieChart_getPrototypeOf(object); if (object === null) break; } return object; }

function nestedPieChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) nestedPieChart_setPrototypeOf(subClass, superClass); }

function nestedPieChart_setPrototypeOf(o, p) { nestedPieChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return nestedPieChart_setPrototypeOf(o, p); }

function nestedPieChart_createSuper(Derived) { var hasNativeReflectConstruct = nestedPieChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = nestedPieChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = nestedPieChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return nestedPieChart_possibleConstructorReturn(this, result); }; }

function nestedPieChart_possibleConstructorReturn(self, call) { if (call && (nestedPieChart_typeof(call) === "object" || typeof call === "function")) { return call; } return nestedPieChart_assertThisInitialized(self); }

function nestedPieChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function nestedPieChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function nestedPieChart_getPrototypeOf(o) { nestedPieChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return nestedPieChart_getPrototypeOf(o); }




















/**
 * @class
 * @classdesc NestedPie Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making NestedPie Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *       @param {string} [props.data.series.parentName] - Value specifying parent data when using group nested pie chart.
 *   @param {Object} [props.options] - Options for making NestedPie Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Object} [props.options.series.aliasName] - Chart options are specified based on the alias name. 'radiusRange', 'angleRange', 'clockwise', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|NestedPie Chart guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|NestedPie Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var NestedPieChart = /*#__PURE__*/function (_Chart) {
  nestedPieChart_inherits(NestedPieChart, _Chart);

  var _super = nestedPieChart_createSuper(NestedPieChart);

  function NestedPieChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        _ref$data = _ref.data,
        series = _ref$data.series,
        categories = _ref$data.categories;

    nestedPieChart_classCallCheck(this, NestedPieChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        pie: series
      },
      categories: categories,
      modules: [store_nestedPieSeriesData]
    });
  }

  nestedPieChart_createClass(NestedPieChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore,
          _this = this;

      nestedPieChart_get(nestedPieChart_getPrototypeOf(NestedPieChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Legend);
      ((_this$store$initStore = this.store.initStoreState.series.pie) !== null && _this$store$initStore !== void 0 ? _this$store$initStore : []).forEach(function (_ref2) {
        var name = _ref2.name;

        _this.componentManager.add(PieSeries, {
          alias: name
        });
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which name of chart to add.
     *   @param {string} dataInfo.name - Chart series name.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [
     *       { name: 'A', data: 10 },
     *       { name: 'B', data: 20 },
     *     ],
     *   },
     *   {
     *     name: 'series name'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', nestedPieChart_objectSpread({
        data: data
      }, dataInfo));
      this.componentManager.add(PieSeries, {
        alias: data.name
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['A', 'B'],
     *   series: [
     *     {
     *       name: 'browsers',
     *       data: [
     *         {
     *           name: 'Chrome',
     *           data: 50,
     *         },
     *         {
     *           name: 'Safari',
     *           data: 20,
     *         },
     *       ]
     *     },
     *     {
     *       name: 'versions',
     *       data: [
     *         {
     *           name: '1',
     *           data: 50,
     *         },
     *         {
     *           name: '2',
     *           data: 20,
     *         },
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var _this$store$initStore2,
          _this2 = this;

      this.componentManager.remove(PieSeries);
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          pie: data.series
        }
      });
      ((_this$store$initStore2 = this.store.initStoreState.series.pie) !== null && _this$store$initStore2 !== void 0 ? _this$store$initStore2 : []).forEach(function (_ref3) {
        var name = _ref3.name;

        _this2.componentManager.add(PieSeries, {
          alias: name
        });
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     alias2: {
     *       radiusRange: [20%, 50%],
     *     },
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     alias1: {
     *       showDot: true,
     *     },
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.alias - alias name.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1, alias: 'name'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', nestedPieChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return NestedPieChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/radarSeries.ts
function radarSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radarSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { radarSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radarSeries_typeof(obj); }

function radarSeries_toConsumableArray(arr) { return radarSeries_arrayWithoutHoles(arr) || radarSeries_iterableToArray(arr) || radarSeries_unsupportedIterableToArray(arr) || radarSeries_nonIterableSpread(); }

function radarSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radarSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radarSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radarSeries_arrayLikeToArray(o, minLen); }

function radarSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function radarSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radarSeries_arrayLikeToArray(arr); }

function radarSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function radarSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radarSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radarSeries_ownKeys(Object(source), true).forEach(function (key) { radarSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radarSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }























function radarSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radarSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radarSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) radarSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) radarSeries_defineProperties(Constructor, staticProps); return Constructor; }

function radarSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radarSeries_setPrototypeOf(subClass, superClass); }

function radarSeries_setPrototypeOf(o, p) { radarSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radarSeries_setPrototypeOf(o, p); }

function radarSeries_createSuper(Derived) { var hasNativeReflectConstruct = radarSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radarSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radarSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radarSeries_possibleConstructorReturn(this, result); }; }

function radarSeries_possibleConstructorReturn(self, call) { if (call && (radarSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return radarSeries_assertThisInitialized(self); }

function radarSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radarSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radarSeries_getPrototypeOf(o) { radarSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radarSeries_getPrototypeOf(o); }

function radarSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var NONE_AREA_OPACITY = 0;
var radarSeries_seriesOpacity = {
  INACTIVE: 0.2,
  ACTIVE: 1
};

var RadarSeries = /*#__PURE__*/function (_Component) {
  radarSeries_inherits(RadarSeries, _Component);

  var _super = radarSeries_createSuper(RadarSeries);

  function RadarSeries() {
    var _this;

    radarSeries_classCallCheck(this, RadarSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "models", {
      area: [],
      line: [],
      dot: []
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "drawModels", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "responders", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "activatedResponders", []);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "theme", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.radar.data[seriesIndex].name;

      var model = _this.responders.filter(function (_ref2) {
        var dataName = _ref2.name;
        return dataName === name;
      })[index];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var index = _ref3.index,
          seriesIndex = _ref3.seriesIndex,
          state = _ref3.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.radar.data[seriesIndex].name;
      var models = [_this.responders.filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      })[index]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: _this.getRespondersWithTheme(models, 'hover'),
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  radarSeries_createClass(RadarSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'radar';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series$showA, _options$series, _series$radar, _options$series2, _options$series3;

      var layout = state.layout,
          radialAxes = state.radialAxes,
          series = state.series,
          legend = state.legend,
          options = state.options,
          theme = state.theme,
          scale = state.scale;

      if (!series.radar) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.radar;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var categories = state.categories;
      var _ref5 = radialAxes.verticalAxis,
          axisSize = _ref5.axisSize,
          centerX = _ref5.centerX,
          centerY = _ref5.centerY;
      var _ref6 = scale.verticalAxis,
          limit = _ref6.limit,
          stepSize = _ref6.stepSize;
      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      var renderOptions = {
        categories: categories,
        degree: DEGREE_360 / categories.length,
        centerX: centerX,
        centerY: centerY,
        showArea: (_options$series$showA = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.showArea) !== null && _options$series$showA !== void 0 ? _options$series$showA : false,
        ratio: axisSize / (max - min)
      };
      var radarData = (_series$radar = series.radar) === null || _series$radar === void 0 ? void 0 : _series$radar.data;
      var radarPointsData = this.makeRadarPointsData(radarData, renderOptions);
      var circleModel = this.renderDotModels(radarPointsData);
      this.models.area = options !== null && options !== void 0 && (_options$series2 = options.series) !== null && _options$series2 !== void 0 && _options$series2.showArea ? this.renderAreaModels(radarPointsData) : [];
      this.models.line = this.renderLineModels(radarPointsData);
      this.models.dot = options !== null && options !== void 0 && (_options$series3 = options.series) !== null && _options$series3 !== void 0 && _options$series3.showDot ? circleModel : [];

      if (!this.drawModels) {
        this.drawModels = {
          area: this.initDrawModels('area', centerX, centerY),
          line: this.initDrawModels('line', centerX, centerY),
          dot: this.models.dot.map(function (m) {
            return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
              x: centerX,
              y: centerY
            });
          })
        };
      }

      var tooltipDataArr = this.makeTooltipModel(circleModel, categories);
      this.responders = circleModel.map(function (m, index) {
        return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[index],
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "initDrawModels",
    value: function initDrawModels(modelName, centerX, centerY) {
      return this.models[modelName].map(function (m) {
        var _m$distances;

        return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
          distances: (_m$distances = m.distances) === null || _m$distances === void 0 ? void 0 : _m$distances.map(function () {
            return 0;
          }),
          points: m.points.map(function () {
            return {
              x: centerX,
              y: centerY
            };
          })
        });
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleModel, categories) {
      return circleModel.map(function (_ref7) {
        var name = _ref7.name,
            color = _ref7.color,
            value = _ref7.value,
            index = _ref7.index;
        return {
          label: name,
          color: color,
          value: value,
          category: categories[index]
        };
      });
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _ref8 = this.theme[type].dot,
          radius = _ref8.radius,
          borderWidth = _ref8.borderWidth,
          borderColor = _ref8.borderColor,
          color = _ref8.color;
      return responders.map(function (responder) {
        var modelColor = color !== null && color !== void 0 ? color : responder.color;
        return radarSeries_objectSpread(radarSeries_objectSpread({}, responder), {}, {
          radius: radius,
          color: modelColor,
          borderColor: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5),
          borderWidth: borderWidth
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getRespondersWithTheme(responders, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref10) {
      var responders = _ref10.responders;
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.activatedResponders = responders;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "makeRadarPointsData",
    value: function makeRadarPointsData(seriesData, renderOptions) {
      var _this2 = this;

      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          degree = renderOptions.degree,
          ratio = renderOptions.ratio,
          showArea = renderOptions.showArea;
      return seriesData.map(function (_ref11) {
        var data = _ref11.data,
            seriesColor = _ref11.color,
            name = _ref11.name;
        var radarPoints = data.reduce(function (acc, value, index) {
          if (isNull(value)) {
            return {
              distances: [].concat(radarSeries_toConsumableArray(acc.distances), [0]),
              linePoints: [].concat(radarSeries_toConsumableArray(acc.linePoints), [null]),
              areaPoints: [].concat(radarSeries_toConsumableArray(acc.areaPoints), [{
                x: centerX,
                y: centerY
              }])
            };
          }

          var distance = value * ratio;
          var point = getRadialPosition(centerX, centerY, distance, calculateDegreeToRadian(degree * index));
          return {
            distances: [].concat(radarSeries_toConsumableArray(acc.distances), [distance]),
            linePoints: [].concat(radarSeries_toConsumableArray(acc.linePoints), [point]),
            areaPoints: [].concat(radarSeries_toConsumableArray(acc.areaPoints), [point])
          };
        }, {
          linePoints: [],
          distances: [],
          areaPoints: []
        });

        if (!isNull(data[0]) && !isNull(data[data.length - 1])) {
          radarPoints.linePoints.push(radarPoints.linePoints[0]);
          radarPoints.areaPoints.push(radarPoints.areaPoints[0]);
        }

        return radarSeries_objectSpread(radarSeries_objectSpread({
          name: name,
          seriesColor: seriesColor,
          data: data
        }, radarPoints), _this2.getSeriesColor(showArea, seriesColor, name));
      });
    }
  }, {
    key: "renderAreaModels",
    value: function renderAreaModels(radarPointsData) {
      return radarPointsData.map(function (_ref12) {
        var distances = _ref12.distances,
            areaPoints = _ref12.areaPoints,
            name = _ref12.name,
            fillColor = _ref12.fillColor,
            seriesColor = _ref12.seriesColor;
        return {
          type: 'areaPoints',
          name: name,
          distances: distances,
          points: areaPoints,
          fillColor: fillColor,
          color: getRGBA(seriesColor, 0),
          lineWidth: 0
        };
      });
    }
  }, {
    key: "renderLineModels",
    value: function renderLineModels(radarPointsData) {
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      return radarPointsData.map(function (_ref13) {
        var distances = _ref13.distances,
            linePoints = _ref13.linePoints,
            name = _ref13.name,
            lineColor = _ref13.lineColor;
        return {
          type: 'linePoints',
          lineWidth: lineWidth !== null && lineWidth !== void 0 ? lineWidth : radarDefault.LINE_WIDTH,
          name: name,
          distances: distances,
          points: linePoints,
          color: lineColor,
          dashSegments: dashSegments
        };
      });
    }
  }, {
    key: "renderDotModels",
    value: function renderDotModels(radarPointsData) {
      var _ref14 = this.theme.dot,
          radius = _ref14.radius,
          dotColor = _ref14.color;
      var result = [];
      radarPointsData.forEach(function (_ref15, seriesIndex) {
        var linePoints = _ref15.linePoints,
            lineColor = _ref15.lineColor,
            name = _ref15.name,
            data = _ref15.data;
        return linePoints.slice(0, linePoints.length - 1).forEach(function (point, index) {
          if (!isNull(point)) {
            result.push(radarSeries_objectSpread(radarSeries_objectSpread({
              type: 'circle'
            }, point), {}, {
              radius: radius,
              color: dotColor !== null && dotColor !== void 0 ? dotColor : lineColor,
              style: [{
                strokeStyle: 'rgba(0, 0, 0, 0)'
              }],
              name: name,
              seriesIndex: seriesIndex,
              index: index,
              value: data === null || data === void 0 ? void 0 : data[index]
            }));
          }
        });
      });
      return result;
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(showArea, seriesColor, name) {
      var active = this.activeSeriesMap[name];
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var color = getRGBA(seriesColor, active ? radarSeries_seriesOpacity.ACTIVE : radarSeries_seriesOpacity.INACTIVE);
      var fillOpacity = NONE_AREA_OPACITY;

      if (showArea) {
        var selectedAreaOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
        fillOpacity = selected ? selectedAreaOpacity : areaOpacity;
      }

      return {
        lineColor: color,
        fillColor: getRGBA(color, fillOpacity)
      };
    }
  }]);

  return RadarSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/radialPlot.ts
function radialPlot_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialPlot_typeof = function _typeof(obj) { return typeof obj; }; } else { radialPlot_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialPlot_typeof(obj); }

function radialPlot_toConsumableArray(arr) { return radialPlot_arrayWithoutHoles(arr) || radialPlot_iterableToArray(arr) || radialPlot_unsupportedIterableToArray(arr) || radialPlot_nonIterableSpread(); }

function radialPlot_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radialPlot_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radialPlot_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radialPlot_arrayLikeToArray(o, minLen); }

function radialPlot_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function radialPlot_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radialPlot_arrayLikeToArray(arr); }

function radialPlot_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function radialPlot_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialPlot_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialPlot_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialPlot_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialPlot_defineProperties(Constructor, staticProps); return Constructor; }

function radialPlot_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialPlot_setPrototypeOf(subClass, superClass); }

function radialPlot_setPrototypeOf(o, p) { radialPlot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialPlot_setPrototypeOf(o, p); }

function radialPlot_createSuper(Derived) { var hasNativeReflectConstruct = radialPlot_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialPlot_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialPlot_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialPlot_possibleConstructorReturn(this, result); }; }

function radialPlot_possibleConstructorReturn(self, call) { if (call && (radialPlot_typeof(call) === "object" || typeof call === "function")) { return call; } return radialPlot_assertThisInitialized(self); }

function radialPlot_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialPlot_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radialPlot_getPrototypeOf(o) { radialPlot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialPlot_getPrototypeOf(o); }

function radialPlot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
























function getScaleMaxLimitValue(scale, totalAngle) {
  var max = scale.limit.max,
      stepSize = scale.stepSize;
  return max + (totalAngle < DEGREE_360 ? DEGREE_0 : stepSize);
}

function findCategoryIndex(categories, value) {
  return categories.findIndex(function (category) {
    return category === value;
  });
}

var RadarPlot = /*#__PURE__*/function (_Component) {
  radialPlot_inherits(RadarPlot, _Component);

  var _super = radialPlot_createSuper(RadarPlot);

  function RadarPlot() {
    var _this;

    radialPlot_classCallCheck(this, RadarPlot);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radialPlot_defineProperty(radialPlot_assertThisInitialized(_this), "models", {
      plot: [],
      line: [],
      band: []
    });

    radialPlot_defineProperty(radialPlot_assertThisInitialized(_this), "circularAxisTheme", void 0);

    return _this;
  }

  radialPlot_createClass(RadarPlot, [{
    key: "initialize",
    value: function initialize(initParam) {
      var _initParam$name;

      this.type = 'plot';
      this.name = (_initParam$name = initParam === null || initParam === void 0 ? void 0 : initParam.name) !== null && _initParam$name !== void 0 ? _initParam$name : 'radialPlot';
    }
  }, {
    key: "render",
    value: function render(state) {
      var _ref;

      var layout = state.layout,
          radialAxes = state.radialAxes,
          options = state.options,
          series = state.series,
          theme = state.theme,
          scale = state.scale;
      this.rect = layout.plot;
      this.circularAxisTheme = theme.circularAxis;
      var categories = (_ref = state.categories) !== null && _ref !== void 0 ? _ref : [];

      if (this.name === 'gauge') {
        var _plot$bands, _plot;

        var bandData = (_plot$bands = options === null || options === void 0 ? void 0 : (_plot = options.plot) === null || _plot === void 0 ? void 0 : _plot.bands) !== null && _plot$bands !== void 0 ? _plot$bands : [];
        var hasCategoryAxis = !isLabelAxisOnYAxis({
          series: series,
          categories: categories
        });
        var renderOptions = this.makeRenderOptionsOnGauge(hasCategoryAxis, radialAxes.circularAxis, categories, scale);
        this.models.band = this.renderBands(bandData, renderOptions, categories);
      } else {
        var _options$plot$type, _options$plot;

        var isRadarChart = !!series.radar;
        var plotType = (_options$plot$type = (_options$plot = options.plot) === null || _options$plot === void 0 ? void 0 : _options$plot.type) !== null && _options$plot$type !== void 0 ? _options$plot$type : isRadarChart ? 'spiderweb' : 'circle';

        var _renderOptions = this.makeRenderOptions(radialAxes, plotType, categories);

        this.models.plot = this.renderPlot(_renderOptions);
        this.models.line = series.radialBar ? this.renderLine(_renderOptions) : [];
      }
    }
  }, {
    key: "makeRenderOptionsOnGauge",
    value: function makeRenderOptionsOnGauge(hasCategoryAxis, circularAxis, categories, scale) {
      var _circularAxis$angle = circularAxis.angle,
          total = _circularAxis$angle.total,
          start = _circularAxis$angle.start,
          outer = circularAxis.radius.outer,
          clockwise = circularAxis.clockwise,
          centerX = circularAxis.centerX,
          centerY = circularAxis.centerY;
      var _ref2 = circularAxis.band,
          bandWidth = _ref2.width,
          bandMargin = _ref2.margin;
      return {
        centerX: centerX,
        centerY: centerY,
        clockwise: clockwise,
        totalAngle: total,
        scaleMaxLimitValue: hasCategoryAxis ? categories.length : getScaleMaxLimitValue(scale.circularAxis, total),
        startAngle: start,
        outerRadius: outer,
        bandWidth: bandWidth,
        bandMargin: bandMargin,
        hasCategoryAxis: hasCategoryAxis
      };
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(radialAxes, type) {
      var categories = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var _ref3 = radialAxes.verticalAxis,
          centerX = _ref3.centerX,
          centerY = _ref3.centerY,
          _ref3$radius = _ref3.radius,
          ranges = _ref3$radius.ranges,
          inner = _ref3$radius.inner,
          outer = _ref3$radius.outer;
      var _radialAxes$circularA = radialAxes.circularAxis,
          _radialAxes$circularA2 = _radialAxes$circularA.angle,
          central = _radialAxes$circularA2.central,
          total = _radialAxes$circularA2.total,
          start = _radialAxes$circularA2.start,
          end = _radialAxes$circularA2.end,
          drawingStart = _radialAxes$circularA2.drawingStart,
          labels = _radialAxes$circularA.label.labels,
          tickInterval = _radialAxes$circularA.tickInterval,
          clockwise = _radialAxes$circularA.clockwise;
      var usingArcPlot = total !== DEGREE_360;
      var lineCount = labels.length;
      return {
        type: type,
        categories: categories,
        centralAngle: central,
        centerX: centerX,
        centerY: centerY,
        initialRadius: inner,
        radius: outer,
        radiusRanges: ranges,
        lineCount: lineCount,
        tickInterval: tickInterval,
        drawingStartAngle: drawingStart,
        usingArcPlot: usingArcPlot,
        startAngle: start,
        endAngle: end,
        clockwise: clockwise
      };
    }
  }, {
    key: "renderPlot",
    value: function renderPlot(renderOptions) {
      var type = renderOptions.type,
          usingArcPlot = renderOptions.usingArcPlot;

      if (usingArcPlot) {
        return this.makeArc(renderOptions);
      }

      if (type === 'spiderweb') {
        return this.makeSpiderwebPlot(renderOptions);
      }

      return this.makeCirclePlot(renderOptions);
    }
  }, {
    key: "makeSpiderwebPlot",
    value: function makeSpiderwebPlot(renderOptions) {
      var centralAngle = renderOptions.centralAngle,
          centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          categories = renderOptions.categories,
          radiusRanges = renderOptions.radiusRanges;
      var _this$circularAxisThe = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe.strokeStyle,
          lineWidth = _this$circularAxisThe.lineWidth;
      return radiusRanges.map(function (radius) {
        var points = categories.map(function (_, index) {
          return getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(centralAngle * index));
        });
        return {
          type: 'polygon',
          color: strokeStyle,
          lineWidth: lineWidth,
          points: points
        };
      });
    }
  }, {
    key: "makeCirclePlot",
    value: function makeCirclePlot(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          radiusRanges = renderOptions.radiusRanges;
      var _this$circularAxisThe2 = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe2.strokeStyle,
          lineWidth = _this$circularAxisThe2.lineWidth;
      return radiusRanges.map(function (radius) {
        return {
          type: 'circle',
          color: 'rgba(0, 0, 0, 0)',
          radius: radius,
          x: centerX,
          y: centerY,
          borderColor: strokeStyle,
          borderWidth: lineWidth
        };
      });
    }
  }, {
    key: "makeArc",
    value: function makeArc(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          radiusRanges = renderOptions.radiusRanges,
          startAngle = renderOptions.startAngle,
          endAngle = renderOptions.endAngle,
          clockwise = renderOptions.clockwise;
      var _this$circularAxisThe3 = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe3.strokeStyle,
          lineWidth = _this$circularAxisThe3.lineWidth;
      return radiusRanges.map(function (radius) {
        return {
          type: 'arc',
          borderWidth: lineWidth,
          borderColor: strokeStyle,
          x: centerX,
          y: centerY,
          angle: {
            start: startAngle,
            end: endAngle
          },
          drawingStartAngle: DEGREE_NEGATIVE_90,
          radius: radius,
          clockwise: clockwise
        };
      });
    }
  }, {
    key: "renderLine",
    value: function renderLine(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          initialRadius = renderOptions.initialRadius,
          radius = renderOptions.radius,
          lineCount = renderOptions.lineCount,
          centralAngle = renderOptions.centralAngle,
          tickInterval = renderOptions.tickInterval,
          drawingStartAngle = renderOptions.drawingStartAngle,
          clockwise = renderOptions.clockwise;
      var _this$circularAxisThe4 = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe4.strokeStyle,
          lineWidth = _this$circularAxisThe4.lineWidth;
      return range(0, lineCount).reduce(function (acc, cur, index) {
        var startDegree = drawingStartAngle + centralAngle * index * (clockwise ? 1 : -1);

        var _getRadialPosition = getRadialPosition(centerX, centerY, initialRadius, calculateDegreeToRadian(startDegree)),
            x = _getRadialPosition.x,
            y = _getRadialPosition.y;

        var _getRadialPosition2 = getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(startDegree)),
            x2 = _getRadialPosition2.x,
            y2 = _getRadialPosition2.y;

        return index % tickInterval === 0 ? [].concat(radialPlot_toConsumableArray(acc), [{
          type: 'line',
          x: x,
          y: y,
          x2: x2,
          y2: y2,
          strokeStyle: strokeStyle,
          lineWidth: lineWidth
        }]) : acc;
      }, []);
    }
  }, {
    key: "renderBands",
    value: function renderBands(bands, renderOptions, categories) {
      var sectors = [];
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          clockwise = renderOptions.clockwise,
          totalAngle = renderOptions.totalAngle,
          scaleMaxLimitValue = renderOptions.scaleMaxLimitValue,
          startAngle = renderOptions.startAngle,
          outerRadius = renderOptions.outerRadius,
          bandWidth = renderOptions.bandWidth,
          bandMargin = renderOptions.bandMargin,
          hasCategoryAxis = renderOptions.hasCategoryAxis;
      bands.forEach(function (_ref4, index) {
        var rangeData = _ref4.range,
            color = _ref4.color;
        var value = hasCategoryAxis ? findCategoryIndex(categories, rangeData[1].toString()) - findCategoryIndex(categories, rangeData[0].toString()) : Number(rangeData[1]) - Number(rangeData[0]);
        var degree = value / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
        var validDegree = calculateValidAngle(degree);
        var prevModel = sectors[sectors.length - 1];
        var startDegree = index && prevModel ? prevModel.degree.end : startAngle;
        var endDegree = calculateValidAngle(startDegree + validDegree);
        sectors.push({
          type: 'sector',
          color: color,
          x: centerX,
          y: centerY,
          clockwise: clockwise,
          degree: {
            start: startDegree,
            end: endDegree
          },
          radius: {
            inner: outerRadius + bandMargin,
            outer: outerRadius + bandWidth
          }
        });
      });
      return sectors;
    }
  }]);

  return RadarPlot;
}(Component);


;// CONCATENATED MODULE: ./src/component/radialAxis.ts
function radialAxis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialAxis_typeof = function _typeof(obj) { return typeof obj; }; } else { radialAxis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialAxis_typeof(obj); }

function radialAxis_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radialAxis_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radialAxis_ownKeys(Object(source), true).forEach(function (key) { radialAxis_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radialAxis_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radialAxis_toConsumableArray(arr) { return radialAxis_arrayWithoutHoles(arr) || radialAxis_iterableToArray(arr) || radialAxis_unsupportedIterableToArray(arr) || radialAxis_nonIterableSpread(); }

function radialAxis_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radialAxis_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radialAxis_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radialAxis_arrayLikeToArray(o, minLen); }

function radialAxis_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function radialAxis_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radialAxis_arrayLikeToArray(arr); }

function radialAxis_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















function radialAxis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialAxis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialAxis_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialAxis_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialAxis_defineProperties(Constructor, staticProps); return Constructor; }

function radialAxis_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialAxis_setPrototypeOf(subClass, superClass); }

function radialAxis_setPrototypeOf(o, p) { radialAxis_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialAxis_setPrototypeOf(o, p); }

function radialAxis_createSuper(Derived) { var hasNativeReflectConstruct = radialAxis_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialAxis_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialAxis_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialAxis_possibleConstructorReturn(this, result); }; }

function radialAxis_possibleConstructorReturn(self, call) { if (call && (radialAxis_typeof(call) === "object" || typeof call === "function")) { return call; } return radialAxis_assertThisInitialized(self); }

function radialAxis_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialAxis_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radialAxis_getPrototypeOf(o) { radialAxis_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialAxis_getPrototypeOf(o); }

function radialAxis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var radialAxis_RECT_SIZE = 4;
var HALF_TICK = 5;

function hasNeedRender(index, pointOnColumn, labelInterval, innerRadius, outerRadius) {
  return !pointOnColumn && index === 0 ? false : !(index % labelInterval) && (pointOnColumn && innerRadius <= outerRadius || !pointOnColumn && innerRadius < outerRadius);
}

var RadialAxis = /*#__PURE__*/function (_Component) {
  radialAxis_inherits(RadialAxis, _Component);

  var _super = radialAxis_createSuper(RadialAxis);

  function RadialAxis() {
    var _this;

    radialAxis_classCallCheck(this, RadialAxis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "models", {
      verticalAxisLabel: [],
      circularAxisLabel: [],
      dot: [],
      line: [],
      tick: []
    });

    radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "verticalAxisTheme", void 0);

    radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "circularAxisTheme", void 0);

    return _this;
  }

  radialAxis_createClass(RadialAxis, [{
    key: "initialize",
    value: function initialize(initParam) {
      var _initParam$name;

      this.type = 'axis';
      this.name = (_initParam$name = initParam === null || initParam === void 0 ? void 0 : initParam.name) !== null && _initParam$name !== void 0 ? _initParam$name : 'radial';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          radialAxes = _ref.radialAxes,
          theme = _ref.theme,
          series = _ref.series;
      this.isShow = !isNoData(series);
      this.rect = layout.plot;

      if (!radialAxes) {
        return;
      }

      this.circularAxisTheme = theme.circularAxis;
      var circularAxis = radialAxes.circularAxis,
          verticalAxis = radialAxes.verticalAxis;

      if (verticalAxis) {
        this.verticalAxisTheme = theme.verticalAxis;
        this.models.verticalAxisLabel = this.renderVerticalAxisLabel(verticalAxis);
      }

      this.models.circularAxisLabel = this.renderCircularAxisLabel(circularAxis);

      if (this.name === 'gauge') {
        this.models.line = this.renderArcLine(circularAxis);
        this.models.tick = this.renderTick(circularAxis);
      } else {
        this.models.dot = this.renderDotModel(circularAxis);
      }
    }
  }, {
    key: "getBubbleShadowStyle",
    value: function getBubbleShadowStyle() {
      var _ref2 = this.verticalAxisTheme.label.textBubble,
          visible = _ref2.visible,
          shadowColor = _ref2.shadowColor,
          shadowOffsetX = _ref2.shadowOffsetX,
          shadowOffsetY = _ref2.shadowOffsetY,
          shadowBlur = _ref2.shadowBlur;
      return visible && shadowColor ? [{
        shadowColor: shadowColor,
        shadowOffsetX: shadowOffsetX,
        shadowOffsetY: shadowOffsetY,
        shadowBlur: shadowBlur
      }] : null;
    }
  }, {
    key: "renderVerticalAxisLabel",
    value: function renderVerticalAxisLabel(verticalAxis) {
      var _this2 = this;

      var _verticalAxis$radius = verticalAxis.radius,
          ranges = _verticalAxis$radius.ranges,
          outer = _verticalAxis$radius.outer,
          _verticalAxis$label = verticalAxis.label,
          labels = _verticalAxis$label.labels,
          interval = _verticalAxis$label.interval,
          maxWidth = _verticalAxis$label.maxWidth,
          maxHeight = _verticalAxis$label.maxHeight,
          margin = _verticalAxis$label.margin,
          align = _verticalAxis$label.align,
          start = verticalAxis.angle.start,
          pointOnColumn = verticalAxis.pointOnColumn,
          centerX = verticalAxis.centerX,
          centerY = verticalAxis.centerY,
          tickDistance = verticalAxis.tickDistance;
      var labelAdjustment = pointOnColumn ? tickDistance / 2 : 0;
      var font = getTitleFontString(this.verticalAxisTheme.label);
      var _ref3 = this.verticalAxisTheme.label.textBubble,
          textBubbleVisible = _ref3.visible,
          backgroundColor = _ref3.backgroundColor,
          borderRadius = _ref3.borderRadius,
          borderColor = _ref3.borderColor,
          borderWidth = _ref3.borderWidth,
          paddingX = _ref3.paddingX,
          paddingY = _ref3.paddingY;
      var labelPaddingX = textBubbleVisible ? paddingX : 0;
      var labelPaddingY = textBubbleVisible ? paddingY : 0;
      var width = maxWidth + labelPaddingX * 2 - margin;
      var height = maxHeight + labelPaddingY * 2;
      var fontColor = this.verticalAxisTheme.label.color;
      return ranges.reduce(function (acc, radius, index) {
        var _getRadialPosition = getRadialPosition(centerX, centerY, radius - labelAdjustment, calculateDegreeToRadian(start)),
            x = _getRadialPosition.x,
            y = _getRadialPosition.y;

        var needRender = hasNeedRender(index, pointOnColumn, interval, radius, outer);
        var posX = x + margin;
        var labelPosX = x + margin + labelPaddingX;

        if (align === 'center') {
          posX = x - margin - width / 2;
          labelPosX = x - margin;
        } else if (includes(['right', 'end'], align)) {
          posX = x - margin - width;
          labelPosX = x - margin - labelPaddingX;
        }

        return needRender ? [].concat(radialAxis_toConsumableArray(acc), [{
          type: 'bubbleLabel',
          rotationPosition: {
            x: x,
            y: y
          },
          radian: calculateDegreeToRadian(start, 0),
          bubble: {
            x: posX,
            y: y - height / 2,
            width: width,
            height: height,
            align: align,
            radius: borderRadius,
            fill: backgroundColor,
            lineWidth: borderWidth,
            strokeStyle: borderColor,
            style: _this2.getBubbleShadowStyle()
          },
          label: {
            text: labels[index],
            x: labelPosX,
            y: y,
            style: [{
              font: font,
              fillStyle: fontColor,
              textAlign: align,
              textBaseline: 'middle'
            }]
          }
        }]) : acc;
      }, []);
    }
  }, {
    key: "renderDotModel",
    value: function renderDotModel(circularAxis) {
      var _circularAxis$angle = circularAxis.angle,
          central = _circularAxis$angle.central,
          drawingStart = _circularAxis$angle.drawingStart,
          _circularAxis$label = circularAxis.label,
          labels = _circularAxis$label.labels,
          interval = _circularAxis$label.interval,
          outer = circularAxis.radius.outer,
          centerX = circularAxis.centerX,
          centerY = circularAxis.centerY,
          clockwise = circularAxis.clockwise;
      var dotColor = this.circularAxisTheme.dotColor;
      return labels.reduce(function (acc, cur, index) {
        var startDegree = drawingStart + central * index * (clockwise ? 1 : -1);

        var _getRadialPosition2 = getRadialPosition(centerX, centerY, outer, calculateDegreeToRadian(calculateValidAngle(startDegree))),
            x = _getRadialPosition2.x,
            y = _getRadialPosition2.y;

        return index % interval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [{
          type: 'rect',
          color: dotColor,
          width: radialAxis_RECT_SIZE,
          height: radialAxis_RECT_SIZE,
          x: x - radialAxis_RECT_SIZE / 2,
          y: y - radialAxis_RECT_SIZE / 2
        }]) : acc;
      }, []);
    }
  }, {
    key: "renderCircularAxisLabel",
    value: function renderCircularAxisLabel(circularAxis) {
      var centerX = circularAxis.centerX,
          centerY = circularAxis.centerY,
          clockwise = circularAxis.clockwise,
          _circularAxis$label2 = circularAxis.label,
          labels = _circularAxis$label2.labels,
          interval = _circularAxis$label2.interval,
          margin = _circularAxis$label2.margin,
          maxHeight = _circularAxis$label2.maxHeight,
          _circularAxis$angle2 = circularAxis.angle,
          drawingStart = _circularAxis$angle2.drawingStart,
          central = _circularAxis$angle2.central,
          outer = circularAxis.radius.outer;
      var radius = outer + (margin + maxHeight / 2) * (this.name === 'gauge' ? -1 : 1);
      var labelTheme = this.circularAxisTheme.label;
      var font = getTitleFontString(labelTheme);
      var degree = central * (clockwise ? 1 : -1);
      return labels.reduce(function (acc, text, index) {
        var startDegree = drawingStart + degree * index;
        var validStartAngle = calculateValidAngle(startDegree);
        return index % interval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [radialAxis_objectSpread({
          type: 'label',
          style: [{
            textAlign: 'center',
            textBaseline: 'middle',
            font: font,
            fillStyle: labelTheme.color
          }],
          text: text
        }, getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(validStartAngle)))]) : acc;
      }, []);
    }
  }, {
    key: "renderTick",
    value: function renderTick(circularAxis) {
      var centerX = circularAxis.centerX,
          centerY = circularAxis.centerY,
          tickInterval = circularAxis.tickInterval,
          clockwise = circularAxis.clockwise,
          _circularAxis$angle3 = circularAxis.angle,
          central = _circularAxis$angle3.central,
          drawingStart = _circularAxis$angle3.drawingStart,
          labels = circularAxis.label.labels,
          outer = circularAxis.radius.outer;
      var _this$circularAxisThe = this.circularAxisTheme.tick,
          strokeStyle = _this$circularAxisThe.strokeStyle,
          lineWidth = _this$circularAxisThe.lineWidth;
      return labels.reduce(function (acc, cur, index) {
        var startDegree = drawingStart + central * index * (clockwise ? 1 : -1);

        var _getRadialPosition3 = getRadialPosition(centerX, centerY, outer - HALF_TICK, calculateDegreeToRadian(calculateValidAngle(startDegree))),
            x = _getRadialPosition3.x,
            y = _getRadialPosition3.y;

        var _getRadialPosition4 = getRadialPosition(centerX, centerY, outer + HALF_TICK, calculateDegreeToRadian(calculateValidAngle(startDegree))),
            x2 = _getRadialPosition4.x,
            y2 = _getRadialPosition4.y;

        return index % tickInterval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [{
          type: 'line',
          lineWidth: lineWidth,
          strokeStyle: strokeStyle,
          x: x,
          y: y,
          x2: x2,
          y2: y2
        }]) : acc;
      }, []);
    }
  }, {
    key: "renderArcLine",
    value: function renderArcLine(circularAxis) {
      var centerX = circularAxis.centerX,
          centerY = circularAxis.centerY,
          clockwise = circularAxis.clockwise,
          _circularAxis$angle4 = circularAxis.angle,
          start = _circularAxis$angle4.start,
          end = _circularAxis$angle4.end,
          total = _circularAxis$angle4.total,
          outer = circularAxis.radius.outer;
      var _this$circularAxisThe2 = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe2.strokeStyle,
          lineWidth = _this$circularAxisThe2.lineWidth;
      return total === DEGREE_360 ? [{
        type: 'circle',
        x: centerX,
        y: centerY,
        radius: outer,
        borderWidth: lineWidth,
        borderColor: strokeStyle,
        color: 'rgba(0, 0, 0, 0)'
      }] : [{
        type: 'arc',
        borderWidth: lineWidth,
        borderColor: strokeStyle,
        x: centerX,
        y: centerY,
        angle: {
          start: start,
          end: end
        },
        drawingStartAngle: DEGREE_NEGATIVE_90,
        radius: outer,
        clockwise: clockwise
      }];
    }
  }]);

  return RadialAxis;
}(Component);


;// CONCATENATED MODULE: ./src/charts/radarChart.ts
function radarChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radarChart_typeof = function _typeof(obj) { return typeof obj; }; } else { radarChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radarChart_typeof(obj); }


















function radarChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radarChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radarChart_ownKeys(Object(source), true).forEach(function (key) { radarChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radarChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radarChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function radarChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radarChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radarChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) radarChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) radarChart_defineProperties(Constructor, staticProps); return Constructor; }

function radarChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { radarChart_get = Reflect.get; } else { radarChart_get = function _get(target, property, receiver) { var base = radarChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return radarChart_get(target, property, receiver || target); }

function radarChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = radarChart_getPrototypeOf(object); if (object === null) break; } return object; }

function radarChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radarChart_setPrototypeOf(subClass, superClass); }

function radarChart_setPrototypeOf(o, p) { radarChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radarChart_setPrototypeOf(o, p); }

function radarChart_createSuper(Derived) { var hasNativeReflectConstruct = radarChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radarChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radarChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radarChart_possibleConstructorReturn(this, result); }; }

function radarChart_possibleConstructorReturn(self, call) { if (call && (radarChart_typeof(call) === "object" || typeof call === "function")) { return call; } return radarChart_assertThisInitialized(self); }

function radarChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radarChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radarChart_getPrototypeOf(o) { radarChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radarChart_getPrototypeOf(o); }
























/**
 * @class
 * @classdesc Radar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Radar Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Radar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.showArea=false] - Whether to fill area or not.
 *     @param {Object} [props.options.circularAxis]
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *     @param {Object} [props.options.verticalAxis]
 *       @param {Object} [props.options.verticalAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.verticalAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.verticalAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.type] - Radar plot type. 'spiderweb', 'circle' is available.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Radar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.verticalAxis] - Vertical Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var RadarChart = /*#__PURE__*/function (_Chart) {
  radarChart_inherits(RadarChart, _Chart);

  var _super = radarChart_createSuper(RadarChart);

  function RadarChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    radarChart_classCallCheck(this, RadarChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        radar: data.series
      },
      categories: data.categories,
      modules: [store_dataRange, store_scale, radialAxes]
    });
  }

  radarChart_createClass(RadarChart, [{
    key: "initialize",
    value: function initialize() {
      radarChart_get(radarChart_getPrototypeOf(RadarChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Legend);
      this.componentManager.add(RadarPlot);
      this.componentManager.add(RadialAxis);
      this.componentManager.add(RadarSeries);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, polygon_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          radar: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', radarChart_objectSpread(radarChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return RadarChart;
}(Chart);


;// CONCATENATED MODULE: ./src/helpers/squarifier.ts
function squarifier_toConsumableArray(arr) { return squarifier_arrayWithoutHoles(arr) || squarifier_iterableToArray(arr) || squarifier_unsupportedIterableToArray(arr) || squarifier_nonIterableSpread(); }

function squarifier_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function squarifier_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return squarifier_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return squarifier_arrayLikeToArray(o, minLen); }

function squarifier_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function squarifier_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return squarifier_arrayLikeToArray(arr); }

function squarifier_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
















function calculateScale(values, width, height) {
  return width * height / calculator_sum(values);
}

function isVerticalStack(_ref) {
  var height = _ref.height,
      width = _ref.width;
  return height < width;
}

function selectBaseSize(baseBound) {
  return isVerticalStack(baseBound) ? baseBound.height : baseBound.width;
}

function makeBaseData(seriesItems, baseBound) {
  var width = baseBound.width,
      height = baseBound.height;
  var scale = calculateScale(pluck(seriesItems, 'data'), width, height);
  return seriesItems.map(function (seriesItem) {
    return {
      id: seriesItem.id,
      weight: seriesItem.data * scale
    };
  }).sort(function (a, b) {
    return b.weight - a.weight;
  });
}
/**
 * Calculate worst aspect ratio.
 * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf
 */


function worst(total, min, max, baseSize) {
  var sumSquare = total * total;
  var sizeSquare = baseSize * baseSize;
  return Math.max(sizeSquare * max / sumSquare, sumSquare / (sizeSquare * min));
}

function changedStackDirection(total, weights, baseSize, newWeight) {
  var minWeight = Math.min.apply(Math, squarifier_toConsumableArray(weights));
  var maxWeight = Math.max.apply(Math, squarifier_toConsumableArray(weights));
  var beforeWorst = worst(total, minWeight, maxWeight, baseSize);
  var newWorst = worst(total + newWeight, Math.min(minWeight, newWeight), Math.max(maxWeight, newWeight), baseSize);
  return newWorst >= beforeWorst;
}

function calculateFixedSize(baseSize, total, rows) {
  if (!total) {
    var weights = pluck(rows, 'weight');
    total = calculator_sum(weights);
  }

  return total / baseSize;
}

function addBounds(startPosition, rows, fixedSize, callback) {
  rows.reduce(function (storedPosition, rowDatum) {
    var dynamicSize = rowDatum.weight / fixedSize;
    callback(dynamicSize, storedPosition, rowDatum.id);
    return storedPosition + dynamicSize;
  }, startPosition);
}

function addBound(boundMap, id, rect) {
  boundMap[id] = rect;
}

function addBoundsForVerticalStack(boundMap, rows, baseBound, baseSize, total) {
  var fixedWidth = calculateFixedSize(baseSize, total, rows);
  addBounds(baseBound.y, rows, fixedWidth, function (dynamicHeight, storedTop, id) {
    addBound(boundMap, id, {
      x: baseBound.x,
      y: storedTop,
      width: fixedWidth,
      height: dynamicHeight
    });
  });
  baseBound.x += fixedWidth;
  baseBound.width -= fixedWidth;
}

function addBoundsForHorizontalStack(boundMap, rows, baseBound, baseSize, total) {
  var fixedHeight = calculateFixedSize(baseSize, total, rows);
  addBounds(baseBound.x, rows, fixedHeight, function (dynamicWidth, storedLeft, id) {
    addBound(boundMap, id, {
      x: storedLeft,
      y: baseBound.y,
      width: dynamicWidth,
      height: fixedHeight
    });
  });
  baseBound.y += fixedHeight;
  baseBound.height -= fixedHeight;
}

function getAddingBoundsFunction(baseBound) {
  if (isVerticalStack(baseBound)) {
    return addBoundsForVerticalStack;
  }

  return addBoundsForHorizontalStack;
}

function squarify(layout, seriesItems) {
  var baseBound = layout;
  var baseData = makeBaseData(seriesItems, baseBound);
  var row = [];
  var baseSize, addBoundsFunc;
  var boundMap = {};
  baseData.forEach(function (datum) {
    var weights = pluck(row, 'weight');
    var totalWeight = calculator_sum(weights);

    if (row.length && changedStackDirection(totalWeight, weights, baseSize, datum.weight)) {
      addBoundsFunc(boundMap, row, baseBound, baseSize, totalWeight);
      row = [];
    }

    if (!row.length) {
      baseSize = selectBaseSize(baseBound);
      addBoundsFunc = getAddingBoundsFunction(baseBound);
    }

    row.push(datum);
  });

  if (row.length) {
    addBoundsFunc(boundMap, row, baseBound, baseSize);
  }

  return boundMap;
}
;// CONCATENATED MODULE: ./src/component/treemapSeries.ts
function treemapSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { treemapSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { treemapSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return treemapSeries_typeof(obj); }

function treemapSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function treemapSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { treemapSeries_ownKeys(Object(source), true).forEach(function (key) { treemapSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { treemapSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function treemapSeries_toConsumableArray(arr) { return treemapSeries_arrayWithoutHoles(arr) || treemapSeries_iterableToArray(arr) || treemapSeries_unsupportedIterableToArray(arr) || treemapSeries_nonIterableSpread(); }

function treemapSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function treemapSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return treemapSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return treemapSeries_arrayLikeToArray(o, minLen); }

function treemapSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function treemapSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return treemapSeries_arrayLikeToArray(arr); }

function treemapSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

























function treemapSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function treemapSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function treemapSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) treemapSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) treemapSeries_defineProperties(Constructor, staticProps); return Constructor; }

function treemapSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) treemapSeries_setPrototypeOf(subClass, superClass); }

function treemapSeries_setPrototypeOf(o, p) { treemapSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return treemapSeries_setPrototypeOf(o, p); }

function treemapSeries_createSuper(Derived) { var hasNativeReflectConstruct = treemapSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = treemapSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = treemapSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return treemapSeries_possibleConstructorReturn(this, result); }; }

function treemapSeries_possibleConstructorReturn(self, call) { if (call && (treemapSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return treemapSeries_assertThisInitialized(self); }

function treemapSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function treemapSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function treemapSeries_getPrototypeOf(o) { treemapSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return treemapSeries_getPrototypeOf(o); }

function treemapSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











var TreemapSeries = /*#__PURE__*/function (_Component) {
  treemapSeries_inherits(TreemapSeries, _Component);

  var _super = treemapSeries_createSuper(TreemapSeries);

  function TreemapSeries() {
    var _this;

    treemapSeries_classCallCheck(this, TreemapSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "models", {
      series: [],
      layer: []
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "responders", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "theme", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "activatedResponders", []);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "zoomable", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.emitMouseEvent([]);
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var seriesIndex = _ref.seriesIndex;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var model = _this.responders.find(function (_ref2) {
        var indexes = _ref2.indexes;
        return last(indexes) === seriesIndex;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var models = _this.getRespondersWithTheme([model], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var seriesIndex = _ref3.seriesIndex;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var model = _this.responders.find(function (_ref4) {
        var indexes = _ref4.indexes;
        return last(indexes) === seriesIndex;
      });

      if (model) {
        _this.emitMouseEvent([model]);
      }
    });

    return _this;
  }

  treemapSeries_createClass(TreemapSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'treemap';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "getAllChildSeries",
    value: function getAllChildSeries(series, parentId) {
      var _this2 = this;

      var allChildSeries = [];
      series.forEach(function (data) {
        if (data.parentId === parentId) {
          allChildSeries.push(data);

          if (data.hasChild) {
            var res = _this2.getAllChildSeries(series, data.id);

            allChildSeries.push.apply(allChildSeries, treemapSeries_toConsumableArray(res));
          }
        }
      });
      return allChildSeries;
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _options$series$zooma, _options$series;

      var layout = chartState.layout,
          treemapSeries = chartState.treemapSeries,
          colorValueScale = chartState.colorValueScale,
          options = chartState.options,
          theme = chartState.theme,
          treemapZoomId = chartState.treemapZoomId;

      if (!treemapSeries) {
        throw new Error(message.noDataError(this.name));
      }

      var currentTreemapZoomId = treemapZoomId.cur;
      var series = this.getAllChildSeries(treemapSeries, currentTreemapZoomId);
      this.theme = theme.series.treemap;
      this.rect = layout.plot;
      this.selectable = this.getSelectableOption(options);
      this.models = this.renderTreemapSeries(series, options, colorValueScale, currentTreemapZoomId);
      this.zoomable = (_options$series$zooma = (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.zoomable) !== null && _options$series$zooma !== void 0 ? _options$series$zooma : false;

      if (getDataLabelsOptions(options, this.name).visible) {
        var _options$series$dataL, _options$series2, _options$series2$data;

        var useTreemapLeaf = (_options$series$dataL = (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : _options$series2$data.useTreemapLeaf) !== null && _options$series$dataL !== void 0 ? _options$series$dataL : false;
        var dataLabelModel = this.makeDataLabel(useTreemapLeaf, currentTreemapZoomId);
        this.renderDataLabels(dataLabelModel);
      }

      this.responders = this.makeTreemapSeriesResponder(currentTreemapZoomId);
    }
  }, {
    key: "makeTreemapSeriesResponder",
    value: function makeTreemapSeriesResponder(treemapCurrentDepthParentId) {
      var tooltipData = this.makeTooltipData();
      var series = this.models.series;

      if (this.zoomable) {
        series = series.filter(function (_ref5) {
          var parentId = _ref5.parentId;
          return parentId === treemapCurrentDepthParentId;
        });
      }

      return series.map(function (m, idx) {
        return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
          data: tooltipData[idx],
          thickness: boxDefault.HOVER_THICKNESS,
          style: ['shadow']
        });
      });
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData() {
      return this.models.series.map(function (_ref6) {
        var label = _ref6.label,
            data = _ref6.data,
            color = _ref6.color;
        return {
          label: label,
          color: color,
          value: data
        };
      });
    }
  }, {
    key: "makeBoundMap",
    value: function makeBoundMap(series, parentId, layout) {
      var _this3 = this;

      var boundMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var seriesItems = series.filter(function (item) {
        return item.parentId === parentId;
      });
      boundMap = treemapSeries_objectSpread(treemapSeries_objectSpread({}, boundMap), squarify(treemapSeries_objectSpread({}, layout), seriesItems));
      seriesItems.forEach(function (seriesItem) {
        boundMap = _this3.makeBoundMap(series, seriesItem.id, boundMap[seriesItem.id], boundMap);
      });
      return boundMap;
    }
  }, {
    key: "makeDataLabel",
    value: function makeDataLabel(useTreemapLeaf, treemapCurrentDepthParentId) {
      var series = useTreemapLeaf ? this.models.series.filter(function (_ref7) {
        var hasChild = _ref7.hasChild;
        return !hasChild;
      }) : this.models.series.filter(function (_ref8) {
        var parentId = _ref8.parentId;
        return parentId === treemapCurrentDepthParentId;
      });
      var dataLabelTheme = this.theme.dataLabels;
      return series.map(function (m) {
        return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
          type: 'treemapSeriesName',
          value: m.label,
          direction: 'left',
          plot: {
            x: 0,
            y: 0,
            size: 0
          },
          theme: treemapSeries_objectSpread(treemapSeries_objectSpread({}, dataLabelTheme), {}, {
            color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color
          })
        });
      });
    }
  }, {
    key: "getColor",
    value: function getColor(treemapSeries, colors) {
      var indexes = treemapSeries.indexes;
      var colorIdx = first(indexes);
      return colors[colorIdx];
    }
  }, {
    key: "getOpacity",
    value: function getOpacity(treemapSeries) {
      var indexes = treemapSeries.indexes,
          depth = treemapSeries.depth;
      var idx = last(indexes);
      return indexes.length === 1 ? 0 : Number((0.1 * depth + 0.05 * idx).toFixed(2));
    }
  }, {
    key: "renderTreemapSeries",
    value: function renderTreemapSeries(seriesData, options, colorValueScale, treemapCurrentDepthParentId) {
      var _options$series$useCo,
          _options$series3,
          _this4 = this,
          _options$series4;

      var layer = [];
      var boundMap = this.makeBoundMap(seriesData, treemapCurrentDepthParentId, treemapSeries_objectSpread(treemapSeries_objectSpread({}, this.rect), {}, {
        x: 0,
        y: 0
      }));
      var _this$theme = this.theme,
          colors = _this$theme.colors,
          startColor = _this$theme.startColor,
          endColor = _this$theme.endColor,
          borderWidth = _this$theme.borderWidth,
          borderColor = _this$theme.borderColor;
      var startRGB, distances;
      var useColorValue = (_options$series$useCo = (_options$series3 = options.series) === null || _options$series3 === void 0 ? void 0 : _options$series3.useColorValue) !== null && _options$series$useCo !== void 0 ? _options$series$useCo : false;

      if (useColorValue && startColor && endColor) {
        startRGB = hexToRGB(startColor);
        distances = makeDistances(startRGB, hexToRGB(endColor));
      }

      var series = Object.keys(boundMap).map(function (id) {
        var treemapSeries = seriesData.find(function (item) {
          return item.id === id;
        });
        var colorRatio;

        if (useColorValue) {
          colorRatio = getColorRatio(colorValueScale.limit, treemapSeries.colorValue);
        }

        return treemapSeries_objectSpread(treemapSeries_objectSpread(treemapSeries_objectSpread({}, treemapSeries), boundMap[id]), {}, {
          type: 'rect',
          colorRatio: colorRatio,
          color: useColorValue ? getSpectrumColor(colorRatio, distances, startRGB) : _this4.getColor(treemapSeries, colors),
          opacity: useColorValue ? 0 : _this4.getOpacity(treemapSeries),
          thickness: borderWidth,
          borderColor: borderColor
        });
      });

      if (!((_options$series4 = options.series) !== null && _options$series4 !== void 0 && _options$series4.useColorValue)) {
        layer = series.map(function (m) {
          return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
            color: getRGBA('#000000', m.opacity)
          });
        });
      }

      return {
        series: series,
        layer: layer
      };
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this5 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, treemapSeries_objectSpread(treemapSeries_objectSpread({}, _this5.theme[type]), {}, {
          style: ['shadow']
        }));
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders;

      if (responders.length) {
        if (this.zoomable) {
          var _responders$ = responders[0],
              id = _responders$.id,
              hasChild = _responders$.hasChild;

          if (hasChild) {
            this.emitMouseEvent([]);
            this.store.dispatch('setTreemapZoomId', id);
            this.eventBus.emit('resetSelectedSeries');
          } else if (this.selectable) {
            this.eventBus.emit('renderSelectedSeries', {
              models: this.getRespondersWithTheme(responders, 'select'),
              name: this.name
            });
          }
        } else if (this.selectable) {
          var deepestNode = getDeepestNode(responders);
          this.eventBus.emit('renderSelectedSeries', {
            models: this.getRespondersWithTheme(deepestNode, 'select'),
            name: this.name
          });
        }
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref10) {
      var responders = _ref10.responders;
      var deepestNode = getDeepestNode(responders);
      this.activatedResponders = deepestNode;
      this.emitMouseEvent(deepestNode);
    }
  }, {
    key: "emitMouseEvent",
    value: function emitMouseEvent(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.eventBus.emit('seriesPointHovered', {
        models: responders,
        name: this.name
      });
      this.eventBus.emit('renderSpectrumTooltip', responders);
      this.eventBus.emit('needDraw');
    }
  }]);

  return TreemapSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/backButton.ts
function backButton_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { backButton_typeof = function _typeof(obj) { return typeof obj; }; } else { backButton_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return backButton_typeof(obj); }














function backButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function backButton_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function backButton_createClass(Constructor, protoProps, staticProps) { if (protoProps) backButton_defineProperties(Constructor.prototype, protoProps); if (staticProps) backButton_defineProperties(Constructor, staticProps); return Constructor; }

function backButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) backButton_setPrototypeOf(subClass, superClass); }

function backButton_setPrototypeOf(o, p) { backButton_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return backButton_setPrototypeOf(o, p); }

function backButton_createSuper(Derived) { var hasNativeReflectConstruct = backButton_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = backButton_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = backButton_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return backButton_possibleConstructorReturn(this, result); }; }

function backButton_possibleConstructorReturn(self, call) { if (call && (backButton_typeof(call) === "object" || typeof call === "function")) { return call; } return backButton_assertThisInitialized(self); }

function backButton_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function backButton_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function backButton_getPrototypeOf(o) { backButton_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return backButton_getPrototypeOf(o); }

function backButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var BackButton = /*#__PURE__*/function (_Component) {
  backButton_inherits(BackButton, _Component);

  var _super = backButton_createSuper(BackButton);

  function BackButton() {
    var _this;

    backButton_classCallCheck(this, BackButton);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    backButton_defineProperty(backButton_assertThisInitialized(_this), "responders", void 0);

    backButton_defineProperty(backButton_assertThisInitialized(_this), "models", void 0);

    return _this;
  }

  backButton_createClass(BackButton, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'backButton';
      this.name = 'backButton';
    }
  }, {
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        this.store.dispatch('zoomBack');
        this.eventBus.emit('resetSelectedSeries');
      }
    }
  }, {
    key: "render",
    value: function render(_ref2, computed) {
      var options = _ref2.options,
          layout = _ref2.layout;

      if (!isUsingResetButton(options)) {
        return;
      }

      this.rect = layout.resetButton;
      this.isShow = computed.isTreemapSeriesZooming;
      this.models = this.isShow ? [{
        type: 'backButton',
        x: 0,
        y: 0
      }] : [];
      this.responders = this.isShow ? [{
        type: 'rect',
        x: 0,
        y: 0,
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE
      }] : [];
    }
  }]);

  return BackButton;
}(Component);


;// CONCATENATED MODULE: ./src/charts/treemapChart.ts
function treemapChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { treemapChart_typeof = function _typeof(obj) { return typeof obj; }; } else { treemapChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return treemapChart_typeof(obj); }


















function treemapChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function treemapChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { treemapChart_ownKeys(Object(source), true).forEach(function (key) { treemapChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { treemapChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function treemapChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function treemapChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function treemapChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function treemapChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) treemapChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) treemapChart_defineProperties(Constructor, staticProps); return Constructor; }

function treemapChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { treemapChart_get = Reflect.get; } else { treemapChart_get = function _get(target, property, receiver) { var base = treemapChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return treemapChart_get(target, property, receiver || target); }

function treemapChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = treemapChart_getPrototypeOf(object); if (object === null) break; } return object; }

function treemapChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) treemapChart_setPrototypeOf(subClass, superClass); }

function treemapChart_setPrototypeOf(o, p) { treemapChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return treemapChart_setPrototypeOf(o, p); }

function treemapChart_createSuper(Derived) { var hasNativeReflectConstruct = treemapChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = treemapChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = treemapChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return treemapChart_possibleConstructorReturn(this, result); }; }

function treemapChart_possibleConstructorReturn(self, call) { if (call && (treemapChart_typeof(call) === "object" || typeof call === "function")) { return call; } return treemapChart_assertThisInitialized(self); }

function treemapChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function treemapChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function treemapChart_getPrototypeOf(o) { treemapChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return treemapChart_getPrototypeOf(o); }























/**
 * @class
 * @classdesc Treemap Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Treemap Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.label - Data name.
 *       @param {number} [props.data.series.data] - data value.
 *       @param {number} [props.data.series.colorValue] - color value. If you use the useColorValue option, the color is painted based on this value.
 *       @param {Array<Object>} [props.data.series.children] - Child element value.
 *   @param {Object} [props.options] - Options for making Treemap Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.useColorValue] - Whether to use color value or not.
 *       @param {boolean} [props.options.series.zoomable] - Whether to use zoom feature or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {boolean} [props.options.legend.visible=false] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Treemap Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var TreemapChart = /*#__PURE__*/function (_Chart) {
  treemapChart_inherits(TreemapChart, _Chart);

  var _super = treemapChart_createSuper(TreemapChart);

  function TreemapChart(props) {
    treemapChart_classCallCheck(this, TreemapChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        treemap: props.data.series
      },
      modules: [store_treemapSeriesData, store_colorValueScale]
    });
  }

  treemapChart_createClass(TreemapChart, [{
    key: "initialize",
    value: function initialize() {
      treemapChart_get(treemapChart_getPrototypeOf(TreemapChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(SpectrumLegend);
      this.componentManager.add(TreemapSeries);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(BackButton);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, spectrumLegend_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   label: 'Documents',
     *   children: [
     *     {label: 'A', data: 20},
     *     {label: 'B', data: 40},
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addTreemapSeries', treemapChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData(
     *   series: [
     *     {
     *       label: 'Documents',
     *       children: [
     *         {label: 'A', data: 20},
     *         {label: 'B', data: 40},
     *       ],
     *     },
     *     {
     *       label: 'Documents',
     *       data: 30,
     *     }
     *   ]
     * );
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          treemap: data.series
        }
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', treemapChart_objectSpread(treemapChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return TreemapChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/boxPlotSeries.ts
function boxPlotSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxPlotSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxPlotSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxPlotSeries_typeof(obj); }

function boxPlotSeries_toConsumableArray(arr) { return boxPlotSeries_arrayWithoutHoles(arr) || boxPlotSeries_iterableToArray(arr) || boxPlotSeries_unsupportedIterableToArray(arr) || boxPlotSeries_nonIterableSpread(); }

function boxPlotSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxPlotSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function boxPlotSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxPlotSeries_arrayLikeToArray(arr); }

function boxPlotSeries_slicedToArray(arr, i) { return boxPlotSeries_arrayWithHoles(arr) || boxPlotSeries_iterableToArrayLimit(arr, i) || boxPlotSeries_unsupportedIterableToArray(arr, i) || boxPlotSeries_nonIterableRest(); }

function boxPlotSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxPlotSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxPlotSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxPlotSeries_arrayLikeToArray(o, minLen); }

function boxPlotSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxPlotSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxPlotSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function boxPlotSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxPlotSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlotSeries_ownKeys(Object(source), true).forEach(function (key) { boxPlotSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlotSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }























function boxPlotSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxPlotSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxPlotSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxPlotSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxPlotSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxPlotSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxPlotSeries_setPrototypeOf(subClass, superClass); }

function boxPlotSeries_setPrototypeOf(o, p) { boxPlotSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxPlotSeries_setPrototypeOf(o, p); }

function boxPlotSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxPlotSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxPlotSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxPlotSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxPlotSeries_possibleConstructorReturn(this, result); }; }

function boxPlotSeries_possibleConstructorReturn(self, call) { if (call && (boxPlotSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxPlotSeries_assertThisInitialized(self); }

function boxPlotSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxPlotSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function boxPlotSeries_getPrototypeOf(o) { boxPlotSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxPlotSeries_getPrototypeOf(o); }

function boxPlotSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var MIN_BAR_WIDTH = 5;

function getPadding(tickDistance, barWidth, seriesLength) {
  return (tickDistance - barWidth * seriesLength) / (seriesLength + 1);
}

function getDefaultColor(defaultColor, color) {
  return color !== null && color !== void 0 ? color : defaultColor;
}

var BoxPlotSeries = /*#__PURE__*/function (_Component) {
  boxPlotSeries_inherits(BoxPlotSeries, _Component);

  var _super = boxPlotSeries_createSuper(BoxPlotSeries);

  function BoxPlotSeries() {
    var _this;

    boxPlotSeries_classCallCheck(this, BoxPlotSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "models", {
      rect: [],
      line: [],
      circle: []
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "drawModels", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "responders", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "activatedResponders", []);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "theme", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.boxPlot[seriesIndex].name;

      var models = _this.getRespondersWithTheme(_this.tooltipRectMap["".concat(name, "-").concat(index)], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "showTooltip", function (_ref2) {
      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.boxPlot[seriesIndex].name;

      var models = _this.getRespondersWithTheme(_this.tooltipRectMap["".concat(name, "-").concat(index)], 'hover');

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxPlotSeries_createClass(BoxPlotSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'boxPlot';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series;

      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          scale = state.scale,
          legend = state.legend,
          options = state.options,
          theme = state.theme;

      if (!series.boxPlot) {
        throw new Error(message.noDataError(this.name));
      }

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      this.theme = theme.series.boxPlot;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var categories = state.categories;
      var tickDistance = axes.xAxis.tickDistance;
      var _limit = scale.yAxis.limit,
          min = _limit.min,
          max = _limit.max;
      var boxPlotData = series.boxPlot.data;
      var seriesLength = boxPlotData.length;

      var renderOptions = boxPlotSeries_objectSpread({
        ratio: this.rect.height / (max - min),
        tickDistance: tickDistance
      }, this.getBarWidths(tickDistance, seriesLength));

      var boxPlotModelData = this.makeBoxPlots(boxPlotData, renderOptions);
      var seriesModels = this.renderSeriesModels(boxPlotModelData);
      this.models = seriesModels;

      if (!this.drawModels) {
        this.drawModels = {
          rect: seriesModels.rect.map(function (m) {
            return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
              y: m.y + m.height,
              height: 0
            });
          }),
          line: seriesModels.line,
          circle: seriesModels.circle
        };
      }

      var tooltipData = this.makeTooltipModel(boxPlotData, categories);
      this.tooltipRectMap = this.makeTooltipRectMap(boxPlotModelData, tooltipData);
      this.responders = this.eventDetectType === 'grouped' ? this.makeGroupedResponderModel(boxPlotModelData) : this.makeDefaultResponderModel(boxPlotModelData, tooltipData);
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(boxPlotModelData, tooltipData) {
      var _this2 = this;

      var result = {};
      boxPlotModelData.forEach(function (m, tooltipIndex) {
        if (!isNull(m)) {
          var propName = "".concat(m.name, "-").concat(m.index);

          if (!result[propName]) {
            result[propName] = [];
          }

          result[propName].push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, _this2.makeHoveredModel(m)), {}, {
            data: tooltipData[tooltipIndex]
          }));
        }
      });
      return result;
    }
  }, {
    key: "makeGroupedResponderModel",
    value: function makeGroupedResponderModel(boxPlotModelData) {
      var _this3 = this;

      var result = [];
      boxPlotModelData.forEach(function (m) {
        var type = m.type,
            index = m.index,
            name = m.name;
        var propName = "".concat(name, "-").concat(index);

        if (type === 'boxPlot' && !result[propName]) {
          var _ref3 = m,
              boxPlotDetection = _ref3.boxPlotDetection;
          result.push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({
            type: 'rect',
            name: propName
          }, boxPlotDetection), {}, {
            y: 0,
            height: _this3.rect.height
          }));
        }
      });
      return result;
    }
  }, {
    key: "makeDefaultResponderModel",
    value: function makeDefaultResponderModel(boxPlotModelData, tooltipDataArr) {
      var _this4 = this;

      return boxPlotModelData.map(function (m, index) {
        return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, _this4.makeHoveredModel(m)), {}, {
          data: tooltipDataArr[index],
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "makeHoveredModel",
    value: function makeHoveredModel(model) {
      var point = model.type === 'boxPlot' && model.rect ? {
        x: model.rect.x,
        y: model.rect.y
      } : {
        x: model.x,
        y: model.y
      };

      var hoveredModel = boxPlotSeries_objectSpread({}, model);

      if (model.type === 'boxPlot') {
        ['lowerWhisker', 'upperWhisker', 'maximum', 'minimum', 'median'].forEach(function (prop) {
          if (model[prop]) {
            model[prop].detectionSize = 3;
          }
        });
        model.color = getRGBA(hoveredModel.color, 1);
      }

      return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, hoveredModel), point);
    }
  }, {
    key: "getResponderModelFromMap",
    value: function getResponderModelFromMap(responders) {
      if (!responders.length) {
        return [];
      }

      var propName = responders[0].name;
      return this.tooltipRectMap[propName];
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders;

      if (this.eventDetectType === 'grouped') {
        var models = this.getResponderModelFromMap(responders);
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(models, 'select'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = models;
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = responders;
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref5) {
      var responders = _ref5.responders;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'grouped') {
          models = this.getRespondersWithTheme(this.getResponderModelFromMap(responders), 'select');
        } else {
          models = this.getRespondersWithTheme(responders, 'select');
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "renderSeriesModels",
    value: function renderSeriesModels(boxPlots) {
      return boxPlots.reduce(function (acc, cur) {
        var type = cur.type,
            name = cur.name;

        if (type === 'boxPlot') {
          acc.rect.push(boxPlotSeries_objectSpread({
            name: name
          }, cur.rect));
          ['maximum', 'minimum', 'median', 'upperWhisker', 'lowerWhisker'].forEach(function (prop) {
            acc.line.push(boxPlotSeries_objectSpread({
              name: name
            }, cur[prop]));
          });
        } else {
          acc.circle.push(boxPlotSeries_objectSpread({}, cur));
        }

        return acc;
      }, {
        rect: [],
        line: [],
        circle: []
      });
    }
  }, {
    key: "makeBoxPlots",
    value: function makeBoxPlots(seriesData, renderOptions) {
      var _this5 = this;

      var ratio = renderOptions.ratio,
          barWidth = renderOptions.barWidth;
      var boxPlotModels = [];
      var seriesLength = seriesData.length;
      var dot = this.theme.dot;
      seriesData.forEach(function (_ref6, seriesIndex) {
        var outliers = _ref6.outliers,
            data = _ref6.data,
            name = _ref6.name,
            color = _ref6.color;

        var seriesColor = _this5.getSeriesColor(name, color);

        (data !== null && data !== void 0 ? data : []).forEach(function (datum, dataIndex) {
          if (!isNull(datum)) {
            var startX = _this5.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);

            var rect = _this5.getRect(datum, startX, seriesColor, renderOptions);

            boxPlotModels.push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({
              type: 'boxPlot',
              color: seriesColor,
              name: name,
              rect: rect,
              median: _this5.getMedian(datum, startX, seriesColor, renderOptions),
              minimum: _this5.getMinimum(datum, startX, seriesColor, renderOptions),
              maximum: _this5.getMaximum(datum, startX, seriesColor, renderOptions)
            }, _this5.getWhisker(datum, startX, seriesColor, renderOptions, rect)), {}, {
              index: dataIndex,
              boxPlotDetection: {
                x: startX,
                width: barWidth
              }
            }));
          }
        });
        var _ref7 = dot,
            dotColor = _ref7.color,
            radius = _ref7.radius,
            borderColor = _ref7.borderColor,
            borderWidth = _ref7.borderWidth,
            useSeriesColor = _ref7.useSeriesColor;
        (outliers !== null && outliers !== void 0 ? outliers : []).forEach(function (datum) {
          var _datum = boxPlotSeries_slicedToArray(datum, 2),
              dataIndex = _datum[0],
              value = _datum[1];

          var startX = _this5.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);

          boxPlotModels.push({
            type: 'circle',
            name: name,
            x: startX + barWidth / 2,
            y: _this5.getYPos(value, ratio),
            radius: radius,
            style: [{
              strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : seriesColor,
              lineWidth: borderWidth
            }],
            color: useSeriesColor ? seriesColor : dotColor,
            index: dataIndex
          });
        });
      });
      return boxPlotModels;
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(seriesData, categories) {
      var tooltipData = [];
      seriesData.forEach(function (_ref8) {
        var outliers = _ref8.outliers,
            data = _ref8.data,
            name = _ref8.name,
            color = _ref8.color;
        (data !== null && data !== void 0 ? data : []).forEach(function (datum, dataIndex) {
          if (!isNull(datum)) {
            var boxPlotData = boxPlotSeries_toConsumableArray(datum).reverse();

            tooltipData.push({
              label: name,
              color: color,
              value: ['Maximum', 'Upper Quartile', 'Median', 'Lower Quartile', 'Minimum'].reduce(function (acc, title, index) {
                var value = boxPlotData[index];
                return isNull(value) ? acc : [].concat(boxPlotSeries_toConsumableArray(acc), [{
                  title: title,
                  value: value
                }]);
              }, []),
              category: categories[dataIndex],
              templateType: 'boxPlot'
            });
          }
        });
        (outliers !== null && outliers !== void 0 ? outliers : []).forEach(function (datum) {
          if (!isNull(datum)) {
            var _datum2 = boxPlotSeries_slicedToArray(datum, 2),
                dataIndex = _datum2[0],
                dataValue = _datum2[1];

            tooltipData.push({
              label: name,
              color: color,
              value: [{
                title: 'Outlier',
                value: dataValue
              }],
              category: categories[dataIndex],
              templateType: 'boxPlot'
            });
          }
        });
      });
      return tooltipData;
    }
  }, {
    key: "getStartX",
    value: function getStartX(seriesIndex, dataIndex, renderOptions, seriesLength) {
      var tickDistance = renderOptions.tickDistance,
          barWidth = renderOptions.barWidth;
      var padding = getPadding(tickDistance, barWidth, seriesLength);
      return dataIndex * tickDistance + (seriesIndex + 1) * padding + barWidth * seriesIndex;
    }
  }, {
    key: "getYPos",
    value: function getYPos(value, ratio, lineWidth) {
      return isNumber(lineWidth) ? crispPixel(this.rect.height - value * ratio, lineWidth) : this.rect.height - value * ratio;
    }
  }, {
    key: "getBarWidths",
    value: function getBarWidths(tickDistance, seriesLength) {
      var _this$theme = this.theme,
          barThemeWidth = _this$theme.barWidth,
          barWidthRatios = _this$theme.barWidthRatios;
      var barRatio = barWidthRatios.barRatio,
          minMaxBarRatio = barWidthRatios.minMaxBarRatio;
      var defaultBarWidth = Math.max((tickDistance - getBoxTypeSeriesPadding(tickDistance) * (2 + (seriesLength - 1))) / seriesLength, MIN_BAR_WIDTH);
      var barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance / seriesLength, barThemeWidth) : defaultBarWidth;
      return {
        barWidth: barWidth * barRatio,
        minMaxBarWidth: barWidth * minMaxBarRatio
      };
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          rect = _this$theme$type.rect,
          dot = _this$theme$type.dot,
          line = _this$theme$type.line,
          shadowColor = _this$theme$type.shadowColor,
          shadowOffsetX = _this$theme$type.shadowOffsetX,
          shadowOffsetY = _this$theme$type.shadowOffsetY,
          shadowBlur = _this$theme$type.shadowBlur;
      var _ref9 = line,
          whisker = _ref9.whisker,
          median = _ref9.median,
          maximum = _ref9.maximum,
          minimum = _ref9.minimum;
      var _ref10 = dot,
          dotColor = _ref10.color,
          radius = _ref10.radius,
          borderColor = _ref10.borderColor,
          borderWidth = _ref10.borderWidth,
          useSeriesColor = _ref10.useSeriesColor;
      return responders.map(function (m) {
        var modelType = m.type,
            data = m.data;
        var seriesColor = m.color;
        var model;

        if (modelType === 'circle') {
          seriesColor = data.color;
          model = boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
            radius: radius,
            color: useSeriesColor ? seriesColor : dotColor,
            style: [{
              strokeStyle: getDefaultColor(seriesColor, borderColor),
              lineWidth: borderWidth
            }]
          });
        } else {
          var _ref11 = m,
              seriesRect = _ref11.rect,
              upperWhisker = _ref11.upperWhisker,
              lowerWhisker = _ref11.lowerWhisker,
              seriesMedian = _ref11.median,
              seriesMaximum = _ref11.maximum,
              seriesMinimum = _ref11.minimum;
          model = boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
            rect: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesRect), {}, {
              color: color !== null && color !== void 0 ? color : getRGBA(seriesColor, 1),
              thickness: rect.borderWidth,
              borderColor: rect.borderColor,
              style: [{
                shadowColor: shadowColor,
                shadowOffsetX: shadowOffsetX,
                shadowOffsetY: shadowOffsetY,
                shadowBlur: shadowBlur
              }]
            }),
            upperWhisker: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, upperWhisker), {}, {
              strokeStyle: getDefaultColor(seriesColor, whisker.color),
              lineWidth: whisker.lineWidth
            }),
            lowerWhisker: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, lowerWhisker), {}, {
              strokeStyle: getDefaultColor(seriesColor, whisker.color),
              lineWidth: whisker.lineWidth
            }),
            median: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMedian), {}, {
              strokeStyle: getDefaultColor(seriesColor, median.color),
              lineWidth: median.lineWidth
            }),
            maximum: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMaximum), {}, {
              strokeStyle: getDefaultColor(seriesColor, maximum.color),
              lineWidth: maximum.lineWidth
            }),
            minimum: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMinimum), {}, {
              strokeStyle: getDefaultColor(seriesColor, minimum.color),
              lineWidth: minimum.lineWidth
            })
          });
        }

        return model;
      });
    }
  }, {
    key: "getRect",
    value: function getRect(datum, startX, seriesColor, _ref12) {
      var barWidth = _ref12.barWidth,
          ratio = _ref12.ratio;
      var rect = this.theme.rect;

      var _datum3 = boxPlotSeries_slicedToArray(datum, 4),
          lowerQuartile = _datum3[1],
          highQuartile = _datum3[3];

      return {
        type: 'rect',
        x: startX,
        y: this.getYPos(highQuartile, ratio),
        width: barWidth,
        height: (highQuartile - lowerQuartile) * ratio,
        thickness: rect.borderWidth,
        borderColor: rect.borderColor,
        color: seriesColor
      };
    }
  }, {
    key: "getWhisker",
    value: function getWhisker(datum, startX, seriesColor, _ref13, rect) {
      var barWidth = _ref13.barWidth,
          ratio = _ref13.ratio;

      var _datum4 = boxPlotSeries_slicedToArray(datum, 5),
          minimum = _datum4[0],
          maximum = _datum4[4];

      var _ref14 = this.theme.line.whisker,
          lineWidth = _ref14.lineWidth,
          color = _ref14.color;
      var x = crispPixel(startX + barWidth / 2, lineWidth);
      return {
        upperWhisker: {
          type: 'line',
          x: x,
          y: this.getYPos(maximum, ratio, lineWidth),
          x2: x,
          y2: rect.y,
          strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
          lineWidth: lineWidth
        },
        lowerWhisker: {
          type: 'line',
          x: x,
          y: this.getYPos(minimum, ratio, lineWidth),
          x2: x,
          y2: crispPixel(rect.y + rect.height, lineWidth),
          strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
          lineWidth: lineWidth
        }
      };
    }
  }, {
    key: "getMedian",
    value: function getMedian(datum, startX, seriesColor, _ref15) {
      var barWidth = _ref15.barWidth,
          ratio = _ref15.ratio;
      var median = datum[2];
      var _ref16 = this.theme.line.median,
          lineWidth = _ref16.lineWidth,
          color = _ref16.color;
      return {
        type: 'line',
        x: crispPixel(startX, lineWidth),
        y: this.getYPos(median, ratio, lineWidth),
        x2: crispPixel(startX + barWidth, lineWidth),
        y2: this.getYPos(median, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getMinimum",
    value: function getMinimum(datum, startX, seriesColor, _ref17) {
      var barWidth = _ref17.barWidth,
          ratio = _ref17.ratio,
          minMaxBarWidth = _ref17.minMaxBarWidth;
      var minimum = datum[0];
      var _ref18 = this.theme.line.minimum,
          lineWidth = _ref18.lineWidth,
          color = _ref18.color;
      return {
        type: 'line',
        x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
        y: this.getYPos(minimum, ratio, lineWidth),
        x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
        y2: this.getYPos(minimum, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getMaximum",
    value: function getMaximum(datum, startX, seriesColor, _ref19) {
      var barWidth = _ref19.barWidth,
          ratio = _ref19.ratio,
          minMaxBarWidth = _ref19.minMaxBarWidth;
      var maximum = datum[4];
      var _ref20 = this.theme.line.maximum,
          lineWidth = _ref20.lineWidth,
          color = _ref20.color;
      return {
        type: 'line',
        x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
        y: this.getYPos(maximum, ratio, lineWidth),
        x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
        y2: this.getYPos(maximum, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(seriesName, seriesColor) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var active = this.activeSeriesMap[seriesName];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var selectedOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
      var opacity = selected ? selectedOpacity : areaOpacity;
      return getRGBA(seriesColor, opacity);
    }
  }]);

  return BoxPlotSeries;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/boxPlot.ts







function boxPlot_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxPlot_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlot_ownKeys(Object(source), true).forEach(function (key) { boxPlot_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlot_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxPlot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function boxPlot(ctx, model) {
  var rectModel = model.rect,
      upperWhisker = model.upperWhisker,
      lowerWhisker = model.lowerWhisker,
      median = model.median,
      minimum = model.minimum,
      maximum = model.maximum;

  if (minimum) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, minimum));
  }

  if (lowerWhisker) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, lowerWhisker));
  }

  if (rectModel) {
    rect(ctx, boxPlot_objectSpread({
      type: 'rect'
    }, rectModel));
  }

  if (upperWhisker) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, upperWhisker));
  }

  if (maximum) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, maximum));
  }

  if (median) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, median));
  }
}
;// CONCATENATED MODULE: ./src/charts/boxPlotChart.ts
function boxPlotChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxPlotChart_typeof = function _typeof(obj) { return typeof obj; }; } else { boxPlotChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxPlotChart_typeof(obj); }


















function boxPlotChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxPlotChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlotChart_ownKeys(Object(source), true).forEach(function (key) { boxPlotChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlotChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxPlotChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function boxPlotChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxPlotChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxPlotChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxPlotChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxPlotChart_defineProperties(Constructor, staticProps); return Constructor; }

function boxPlotChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { boxPlotChart_get = Reflect.get; } else { boxPlotChart_get = function _get(target, property, receiver) { var base = boxPlotChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return boxPlotChart_get(target, property, receiver || target); }

function boxPlotChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = boxPlotChart_getPrototypeOf(object); if (object === null) break; } return object; }

function boxPlotChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxPlotChart_setPrototypeOf(subClass, superClass); }

function boxPlotChart_setPrototypeOf(o, p) { boxPlotChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxPlotChart_setPrototypeOf(o, p); }

function boxPlotChart_createSuper(Derived) { var hasNativeReflectConstruct = boxPlotChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxPlotChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxPlotChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxPlotChart_possibleConstructorReturn(this, result); }; }

function boxPlotChart_possibleConstructorReturn(self, call) { if (call && (boxPlotChart_typeof(call) === "object" || typeof call === "function")) { return call; } return boxPlotChart_assertThisInitialized(self); }

function boxPlotChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxPlotChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function boxPlotChart_getPrototypeOf(o) { boxPlotChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxPlotChart_getPrototypeOf(o); }

























/**
 * @class
 * @classdesc BoxPlot Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making BoxPlot Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Array<number>>} props.data.series.data - Series data.
 *       @param {Array<Array<number>>} props.data.series.outliers - Series outliers data.
 *   @param {Object} [props.options] - Options for making BoxPlot Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|BoxPlot Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var BoxPlotChart = /*#__PURE__*/function (_Chart) {
  boxPlotChart_inherits(BoxPlotChart, _Chart);

  var _super = boxPlotChart_createSuper(BoxPlotChart);

  function BoxPlotChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        _ref$data = _ref.data,
        series = _ref$data.series,
        categories = _ref$data.categories;

    boxPlotChart_classCallCheck(this, BoxPlotChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        boxPlot: series
      },
      categories: categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  boxPlotChart_createClass(BoxPlotChart, [{
    key: "initialize",
    value: function initialize() {
      boxPlotChart_get(boxPlotChart_getPrototypeOf(BoxPlotChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BoxPlotSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, boxPlot_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<<Array<number>>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData(
        [
           [3000, 4000, 4714, 6000, 7000],
           [3000, 5750, 7571, 8250, 9000],
        ],
        'newCategory'
      );
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * add outlier.
     * @param {number} seriesIndex - Index of series.
     * @param {number} outliers - Array of outlier.
     * @api
     * @example
     * chart.addOutlier(1, [[1, 10000], [3, 12000]]);
     */

  }, {
    key: "addOutlier",
    value: function addOutlier(seriesIndex, outliers) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addOutlier', {
        seriesIndex: seriesIndex,
        outliers: outliers
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Array<number>>} data.data - Array of data to be added.
     *   @param {Array<Array<number>>} data.outliers - Series outliers data.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   ],
     *   outliers: [
     *     [0, 14000],
     *     [2, 10000],
     *   ]
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'newSeries',
     *       data: [
     *         [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *       ],
     *       outliers: [
     *         [0, 14000],
     *         [2, 10000],
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          boxPlot: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', boxPlotChart_objectSpread(boxPlotChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return BoxPlotChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/radialBarSeries.ts
function radialBarSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialBarSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { radialBarSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialBarSeries_typeof(obj); }

function radialBarSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radialBarSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radialBarSeries_ownKeys(Object(source), true).forEach(function (key) { radialBarSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radialBarSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radialBarSeries_toConsumableArray(arr) { return radialBarSeries_arrayWithoutHoles(arr) || radialBarSeries_iterableToArray(arr) || radialBarSeries_unsupportedIterableToArray(arr) || radialBarSeries_nonIterableSpread(); }

function radialBarSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radialBarSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radialBarSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radialBarSeries_arrayLikeToArray(o, minLen); }

function radialBarSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function radialBarSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radialBarSeries_arrayLikeToArray(arr); }

function radialBarSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

























function radialBarSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialBarSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialBarSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialBarSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialBarSeries_defineProperties(Constructor, staticProps); return Constructor; }

function radialBarSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialBarSeries_setPrototypeOf(subClass, superClass); }

function radialBarSeries_setPrototypeOf(o, p) { radialBarSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialBarSeries_setPrototypeOf(o, p); }

function radialBarSeries_createSuper(Derived) { var hasNativeReflectConstruct = radialBarSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialBarSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialBarSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialBarSeries_possibleConstructorReturn(this, result); }; }

function radialBarSeries_possibleConstructorReturn(self, call) { if (call && (radialBarSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return radialBarSeries_assertThisInitialized(self); }

function radialBarSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialBarSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radialBarSeries_getPrototypeOf(o) { radialBarSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialBarSeries_getPrototypeOf(o); }

function radialBarSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var RadialBarSeries = /*#__PURE__*/function (_Component) {
  radialBarSeries_inherits(RadialBarSeries, _Component);

  var _super = radialBarSeries_createSuper(RadialBarSeries);

  function RadialBarSeries() {
    var _this;

    radialBarSeries_classCallCheck(this, RadialBarSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "models", {});

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "drawModels", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "responders", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "activatedResponders", []);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "tooltipSectorMap", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "theme", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "circularAxis", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var _this$getResponderMod;

      var index = info.index,
          seriesIndex = info.seriesIndex;
      var isAvailable = isNumber(index) && (_this.eventDetectType === 'grouped' || isNumber(seriesIndex));

      if (!isAvailable) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? [].concat(radialBarSeries_toConsumableArray(_this.getGroupedSector([_this.responders[index]], 'select')), radialBarSeries_toConsumableArray(_this.getRadialBarSectorModelsFromResponders([_this.responders[index]]))) : (_this$getResponderMod = _this.getResponderModelsWithTheme([_this.tooltipSectorMap[index][seriesIndex]], 'select')) !== null && _this$getResponderMod !== void 0 ? _this$getResponderMod : [];

      if (!models.length) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'radialBar')) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.getGroupedSector([_this.responders[index]], 'hover') : _this.getResponderModelsWithTheme([_this.tooltipSectorMap[index][seriesIndex]], 'hover');

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.activatedResponders = _this.eventDetectType === 'grouped' ? _this.tooltipSectorMap[index] : models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  radialBarSeries_createClass(RadialBarSeries, [{
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      if (!this.drawModels) {
        return;
      }

      var _this$circularAxis$an = this.circularAxis.angle,
          startAngle = _this$circularAxis$an.start,
          totalAngle = _this$circularAxis$an.total;
      var currentDegree;
      Object.keys(this.models).forEach(function (category) {
        var index = _this2.models[category].findIndex(function (_ref) {
          var clockwise = _ref.clockwise,
              _ref$degree = _ref.degree,
              start = _ref$degree.start,
              end = _ref$degree.end;
          currentDegree = clockwise ? startAngle + totalAngle * delta : startAngle - totalAngle * delta;
          return withinRadian(clockwise, start, end, currentDegree);
        });

        _this2.syncEndAngle(index < 0 ? _this2.models[category].length : index, category);

        if (index !== -1) {
          _this2.drawModels[category][index].degree.end = currentDegree;
        }
      });
    }
  }, {
    key: "syncEndAngle",
    value: function syncEndAngle(index, category) {
      if (index < 1) {
        return;
      }

      for (var i = 0; i < index; i += 1) {
        var prevTargetEndDegree = this.models[category][i].degree.end;

        if (this.drawModels[category][i].degree.end !== prevTargetEndDegree) {
          this.drawModels[category][i].degree.end = prevTargetEndDegree;
        }
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'radialBar';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _ref2,
          _this3 = this;

      var layout = chartState.layout,
          series = chartState.series,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme,
          stackSeries = chartState.stackSeries,
          scale = chartState.scale,
          radialAxes = chartState.radialAxes;
      var categories = (_ref2 = chartState.categories) !== null && _ref2 !== void 0 ? _ref2 : [];

      if (!series.radialBar || !stackSeries.radialBar) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.radialBar;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      this.setEventDetectType(options);
      var initialCategoryMap = categories.reduce(function (acc, category) {
        if (!acc[category]) {
          acc[category] = [];
        }

        return acc;
      }, {});
      var seriesData = series.radialBar.data;
      this.circularAxis = radialAxes.circularAxis;
      var verticalAxisData = radialAxes.verticalAxis;
      var renderOptions = this.makeRenderOptions(verticalAxisData, scale.circularAxis, options === null || options === void 0 ? void 0 : options.series);

      var _this$makeSeriesModel = this.makeSeriesModelData(seriesData, stackSeries.radialBar.stackData, renderOptions, initialCategoryMap),
          categoryMap = _this$makeSeriesModel.categoryMap,
          seriesModels = _this$makeSeriesModel.seriesModels;

      var tooltipData = this.makeTooltipData(seriesModels, categories);
      this.models = categoryMap;

      if (!this.drawModels) {
        this.initDrawModels(categoryMap);
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var dataLabelData = seriesModels.reduce(function (acc, data) {
          return [].concat(radialBarSeries_toConsumableArray(acc), [radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, data), {}, {
            type: 'sector',
            theme: _this3.theme.dataLabels
          })]);
        }, []);
        this.renderDataLabels(dataLabelData);
      }

      this.tooltipSectorMap = this.makeTooltipSectorMap(seriesModels, tooltipData);
      this.responders = this.makeResponders(verticalAxisData.radius.ranges, seriesModels, renderOptions, categories, tooltipData);
    }
  }, {
    key: "initDrawModels",
    value: function initDrawModels(categoryMap) {
      var _this4 = this;

      this.drawModels = {};
      Object.keys(categoryMap).forEach(function (category) {
        _this4.drawModels[category] = categoryMap[category].map(function (m) {
          return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
            degree: radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m.degree), {}, {
              end: m.degree.start
            })
          });
        });
      });
    }
  }, {
    key: "makeResponders",
    value: function makeResponders(radiusRanges, seriesModels, renderOptions, categories, tooltipData) {
      return this.eventDetectType === 'grouped' ? makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) : seriesModels.map(function (m, index) {
        return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
          data: radialBarSeries_objectSpread({}, tooltipData[index])
        });
      });
    }
  }, {
    key: "makeTooltipSectorMap",
    value: function makeTooltipSectorMap(seriesModels, tooltipData) {
      return seriesModels.reduce(function (acc, cur, index) {
        var categoryIndex = cur.index;

        if (!acc[categoryIndex]) {
          acc[categoryIndex] = [];
        }

        acc[categoryIndex].push(radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, cur), {}, {
          data: radialBarSeries_objectSpread({}, tooltipData[index])
        }));
        return acc;
      }, {});
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(options) {
      var _options$series;

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }
    }
  }, {
    key: "getBarWidth",
    value: function getBarWidth(tickDistance, axisSize) {
      var barWidth = this.theme.barWidth;
      var DEFAULT_PADDING = 5;
      return barWidth ? Math.min(tickDistance, calculateSizeWithPercentString(axisSize, barWidth)) : tickDistance - DEFAULT_PADDING * 2;
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(_ref3, scale, options) {
      var _options$clockwise;

      var axisSize = _ref3.axisSize,
          centerX = _ref3.centerX,
          centerY = _ref3.centerY,
          tickDistance = _ref3.tickDistance,
          ranges = _ref3.radius.ranges,
          _ref3$angle = _ref3.angle,
          start = _ref3$angle.start,
          end = _ref3$angle.end;
      var max = scale.limit.max,
          stepSize = scale.stepSize;
      var clockwise = (_options$clockwise = options === null || options === void 0 ? void 0 : options.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
      var totalAngle = getTotalAngle(clockwise, start, end);
      var barWidth = this.getBarWidth(tickDistance, axisSize);
      var padding = (tickDistance - barWidth) / 2;
      var scaleMaxLimitValue = max + (totalAngle < DEGREE_360 ? DEGREE_0 : stepSize);
      return {
        clockwise: clockwise,
        centerX: centerX,
        centerY: centerY,
        radiusRanges: getRadiusRanges(ranges, padding),
        angleRange: {
          start: start,
          end: end
        },
        totalAngle: totalAngle,
        scaleMaxLimitValue: scaleMaxLimitValue,
        startAngle: start
      };
    }
  }, {
    key: "makeSeriesModelData",
    value: function makeSeriesModelData(seriesData, stackSeriesData, renderOptions, initialCategoryMap) {
      var _this5 = this;

      var clockwise = renderOptions.clockwise,
          centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          radiusRanges = renderOptions.radiusRanges,
          totalAngle = renderOptions.totalAngle,
          scaleMaxLimitValue = renderOptions.scaleMaxLimitValue,
          startAngle = renderOptions.startAngle;
      var defaultStartDegree = startAngle;
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          strokeStyle = _this$theme.strokeStyle;
      var sectorModels = [];
      var categories = Object.keys(initialCategoryMap);
      var categoryMap = deepCopy(initialCategoryMap);
      stackSeriesData.forEach(function (_ref4, categoryIndex) {
        var values = _ref4.values;
        var _radiusRanges$categor = radiusRanges[categoryIndex],
            inner = _radiusRanges$categor.inner,
            outer = _radiusRanges$categor.outer;
        values.forEach(function (value, seriesIndex) {
          if (!isNull(value)) {
            var degree = Math.max(value / scaleMaxLimitValue * totalAngle, 1) * (clockwise ? 1 : -1);
            var prevModel = sectorModels[sectorModels.length - 1];
            var startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
            var endDegree = clockwise ? Math.min(startDegree + degree, DEGREE_360) : Math.max(startDegree + degree, DEGREE_0);
            var _ref5 = seriesData[seriesIndex],
                name = _ref5.name,
                seriesColor = _ref5.color;

            var color = _this5.getSeriesColor(name, seriesColor);

            var sectorModel = {
              type: 'sector',
              name: name,
              color: color,
              x: centerX,
              y: centerY,
              degree: {
                start: startDegree,
                end: endDegree
              },
              radius: {
                inner: inner,
                outer: outer
              },
              value: value,
              style: [{
                strokeStyle: strokeStyle
              }],
              lineWidth: lineWidth,
              clockwise: clockwise,
              totalAngle: totalAngle,
              seriesColor: seriesColor,
              seriesIndex: seriesIndex,
              index: categoryIndex,
              drawingStartAngle: DEGREE_NEGATIVE_90
            };
            categoryMap[categories[categoryIndex]].push(sectorModel);
            sectorModels.push(sectorModel);
          }
        });
      });
      return {
        seriesModels: sectorModels,
        categoryMap: categoryMap
      };
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(name, color) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(seriesModels, categories) {
      var tooltipData = [];
      seriesModels.forEach(function (_ref6) {
        var seriesColor = _ref6.seriesColor,
            name = _ref6.name,
            value = _ref6.value,
            index = _ref6.index;

        if (!isNull(value)) {
          tooltipData.push({
            label: name,
            color: seriesColor,
            value: value,
            category: isNumber(index) ? categories[index] : ''
          });
        }
      });
      return tooltipData;
    }
  }, {
    key: "makeTooltipResponder",
    value: function makeTooltipResponder(responders) {
      var _this6 = this;

      var categories = Object.keys(this.models);
      return responders.map(function (responder) {
        return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, responder), getRadialAnchorPosition(makeAnchorPositionParam('center', _this6.models[categories[responder.index]].find(function (_ref7) {
          var name = _ref7.name;
          return name === responder.name;
        }))));
      });
    }
  }, {
    key: "getRadialBarSectorModelsFromResponders",
    value: function getRadialBarSectorModelsFromResponders(responders) {
      var _this$tooltipSectorMa;

      if (!responders.length) {
        return [];
      }

      return (_this$tooltipSectorMa = this.tooltipSectorMap[responders[0].index]) !== null && _this$tooltipSectorMa !== void 0 ? _this$tooltipSectorMa : [];
    }
  }, {
    key: "getGroupedSector",
    value: function getGroupedSector(responders, type) {
      var RadialBarSectorModels = this.getRadialBarSectorModelsFromResponders(responders);
      var _ref8 = this.theme[type].groupedSector,
          color = _ref8.color,
          opacity = _ref8.opacity;
      return RadialBarSectorModels.length ? responders.map(function (m) {
        return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
          color: getRGBA(color, opacity)
        });
      }) : [];
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var RadialBarSectorModels = this.getRadialBarSectorModelsFromResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getGroupedSector(responders, 'hover'),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = RadialBarSectorModels;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref9) {
      var responders = _ref9.responders;

      if (this.eventDetectType === 'grouped') {
        this.onMousemoveGroupedType(responders);
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getResponderModelsWithTheme(responders, 'hover'),
          name: this.name
        });
        this.activatedResponders = this.makeTooltipResponder(responders);
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref10) {
      var responders = _ref10.responders;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'grouped') {
          models = [].concat(radialBarSeries_toConsumableArray(this.getGroupedSector(responders, 'select')), radialBarSeries_toConsumableArray(this.getRadialBarSectorModelsFromResponders(responders)));
        } else {
          models = this.getResponderModelsWithTheme(responders, 'select');
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderModelsWithTheme",
    value: function getResponderModelsWithTheme(responders, type) {
      var theme = this.theme[type];
      var lineWidth = theme.lineWidth;
      var isSameLineWidth = this.theme.lineWidth === lineWidth;
      var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
      return responders.map(function (m) {
        var _theme$color;

        return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
          color: (_theme$color = theme === null || theme === void 0 ? void 0 : theme.color) !== null && _theme$color !== void 0 ? _theme$color : m.color,
          lineWidth: lineWidth,
          style: [pick(theme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')],
          radius: {
            inner: Math.max(m.radius.inner - thickness, 0),
            outer: m.radius.outer + thickness
          }
        });
      });
    }
  }]);

  return RadialBarSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/radialBarChart.ts
function radialBarChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialBarChart_typeof = function _typeof(obj) { return typeof obj; }; } else { radialBarChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialBarChart_typeof(obj); }


















function radialBarChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radialBarChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radialBarChart_ownKeys(Object(source), true).forEach(function (key) { radialBarChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radialBarChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radialBarChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function radialBarChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialBarChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialBarChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialBarChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialBarChart_defineProperties(Constructor, staticProps); return Constructor; }

function radialBarChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { radialBarChart_get = Reflect.get; } else { radialBarChart_get = function _get(target, property, receiver) { var base = radialBarChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return radialBarChart_get(target, property, receiver || target); }

function radialBarChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = radialBarChart_getPrototypeOf(object); if (object === null) break; } return object; }

function radialBarChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialBarChart_setPrototypeOf(subClass, superClass); }

function radialBarChart_setPrototypeOf(o, p) { radialBarChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialBarChart_setPrototypeOf(o, p); }

function radialBarChart_createSuper(Derived) { var hasNativeReflectConstruct = radialBarChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialBarChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialBarChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialBarChart_possibleConstructorReturn(this, result); }; }

function radialBarChart_possibleConstructorReturn(self, call) { if (call && (radialBarChart_typeof(call) === "object" || typeof call === "function")) { return call; } return radialBarChart_assertThisInitialized(self); }

function radialBarChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialBarChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radialBarChart_getPrototypeOf(o) { radialBarChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialBarChart_getPrototypeOf(o); }


























/**
 * @class
 * @classdesc RadialBar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making RadialBar Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making RadialBar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Array<number>|Array<string>} [props.options.series.radiusRange] - Specifies the radius of the circle drawn. It is specified by entering a number or percent string value in start and end.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *     @param {Object} [props.options.circularAxis]
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.circularAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.verticalAxis]
 *       @param {Object} [props.options.verticalAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.verticalAxis.label] - Option to adjust label interval.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|RadialBar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.verticalAxis] - Vertical Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var RadialBarChart = /*#__PURE__*/function (_Chart) {
  radialBarChart_inherits(RadialBarChart, _Chart);

  var _super = radialBarChart_createSuper(RadialBarChart);

  function RadialBarChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    radialBarChart_classCallCheck(this, RadialBarChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        radialBar: data.series
      },
      categories: data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, radialAxes]
    });
  }

  radialBarChart_createClass(RadialBarChart, [{
    key: "initialize",
    value: function initialize() {
      radialBarChart_get(radialBarChart_getPrototypeOf(RadialBarChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Legend);
      this.componentManager.add(RadarPlot);
      this.componentManager.add(RadialBarSeries);
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(RadialAxis);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject, axis_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 20, 30, 40],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          radialBar: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 500,
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     selectable: true
     *   }
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     eventDetectType: 'grouped'
     *   }
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only index is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series
     * @api
     * @example
     * // eventDetectType is 'grouped'
     * chart.showTooltip({index: 1});
     *
     * // eventDetectType is 'point'
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', radialBarChart_objectSpread(radialBarChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return RadialBarChart;
}(Chart);


;// CONCATENATED MODULE: ./src/store/gaugeAxes.ts
function gaugeAxes_toConsumableArray(arr) { return gaugeAxes_arrayWithoutHoles(arr) || gaugeAxes_iterableToArray(arr) || gaugeAxes_unsupportedIterableToArray(arr) || gaugeAxes_nonIterableSpread(); }

function gaugeAxes_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function gaugeAxes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return gaugeAxes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return gaugeAxes_arrayLikeToArray(o, minLen); }

function gaugeAxes_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function gaugeAxes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return gaugeAxes_arrayLikeToArray(arr); }

function gaugeAxes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



















function gaugeAxes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function gaugeAxes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { gaugeAxes_ownKeys(Object(source), true).forEach(function (key) { gaugeAxes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { gaugeAxes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function gaugeAxes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var DEFAULT_LABEL_PADDING = 15;
var RANGE_BAR_MARGIN = 10;
var CLOCK_HAND_MARGIN = 10;
var DATA_LABEL_MARGIN = 30;

function makeSolidData(outerRadius, barWidth, solidOptions) {
  var initialSolidOptions = solidOptions !== null && solidOptions !== void 0 ? solidOptions : false;
  var solidBarWidth = calculateSizeWithPercentString(outerRadius, barWidth);
  var defaultSolidOptions = {
    visible: true,
    radiusRange: {
      inner: outerRadius - solidBarWidth,
      outer: outerRadius
    },
    barWidth: solidBarWidth,
    clockHand: false
  };

  if (!initialSolidOptions) {
    return gaugeAxes_objectSpread(gaugeAxes_objectSpread({}, defaultSolidOptions), {}, {
      visible: false
    });
  }

  return isObject(initialSolidOptions) ? gaugeAxes_objectSpread(gaugeAxes_objectSpread({}, defaultSolidOptions), initialSolidOptions) : defaultSolidOptions;
}

function gaugeAxes_getCircularAxisData(_ref) {
  var _options$series, _options$circularAxis;

  var labels = _ref.labels,
      intervalData = _ref.intervalData,
      circularAxisLabelMargin = _ref.circularAxisLabelMargin,
      circularAxisLabelFont = _ref.circularAxisLabelFont,
      defaultAxisData = _ref.defaultAxisData,
      bandWidth = _ref.bandWidth,
      options = _ref.options,
      solidBarWidth = _ref.solidBarWidth;

  var _getMaxLabelSize = getMaxLabelSize(labels, circularAxisLabelMargin, circularAxisLabelFont),
      maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

  var totalAngle = defaultAxisData.totalAngle,
      axisSize = defaultAxisData.axisSize,
      centerX = defaultAxisData.centerX,
      centerY = defaultAxisData.centerY,
      startAngle = defaultAxisData.startAngle,
      endAngle = defaultAxisData.endAngle,
      drawingStartAngle = defaultAxisData.drawingStartAngle,
      clockwise = defaultAxisData.clockwise;
  var tickInterval = intervalData.tickInterval,
      labelInterval = intervalData.labelInterval;
  var outerRadius = axisSize - bandWidth - RANGE_BAR_MARGIN;
  var solidBarWidthValue = solidBarWidth !== null && solidBarWidth !== void 0 ? solidBarWidth : outerRadius * 0.1;
  var solidData = makeSolidData(outerRadius - circularAxisLabelMargin - maxLabelHeight - (circularAxisLabelMargin - 5), solidBarWidthValue, options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.solid);
  var centralAngle = totalAngle / (labels.length + (totalAngle < DEGREE_360 ? -1 : DEGREE_0));
  var maxClockHandSize = outerRadius - circularAxisLabelMargin - maxLabelHeight - CLOCK_HAND_MARGIN + (solidData.visible ? -solidData.barWidth - CLOCK_HAND_MARGIN : 0);
  return {
    axisSize: axisSize,
    centerX: centerX,
    centerY: centerY,
    label: {
      labels: labels,
      interval: labelInterval,
      margin: circularAxisLabelMargin,
      maxWidth: maxLabelWidth,
      maxHeight: maxLabelHeight
    },
    radius: {
      inner: 0,
      outer: outerRadius
    },
    angle: {
      start: startAngle,
      end: endAngle,
      total: totalAngle,
      central: centralAngle,
      drawingStart: drawingStartAngle
    },
    band: {
      width: bandWidth,
      margin: RANGE_BAR_MARGIN
    },
    tickInterval: tickInterval,
    clockwise: clockwise,
    maxClockHandSize: maxClockHandSize,
    title: makeTitleOption(options === null || options === void 0 ? void 0 : (_options$circularAxis = options.circularAxis) === null || _options$circularAxis === void 0 ? void 0 : _options$circularAxis.title),
    solidData: solidData
  };
}

function gaugeAxes_makeLabels(options, rawLabels, axisName) {
  var _options$axisName$lab, _options$axisName, _options$axisName$lab2;

  var formatter = (_options$axisName$lab = (_options$axisName = options[axisName]) === null || _options$axisName === void 0 ? void 0 : (_options$axisName$lab2 = _options$axisName.label) === null || _options$axisName$lab2 === void 0 ? void 0 : _options$axisName$lab2.formatter) !== null && _options$axisName$lab !== void 0 ? _options$axisName$lab : function (value) {
    return value;
  };
  return rawLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: rawLabels,
      axisName: axisName
    });
  });
}

function gaugeAxes_getAxisLabels(isLabelOnVerticalAxis, options, categories, scale) {
  var valueAxisName = isLabelOnVerticalAxis ? RadialAxisType.CIRCULAR : RadialAxisType.VERTICAL;
  var _ref2 = scale[valueAxisName],
      limit = _ref2.limit,
      stepSize = _ref2.stepSize;
  var valueLabels = gaugeAxes_makeLabels(options, makeLabelsFromLimit(limit, stepSize), valueAxisName);
  var categoryLabels = gaugeAxes_makeLabels(options, categories, isLabelOnVerticalAxis ? RadialAxisType.VERTICAL : RadialAxisType.CIRCULAR);
  return isLabelOnVerticalAxis ? valueLabels : categoryLabels;
}

function gaugeAxes_getAxisLabelMargin(options) {
  var _options$circularAxis2, _options$circularAxis3, _options$circularAxis4;

  return (_options$circularAxis2 = options === null || options === void 0 ? void 0 : (_options$circularAxis3 = options.circularAxis) === null || _options$circularAxis3 === void 0 ? void 0 : (_options$circularAxis4 = _options$circularAxis3.label) === null || _options$circularAxis4 === void 0 ? void 0 : _options$circularAxis4.margin) !== null && _options$circularAxis2 !== void 0 ? _options$circularAxis2 : DEFAULT_LABEL_PADDING;
}

function gaugeAxes_hasAxesLayoutChanged(previousAxes, currentAxes) {
  var _previousAxes$label, _previousAxes$label2;

  var prevMaxWidth = previousAxes === null || previousAxes === void 0 ? void 0 : (_previousAxes$label = previousAxes.label) === null || _previousAxes$label === void 0 ? void 0 : _previousAxes$label.maxWidth;
  var prevMaxHeight = previousAxes === null || previousAxes === void 0 ? void 0 : (_previousAxes$label2 = previousAxes.label) === null || _previousAxes$label2 === void 0 ? void 0 : _previousAxes$label2.maxHeight;
  var curMaxWidth = currentAxes.label.maxWidth;
  var curMaxHeight = currentAxes.label.maxHeight;
  return prevMaxHeight !== curMaxHeight || prevMaxWidth !== curMaxWidth;
}

var gaugeAxes_axes = {
  name: 'gaugeAxes',
  state: function state() {
    return {
      radialAxes: {
        circularAxis: {}
      }
    };
  },
  action: {
    setCircularAxisData: function setCircularAxisData(_ref3) {
      var _options$series$dataL, _options$series2, _options$series2$data, _plot, _plot$bands, _bands$barWidth, _theme$plot, _theme$plot$bands, _theme$series$gauge, _theme$series$gauge$s, _state$radialAxes;

      var state = _ref3.state;
      var series = state.series,
          layout = state.layout,
          scale = state.scale;
      var categories = state.categories;
      var plot = layout.plot;
      var isLabelOnVerticalAxis = isLabelAxisOnYAxis({
        series: series,
        categories: categories
      });
      var options = state.options;
      var theme = state.theme;
      var circularAxisLabelFont = getTitleFontString(theme.circularAxis.label);
      var circularAxisLabelMargin = gaugeAxes_getAxisLabelMargin(options);
      var circularAxisLabels = gaugeAxes_getAxisLabels(isLabelOnVerticalAxis, options, categories, scale);

      var _getMaxLabelSize2 = getMaxLabelSize(circularAxisLabels, circularAxisLabelMargin, circularAxisLabelFont),
          maxLabelWidth = _getMaxLabelSize2.maxLabelWidth,
          maxLabelHeight = _getMaxLabelSize2.maxLabelHeight;

      var defaultAxisData = getDefaultRadialAxisData(options, plot, maxLabelWidth, maxLabelHeight, isLabelOnVerticalAxis);
      var dataLabelHeight = getFontHeight(getTitleFontString(theme.series.gauge.dataLabels));
      var dataLabelOffsetY = (_options$series$dataL = options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : _options$series2$data.offsetY) !== null && _options$series$dataL !== void 0 ? _options$series$dataL : DATA_LABEL_MARGIN;

      if (defaultAxisData.isSemiCircular) {
        defaultAxisData.centerY = defaultAxisData.centerY - (dataLabelOffsetY > 0 ? dataLabelOffsetY + dataLabelHeight : 0);
        var diffHeight = defaultAxisData.centerY - defaultAxisData.axisSize;
        defaultAxisData.axisSize += diffHeight < 0 ? diffHeight : 0;
      }

      var defualtBandWidth = options !== null && options !== void 0 && (_plot = options.plot) !== null && _plot !== void 0 && (_plot$bands = _plot.bands) !== null && _plot$bands !== void 0 && _plot$bands.length ? defaultAxisData.axisSize / 2 - RANGE_BAR_MARGIN : 0;
      var bandWidth = (_bands$barWidth = (_theme$plot = theme.plot) === null || _theme$plot === void 0 ? void 0 : (_theme$plot$bands = _theme$plot.bands) === null || _theme$plot$bands === void 0 ? void 0 : _theme$plot$bands.barWidth) !== null && _bands$barWidth !== void 0 ? _bands$barWidth : defualtBandWidth;
      var circularAxisData = gaugeAxes_getCircularAxisData({
        labels: circularAxisLabels,
        intervalData: getInitAxisIntervalData(true, {
          axis: options.circularAxis,
          categories: categories,
          layout: layout
        }),
        defaultAxisData: defaultAxisData,
        circularAxisLabelMargin: circularAxisLabelMargin,
        circularAxisLabelFont: circularAxisLabelFont,
        bandWidth: bandWidth,
        options: options,
        solidBarWidth: (_theme$series$gauge = theme.series.gauge) === null || _theme$series$gauge === void 0 ? void 0 : (_theme$series$gauge$s = _theme$series$gauge.solid) === null || _theme$series$gauge$s === void 0 ? void 0 : _theme$series$gauge$s.barWidth
      });

      if (gaugeAxes_hasAxesLayoutChanged((_state$radialAxes = state.radialAxes) === null || _state$radialAxes === void 0 ? void 0 : _state$radialAxes.circularAxis, circularAxisData)) {
        this.notify(state, 'layout');
      }

      state.radialAxes = {
        circularAxis: circularAxisData
      };
    },
    addGaugePlotBand: function addGaugePlotBand(_ref4, _ref5) {
      var _plot$bands2, _state$options, _state$options$plot;

      var state = _ref4.state;
      var data = _ref5.data;
      var bands = (_plot$bands2 = (_state$options = state.options) === null || _state$options === void 0 ? void 0 : (_state$options$plot = _state$options.plot) === null || _state$options$plot === void 0 ? void 0 : _state$options$plot.bands) !== null && _plot$bands2 !== void 0 ? _plot$bands2 : [];

      if (!isExistPlotId(bands, data)) {
        this.dispatch('updateOptions', {
          options: {
            plot: {
              bands: [].concat(gaugeAxes_toConsumableArray(bands), [data])
            }
          }
        });
      }
    },
    removeGaugePlotBand: function removeGaugePlotBand(_ref6, _ref7) {
      var _plot$bands3, _state$options2, _state$options2$plot;

      var state = _ref6.state;
      var id = _ref7.id;
      var bands = ((_plot$bands3 = (_state$options2 = state.options) === null || _state$options2 === void 0 ? void 0 : (_state$options2$plot = _state$options2.plot) === null || _state$options2$plot === void 0 ? void 0 : _state$options2$plot.bands) !== null && _plot$bands3 !== void 0 ? _plot$bands3 : []).filter(function (_ref8) {
        var bandId = _ref8.id;
        return bandId !== id;
      });
      this.dispatch('updateOptions', {
        options: {
          plot: {
            bands: bands
          }
        }
      });
    }
  },
  observe: {
    updateRadialAxes: function updateRadialAxes() {
      this.dispatch('setCircularAxisData');
    }
  }
};
/* harmony default export */ var gaugeAxes = (gaugeAxes_axes);
;// CONCATENATED MODULE: ./src/component/gaugeSeries.ts
function gaugeSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { gaugeSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { gaugeSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return gaugeSeries_typeof(obj); }

function gaugeSeries_toConsumableArray(arr) { return gaugeSeries_arrayWithoutHoles(arr) || gaugeSeries_iterableToArray(arr) || gaugeSeries_unsupportedIterableToArray(arr) || gaugeSeries_nonIterableSpread(); }

function gaugeSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function gaugeSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return gaugeSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return gaugeSeries_arrayLikeToArray(o, minLen); }

function gaugeSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function gaugeSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return gaugeSeries_arrayLikeToArray(arr); }

function gaugeSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function gaugeSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function gaugeSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { gaugeSeries_ownKeys(Object(source), true).forEach(function (key) { gaugeSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { gaugeSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
























function gaugeSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function gaugeSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function gaugeSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) gaugeSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) gaugeSeries_defineProperties(Constructor, staticProps); return Constructor; }

function gaugeSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) gaugeSeries_setPrototypeOf(subClass, superClass); }

function gaugeSeries_setPrototypeOf(o, p) { gaugeSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return gaugeSeries_setPrototypeOf(o, p); }

function gaugeSeries_createSuper(Derived) { var hasNativeReflectConstruct = gaugeSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = gaugeSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = gaugeSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return gaugeSeries_possibleConstructorReturn(this, result); }; }

function gaugeSeries_possibleConstructorReturn(self, call) { if (call && (gaugeSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return gaugeSeries_assertThisInitialized(self); }

function gaugeSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function gaugeSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function gaugeSeries_getPrototypeOf(o) { gaugeSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return gaugeSeries_getPrototypeOf(o); }

function gaugeSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var DETECTION_SIZE_MARGIN = 3;

var GaugeSeries = /*#__PURE__*/function (_Component) {
  gaugeSeries_inherits(GaugeSeries, _Component);

  var _super = gaugeSeries_createSuper(GaugeSeries);

  function GaugeSeries() {
    var _this;

    gaugeSeries_classCallCheck(this, GaugeSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "models", {
      clockHand: [],
      solid: [],
      backgroundSolid: []
    });

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "drawModels", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "responders", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "activatedResponders", []);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "tooltipMap", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "theme", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "circularAxis", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var _this$tooltipMap$cloc;

      var index = info.index;

      if (!isNumber(index)) {
        return;
      }

      var model = (_this$tooltipMap$cloc = _this.tooltipMap.clockHand[index]) !== null && _this$tooltipMap$cloc !== void 0 ? _this$tooltipMap$cloc : _this.tooltipMap.solid[index];

      if (!model) {
        return;
      }

      var models = _this.getResponderModelsWithTheme(_this.getResponderModels([model]), 'select');

      if (!models.length) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index;

      var models = _this.getResponderModelsWithTheme([_this.tooltipMap.clockHand[index]], 'hover');

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  gaugeSeries_createClass(GaugeSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'gauge';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      if (!this.drawModels) {
        return;
      }

      var _this$circularAxis = this.circularAxis,
          _this$circularAxis$an = _this$circularAxis.angle,
          startAngle = _this$circularAxis$an.start,
          totalAngle = _this$circularAxis$an.total,
          clockwise = _this$circularAxis.clockwise;
      var currentDegree = clockwise ? startAngle + totalAngle * delta : startAngle - totalAngle * delta;
      this.models.clockHand.forEach(function (model, index) {
        var x = model.x,
            y = model.y,
            animationDegree = model.animationDegree,
            handSize = model.handSize;

        if (clockwise && animationDegree < currentDegree || !clockwise && animationDegree > currentDegree) {
          _this2.syncEndAngle(index);

          return;
        }

        var _getRadialPosition = getRadialPosition(x, y, handSize, calculateDegreeToRadian(calculateValidAngle(currentDegree))),
            x2 = _getRadialPosition.x,
            y2 = _getRadialPosition.y;

        _this2.drawModels.clockHand[index].x2 = x2;
        _this2.drawModels.clockHand[index].y2 = y2;
      });
      this.models.solid.forEach(function () {
        var index = _this2.models.solid.findIndex(function (_ref) {
          var animationDegree = _ref.animationDegree;
          var _ref2 = animationDegree,
              start = _ref2.start,
              end = _ref2.end;
          return withinRadian(clockwise, start, end, currentDegree);
        });

        _this2.syncSectorEndAngle(index < 0 ? _this2.models.solid.length : index);

        if (index !== -1) {
          _this2.drawModels.solid[index].degree.end = calculateValidAngle(currentDegree);
        }
      });
    }
  }, {
    key: "updateModels",
    value: function updateModels(current, target, delta) {
      var total = this.circularAxis.angle.total;
      Object.keys(current).forEach(function (key) {
        if (!current || !target) {
          return;
        }

        if (key[0] !== '_') {
          if (isNumber(current[key])) {
            current[key] = current[key] + (target[key] - current[key]) * delta;
          } else if (key === 'degree') {
            if (total < DEGREE_360 && current.degree.end < DEGREE_90) {
              current[key].end = DEGREE_360 + current[key].end - (DEGREE_360 - target[key].end + current[key].end) * delta;
            } else {
              current[key].end = current[key].end + (target[key].end - current[key].end) * delta;
            }
          } else {
            current[key] = target[key];
          }
        }
      });
    }
  }, {
    key: "update",
    value: function update(delta) {
      var _this3 = this;

      this.models.clockHand.forEach(function (model, index) {
        _this3.updateModels(_this3.drawModels.clockHand[index], model, delta);
      });
      this.models.solid.forEach(function (model, index) {
        _this3.updateModels(_this3.drawModels.solid[index], model, delta);
      });
    }
  }, {
    key: "syncEndAngle",
    value: function syncEndAngle(index) {
      var model = this.models.clockHand[index];
      var drawModel = this.drawModels.clockHand[index];

      if (model.x2 !== drawModel.x2 || model.y2 !== drawModel.y2) {
        drawModel.x2 = model.x2;
        drawModel.y2 = model.y2;
      }
    }
  }, {
    key: "syncSectorEndAngle",
    value: function syncSectorEndAngle(index) {
      if (!index) {
        return;
      }

      for (var i = 0; i < index; i += 1) {
        var prevTargetEndDegree = this.models.solid[i].degree.end;

        if (this.drawModels.solid[i].degree.end !== prevTargetEndDegree) {
          this.drawModels.solid[i].degree.end = prevTargetEndDegree;
        }
      }
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _ref3;

      var layout = chartState.layout,
          series = chartState.series,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme,
          scale = chartState.scale,
          radialAxes = chartState.radialAxes;
      var categories = (_ref3 = chartState.categories) !== null && _ref3 !== void 0 ? _ref3 : [];

      if (!series.gauge) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.gauge;
      this.rect = layout.plot;
      this.circularAxis = radialAxes.circularAxis;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var seriesData = series.gauge.data;
      var hasCategoryAxis = !isLabelAxisOnYAxis({
        series: series,
        categories: categories
      });
      var renderOptions = this.makeRenderOptions(hasCategoryAxis, categories, scale, options === null || options === void 0 ? void 0 : options.series);
      var clockHandModels = this.renderClockHands(seriesData, renderOptions);
      this.models.clockHand = renderOptions.useClockHand ? clockHandModels : [];
      var solidModels = this.renderSolidModels(seriesData, clockHandModels, renderOptions);
      var tooltipData = this.makeTooltipData(clockHandModels);

      if (!this.drawModels) {
        this.initDrawModels();
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var _clockHandModels$ = clockHandModels[0],
            value = _clockHandModels$.value,
            name = _clockHandModels$.name,
            x = _clockHandModels$.x,
            y = _clockHandModels$.y,
            data = _clockHandModels$.seriesData;
        this.renderDataLabels([{
          type: 'point',
          theme: this.theme.dataLabels,
          value: value,
          name: name,
          x: x,
          y: y + DATA_LABEL_MARGIN,
          data: data
        }]);
      }

      this.tooltipMap = this.makeTooltipMap(tooltipData, renderOptions);
      this.responders = this.getResponders(clockHandModels, solidModels, tooltipData, renderOptions.useClockHand);
    }
  }, {
    key: "renderSolidModels",
    value: function renderSolidModels(seriesData, clockHandModels, renderOptions) {
      var solidModels = [];
      this.models.clockHand = renderOptions.useClockHand ? clockHandModels : [];

      if (renderOptions.solidData.visible) {
        solidModels = this.renderSectors(seriesData, renderOptions);
        this.models.backgroundSolid = this.renderBackgroundSolid(renderOptions);
        this.models.solid = solidModels;
      }

      return solidModels;
    }
  }, {
    key: "initDrawModels",
    value: function initDrawModels() {
      var start = this.circularAxis.angle.start;
      this.drawModels = {
        clockHand: this.models.clockHand.map(function (m) {
          var _getRadialPosition2 = getRadialPosition(m.x, m.y, m.handSize, calculateDegreeToRadian(start)),
              x2 = _getRadialPosition2.x,
              y2 = _getRadialPosition2.y;

          return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
            x2: x2,
            y2: y2,
            testDegree: 0
          });
        }),
        backgroundSolid: this.models.backgroundSolid,
        solid: this.models.solid.map(function (m) {
          return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
            degree: gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m.degree), {}, {
              end: m.degree.start
            })
          });
        })
      };
    }
  }, {
    key: "getResponders",
    value: function getResponders(clockHandModels, sectorModels, tooltipData) {
      var useClockHand = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var clockHandResponders = !useClockHand ? [] : clockHandModels.map(function (m, index) {
        return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
          detectionSize: m.baseLine + DETECTION_SIZE_MARGIN,
          data: gaugeSeries_objectSpread({}, tooltipData[index])
        });
      });
      return sectorModels.length ? [].concat(gaugeSeries_toConsumableArray(sectorModels.map(function (m, index) {
        return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
          data: gaugeSeries_objectSpread({}, tooltipData[index])
        });
      })), gaugeSeries_toConsumableArray(clockHandResponders)) : clockHandResponders;
    }
  }, {
    key: "getHandSize",
    value: function getHandSize(size) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var maxClockHandSize = this.circularAxis.maxClockHandSize;

      if (size) {
        return Array.isArray(size) ? calculateSizeWithPercentString(maxClockHandSize, size[index]) : calculateSizeWithPercentString(maxClockHandSize, size);
      }

      return maxClockHandSize;
    }
  }, {
    key: "renderClockHands",
    value: function renderClockHands(seriesData, renderOptions) {
      var _this4 = this;

      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          totalAngle = renderOptions.totalAngle,
          clockwise = renderOptions.clockwise,
          scaleMaxLimitValue = renderOptions.scaleMaxLimitValue,
          categories = renderOptions.categories,
          drawingStartAngle = renderOptions.drawingStartAngle;
      var seriesModels = [];
      var _this$theme$clockHand = this.theme.clockHand,
          size = _this$theme$clockHand.size,
          baseLine = _this$theme$clockHand.baseLine,
          clockHandColor = _this$theme$clockHand.color;
      var _this$theme$pin = this.theme.pin,
          radius = _this$theme$pin.radius,
          pinColor = _this$theme$pin.color,
          borderWidth = _this$theme$pin.borderWidth,
          borderColor = _this$theme$pin.borderColor;
      seriesData.forEach(function (_ref4, seriesIndex) {
        var name = _ref4.name,
            data = _ref4.data,
            color = _ref4.color;

        var seriesColor = _this4.getSeriesColor(name, color);

        data.forEach(function (value, index) {
          var val = utils_isString(value) ? categories.findIndex(function (category) {
            return category === value;
          }) : value;
          var degree = drawingStartAngle + val / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
          var validDegree = calculateValidAngle(degree);

          var handSize = _this4.getHandSize(size, index);

          var _getRadialPosition3 = getRadialPosition(centerX, centerY, handSize, calculateDegreeToRadian(validDegree)),
              x2 = _getRadialPosition3.x,
              y2 = _getRadialPosition3.y;

          seriesModels.push({
            type: 'clockHand',
            color: clockHandColor !== null && clockHandColor !== void 0 ? clockHandColor : seriesColor,
            name: name,
            value: value,
            x: centerX,
            y: centerY,
            x2: x2,
            y2: y2,
            pin: {
              radius: radius,
              color: pinColor !== null && pinColor !== void 0 ? pinColor : seriesColor,
              style: [{
                strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(seriesColor, 0.1),
                lineWidth: borderWidth ? borderWidth + radius : 0
              }]
            },
            degree: validDegree,
            animationDegree: degree,
            baseLine: baseLine,
            handSize: handSize,
            seriesData: data,
            index: index,
            seriesIndex: seriesIndex
          });
        });
      });
      return seriesModels;
    }
  }, {
    key: "renderBackgroundSolid",
    value: function renderBackgroundSolid(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          startAngle = renderOptions.startAngle,
          totalAngle = renderOptions.totalAngle,
          clockwise = renderOptions.clockwise,
          solidData = renderOptions.solidData;
      var _ref5 = this.theme.solid.backgroundSolid,
          color = _ref5.color;
      return [{
        type: 'sector',
        color: color,
        x: centerX,
        y: centerY,
        clockwise: clockwise,
        degree: {
          start: startAngle,
          end: startAngle + totalAngle
        },
        radius: solidData.radiusRange
      }];
    }
  }, {
    key: "renderSectors",
    value: function renderSectors(seriesData, renderOptions) {
      var _this5 = this;

      var sectors = [];
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          clockwise = renderOptions.clockwise,
          totalAngle = renderOptions.totalAngle,
          scaleMaxLimitValue = renderOptions.scaleMaxLimitValue,
          startAngle = renderOptions.startAngle,
          categories = renderOptions.categories,
          solidData = renderOptions.solidData;
      var radiusRange = solidData.radiusRange;
      var _ref6 = this.theme.solid,
          lineWidth = _ref6.lineWidth,
          strokeStyle = _ref6.strokeStyle;
      seriesData.forEach(function (_ref7, index) {
        var name = _ref7.name,
            data = _ref7.data,
            color = _ref7.color;

        var seriesColor = _this5.getSeriesColor(name, color);

        var value = data[0];
        var val = utils_isString(value) ? categories.findIndex(function (category) {
          return category === value;
        }) : value;
        var degree = val / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
        var validDegree = calculateValidAngle(degree);
        var startDegree = startAngle;
        var endDegree = startDegree + degree;
        var animationStartDegree = startAngle;
        var animationEndDegree = animationStartDegree + validDegree;
        sectors.push({
          type: 'sector',
          color: seriesColor,
          x: centerX,
          y: centerY,
          clockwise: clockwise,
          degree: {
            start: startDegree,
            end: endDegree
          },
          radius: radiusRange,
          animationDegree: {
            start: animationStartDegree,
            end: animationEndDegree
          },
          drawingStartAngle: DEGREE_NEGATIVE_90,
          style: [{
            strokeStyle: strokeStyle
          }],
          lineWidth: lineWidth,
          index: index
        });
      });
      return sectors;
    }
  }, {
    key: "makeTooltipMap",
    value: function makeTooltipMap(tooltipData, renderOptions) {
      var _this$models = this.models,
          clockHand = _this$models.clockHand,
          solid = _this$models.solid;
      var useClockHand = renderOptions.useClockHand;
      return tooltipData.reduce(function (acc, data, index) {
        if (useClockHand) {
          acc.clockHand.push(gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, clockHand[index]), {}, {
            detectionSize: clockHand[index].baseLine + 3,
            data: data
          }));
        }

        if (solid[index]) {
          acc.solid.push(gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, solid[index]), {}, {
            data: data
          }));
        }

        return acc;
      }, {
        solid: [],
        clockHand: []
      });
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(hasCategoryAxis, categories, scale, options) {
      var _options$clockwise;

      var _this$circularAxis2 = this.circularAxis,
          centerX = _this$circularAxis2.centerX,
          centerY = _this$circularAxis2.centerY,
          solidData = _this$circularAxis2.solidData,
          _this$circularAxis2$a = _this$circularAxis2.angle,
          start = _this$circularAxis2$a.start,
          end = _this$circularAxis2$a.end,
          drawingStart = _this$circularAxis2$a.drawingStart,
          outer = _this$circularAxis2.radius.outer;
      var solid = this.circularAxis.solidData;
      var clockwise = (_options$clockwise = options === null || options === void 0 ? void 0 : options.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
      var totalAngle = getTotalAngle(clockwise, start, end);
      return {
        clockwise: clockwise,
        centerX: centerX,
        centerY: centerY,
        angleRange: {
          start: start,
          end: end
        },
        totalAngle: totalAngle,
        scaleMaxLimitValue: hasCategoryAxis ? categories.length : getScaleMaxLimitValue(scale.circularAxis, totalAngle),
        startAngle: start,
        categories: categories,
        drawingStartAngle: drawingStart,
        outerRadius: outer,
        useClockHand: solid.visible ? solid.clockHand : true,
        solidData: solidData
      };
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(name, color) {
      var _this$theme = this.theme,
          select = _this$theme.select,
          areaOpacity = _this$theme.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(seriesModels) {
      return seriesModels.reduce(function (acc, _ref8) {
        var color = _ref8.color,
            name = _ref8.name,
            value = _ref8.value,
            index = _ref8.index,
            seriesIndex = _ref8.seriesIndex;
        return isNull(value) ? acc : [].concat(gaugeSeries_toConsumableArray(acc), [{
          label: name,
          color: color,
          value: value,
          index: index,
          seriesIndex: seriesIndex
        }]);
      }, []);
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref9) {
      var responders = _ref9.responders;
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getResponderModelsWithTheme(this.getResponderModels(responders), 'hover'),
        name: this.name
      });
      this.activatedResponders = responders.map(function (responder) {
        return gaugeSeries_objectSpread({}, responder);
      });
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "getResponderModels",
    value: function getResponderModels(responders) {
      var _this$tooltipMap = this.tooltipMap,
          clockHand = _this$tooltipMap.clockHand,
          solid = _this$tooltipMap.solid;
      return responders.reduce(function (acc, responder) {
        var index = responder.index;
        var clockHandModel = clockHand[index] ? [clockHand[index]] : [];
        var solidModel = solid[index] ? [solid[index]] : [];
        return [].concat(gaugeSeries_toConsumableArray(acc), clockHandModel, solidModel);
      }, []);
    }
  }, {
    key: "onClick",
    value: function onClick(_ref10) {
      var responders = _ref10.responders;

      if (this.selectable) {
        var models = this.getResponderModelsWithTheme(this.getResponderModels(responders), 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderModelsWithSolidTheme",
    value: function getResponderModelsWithSolidTheme(responder, type) {
      var _solidTheme$color;

      var solidTheme = this.theme[type].solid;
      var lineWidth = solidTheme.lineWidth;
      var isSameLineWidth = this.theme.solid === lineWidth;
      var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
      return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, responder), {}, {
        color: (_solidTheme$color = solidTheme.color) !== null && _solidTheme$color !== void 0 ? _solidTheme$color : responder.color,
        lineWidth: lineWidth,
        style: [pick(solidTheme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')],
        radius: {
          inner: Math.max(responder.radius.inner - thickness, 0),
          outer: responder.radius.outer + thickness
        }
      });
    }
  }, {
    key: "getResponderWithClockHandTheme",
    value: function getResponderWithClockHandTheme(responder, type) {
      var _this$theme$type = this.theme[type],
          clockHand = _this$theme$type.clockHand,
          pin = _this$theme$type.pin;
      var _ref11 = clockHand,
          size = _ref11.size,
          baseLine = _ref11.baseLine,
          clockHandColor = _ref11.color;
      var _ref12 = pin,
          radius = _ref12.radius,
          pinColor = _ref12.color,
          borderWidth = _ref12.borderWidth,
          borderColor = _ref12.borderColor;
      var pinRadius = radius !== null && radius !== void 0 ? radius : responder.pin.radius;
      var pinStyle = [{
        strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(responder.pin.style[0].strokeStyle, 0.3),
        lineWidth: borderWidth ? borderWidth + pinRadius : 0
      }];
      return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, responder), {}, {
        color: clockHandColor !== null && clockHandColor !== void 0 ? clockHandColor : responder.color,
        pin: {
          radius: pinRadius,
          color: pinColor !== null && pinColor !== void 0 ? pinColor : responder.pin.color,
          style: pinStyle
        },
        baseLine: baseLine !== null && baseLine !== void 0 ? baseLine : responder.baseLine,
        handSize: size ? this.getHandSize(size, responder.index) : responder.handSize
      });
    }
  }, {
    key: "getResponderModelsWithTheme",
    value: function getResponderModelsWithTheme(responders, type) {
      var _this6 = this;

      return responders.map(function (m) {
        return (m === null || m === void 0 ? void 0 : m.type) === 'sector' ? _this6.getResponderModelsWithSolidTheme(m, type) : _this6.getResponderWithClockHandTheme(m, type);
      });
    }
  }]);

  return GaugeSeries;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/gauge.ts




function getClockHandPoints(model) {
  var x = model.x,
      y = model.y,
      x2 = model.x2,
      y2 = model.y2,
      degree = model.degree,
      baseLine = model.baseLine;
  var halfBaseLine = baseLine / 2;
  var startPoint, endPoint;

  if (x === x2) {
    startPoint = {
      x: x - halfBaseLine,
      y: y
    };
    endPoint = {
      x: x + halfBaseLine,
      y: y
    };
  } else if (y === y2) {
    startPoint = {
      x: x,
      y: y - halfBaseLine
    };
    endPoint = {
      x: x,
      y: y + halfBaseLine
    };
  } else {
    startPoint = getRadialPosition(x, y, halfBaseLine, calculateDegreeToRadian(calculateValidAngle(degree + DEGREE_90)));
    endPoint = getRadialPosition(x, y, halfBaseLine, calculateDegreeToRadian(calculateValidAngle(degree - DEGREE_90)));
  }

  return [startPoint, {
    x: x2,
    y: y2
  }, endPoint];
}

function clockHand(ctx, model) {
  var color = model.color,
      x = model.x,
      y = model.y,
      _model$pin = model.pin,
      pinColor = _model$pin.color,
      radius = _model$pin.radius,
      style = _model$pin.style;
  circle(ctx, {
    type: 'circle',
    x: x,
    y: y,
    radius: radius,
    color: pinColor,
    style: style
  });
  polygon(ctx, {
    type: 'polygon',
    color: color,
    lineWidth: 1,
    fillColor: color,
    points: getClockHandPoints(model)
  });
}
;// CONCATENATED MODULE: ./src/charts/gaugeChart.ts
function gaugeChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { gaugeChart_typeof = function _typeof(obj) { return typeof obj; }; } else { gaugeChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return gaugeChart_typeof(obj); }


















function gaugeChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function gaugeChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { gaugeChart_ownKeys(Object(source), true).forEach(function (key) { gaugeChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { gaugeChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function gaugeChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function gaugeChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function gaugeChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function gaugeChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) gaugeChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) gaugeChart_defineProperties(Constructor, staticProps); return Constructor; }

function gaugeChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { gaugeChart_get = Reflect.get; } else { gaugeChart_get = function _get(target, property, receiver) { var base = gaugeChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return gaugeChart_get(target, property, receiver || target); }

function gaugeChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = gaugeChart_getPrototypeOf(object); if (object === null) break; } return object; }

function gaugeChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) gaugeChart_setPrototypeOf(subClass, superClass); }

function gaugeChart_setPrototypeOf(o, p) { gaugeChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return gaugeChart_setPrototypeOf(o, p); }

function gaugeChart_createSuper(Derived) { var hasNativeReflectConstruct = gaugeChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = gaugeChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = gaugeChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return gaugeChart_possibleConstructorReturn(this, result); }; }

function gaugeChart_possibleConstructorReturn(self, call) { if (call && (gaugeChart_typeof(call) === "object" || typeof call === "function")) { return call; } return gaugeChart_assertThisInitialized(self); }

function gaugeChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function gaugeChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function gaugeChart_getPrototypeOf(o) { gaugeChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return gaugeChart_getPrototypeOf(o); }


























/**
 * @class
 * @classdesc Gauge Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Gauge Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Gauge Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *       @param {boolean | Object} [props.options.series.solid] - When this option is set, the radial bar is displayed. It can be used when there is one series data. The default value is 'false'.
 *     @param {Object} [props.options.circularAxis]
 *       @param {string|Object} [props.options.circularAxis.title] - Axis title.
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.circularAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 *       @param {Object} [props.options.theme.plot] - Plot Theme.
 * @extends Chart
 */
var GaugeChart = /*#__PURE__*/function (_Chart) {
  gaugeChart_inherits(GaugeChart, _Chart);

  var _super = gaugeChart_createSuper(GaugeChart);

  function GaugeChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    gaugeChart_classCallCheck(this, GaugeChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        gauge: data.series
      },
      categories: data.categories,
      modules: [store_dataRange, store_scale, gaugeAxes]
    });
  }

  gaugeChart_createClass(GaugeChart, [{
    key: "initialize",
    value: function initialize() {
      gaugeChart_get(gaugeChart_getPrototypeOf(GaugeChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(RadarPlot, {
        name: 'gauge'
      });
      this.componentManager.add(RadialAxis, {
        name: 'gauge'
      });
      this.componentManager.add(AxisTitle, {
        name: 'circularAxis'
      });
      this.componentManager.add(GaugeSeries);
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject, axis_namespaceObject, gauge_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 20],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} [category] - Category to be added.
     * @api
     * @example
     * // without categories
     * chart.addData([10], '6');
     *
     * // with categories
     * chart.addData([10], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.resetSeries();
      this.animationControlFlag.updating = true;
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          gauge: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 500,
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     selectable: true
     *   }
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     title: 'Olympic Medals',
     *   }
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', gaugeChart_objectSpread(gaugeChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     *   @param {Array<string|number>} data.range - The range to be drawn.
     *   @param {string} data.color - Plot band color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   range: [10, 20],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addGaugePlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removeGaugePlotBand', {
        id: id
      });
    }
  }]);

  return GaugeChart;
}(Chart);


;// CONCATENATED MODULE: ./src/index.ts
function src_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function src_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




















var src_Chart = function Chart() {
  src_classCallCheck(this, Chart);
};

src_defineProperty(src_Chart, "lineChart", function (props) {
  return new LineChart(props);
});

src_defineProperty(src_Chart, "areaChart", function (props) {
  return new AreaChart(props);
});

src_defineProperty(src_Chart, "barChart", function (props) {
  return new BarChart(props);
});

src_defineProperty(src_Chart, "boxPlotChart", function (props) {
  return new BoxPlotChart(props);
});

src_defineProperty(src_Chart, "columnChart", function (props) {
  return new ColumnChart(props);
});

src_defineProperty(src_Chart, "pieChart", function (props) {
  return new PieChart(props);
});

src_defineProperty(src_Chart, "heatmapChart", function (props) {
  return new HeatmapChart(props);
});

src_defineProperty(src_Chart, "bubbleChart", function (props) {
  return new BubbleChart(props);
});

src_defineProperty(src_Chart, "scatterChart", function (props) {
  return new ScatterChart(props);
});

src_defineProperty(src_Chart, "bulletChart", function (props) {
  return new BulletChart(props);
});

src_defineProperty(src_Chart, "radarChart", function (props) {
  return new RadarChart(props);
});

src_defineProperty(src_Chart, "treemapChart", function (props) {
  return new TreemapChart(props);
});

src_defineProperty(src_Chart, "nestedPieChart", function (props) {
  return new NestedPieChart(props);
});

src_defineProperty(src_Chart, "lineAreaChart", function (props) {
  return new LineAreaChart(props);
});

src_defineProperty(src_Chart, "lineScatterChart", function (props) {
  return new LineScatterChart(props);
});

src_defineProperty(src_Chart, "columnLineChart", function (props) {
  return new ColumnLineChart(props);
});

src_defineProperty(src_Chart, "radialBarChart", function (props) {
  return new RadialBarChart(props);
});

src_defineProperty(src_Chart, "gaugeChart", function (props) {
  return new GaugeChart(props);
});



}();
__webpack_exports__ = __webpack_exports__.default;
/******/ 	return __webpack_exports__;
/******/ })()
;
});