(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview  Axis component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    chartConst = require('../const'),
    calculator = require('../helpers/calculator'),
    renderUtil = require('../helpers/renderUtil'),
    axisTemplate = require('./axisTemplate');

var Axis = tui.util.defineClass(/** @lends Axis.prototype */ {
    /**
     * Axis component.
     * @constructs Axis
     * @param {object} params parameters
     *      @param {{
     *          labels: array.<string>,
     *          tickCount: number,
     *          isLabelAxis: boolean,
     *          isVertical: boolean
     *      }} params.data axis data
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     *      @param {object} params.options axis options
     */
    init: function(params) {
        tui.util.extend(this, params);
        /**
         * Axis view className
         */
        this.className = 'tui-chart-axis-area';
    },

    /**
     * To render axis area.
     * @param {HTMLElement} elAxisArea axis area element
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound axis bound
     * @param {object} data rendering data
     * @private
     */
    _renderAxisArea: function(elAxisArea, bound, data) {
        var theme = this.theme,
            isVertical = !!data.isVertical,
            isPositionRight = !!data.isPositionRight,
            options = this.options,
            dimension = bound.dimension,
            size = isVertical ? dimension.height : dimension.width,
            elTitleArea = this._renderTitleArea({
                title: options.title,
                theme: theme.title,
                isVertical: isVertical,
                isPositionRight: isPositionRight,
                size: size
            }),
            elLabelArea = this._renderLabelArea(data, size, dimension.width, bound.degree),
            elTickArea;

        this.data = data;
        this.bound = bound;

        if (!isVertical || !data.aligned) {
            elTickArea = this._renderTickArea(size);
        }
        renderUtil.renderDimension(elAxisArea, dimension);
        renderUtil.renderPosition(elAxisArea, bound.position);
        dom.addClass(elAxisArea, isVertical ? 'vertical' : 'horizontal');
        dom.addClass(elAxisArea, isPositionRight ? 'right' : '');
        dom.append(elAxisArea, [elTitleArea, elTickArea, elLabelArea]);
    },

    /**
     * To render axis component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound axis bound
     * @param {object} data rendering data
     * @returns {HTMLElement} axis area base element
     */
    render: function(bound, data) {
        var el = dom.create('DIV', this.className);
        this._renderAxisArea(el, bound, data);
        this.elAxisArea = el;
        return el;
    },

    /**
     * To resize axis component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound axis bound
     * @param {object} data rendering data
     */
    resize: function(bound, data) {
        this.elAxisArea.innerHTML = '';
        this._renderAxisArea(this.elAxisArea, bound, data);
    },

    /**
     * Render css style of title area
     * @param {HTMLElement} elTitleArea title element
     * @param {number} size (width or height)
     * @param {boolean} isPositionRight whether right position or not?
     * @private
     */
    _renderTitleAreaStyle: function(elTitleArea, size, isPositionRight) {
        var cssTexts = [
            renderUtil.concatStr('width:', size, 'px')
        ];

        if (isPositionRight) {
            cssTexts.push(renderUtil.concatStr('right:', -size, 'px'));
            cssTexts.push(renderUtil.concatStr('top:', 0, 'px'));
        } else {
            cssTexts.push(renderUtil.concatStr('left:', 0, 'px'));
            if (!renderUtil.isOldBrowser()) {
                cssTexts.push(renderUtil.concatStr('top:', size, 'px'));
            }
        }

        elTitleArea.style.cssText += ';' + cssTexts.join(';');
    },

    /**
     * Title area renderer
     * @param {object} params parameters
     *      @param {string} params.title axis title
     *      @param {object} params.theme title theme
     *      @param {boolean} params.isVertical whether vertical or not?
     *      @param {boolean} params.isPositionRight whether right position or not?
     *      @param {number} params.size (width or height)
     * @returns {HTMLElement} title element
     * @private
     */
    _renderTitleArea: function(params) {
        var elTitleArea = renderUtil.renderTitle(params.title, params.theme, 'tui-chart-title-area');

        if (elTitleArea && params.isVertical) {
            this._renderTitleAreaStyle(elTitleArea, params.size, params.isPositionRight);
        }

        return elTitleArea;
    },

    /**
     * Redner tick area.
     * @param {number} size size or height
     * @returns {HTMLElement} tick area element
     * @private
     */
    _renderTickArea: function(size) {
        var data = this.data,
            tickCount = data.tickCount,
            tickColor = this.theme.tickColor,
            positions = calculator.makeTickPixelPositions(size, tickCount),
            elTickArea = dom.create('DIV', 'tui-chart-tick-area'),
            posType = data.isVertical ? 'bottom' : 'left',
            borderColorType = data.isVertical ? (data.isPositionRight ? 'borderLeftColor' : 'borderRightColor') : 'borderTopColor',
            template = axisTemplate.tplAxisTick,
            ticksHtml = tui.util.map(positions, function(position, index) {
                var cssText;
                if (data.aligned && data.labels[index] === chartConst.EMPTY_AXIS_LABEL) {
                    return '';
                }
                cssText = [
                    renderUtil.concatStr('background-color:', tickColor),
                    renderUtil.concatStr(posType, ': ', position, 'px')
                ].join(';');
                return template({cssText: cssText});
            }, this).join('');

        elTickArea.innerHTML = ticksHtml;
        elTickArea.style[borderColorType] = tickColor;

        return elTickArea;
    },

    /**
     * To make cssText of vertical label.
     * @param {number} axisWidth axis width
     * @param {number} titleAreaWidth title area width
     * @returns {string} cssText
     * @private
     */
    _makeVerticalLabelCssText: function(axisWidth, titleAreaWidth) {
        return ';width:' + (axisWidth - titleAreaWidth + chartConst.V_LABEL_RIGHT_PADDING) + 'px';
    },

    /**
     * Render label area.
     * @param {object} data rendering data
     * @param {number} size label area size
     * @param {number} axisWidth axis area width
     * @param {number} degree rotation degree
     * @returns {HTMLElement} label area element
     * @private
     */
    _renderLabelArea: function(data, size, axisWidth, degree) {
        var tickPixelPositions = calculator.makeTickPixelPositions(size, data.tickCount),
            labelSize = tickPixelPositions[1] - tickPixelPositions[0],
            posType = 'left',
            cssTexts = this._makeLabelCssTexts({
                isVertical: data.isVertical,
                isLabelAxis: data.isLabelAxis,
                labelSize: labelSize
            }),
            elLabelArea = dom.create('DIV', 'tui-chart-label-area'),
            areaCssText = renderUtil.makeFontCssText(this.theme.label),
            labelsHtml, titleAreaWidth;

        if (data.isVertical) {
            posType = data.isLabelAxis ? 'top' : 'bottom';
            titleAreaWidth = this._getRenderedTitleHeight() + chartConst.TITLE_AREA_WIDTH_PADDING;
            areaCssText += this._makeVerticalLabelCssText(axisWidth, titleAreaWidth);
        }

        tickPixelPositions.length = data.labels.length;

        labelsHtml = this._makeLabelsHtml({
            positions: tickPixelPositions,
            labels: data.labels,
            posType: posType,
            cssTexts: cssTexts,
            labelSize: labelSize,
            degree: degree,
            theme: this.theme.label
        });

        elLabelArea.innerHTML = labelsHtml;
        elLabelArea.style.cssText = areaCssText;

        this._changeLabelAreaPosition({
            elLabelArea: elLabelArea,
            isVertical: data.isVertical,
            isLabelAxis: data.isLabelAxis,
            theme: this.theme.label,
            labelSize: labelSize,
            aligned: data.aligned
        });

        return elLabelArea;
    },

    /**
     * Get height of title area ;
     * @returns {number} height
     * @private
     */
    _getRenderedTitleHeight: function() {
        var title = this.options.title,
            theme = this.theme.title,
            result = title ? renderUtil.getRenderedLabelHeight(title, theme) : 0;
        return result;
    },

    /**
     * To make cssTexts of label.
     * @param {object} params parameter
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {boolean} params.isLabelAxis whether label axis or not
     *      @param {number} params.labelSize label size (width or height)
     * @returns {string[]} cssTexts
     * @private
     */
    _makeLabelCssTexts: function(params) {
        var cssTexts = [];

        if (params.isVertical && params.isLabelAxis) {
            cssTexts.push(renderUtil.concatStr('height:', params.labelSize, 'px'));
            cssTexts.push(renderUtil.concatStr('line-height:', params.labelSize, 'px'));
        } else if (!params.isVertical) {
            cssTexts.push(renderUtil.concatStr('width:', params.labelSize, 'px'));
        }

        return cssTexts;
    },

    /**
     * To calculate rotation moving position.
     * @param {object} params parameters
     *      @param {number} params.degree rotation degree
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {number} params.moveLeft move left
     *      @param {number} params.top top
     * @returns {{top:number, left: number}} position
     * @private
     */
    _calculateRotationMovingPosition: function(params) {
        var moveLeft = params.moveLeft;
        if (params.degree === chartConst.ANGLE_85) {
            moveLeft += calculator.calculateAdjacent(chartConst.ANGLE_90 - params.degree, params.labelHeight / 2);
        }

        return {
            top: params.top,
            left: params.left - moveLeft
        };
    },

    /**
     * To calculate rotation moving position for ie8.
     * @param {object} params parameters
     *      @param {number} params.degree rotation degree
     *      @param {number} params.labelWidth label width
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {(string | number)} params.label label
     *      @param {object} theme label theme
     * @returns {{top:number, left: number}} position
     * @private
     */
    _calculateRotationMovingPositionForIE8: function(params) {
        var labelWidth = renderUtil.getRenderedLabelWidth(params.label, params.theme),
            smallAreaWidth = calculator.calculateAdjacent(chartConst.ANGLE_90 - params.degree, params.labelHeight / 2),
            newLabelWidth = (calculator.calculateAdjacent(params.degree, labelWidth / 2) + smallAreaWidth) * 2,
            collectLeft = labelWidth - newLabelWidth,
            moveLeft = (params.labelWidth / 2) - (smallAreaWidth * 2);

        if (params.degree === chartConst.ANGLE_85) {
            moveLeft += smallAreaWidth;
        }

        return {
            top: chartConst.XAXIS_LABEL_TOP_MARGIN,
            left: params.left + collectLeft - moveLeft
        };
    },

    /**
     * To make cssText for rotation moving.
     * @param {object} params parameters
     *      @param {number} params.degree rotation degree
     *      @param {number} params.labelWidth label width
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {number} params.moveLeft move left
     *      @param {number} params.top top
     *      @param {(string | number)} params.label label
     *      @param {object} theme label theme
     * @returns {string} cssText
     * @private
     */
    _makeCssTextForRotationMoving: function(params) {
        var position;
        if (renderUtil.isOldBrowser()) {
            position = this._calculateRotationMovingPositionForIE8(params);
        } else {
            position = this._calculateRotationMovingPosition(params);
        }
        return renderUtil.concatStr('left:', position.left, 'px', ';top:', position.top, 'px');
    },

    /**
     * To make html of rotation labels.
     * @param {object} params parameters
     *      @param {array.<object>} params.positions label position array
     *      @param {string[]} params.labels label array
     *      @param {string} params.posType position type (left or bottom)
     *      @param {string[]} params.cssTexts css array
     * @returns {string} labels html
     * @private
     */
    _makeRotationLabelsHtml: function(params) {
        var template = axisTemplate.tplAxisLabel,
            labelHeight = renderUtil.getRenderedLabelHeight(params.labels[0], params.theme),
            labelCssText = params.cssTexts.length ? params.cssTexts.join(';') + ';' : '',
            addClass = ' rotation' + params.degree,
            halfWidth = params.labelSize / 2,
            moveLeft = calculator.calculateAdjacent(params.degree, halfWidth),
            top = calculator.calculateOpposite(params.degree, halfWidth) + chartConst.XAXIS_LABEL_TOP_MARGIN,
            labelsHtml = tui.util.map(params.positions, function(position, index) {
                var label = params.labels[index],
                    rotationCssText = this._makeCssTextForRotationMoving({
                        degree: params.degree,
                        labelHeight: labelHeight,
                        labelWidth: params.labelSize,
                        top: top,
                        left: position,
                        moveLeft: moveLeft,
                        label: label,
                        theme: params.theme
                    });

                return template({
                    addClass: addClass,
                    cssText: labelCssText + rotationCssText,
                    label: label
                });
            }, this).join('');

        return labelsHtml;
    },

    /**
     * To make html of normal labels.
     * @param {object} params parameters
     *      @param {array.<object>} params.positions label position array
     *      @param {string[]} params.labels label array
     *      @param {string} params.posType position type (left or bottom)
     *      @param {string[]} params.cssTexts css array
     * @returns {string} labels html
     * @private
     */
    _makeNormalLabelsHtml: function(params) {
        var template = axisTemplate.tplAxisLabel,
            labelCssText = params.cssTexts.length ? params.cssTexts.join(';') + ';' : '',
            labelsHtml = tui.util.map(params.positions, function(position, index) {
                var addCssText = renderUtil.concatStr(params.posType, ':', position, 'px');
                return template({
                    addClass: '',
                    cssText: labelCssText + addCssText,
                    label: params.labels[index]
                });
            }, this).join('');
        return labelsHtml;
    },

    /**
     * To make html of labels.
     * @param {object} params parameters
     *      @param {array.<object>} params.positions label position array
     *      @param {string[]} params.labels label array
     *      @param {string} params.posType position type (left or bottom)
     *      @param {string[]} params.cssTexts css array
     * @returns {string} labels html
     * @private
     */
    _makeLabelsHtml: function(params) {
        var labelsHtml;
        if (params.degree) {
            labelsHtml = this._makeRotationLabelsHtml(params);
        } else {
            labelsHtml = this._makeNormalLabelsHtml(params);
        }

        return labelsHtml;
    },

    /**
     * Change position of label area.
     * @param {object} params parameter
     *      @param {HTMLElement} params.elLabelArea label area element
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {boolean} params.isLabelAxis whether label axis or not
     *      @param {{fontSize: number, fontFamily: string, color: string}} params.theme label theme
     *      @param {number} params.labelSize label size (width or height)
     * @private
     */
    _changeLabelAreaPosition: function(params) {
        var labelHeight;

        if (params.isLabelAxis && !params.aligned) {
            return;
        }

        if (params.isVertical) {
            labelHeight = renderUtil.getRenderedLabelHeight('ABC', params.theme);
            params.elLabelArea.style.top = renderUtil.concatStr(parseInt(labelHeight / 2, 10), 'px');
        } else {
            params.elLabelArea.style.left = renderUtil.concatStr('-', parseInt(params.labelSize / 2, 10), 'px');
        }
    }
});

module.exports = Axis;

},{"../const":15,"../helpers/calculator":28,"../helpers/domHandler":30,"../helpers/renderUtil":33,"./axisTemplate":2}],2:[function(require,module,exports){
/**
 * @fileoverview This is templates or axis view.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_AXIS_TICK: '<div class="tui-chart-tick" style="{{ cssText }}"></div>',
    HTML_AXIS_LABEL: '<div class="tui-chart-label{{ addClass }}" style="{{ cssText }}"><span>{{ label }}</span></div>'
};

module.exports = {
    tplAxisTick: templateMaker.template(tags.HTML_AXIS_TICK),
    tplAxisLabel: templateMaker.template(tags.HTML_AXIS_LABEL)
};

},{"../helpers/templateMaker":34}],3:[function(require,module,exports){
/**
 * @fileoverview chart.js is entry point of Toast UI Chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var chartConst = require('./const'),
    chartFactory = require('./factories/chartFactory'),
    pluginFactory = require('./factories/pluginFactory'),
    themeFactory = require('./factories/themeFactory');

var _createChart;

require('./polyfill');
require('./code-snippet-util');
require('./registerCharts');
require('./registerThemes');

/**
 * NHN Entertainment Toast UI Chart.
 * @namespace tui.chart
 */
tui.util.defineNamespace('tui.chart');

/**
 * Create chart.
 * @param {HTMLElement} container container
 * @param {array.<array>} data chart data
 * @param {{
 *   chart: {
 *     width: number,
 *     height: number,
 *     title: string,
 *     format: string
 *   },
 *   yAxis: {
 *     title: string,
 *     min: number
 *   },
 *   xAxis: {
 *     title: strig,
 *     min: number
 *   },
 *   tooltip: {
 *     suffix: string,
 *     template: string
 *   },
 *   theme: string
 * }} options chart options
 * @returns {object} chart instance.
 * @private
 * @ignore
 */
_createChart = function(container, data, options) {
    var themeName, theme, chart;
    options = options || {};
    themeName = options.theme || chartConst.DEFAULT_THEME_NAME;
    theme = themeFactory.get(themeName);

    chart = chartFactory.get(options.chartType, data, theme, options);
    container.appendChild(chart.render());
    chart.animateChart();

    return chart;
};

/**
 * Bar chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {array.<string>} data.categories categories
 *      @param {array.<array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.labelInterval label interval of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.min minimal value of horizontal axis
 *          @param {number} options.xAxis.max maximum value of horizontal axis
 *      @param {object} options.series options of series
 *          @param {string} options.series.stacked stacked type
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {number} options.series.barWidth bar width
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {string} options.tooltip.template template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Bar Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.barChart(container, data, options);
 */
tui.chart.barChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_BAR;
    return _createChart(container, data, options);
};

/**
 * Column chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {array.<string>} data.categories categories
 *      @param {array.<array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *      @param {object} options.series options of series
 *          @param {string} options.series.stacked stacked type
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {number} options.series.barWidth bar width
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {string} options.tooltip.template template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} column chart
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Column Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.columnChart(container, data, options);
 */
tui.chart.columnChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_COLUMN;
    return _createChart(container, data, options);
};

/**
 * Line chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {array.<string>} data.categories categories
 *      @param {array.<array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.hasDot whether has dot or not
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {string} options.tooltip.template template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Line Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       },
 *       series: {
 *         hasDot: true
 *       }
 *     };
 * tui.chart.lineChart(container, data, options);
 */
tui.chart.lineChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_LINE;
    return _createChart(container, data, options);
};

/**
 * Area chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {array.<string>} data.categories categories
 *      @param {array.<array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.hasDot whether has dot or not
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {string} options.tooltip.template template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Area Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.areaChart(container, data, options);
 */
tui.chart.areaChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_AREA;
    return _createChart(container, data, options);
};

/**
 * Combo chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {array.<string>} data.categories categories
 *      @param {array.<array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object[]} options.yAxis options of vertical axis
 *          @param {string} options.yAxis[].title title of vertical axis
 *          @param {number} options.yAxis[].min minimal value of vertical axis
 *          @param {number} options.yAxis[].max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *      @param {object} options.series options of series
 *          @param {object} options.series.column options of column series
 *              @param {string} options.series.column.stacked stacked type
 *              @param {boolean} options.series.column.showLabel whether show label or not
 *              @param {number} options.series.column.barWidth bar width
 *              @param {boolean} options.series.column.hasSelection whether has selection or not
 *          @param {object} options.series.line options of line series
 *              @param {boolean} options.series.line.hasDot whether has dot or not
 *              @param {boolean} options.series.line.showLabel whether show label or not
 *              @param {boolean} options.series.line.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {object} options.tooltip.column options of column tooltip
 *              @param {string} options.tooltip.column.suffix suffix of tooltip
 *              @param {string} options.tooltip.column.template template of tooltip
 *              @param {string} options.tooltip.column.align tooltip align option
 *              @param {object} options.tooltip.column.position relative position
 *                  @param {number} options.tooltip.column.position.left position left
 *                  @param {number} options.tooltip.column.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: {
 *         column: [
 *           {
 *             name: 'Legend1',
 *             data: [20, 30, 50]]
 *           },
 *           {
 *             name: 'Legend2',
 *             data: [40, 40, 60]
 *           },
 *           {
 *             name: 'Legend3',
 *             data: [60, 50, 10]
 *           },
 *           {
 *             name: 'Legend4',
 *             data: [80, 10, 70]
 *           }
 *         },
 *         line: [
 *           {
 *             name: 'Legend5',
 *             data: [1, 2, 3]
 *           }
 *         ]
 *       }
 *     },
 *     options = {
 *       chart: {
 *         title: 'Combo Chart'
 *       },
 *       yAxis:[
 *         {
 *           title: 'Y Axis',
 *           chartType: 'line'
 *         },
 *         {
 *           title: 'Y Right Axis'
 *         }
 *       ],
 *       xAxis: {
 *         title: 'X Axis'
 *       },
 *       series: {
 *         hasDot: true
 *       }
 *     };
 * tui.chart.comboChart(container, data, options);
 */
tui.chart.comboChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_COMBO;
    return _createChart(container, data, options);
};

/**
 * Pie chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {array.<array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {string} options.tooltip.template template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: 20
 *         },
 *         {
 *           name: 'Legend2',
 *           data: 40
 *         },
 *         {
 *           name: 'Legend3',
 *           data: 60
 *         },
 *         {
 *           name: 'Legend4',
 *           data: 80
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Pie Chart'
 *       }
 *     };
 * tui.chart.pieChart(container, data, options);
 */
tui.chart.pieChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_PIE;
    return _createChart(container, data, options);
};

/**
 * Register theme.
 * @memberOf tui.chart
 * @param {string} themeName theme name
 * @param {object} theme application chart theme
 *      @param {object} theme.chart chart theme
 *          @param {string} theme.chart.fontFamily font family of chart
 *          @param {string} theme.chart.background background of chart
 *      @param {object} theme.title chart theme
 *          @param {number} theme.title.fontSize font size of chart title
 *          @param {string} theme.title.fontFamily font family of chart title
 *          @param {string} theme.title.color font color of chart title
 *          @param {string} theme.title.background background of chart title
 *      @param {object} theme.yAxis theme of vertical axis
 *          @param {object} theme.yAxis.title theme of vertical axis title
 *              @param {number} theme.yAxis.title.fontSize font size of vertical axis title
 *              @param {string} theme.yAxis.title.fontFamily font family of vertical axis title
 *              @param {string} theme.yAxis.title.color font color of vertical axis title
 *          @param {object} theme.yAxis.label theme of vertical axis label
 *              @param {number} theme.yAxis.label.fontSize font size of vertical axis label
 *              @param {string} theme.yAxis.label.fontFamily font family of vertical axis label
 *              @param {string} theme.yAxis.label.color font color of vertical axis label
 *          @param {string} theme.yAxis.tickcolor color of vertical axis tick
 *      @param {object} theme.xAxis theme of horizontal axis
 *          @param {object} theme.xAxis.title theme of horizontal axis title
 *              @param {number} theme.xAxis.title.fontSize font size of horizontal axis title
 *              @param {string} theme.xAxis.title.fontFamily font family of horizontal axis title
 *              @param {string} theme.xAxis.title.color font color of horizontal axis title
 *          @param {object} theme.xAxis.label theme of horizontal axis label
 *              @param {number} theme.xAxis.label.fontSize font size of horizontal axis label
 *              @param {string} theme.xAxis.label.fontFamily font family of horizontal axis label
 *              @param {string} theme.xAxis.label.color font color of horizontal axis label
 *          @param {string} theme.xAxis.tickcolor color of horizontal axis tick
 *      @param {object} theme.plot plot theme
 *          @param {string} theme.plot.lineColor plot line color
 *          @param {string} theme.plot.background plot background
 *      @param {object} theme.series series theme
 *          @param {array.<string>} theme.series.colors series colors
 *          @param {string} theme.series.borderColor series border color
 *      @param {object} theme.legend legend theme
 *          @param {object} theme.legend.label theme of legend label
 *              @param {number} theme.legend.label.fontSize font size of legend label
 *              @param {string} theme.legend.label.fontFamily font family of legend label
 *              @param {string} theme.legend.label.color font color of legend label
 * @example
 * var theme = {
 *   yAxis: {
 *     tickColor: '#ccbd9a',
 *       title: {
 *         color: '#333333'
 *       },
 *       label: {
 *         color: '#6f491d'
 *       }
 *     },
 *     xAxis: {
 *       tickColor: '#ccbd9a',
 *       title: {
 *         color: '#333333'
 *       },
 *       label: {
 *         color: '#6f491d'
 *       }
 *     },
 *     plot: {
 *       lineColor: '#e5dbc4',
 *       background: '#f6f1e5'
 *     },
 *     series: {
 *       colors: ['#40abb4', '#e78a31', '#c1c452', '#795224', '#f5f5f5'],
 *       borderColor: '#8e6535',
 *       selectionColor: '#cccccc',
 *     },
 *     legend: {
 *       label: {
 *         color: '#6f491d'
 *       }
 *     }
 *   };
 * chart.registerTheme('newTheme', theme);
 */
tui.chart.registerTheme = function(themeName, theme) {
    themeFactory.register(themeName, theme);
};

/**
 * Register graph plugin.
 * @memberOf tui.chart
 * @param {string} libType type of graph library
 * @param {object} plugin plugin to control library
 * @example
 * var pluginRaphael = {
 *   bar: function() {} // Render class
 * };
 * tui.chart.registerPlugin('raphael', pluginRaphael);
 */
tui.chart.registerPlugin = function(libType, plugin) {
    pluginFactory.register(libType, plugin);
};

},{"./code-snippet-util":14,"./const":15,"./factories/chartFactory":23,"./factories/pluginFactory":24,"./factories/themeFactory":25,"./polyfill":47,"./registerCharts":48,"./registerThemes":49}],4:[function(require,module,exports){
/**
 * @fileoverview Area chart
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    lineTypeMixer = require('./lineTypeMixer'),
    axisTypeMixer = require('./axisTypeMixer'),
    verticalTypeMixer = require('./verticalTypeMixer'),
    Series = require('../series/areaChartSeries');

var AreaChart = tui.util.defineClass(ChartBase, /** @lends LineChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-area-chart',

    /**
     * Series class
     * @type {function}
     */
    Series: Series,

    /**
     * Area chart.
     * @constructs AreaChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes verticalTypeMixer
     * @mixes lineTypeMixer
     */
    init: function() {
        this._lineTypeInit.apply(this, arguments);
    }
});

axisTypeMixer.mixin(AreaChart);
verticalTypeMixer.mixin(AreaChart);
lineTypeMixer.mixin(AreaChart);

module.exports = AreaChart;

},{"../series/areaChartSeries":50,"./axisTypeMixer":5,"./chartBase":7,"./lineTypeMixer":11,"./verticalTypeMixer":13}],5:[function(require,module,exports){
/**
 * @fileoverview axisTypeMixer is mixer of axis type chart(bar, column, line, area).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil'),
    Axis = require('../axes/axis'),
    Plot = require('../plots/plot'),
    Legend = require('../legends/legend'),
    GroupTypeCustomEvent = require('../customEvents/groupTypeCustomEvent'),
    PointTypeCustomEvent = require('../customEvents/pointTypeCustomEvent'),
    Tooltip = require('../tooltips/tooltip'),
    GroupTooltip = require('../tooltips/groupTooltip');

/**
 * axisTypeMixer is base class of axis type chart(bar, column, line, area).
 * @mixin
 */
var axisTypeMixer = {
    /**
     * Add axis components.
     * @param {array.<string>} axisNames axis names
     * @param {boolean} aligned whether aligned or not
     * @private
     */
    _addAxisComponents: function(axisNames, aligned) {
        tui.util.forEach(axisNames, function(name) {
            var axisParams = {
                aligned: aligned
            };
            if (name === 'yrAxis') {
                axisParams.componentType = 'yAxis';
                axisParams.index = 1;
            }
            this._addComponent(name, Axis, axisParams);
        }, this);
    },

    /**
     * Add series components
     * @param {array<object>} serieses serieses
     * @param {object} options options
     * @param {boolean} aligned whether aligned or not
     * @private
     */
    _addSeriesComponents: function(serieses, options, aligned) {
        var seriesBaseParams = {
            libType: options.libType,
            chartType: options.chartType,
            parentChartType: options.parentChartType,
            aligned: aligned,
            hasGroupTooltip: this.hasGroupTooltip,
            userEvent: this.userEvent,
            componentType: 'series'
        };

        tui.util.forEach(serieses, function(series) {
            var seriesParams = tui.util.extend(seriesBaseParams, series.data);
            this._addComponent(series.name, series.SeriesClass, seriesParams);
        }, this);
    },

    /**
     * Add tooltip component
     * @param {object} convertedData convertedData
     * @param {object} options options
     * @private
     */
    _addTooltipComponent: function(convertedData, options) {
        if (this.hasGroupTooltip) {
            this._addComponent('tooltip', GroupTooltip, {
                labels: convertedData.labels,
                joinFormattedValues: convertedData.joinFormattedValues,
                joinLegendLabels: convertedData.joinLegendLabels,
                isVertical: this.isVertical,
                userEvent: this.userEvent
            });
        } else {
            this._addComponent('tooltip', Tooltip, {
                values: convertedData.values,
                formattedValues: convertedData.formattedValues,
                labels: convertedData.labels,
                legendLabels: convertedData.legendLabels,
                joinLegendLabels: convertedData.joinLegendLabels,
                chartType: options.chartType,
                isVertical: this.isVertical,
                userEvent: this.userEvent
            });
        }
    },

    /**
     * Add legend component.
     * @param {object} convertedData convertedData
     * @param {array.<string>} seriesChartTypes series chart types
     * @param {string} chartType chartType
     * @param {object} legendOptions legend options
     * @private
     */
    _addLegendComponent: function(convertedData, seriesChartTypes, chartType, legendOptions) {
        if (!legendOptions || !legendOptions.hidden) {
            this._addComponent('legend', Legend, {
                joinLegendLabels: convertedData.joinLegendLabels,
                legendLabels: convertedData.legendLabels,
                seriesChartTypes: seriesChartTypes,
                chartType: chartType,
                userEvent: this.userEvent
            });
        }
    },

    /**
     * Add components for axis type chart.
     * @param {object} params parameters
     *      @param {object} params.convertedData converted data
     *      @param {object} params.axes axes data
     *      @param {object} params.plotData plot data
     *      @param {function} params.serieses serieses
     * @private
     */
    _addComponentsForAxisType: function(params) {
        var convertedData = params.convertedData,
            options = this.options,
            aligned = !!params.aligned;

        this._addComponent('plot', Plot);
        this._addAxisComponents(params.axes, aligned);
        this._addLegendComponent(convertedData, params.seriesChartTypes, params.chartType, this.options.legend);
        this._addSeriesComponents(params.serieses, options, aligned);
        this._addTooltipComponent(convertedData, options);
    },

    /**
     * Get scales.
     * @param {{yAxis: object, xAxis: object}} axesData axes data
     * @param {array.<string>} chartTypes chart types
     * @returns {array.<{min: number, max: number}>} scales
     * @param {boolean} isVertical whether vertical or not
     * @private
     */
    _getScales: function(axesData, chartTypes, isVertical) {
        var scales = {},
            yAxisScale = axesData.yAxis.scale;

        scales[chartTypes[0]] = isVertical ? yAxisScale : axesData.xAxis.scale;

        if (chartTypes.length > 1) {
            scales[chartTypes[1]] = axesData.yrAxis ? axesData.yrAxis.scale : yAxisScale;
        }

        return scales;
    },

    /**
     * To make series data for rendering.
     * @param {{yAxis: object, xAxis: object}} axesData axes data
     * @param {array.<string>} chartTypes chart types
     * @param {boolean} isVertical whether vertical or not
     * @returns {object} series data
     * @private
     */
    _makeSeriesDataForRendering: function(axesData, chartTypes, isVertical) {
        var scales = this._getScales(axesData, chartTypes, isVertical),
            aligned = axesData.xAxis.aligned,
            seriesData = {};

        tui.util.forEachArray(chartTypes, function(chartType) {
            var key = chartTypes.length > 1 ? chartType + 'Series' : 'series';
            seriesData[key] = {
                scale: scales[chartType],
                aligned: aligned
            };
        });
        return seriesData;
    },

    /**
     * To make rendering data for axis type chart.
     * @param {object} bounds chart bounds
     * @param {object} convertedData convertedData
     * @param {object} options options
     * @return {object} data for rendering
     * @private
     * @override
     */
    _makeRenderingData: function(bounds, convertedData, options) {
        var axesData = this._makeAxesData(convertedData, bounds, options),
            optionChartTypes = this.chartTypes || [this.chartType],
            seriesData = this._makeSeriesDataForRendering(axesData, optionChartTypes, this.isVertical);

        return tui.util.extend({
            plot: {
                vTickCount: axesData.yAxis.validTickCount,
                hTickCount: axesData.xAxis.validTickCount
            },
            customEvent: {
                tickCount: this.isVertical ? axesData.xAxis.tickCount : axesData.yAxis.tickCount
            },
            tooltip: {
                chartDimension: bounds.chart.dimension
            }
        }, seriesData, axesData);
    },

    /**
     * Add grouped event handler layer.
     * @param {{yAxis: obejct, xAxis: object}} axesData axes data
     * @param {string} chartType chart type
     * @param {boolean} isVertical whether vertical or not
     * @private
     * @override
     */
    _addCustomEventComponentForGroupTooltip: function() {
        this._addComponent('customEvent', GroupTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add custom event component for normal tooltip.
     * @private
     */
    _addCustomEventComponentForNormalTooltip: function() {
        this._addComponent('customEvent', PointTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add custom event component.
     * @private
     */
    _addCustomEventComponent: function() {
        if (this.hasGroupTooltip) {
            this._addCustomEventComponentForGroupTooltip();
        } else {
            this._addCustomEventComponentForNormalTooltip();
        }
    },

    /**
     * Attach coordinate event.
     * @private
     */
    _attachCustomEventForGroupTooltip: function() {
        var customEvent = this.componentMap.customEvent,
            tooltip = this.componentMap.tooltip,
            serieses = tui.util.filter(this.componentMap, function(component) {
                return component.componentType === 'series';
            });
        customEvent.on('showGroupTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideGroupTooltip', tooltip.onHide, tooltip);

        tui.util.forEach(serieses, function(series) {
            if (series.onShowGroupTooltipLine) {
                tooltip.on('showGroupTooltipLine', series.onShowGroupTooltipLine, series);
                tooltip.on('hideGroupTooltipLine', series.onHideGroupTooltipLine, series);
            }
            tooltip.on('showGroupAnimation', series.onShowGroupAnimation, series);
            tooltip.on('hideGroupAnimation', series.onHideGroupAnimation, series);
        }, this);
    },

    /**
     * To attach custom event for normal tooltip.
     * @private
     */
    _attachCustomEventForNormalTooltip: function() {
        var customEvent = this.componentMap.customEvent,
            tooltip = this.componentMap.tooltip,
            serieses = tui.util.filter(this.componentMap, function(component) {
                return component.componentType === 'series';
            });

        customEvent.on('showTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideTooltip', tooltip.onHide, tooltip);

        tui.util.forEach(serieses, function(series) {
            if (series.onShowAnimation) {
                tooltip.on(renderUtil.makeCustomEventName('show', series.chartType, 'animation'), series.onShowAnimation, series);
                tooltip.on(renderUtil.makeCustomEventName('hide', series.chartType, 'animation'), series.onHideAnimation, series);
            }
        }, this);
    },

    /**
     * To attach custom event for series selection.
     * @private
     */
    _attachCustomEventForSeriesSelection: function() {
        var customEvent = this.componentMap.customEvent,
            serieses = tui.util.filter(this.componentMap, function(component) {
                return component.componentType === 'series';
            });
        tui.util.forEach(serieses, function(series) {
            customEvent.on(renderUtil.makeCustomEventName('select', series.chartType, 'series'), series.onSelectSeries, series);
            customEvent.on(renderUtil.makeCustomEventName('unselect', series.chartType, 'series'), series.onUnselectSeries, series);
        }, this);
    },

    /**
     * Attach custom event.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        if (this.hasGroupTooltip) {
            this._attachCustomEventForGroupTooltip();
        } else {
            this._attachCustomEventForNormalTooltip();
        }

        this._attachCustomEventForSeriesSelection();
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = axisTypeMixer;

},{"../axes/axis":1,"../customEvents/groupTypeCustomEvent":19,"../customEvents/pointTypeCustomEvent":20,"../helpers/predicate":32,"../helpers/renderUtil":33,"../legends/legend":36,"../plots/plot":38,"../tooltips/groupTooltip":60,"../tooltips/tooltip":62}],6:[function(require,module,exports){
/**
 * @fileoverview Bar chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    axisTypeMixer = require('./axisTypeMixer'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    Series = require('../series/barChartSeries');

var BarChart = tui.util.defineClass(ChartBase, /** @lends BarChart.prototype */ {
    /**
     * Bar chart.
     * @constructs BarChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @param {array.<array>} userData chart data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(userData, theme, options) {
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-bar-chart';

        ChartBase.call(this, {
            userData: userData,
            theme: theme,
            options: options,
            hasAxes: true
        });

        this._addComponents(this.convertedData, options.chartType);
    },

    /**
     * To make axes data
     * @param {object} convertedData converted data
     * @param {object} bounds chart bounds
     * @param {object} options chart options
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function(convertedData, bounds, options) {
        var xAxisData = axisDataMaker.makeValueAxisData({
                values: convertedData.values,
                seriesDimension: bounds.series.dimension,
                stacked: options.series && options.series.stacked || '',
                chartType: options.chartType,
                formatFunctions: convertedData.formatFunctions,
                options: options.xAxis
            }),
            yAxisData = axisDataMaker.makeLabelAxisData({
                labels: convertedData.labels,
                isVertical: true
            });

        return {
            xAxis: xAxisData,
            yAxis: yAxisData
        };
    },

    /**
     * Add components
     * @param {object} convertedData converted data
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(convertedData, chartType) {
        var seriesData = {
            allowNegativeTooltip: true,
            data: {
                values: convertedData.values,
                formattedValues: convertedData.formattedValues,
                formatFunctions: convertedData.formatFunctions,
                joinLegendLabels: convertedData.joinLegendLabels
            }
        };

        this._addComponentsForAxisType({
            convertedData: convertedData,
            axes: ['yAxis', 'xAxis'],
            chartType: chartType,
            serieses: [
                {
                    name: 'series',
                    SeriesClass: Series,
                    data: seriesData
                }
            ]
        });
    }
});

axisTypeMixer.mixin(BarChart);

module.exports = BarChart;

},{"../helpers/axisDataMaker":26,"../series/barChartSeries":51,"./axisTypeMixer":5,"./chartBase":7}],7:[function(require,module,exports){
/**
 * @fileoverview ChartBase
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    dataConverter = require('../helpers/dataConverter'),
    boundsMaker = require('../helpers/boundsMaker'),
    UserEventListener = require('../helpers/userEventListener');

var ChartBase = tui.util.defineClass(/** @lends ChartBase.prototype */ {
    /**
     * Chart base.
     * @constructs ChartBase
     * @param {object} params parameters
     *      @param {object} params.bounds chart bounds
     *      @param {object} params.theme chart theme
     *      @param {{yAxis: obejct, xAxis: object}} axesData axes data
     *      @param {object} params.options chart options
     *      @param {boolean} param.isVertical whether vertical or not
     */
    init: function(params) {
        /**
         * converted data
         * @type {object}
         */
        this.convertedData = this._makeConvertedData(params);

        /**
         * component array
         * @type {array}
         */
        this.components = [];

        /**
         * component instance map
         * @type {object}
         */
        this.componentMap = {};

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {object}
         */
        this.options = params.options;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;

        /**
         * whether vertical or not
         * @type {boolean}
         */
        this.isVertical = !!params.isVertical;

        /**
         * whether chart has group tooltip or not
         * @type {*|boolean}
         */
        this.hasGroupTooltip = params.options.tooltip && params.options.tooltip.grouped;

        /**
         * user event listener
         * @type {object}
         */
        this.userEvent = new UserEventListener();

        this.chartType = this.options.chartType;

        this._addCustomEventComponent();
    },

    /**
     * To make converted data.
     * @param {object} params parameters
     *      @params {object} userData user data
     *      @params {{chart: object, chartType: string}} options chart options
     *      @params {array} seriesChartTypes series chart types
     * @returns {object} converted data
     * @private
     */
    _makeConvertedData: function(params) {
        var options = params.options,
            convertedData = dataConverter.convert(params.userData, options.chart, options.chartType, params.seriesChartTypes);
        return convertedData;
    },

    /**
     *
     * @private
     * @abastract
     */
    _addCustomEventComponent: function() {},

    /**
     * To add component.
     * The component refers to a component of the chart.
     * The component types are axis, legend, plot, series and customEvent.
     * Chart Component Description : https://i-msdn.sec.s-msft.com/dynimg/IC267997.gif
     * @param {string} name component name
     * @param {function} Component component function
     * @param {object} params parameters
     * @private
     */
    _addComponent: function(name, Component, params) {
        var commonParams = {},
            options, index, theme, component;

        params = params || {};

        options = params.options || this.options[params && params.componentType || name];
        theme = params.theme || this.theme[params && params.componentType || name];
        index = params && params.index || 0;

        commonParams.theme = tui.util.isArray(theme) ? theme[index] : theme;
        commonParams.options = tui.util.isArray(options) ? options[index] : options || {};

        params = tui.util.extend(params, commonParams);

        component = new Component(params);

        this.components.push({
            name: name,
            componentType: params.componentType,
            instance: component
        });
        this.componentMap[name] = component;
    },

    /**
     * To make bounds.
     * @param {object} boundsParams parameters for making bounds
     * @returns {object} chart bounds
     * @private
     */
    _makeBounds: function(boundsParams) {
        return boundsMaker.make(tui.util.extend({
            convertedData: this.convertedData,
            theme: this.theme,
            options: this.options,
            hasAxes: this.hasAxes,
            isVertical: this.isVertical
        }, boundsParams));
    },

    /**
     * To make rendering data for axis type chart.
     * @param {object} bounds chart bounds
     * @param {object} convertedData convertedData
     * @param {object} options options
     * @private
     * @abstract
     */
    _makeRenderingData: function() {},

    /**
     * Attach custom evnet.
     * @private
     * @abstract
     */
    _attachCustomEvent: function() {},

    /**
     * Render chart.
     * @param {object} boundsParams parameters for making bounds
     * @returns {HTMLElement} chart element
     */
    render: function(boundsParams) {
        var el = dom.create('DIV', this.className),
            bounds, renderingData;

        if (boundsParams) {
            this._makeBounds = tui.util.bind(this._makeBounds, this, boundsParams);
        }

        dom.addClass(el, 'tui-chart');
        bounds = this._makeBounds();
        renderingData = this._makeRenderingData(bounds, this.convertedData, this.options);

        this._renderTitle(el);
        renderUtil.renderDimension(el, bounds.chart.dimension);
        renderUtil.renderBackground(el, this.theme.chart.background);
        renderUtil.renderFontFamily(el, this.theme.chart.fontFamily);
        this._renderComponents(el, this.components, bounds, renderingData);
        this._sendSeriesData();
        this._attachCustomEvent();
        this.elChart = el;

        return el;
    },

    /**
     * Render title.
     * @param {HTMLElement} el target element
     * @private
     */
    _renderTitle: function(el) {
        var chartOptions = this.options.chart || {},
            elTitle = renderUtil.renderTitle(chartOptions.title, this.theme.title, 'tui-chart-title');
        dom.append(el, elTitle);
    },

    /**
     * Find bound about component
     * @param {object} bounds components bounds
     * @param {string} name component name
     * @param {string} componentType component type
     * @returns {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} found bound
     * @private
     */
    _findBound: function(bounds, name, componentType) {
        return bounds[name] || (componentType && bounds[componentType]);
    },

    /**
     * Render components.
     * @param {HTMLElement} container container element
     * @param {array.<object>} components components
     * @param {array.<object>} bounds bounds
     * @param {object} renderingData data for rendering
     * @private
     */
    _renderComponents: function(container, components, bounds, renderingData) {
        var elements;
        elements = tui.util.map(components, function(component) {
            var name = component.name,
                bound = this._findBound(bounds, name, component.componentType),
                data = renderingData[name],
                elComponent;
            if (!bound) {
                return null;
            }

            elComponent = component.instance.render(bound, data);

            return elComponent;
        }, this);
        dom.append(container, elements);
    },

    /**
     * Send series data to custom event component.
     * @private
     */
    _sendSeriesData: function() {
        var seriesInfos, chartTypes;

        if (!this.componentMap.customEvent) {
            return;
        }

        chartTypes = this.chartTypes || [this.chartType];
        seriesInfos = tui.util.map(chartTypes, function(chartType) {
            var key = chartTypes.length === 1 ? 'series' : chartType + 'Series';
            return {
                chartType: chartType,
                data: this.componentMap[key].getSeriesData()
            };
        }, this);
        this.componentMap.customEvent.initCustomEventData(seriesInfos);
    },

    /**
     * To make event name for animation.
     * @param {string} chartType chart type
     * @param {string} prefix prefix
     * @returns {string} event name
     * @private
     */
    _makeAnimationEventName: function(chartType, prefix) {
        return prefix + chartType.substring(0, 1).toUpperCase() + chartType.substring(1) + 'Animation';
    },

    /**
     * Animate chart.
     */
    animateChart: function() {
        tui.util.forEachArray(this.components, function(component) {
            if (component.instance.animateComponent) {
                component.instance.animateComponent();
            }
        });
    },

    /**
     * To register of user event.
     * @param {string} eventName event name
     * @param {function} func event callback
     */
    on: function(eventName, func) {
        this.userEvent.register(eventName, func);
    },

    /**
     * Update dimension.
     * @param {{width: number, height: number}} dimension dimension
     * @returns {boolean} whether changed or not
     * @private
     */
    _updateDimension: function(dimension) {
        var changed = false;
        if (dimension.width) {
            this.options.chart.width = dimension.width;
            changed = true;
        }

        if (dimension.height) {
            this.options.chart.height = dimension.height;
            changed = true;
        }

        return changed;
    },

    /**
     * Resize components.
     * @param {array.<{name: string, instance: object}>} components components
     * @param {array.<object>} bounds bounds
     * @param {object} renderingData data for rendering
     * @private
     */
    _resizeComponents: function(components, bounds, renderingData) {
        tui.util.forEachArray(components, function(component) {
            var name = component.name,
                bound = this._findBound(bounds, name, component.componentType),
                data = renderingData[name];

            if (!component.instance.resize) {
                return;
            }

            component.instance.resize(bound, data);
        }, this);
    },

    /**
     * Public API for resizable.
     * @param {{width: number, height: number}} dimension dimension
     */
    resize: function(dimension) {
        var changed, bounds, renderingData;

        if (!dimension) {
            return;
        }

        changed = this._updateDimension(dimension);

        if (!changed) {
            return;
        }

        bounds = this._makeBounds();

        renderingData = this._makeRenderingData(bounds, this.convertedData, this.options);
        renderUtil.renderDimension(this.elChart, bounds.chart.dimension);
        this._resizeComponents(this.components, bounds, renderingData);
        this._sendSeriesData();
    },

    /**
     * Set tooltip align option.
     * @param {string} align align
     */
    setTooltipAlign: function(align) {
        this.componentMap.tooltip.setAlign(align);
    },

    /**
     * Set position option.
     * @param {{left: number, top: number}} position moving position
     */
    setTooltipPosition: function(position) {
        this.componentMap.tooltip.setPosition(position);
    },

    /**
     * Reset tooltip align option.
     */
    resetTooltipAlign: function() {
        this.componentMap.tooltip.resetAlign();
    },

    /**
     * Reset tooltip position.
     */
    resetTooltipPosition: function() {
        this.componentMap.tooltip.resetPosition();
    }
});

module.exports = ChartBase;

},{"../helpers/boundsMaker":27,"../helpers/dataConverter":29,"../helpers/domHandler":30,"../helpers/renderUtil":33,"../helpers/userEventListener":35}],8:[function(require,module,exports){
/**
 * @fileoverview Column chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    axisTypeMixer = require('./axisTypeMixer'),
    verticalTypeMixer = require('./verticalTypeMixer'),
    Series = require('../series/columnChartSeries');

var ColumnChart = tui.util.defineClass(ChartBase, /** @lends ColumnChart.prototype */ {
    /**
     * Column chart.
     * @constructs ColumnChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes verticalTypeMixer
     * @param {array.<array>} userData chart data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @param {object} initedData initialized data from combo chart
     */
    init: function(userData, theme, options) {
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-column-chart';

        ChartBase.call(this, {
            userData: userData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(this.convertedData, options.chartType);
    },

    /**
     * Add components
     * @param {object} convertedData converted data
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(convertedData, chartType) {
        var seriesData = {
            allowNegativeTooltip: true,
            data: {
                values: convertedData.values,
                formattedValues: convertedData.formattedValues,
                formatFunctions: convertedData.formatFunctions,
                joinLegendLabels: convertedData.joinLegendLabels
            }
        };
        this._addComponentsForAxisType({
            convertedData: convertedData,
            axes: ['yAxis', 'xAxis'],
            chartType: chartType,
            serieses: [
                {
                    name: 'series',
                    SeriesClass: Series,
                    data: seriesData
                }
            ]
        });
    }
});

axisTypeMixer.mixin(ColumnChart);
verticalTypeMixer.mixin(ColumnChart);

module.exports = ColumnChart;

},{"../series/columnChartSeries":53,"./axisTypeMixer":5,"./chartBase":7,"./verticalTypeMixer":13}],9:[function(require,module,exports){
/**
 * @fileoverview Combo chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var calculator = require('../helpers/calculator'),
    ChartBase = require('./chartBase'),
    axisTypeMixer = require('./axisTypeMixer'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    predicate = require('../helpers/predicate'),
    defaultTheme = require('../themes/defaultTheme'),
    ColumnChartSeries = require('../series/columnChartSeries'),
    LineChartSeries = require('../series/lineChartSeries');

var ComboChart = tui.util.defineClass(ChartBase, /** @lends ComboChart.prototype */ {
    /**
     * Combo chart.
     * @constructs ComboChart
     * @extends ChartBase
     * @param {array.<array>} userData chart data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(userData, theme, options) {
        var seriesChartTypes = tui.util.keys(userData.series).sort(),
            optionChartTypes = this._getYAxisOptionChartTypes(seriesChartTypes, options.yAxis),
            chartTypes = optionChartTypes.length ? optionChartTypes : seriesChartTypes;

        this.chartTypes = chartTypes;
        this.seriesChartTypes = seriesChartTypes;
        this.optionChartTypes = optionChartTypes;
        this.className = 'tui-combo-chart';

        ChartBase.call(this, {
            userData: userData,
            theme: theme,
            options: options,
            seriesChartTypes: seriesChartTypes,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(this.convertedData, this.options, this.theme);
    },

    /**
     * To make options map
     * @param {object} chartTypes chart types
     * @param {object} options chart options
     * @param {object} orderInfo chart order
     * @returns {object} options map
     * @private
     */
    _makeOptionsMap: function(chartTypes, options) {
        var optionsMap = {};
        tui.util.forEachArray(chartTypes, function(chartType) {
            optionsMap[chartType] = options.series && options.series[chartType];
        });
        return optionsMap;
    },

    /**
     * To make theme map
     * @param {object} chartTypes chart types
     * @param {object} theme chart theme
     * @param {object} legendLabels legend labels
     * @returns {object} theme map
     * @private
     */
    _makeThemeMap: function(chartTypes, theme, legendLabels) {
        var themeMap = {},
            colorCount = 0;
        tui.util.forEachArray(chartTypes, function(chartType) {
            var chartTheme = JSON.parse(JSON.stringify(theme)),
                removedColors;

            if (chartTheme.series[chartType]) {
                themeMap[chartType] = chartTheme.series[chartType];
            } else if (!chartTheme.series.colors) {
                themeMap[chartType] = JSON.parse(JSON.stringify(defaultTheme.series));
                themeMap[chartType].label.fontFamily = chartTheme.chart.fontFamily;
            } else {
                removedColors = chartTheme.series.colors.splice(0, colorCount);
                chartTheme.series.colors = chartTheme.series.colors.concat(removedColors);
                themeMap[chartType] = chartTheme.series;
                colorCount += legendLabels[chartType].length;
            }
        });
        return themeMap;
    },

    /**
     * To make serieses
     * @param {array.<string>} chartTypes chart types
     * @param {object} convertedData converted data.
     * @param {object} options chart options
     * @param {object} theme chart theme
     * @returns {array.<object>} serieses
     * @private
     */
    _makeSerieses: function(chartTypes, convertedData, options, theme) {
        var seriesClasses = {
                column: ColumnChartSeries,
                line: LineChartSeries
            },
            optionsMap = this._makeOptionsMap(chartTypes, options),
            themeMap = this._makeThemeMap(chartTypes, theme, convertedData.legendLabels),
            serieses;
        serieses = tui.util.map(chartTypes, function(chartType) {
            var values = convertedData.values[chartType],
                formattedValues = convertedData.formattedValues[chartType],
                data;

            if (predicate.isLineTypeChart(chartType)) {
                values = tui.util.pivot(values);
                formattedValues = tui.util.pivot(formattedValues);
            }

            data = {
                allowNegativeTooltip: true,
                componentType: 'series',
                chartType: chartType,
                options: optionsMap[chartType],
                theme: themeMap[chartType],
                data: {
                    values: values,
                    formattedValues: formattedValues,
                    formatFunctions: convertedData.formatFunctions,
                    joinLegendLabels: convertedData.joinLegendLabels
                }
            };

            return {
                name: chartType + 'Series',
                SeriesClass: seriesClasses[chartType],
                data: data
            };
        });

        return serieses;
    },

    /**
     * Add components
     * @param {object} convertedData converted data
     * @param {object} options chart options
     * @param {object} theme chart theme
     * @private
     */
    _addComponents: function(convertedData, options, theme) {
        var axes = ['yAxis', 'xAxis'],
            serieses = this._makeSerieses(this.seriesChartTypes, convertedData, options, theme);

        if (this.optionChartTypes.length) {
            axes.push('yrAxis');
        }

        this._addComponentsForAxisType({
            convertedData: convertedData,
            axes: axes,
            seriesChartTypes: this.seriesChartTypes,
            chartType: options.chartType,
            serieses: serieses
        });
    },

    /**
     * Get y axis option chart types.
     * @param {array.<string>} chartTypes chart types
     * @param {object} yAxisOptions y axis options
     * @returns {array.<string>} chart types
     * @private
     */
    _getYAxisOptionChartTypes: function(chartTypes, yAxisOptions) {
        var resultChartTypes = chartTypes.slice(),
            isReverse = false,
            optionChartTypes;

        yAxisOptions = yAxisOptions ? [].concat(yAxisOptions) : [];

        if (yAxisOptions.length === 1 && !yAxisOptions[0].chartType) {
            resultChartTypes = [];
        } else if (yAxisOptions.length) {
            optionChartTypes = tui.util.map(yAxisOptions, function(option) {
                return option.chartType;
            });

            tui.util.forEachArray(optionChartTypes, function(chartType, index) {
                isReverse = isReverse || (chartType && resultChartTypes[index] !== chartType || false);
            });

            if (isReverse) {
                resultChartTypes.reverse();
            }
        }

        return resultChartTypes;
    },

    /**
     * To make y axis data.
     * @param {object} params parameters
     *      @param {number} params.index chart index
     *      @param {object} params.convertedData converted data
     *      @param {{width: number, height: number}} params.seriesDimension series dimension
     *      @param {array.<string>} chartTypes chart type
     *      @param {boolean} isOneYAxis whether one series or not
     *      @param {object} options chart options
     *      @param {object} addParams add params
     * @returns {object} y axis data
     * @private
     */
    _makeYAxisData: function(params) {
        var convertedData = params.convertedData,
            index = params.index,
            chartType = params.chartTypes[index],
            options = params.options,
            yAxisValues, yAxisOptions, seriesOption;

        if (params.isOneYAxis) {
            yAxisValues = convertedData.joinValues;
            yAxisOptions = [options.yAxis];
        } else {
            yAxisValues = convertedData.values[chartType];
            yAxisOptions = options.yAxis || [];
        }

        seriesOption = options.series && options.series[chartType] || options.series;

        return axisDataMaker.makeValueAxisData(tui.util.extend({
            values: yAxisValues,
            stacked: seriesOption && seriesOption.stacked || '',
            options: yAxisOptions[index],
            chartType: chartType,
            seriesDimension: params.seriesDimension,
            formatFunctions: convertedData.formatFunctions,
            isVertical: true
        }, params.addParams));
    },

    /**
     * To make axes data
     * @param {object} convertedData converted data
     * @param {object} bounds chart bounds
     * @param {object} options chart options
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function(convertedData, bounds, options) {
        var formatFunctions = convertedData.formatFunctions,
            yAxisParams = {
                convertedData: convertedData,
                seriesDimension: bounds.series.dimension,
                chartTypes: this.chartTypes,
                isOneYAxis: !this.optionChartTypes.length,
                options: options
            },
            xAxisData = axisDataMaker.makeLabelAxisData({
                labels: convertedData.labels
            }),
            yAxisData = this._makeYAxisData(tui.util.extend({
                index: 0
            }, yAxisParams)),
            axesData, yrAxisData;

        axesData = {
            yAxis: yAxisData,
            xAxis: xAxisData
        };

        if (!yAxisParams.isOneYAxis) {
            yrAxisData = this._makeYAxisData(tui.util.extend({
                index: 1,
                addParams: {
                    isPositionRight: true
                }
            }, yAxisParams));
            if (yAxisData.tickCount < yrAxisData.tickCount) {
                this._increaseYAxisTickCount(yrAxisData.tickCount - yAxisData.tickCount, yAxisData, formatFunctions);
            } else if (yAxisData.tickCount > yrAxisData.tickCount) {
                this._increaseYAxisTickCount(yAxisData.tickCount - yrAxisData.tickCount, yrAxisData, formatFunctions);
            }

            yrAxisData.aligned = xAxisData.aligned;
            axesData.yrAxis = yrAxisData;
        }

        return axesData;
    },

    /**
     * Increase y axis tick count.
     * @param {number} increaseTickCount increase tick count
     * @param {object} toData to tick info
     * @param {array.<function>} formatFunctions format functions
     * @private
     */
    _increaseYAxisTickCount: function(increaseTickCount, toData, formatFunctions) {
        toData.scale.max += toData.step * increaseTickCount;
        toData.labels = axisDataMaker.formatLabels(calculator.makeLabelsFromScale(toData.scale, toData.step), formatFunctions);
        toData.tickCount += increaseTickCount;
        toData.validTickCount += increaseTickCount;
    },

    /**
     * Render
     * @returns {HTMLElement} chart element
     */
    render: function() {
        //this._attachComboChartCoordinateEvent();
        return ChartBase.prototype.render.call(this, {
            seriesChartTypes: this.seriesChartTypes,
            optionChartTypes: this.optionChartTypes
        });
    }
});

axisTypeMixer.mixin(ComboChart);

module.exports = ComboChart;

},{"../helpers/axisDataMaker":26,"../helpers/calculator":28,"../helpers/predicate":32,"../series/columnChartSeries":53,"../series/lineChartSeries":54,"../themes/defaultTheme":59,"./axisTypeMixer":5,"./chartBase":7}],10:[function(require,module,exports){
/**
 * @fileoverview Line chart
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    lineTypeMixer = require('./lineTypeMixer'),
    axisTypeMixer = require('./axisTypeMixer'),
    verticalTypeMixer = require('./verticalTypeMixer'),
    Series = require('../series/lineChartSeries');

var LineChart = tui.util.defineClass(ChartBase, /** @lends LineChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-line-chart',

    /**
     * Series class
     * @type {function}
     */
    Series: Series,

    /**
     * Line chart.
     * @constructs LineChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes verticalTypeMixer
     * @mixes lineTypeMixer
     */
    init: function() {
        this._lineTypeInit.apply(this, arguments);
    }
});

axisTypeMixer.mixin(LineChart);
verticalTypeMixer.mixin(LineChart);
lineTypeMixer.mixin(LineChart);

module.exports = LineChart;

},{"../series/lineChartSeries":54,"./axisTypeMixer":5,"./chartBase":7,"./lineTypeMixer":11,"./verticalTypeMixer":13}],11:[function(require,module,exports){
/**
 * @fileoverview lineTypeMixer is mixer of line type chart(line, area).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    AreaTypeCustomEvent = require('../customEvents/areaTypeCustomEvent');

/**
 * lineTypeMixer is mixer of line type chart(line, area).
 * @mixin
 */
var lineTypeMixer = {
    /**
     * Initialize line type chart.
     * @param {array.<array>} userData chart data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @param {object} initedData initialized data from combo chart
     * @private
     */
    _lineTypeInit: function(userData, theme, options) {
        ChartBase.call(this, {
            userData: userData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(this.convertedData, options.chartType);
    },

    _addCustomEventComponentForNormalTooltip: function() {
        this._addComponent('customEvent', AreaTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add components
     * @param {object} convertedData converted data
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(convertedData, chartType) {
        var seriesData = {
            data: {
                values: tui.util.pivot(convertedData.values),
                formattedValues: tui.util.pivot(convertedData.formattedValues),
                formatFunctions: convertedData.formatFunctions,
                joinLegendLabels: convertedData.joinLegendLabels
            }
        };
        this._addComponentsForAxisType({
            convertedData: convertedData,
            axes: ['yAxis', 'xAxis'],
            chartType: chartType,
            serieses: [
                {
                    name: 'series',
                    SeriesClass: this.Series,
                    data: seriesData
                }
            ]
        });
    },

    /**
     * Render
     * @returns {HTMLElement} chart element
     */
    render: function() {
        return ChartBase.prototype.render.apply(this, arguments);
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = lineTypeMixer;

},{"../customEvents/areaTypeCustomEvent":16,"./chartBase":7}],12:[function(require,module,exports){
/**
 * @fileoverview Pie chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil'),
    Legend = require('../legends/legend'),
    Tooltip = require('../tooltips/tooltip'),
    Series = require('../series/pieChartSeries');

var PieChart = tui.util.defineClass(ChartBase, /** @lends PieChart.prototype */ {
    /**
     * Column chart.
     * @constructs PieChart
     * @extends ChartBase
     * @param {array.<array>} userData chart data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(userData, theme, options) {
        this.className = 'tui-pie-chart';

        options.tooltip = options.tooltip || {};

        if (!options.tooltip.align) {
            options.tooltip.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }

        ChartBase.call(this, {
            userData: userData,
            theme: theme,
            options: options
        });

        this._addComponents(this.convertedData, theme.chart.background, options);
    },

    /**
     * Add components
     * @param {object} convertedData converted data
     * @param {object} chartBackground chart background
     * @param {object} options chart options
     * @private
     */
    _addComponents: function(convertedData, chartBackground, options) {
        var legendAlign, isPieLegendType;
        options.legend = options.legend || {};
        legendAlign = options.legend && options.legend.align;
        isPieLegendType = predicate.isPieLegendAlign(legendAlign);
        if (convertedData.joinLegendLabels && !isPieLegendType && !options.legend.hidden) {
            this._addComponent('legend', Legend, {
                joinLegendLabels: convertedData.joinLegendLabels,
                legendLabels: convertedData.legendLabels,
                chartType: options.chartType,
                userEvent: this.userEvent
            });
        }

        this._addComponent('tooltip', Tooltip, {
            values: convertedData.values,
            formattedValues: convertedData.formattedValues,
            labels: convertedData.labels,
            legendLabels: convertedData.legendLabels,
            joinLegendLabels: convertedData.joinLegendLabels,
            userEvent: this.userEvent,
            chartType: options.chartType
        });

        this._addComponent('series', Series, {
            libType: options.libType,
            chartType: options.chartType,
            componentType: 'series',
            chartBackground: chartBackground,
            userEvent: this.userEvent,
            legendAlign: isPieLegendType && !options.legend.hidden ? legendAlign : null,
            data: {
                values: convertedData.values,
                formattedValues: convertedData.formattedValues,
                legendLabels: convertedData.legendLabels,
                joinLegendLabels: convertedData.joinLegendLabels
            }
        });
    },

    /**
     * To make rendering data for pie chart.
     * @param {object} bounds chart bounds
     * * @param {object} bounds chart bounds
     * @return {object} data for rendering
     * @private
     * @override
     */
    _makeRenderingData: function(bounds) {
        return {
            tooltip: {
                seriesPosition: bounds.series.position,
                chartDimension: bounds.chart.dimension
            },
            series: {
                chartWidth: bounds.chart.dimension.width
            }
        };
    },

    /**
     * Attach custom evnet.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var tooltip = this.componentMap.tooltip,
            serieses = tui.util.filter(this.componentMap, function (component) {
                return component.componentType === 'series';
            });
        tui.util.forEach(serieses, function (series) {
            series.on('showTooltip', tooltip.onShow, tooltip);
            series.on('hideTooltip', tooltip.onHide, tooltip);

            if (series.onShowAnimation) {
                tooltip.on(renderUtil.makeCustomEventName('show', series.chartType, 'animation'), series.onShowAnimation, series);
                tooltip.on(renderUtil.makeCustomEventName('hide', series.chartType, 'animation'), series.onHideAnimation, series);
            }
        }, this);
    }
});

module.exports = PieChart;

},{"../const":15,"../helpers/predicate":32,"../helpers/renderUtil":33,"../legends/legend":36,"../series/pieChartSeries":56,"../tooltips/tooltip":62,"./chartBase":7}],13:[function(require,module,exports){
/**
 * @fileoverview verticalTypeMixer is mixer of vertical type chart(column, line, area).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var axisDataMaker = require('../helpers/axisDataMaker'),
    predicate = require('../helpers/predicate');

/**
 * verticalTypeMixer is mixer of vertical type chart(column, line, area).
 * @mixin
 */
var verticalTypeMixer = {
    /**
     * To make axes data
     * @param {object} convertedData converted data
     * @param {object} bounds chart bounds
     * @param {object} options chart options
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function(convertedData, bounds, options) {
        var aligned = predicate.isLineTypeChart(options.chartType),
            xAxisData = axisDataMaker.makeLabelAxisData({
                labels: convertedData.labels,
                aligned: aligned,
                options: options.xAxis
            }),
            yAxisData = axisDataMaker.makeValueAxisData({
                values: convertedData.values,
                seriesDimension: bounds.series.dimension,
                stacked: options.series && options.series.stacked || '',
                chartType: options.chartType,
                formatFunctions: convertedData.formatFunctions,
                options: options.yAxis,
                isVertical: true,
                aligned: aligned
            });

        return {
            xAxis: xAxisData,
            yAxis: yAxisData
        };
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = verticalTypeMixer;

},{"../helpers/axisDataMaker":26,"../helpers/predicate":32}],14:[function(require,module,exports){
'use strict';

/**
 * Pick minimum value from value array.
 * @param {array} arr value array
 * @param {function} condition condition function
 * @param {object} context target context
 * @returns {*} minimum value
 */
var min = function(arr, condition, context) {
    var result, minValue, rest;
    if (!condition) {
        condition = function(item) {
            return item;
        };
    }
    result = arr[0];
    minValue = condition.call(context, result);
    rest = arr.slice(1);
    tui.util.forEachArray(rest, function(item) {
        var compareValue = condition.call(context, item);
        if (compareValue < minValue) {
            minValue = compareValue;
            result = item;
        }
    });
    return result;
};

/**
 * Pick maximum value from value array.
 * @param {array} arr value array
 * @param {function} condition condition function
 * @param {object} context target context
 * @returns {*} maximum value
 */
var max = function(arr, condition, context) {
    var result, maxValue, rest;
    if (!condition) {
        condition = function(item) {
            return item;
        };
    }
    result = arr[0];
    maxValue = condition.call(context, result);
    rest = arr.slice(1);
    tui.util.forEachArray(rest, function(item) {
        var compareValue = condition.call(context, item);
        if (compareValue > maxValue) {
            maxValue = compareValue;
            result = item;
        }
    });
    return result;
};

/**
 * Whether one of them is true or not.
 * @param {array} arr target array
 * @param {function} condition condition function
 * @returns {boolean} result boolean
 */
var any = function(arr, condition) {
    var result = false;
    tui.util.forEachArray(arr, function(item) {
        if (condition(item)) {
            result = true;
            return false;
        }
    });
    return result;
};

/**
 * All of them is true or not.
 * @param {array} arr target array
 * @param {function} condition condition function
 * @returns {boolean} result boolean
 */
var all = function(arr, condition) {
    var result = true;
    tui.util.forEachArray(arr, function(item) {
        if (!condition(item)) {
            result = false;
            return false;
        }
    });
    return result;
};

/**
 * Array pivot.
 * @memberOf module:calculator
 * @param {array.<array>} arr2d target 2d array
 * @returns {array.<array>} pivoted 2d array
 */
var pivot = function(arr2d) {
    var result = [];
    tui.util.forEachArray(arr2d, function(arr) {
        tui.util.forEachArray(arr, function(value, index) {
            if (!result[index]) {
                result[index] = [];
            }
            result[index].push(value);
        });
    });
    return result;
};

/**
 * Get after point length.
 * @param {string | number} value target value
 * @returns {number} result length
 */
var lengthAfterPoint = function(value) {
    var valueArr = (value + '').split('.');
    return valueArr.length === 2 ? valueArr[1].length : 0;
};

/**
 * Find multiple num.
 * @param {...array} target values
 * @returns {number} multiple num
 */
var findMultipleNum = function() {
    var args = [].slice.call(arguments),
        underPointLens = tui.util.map(args, function(value) {
            return tui.util.lengthAfterPoint(value);
        }),
        underPointLen = tui.util.max(underPointLens),
        multipleNum = Math.pow(10, underPointLen);
    return multipleNum;
};

/**
 * Modulo operation for floating point operation.
 * @param {number} target target values
 * @param {number} modNum mod num
 * @returns {number} result mod
 */
var mod = function(target, modNum) {
    var multipleNum = tui.util.findMultipleNum(modNum);
    return ((target * multipleNum) % (modNum * multipleNum)) / multipleNum;
};

/**
 * Addition for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} addition result
 */
var addition = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) + (b * multipleNum)) / multipleNum;
};

/**
 * Subtraction for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} subtraction result
 */
var subtraction = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) - (b * multipleNum)) / multipleNum;
};

/**
 * Multiplication for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} multiplication result
 */
var multiplication = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) * (b * multipleNum)) / (multipleNum * multipleNum);
};

/**
 * Division for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} division result
 */
var division = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return (a * multipleNum) / (b * multipleNum);
};

/**
 * Sum.
 * @param {array.<number>} values target values
 * @returns {number} result value
 */
var sum = function(values) {
    var copyArr = values.slice();
    copyArr.unshift(0);
    return tui.util.reduce(copyArr, function(base, add) {
        return parseFloat(base) + parseFloat(add);
    });
};


var properCase = function(str) {
    return str.substring(0, 1).toUpperCase() + str.substring(1);
};

tui.util.min = min;
tui.util.max = max;
tui.util.any = any;
tui.util.all = all;
tui.util.pivot = pivot;
tui.util.lengthAfterPoint = lengthAfterPoint;
tui.util.mod = mod;
tui.util.findMultipleNum = findMultipleNum;
tui.util.addition = addition;
tui.util.subtraction = subtraction;
tui.util.multiplication = multiplication;
tui.util.division = division;
tui.util.sum = sum;
tui.util.properCase = properCase;

var aps = Array.prototype.slice;

/**
 * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed
 * since the last time the debouced function was invoked.
 * @param {function} fn The function to debounce.
 * @param {number} [delay=0] The number of milliseconds to delay
 * @memberof tui.util
 * @returns {function} debounced function.
 * @example
 *
 * function someMethodToInvokeDebounced() {}
 *
 * var debounced = tui.util.debounce(someMethodToInvokeDebounced, 300);
 *
 * // invoke repeatedly
 * debounced();
 * debounced();
 * debounced();
 * debounced();
 * debounced();
 * debounced();    // last invoke of debounced()
 *
 * // invoke someMethodToInvokeDebounced() after 300 milliseconds.
 */
function debounce(fn, delay) {
    var timer,
        args;

    /* istanbul ignore next */
    delay = delay || 0;

    function debounced() {
        args = aps.call(arguments);

        window.clearTimeout(timer);
        timer = window.setTimeout(function() {
            fn.apply(null, args);
        }, delay);
    }

    return debounced;
}

/**
 * Creates a throttled function that only invokes fn at most once per every interval milliseconds.
 *
 * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)
 *
 * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.
 * @param {function} fn function to throttle
 * @param {number} [interval=0] the number of milliseconds to throttle invocations to.
 * @memberof tui.util
 * @returns {function} throttled function
 * @example
 *
 * function someMethodToInvokeThrottled() {}
 *
 * var throttled = tui.util.throttle(someMethodToInvokeThrottled, 300);
 *
 * // invoke repeatedly
 * throttled();    // invoke (leading)
 * throttled();
 * throttled();    // invoke (near 300 milliseconds)
 * throttled();
 * throttled();
 * throttled();    // invoke (near 600 milliseconds)
 * // ...
 * // invoke (trailing)
 *
 * // if you need reuse throttled method. then invoke reset()
 * throttled.reset();
 */
function throttle(fn, interval) {
    var base,
        _timestamp = tui.util.timestamp,
        debounced,
        isLeading = true,
        stamp,
        args,
        tick = function(_args) {
            fn.apply(null, _args);
            base = null;
        };

    /* istanbul ignore next */
    interval = interval || 0;

    debounced = tui.util.debounce(tick, interval);

    function throttled() {
        args = aps.call(arguments);

        if (isLeading) {
            tick(args);
            isLeading = false;
            return;
        }

        stamp = _timestamp();

        base = base || stamp;

        debounced(args);

        if ((stamp - base) >= interval) {
            tick(args);
        }
    }

    function reset() {
        isLeading = true;
        base = null;
    }

    throttled.reset = reset;
    return throttled;
}

tui.util.debounce = debounce;
tui.util.throttle = throttle;

},{}],15:[function(require,module,exports){
/**
 * @fileoverview Chart const
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

/**
 * Chart const
 * @readonly
 * @enum {number}
 */
var chartConst = {
    /** tui class names
     * @type {string}
     */
    CLASS_NAME_LEGEND: 'tui-chart-legend',
    /** @type {string} */
    CLASS_NAME_SERIES_LABEL: 'tui-chart-series-label',
    /** @type {string} */
    CLASS_NAME_SERIES_LEGEND: 'tui-chart-series-legend',
    /** chart types
     * @type {string}
     */
    CHART_TYPE_BAR: 'bar',
    /** @type {string} */
    CHART_TYPE_COLUMN: 'column',
    /** @type {string} */
    CHART_TYPE_LINE: 'line',
    /** @type {string} */
    CHART_TYPE_AREA: 'area',
    /** @type {string} */
    CHART_TYPE_COMBO: 'combo',
    /** @type {string} */
    CHART_TYPE_PIE: 'pie',
    /** chart padding */
    CHART_PADDING: 10,
    /** chart default width */
    CHART_DEFAULT_WIDTH: 500,
    /** chart default height */
    CHART_DEFAULT_HEIGHT: 400,
    /** hidden width */
    HIDDEN_WIDTH: 1,
    /** rendered text padding */
    TEXT_PADDING: 2,
    /** series expand size */
    SERIES_EXPAND_SIZE: 10,
    /** series label padding */
    SERIES_LABEL_PADDING: 5,
    /** default font size of title */
    DEFAULT_TITLE_FONT_SIZE: 14,
    /** default font size of axis title */
    DEFAULT_AXIS_TITLE_FONT_SIZE: 10,
    /** default font size of label */
    DEFAULT_LABEL_FONT_SIZE: 12,
    /** default font size of series label */
    DEFAULT_SERIES_LABEL_FONT_SIZE: 11,
    /** @type {string} */
    /** default graph plugin
     * @type {string}
     */
    DEFAULT_PLUGIN: 'raphael',
    /** default tick color
     * @type {string}
     */
    DEFAULT_TICK_COLOR: 'black',
    /** default theme name
     * @type {string}
     */
    DEFAULT_THEME_NAME: 'default',
    /** stacked option types
     * @type {string}
     */
    STACKED_NORMAL_TYPE: 'normal',
    /** @type {string} */
    STACKED_PERCENT_TYPE: 'percent',
    /** empty axis label */
    EMPTY_AXIS_LABEL: '',
    /** angel */
    ANGLE_85: 85,
    ANGLE_90: 90,
    ANGLE_360: 360,
    /** radian */
    RAD: Math.PI / 180,
    /** series legend types
     * @type {string}
     */
    LEGEND_ALIGN_OUTER: 'outer',
    /** @type {string} */
    LEGEND_TYPE_CENTER: 'center',
    /** series outer label padding */
    SERIES_OUTER_LABEL_PADDING: 20,
    /** default rate of pie graph */
    PIE_GRAPH_DEFAULT_RATE: 0.8,
    /** small rate of pie graph */
    PIE_GRAPH_SMALL_RATE: 0.65,
    /** dot radius */
    DOT_RADIUS: 4,
    /** yAxis properties
     * @type {array.<string>}
     */
    YAXIS_PROPS: ['tickColor', 'title', 'label'], // yaxis theme  - chart type filtering  
    /** series properties
     * @type {array.<string>}
     */
    SERIES_PROPS: ['label', 'colors', 'borderColor', 'singleColors', 'selectionColor'], // series theme  - chart type filtering  
    /** title area width padding */
    TITLE_AREA_WIDTH_PADDING: 20,
    /** top margin of x axis label */
    XAXIS_LABEL_TOP_MARGIN: 10,
    /** right padding of vertical label */
    V_LABEL_RIGHT_PADDING: 10,
    /** tooltip prefix
     * @type {string}
     */
    TOOLTIP_PREFIX: 'tui-chart-tooltip',
    /** minimum pixel type step size */
    MIN_PIXEL_TYPE_STEP_SIZE: 40,
    /** maximum pixel type step size */
    MAX_PIXEL_TYPE_STEP_SIZE: 60,
    /** tick info of percent stacked option
     * @type {object}
     */
    PERCENT_STACKED_TICK_INFO: {
        scale: {
            min: 0,
            max: 100
        },
        step: 25,
        tickCount: 5,
        labels: [0, 25, 50, 75, 100]
    },
    /** title add padding */
    TITLE_PADDING: 20,
    /** legend area padding */
    LEGEND_AREA_PADDING: 10,
    /** legend rect width */
    LEGEND_RECT_WIDTH: 12,
    /** lgend label left padding */
    LEGEND_LABEL_LEFT_PADDING: 5,
    /** AXIS LABEL PADDING */
    AXIS_LABEL_PADDING: 7,
    /** rotations degree candidates */
    DEGREE_CANDIDATES: [25, 45, 65, 85],
    /** xAxis label compare margin */
    XAXIS_LABEL_COMPARE_MARGIN: 20,
    /** xAxis label gutter */
    XAXIS_LABEL_GUTTER: 2,
    /** stand multiple nums of axis */
    AXIS_STANDARD_MULTIPLE_NUMS: [1, 2, 5, 10],
    /** label padding top */
    LABEL_PADDING_TOP: 2,
    /** line margin top */
    LINE_MARGIN_TOP: 5,
    /** tooltip gap */
    TOOLTIP_GAP: 5,
    /** tooltip direction
     * @type {string}
     */
    TOOLTIP_DIRECTION_FORWARD: 'forword',
    /** @type {string} */
    TOOLTIP_DIRECTION_CENTER: 'center',
    /** @type {string} */
    TOOLTIP_DIRECTION_BACKWARD: 'backword',
    /** tooltip align options
     * @type {string}
     */
    TOOLTIP_DEFAULT_ALIGN_OPTION: 'center top',
    /** @type {string} */
    TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION: 'right middle',
    /** @type {string} */
    TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION: 'right middle',
    /** @type {string} */
    TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION: 'center bottom',
    /** hide delay */
    HIDE_DELAY: 200
};
module.exports = chartConst;

},{}],16:[function(require,module,exports){
/**
 * @fileoverview AreaTypeCustomEvent is event handle layer for line type chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    AreaTypeDataModel = require('./areaTypeDataModel'),
    chartConst = require('../const');

var AreaTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends AreaTypeCustomEvent.prototype */ {
    /**
     * AreaTypeCustomEvent is custom event for line type chart.
     * @param {object} params parameters
     * @constructs AreaTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function(params) {
        CustomEventBase.call(this, params);
    },

    /**
     * Initialize data of custom event
     * @param {array.<object>} seriesInfos series infos
     */
    initCustomEventData: function(seriesInfos) {
        var seriesInfo = seriesInfos[0];
        this.dataModel = new AreaTypeDataModel(seriesInfo);
        CustomEventBase.prototype.initCustomEventData.call(this, seriesInfos);
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e mouse event object
     * @override
     */
    onMousemove: function(e) {
        var elTarget = e.target || e.srcElement,
            bound = elTarget.getBoundingClientRect(),
            layerX = e.clientX - chartConst.SERIES_EXPAND_SIZE - bound.left,
            layerY = e.clientY - bound.top,
            groupIndex = this.tickBaseDataModel.findIndex(layerX),
            foundData = this.dataModel.findData(groupIndex, layerY);

        if (!this._isChanged(this.prevFoundData, foundData)) {
            return;
        }

        if (foundData) {
            this.fire('showTooltip', foundData);
            this.prevFoundData = foundData;
        } else if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
            delete this.prevFoundData;
        }
    },

    /**
     * On mouseout.
     * @param {MouseEvent} e mouse event object
     * @override
     */
    onMouseout: function() {
        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
            delete this.prevFoundData;
        }
    }
});

tui.util.CustomEvents.mixin(AreaTypeCustomEvent);

module.exports = AreaTypeCustomEvent;

},{"../const":15,"./areaTypeDataModel":17,"./customEventBase":18}],17:[function(require,module,exports){
/**
 * @fileoverview AreaTypeDataModel is data model for area type custom event.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var AreaTypeDataModel = tui.util.defineClass(/** @lends AreaTypeDataModel.prototype */ {
    /**
     * AreaTypeDataModel is data mode for area type custom event.
     * @constructs AreaTypeDataModel
     * @param {object} seriesInfo series info
     */
    init: function(seriesInfo) {
        this.data = this._makeData(seriesInfo.data.groupPositions, seriesInfo.chartType);
    },

    /**
     * To make area type data for custom event.
     * @param {array.<array.<group>>} groupPositions group positions
     * @param {string} chartType cahrt type
     * @returns {array} area type data for custom even
     * @private
     */
    _makeData: function(groupPositions, chartType) {
        groupPositions = tui.util.pivot(groupPositions);
        return tui.util.map(groupPositions, function(positions, groupIndex) {
            return tui.util.map(positions, function(position, index) {
                return {
                    chartType: chartType,
                    indexes: {
                        groupIndex: groupIndex,
                        index: index
                    },
                    bound: position
                };
            });
        });
    },

    /**
     * Find Data.
     * @param {number} groupIndex group index
     * @param {number} layerY mouse position
     * @returns {object} index
     */
    findData: function(groupIndex, layerY) {
        var result,
            min = 10000;
        tui.util.forEach(this.data[groupIndex], function(data) {
            var diff = Math.abs(layerY - data.bound.top);
            if (min > diff) {
                min = diff;
                result = data;
            }
        });
        return result;
    }
});

module.exports = AreaTypeDataModel;

},{}],18:[function(require,module,exports){
/**
 * @fileoverview CustomEventBase is base class for event handle layers.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var eventListener = require('../helpers/eventListener'),
    TickBaseDataModel = require('./tickBaseDataModel'),
    PointTypeDataModel = require('./pointTypeDataModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var CustomEventBase = tui.util.defineClass(/** @lends CustomEventBase.prototype */ {
    /**
     * CustomEventBase is base class for custom event components.
     * @constructs CustomEventBase
     * @param {object} params parameters
     *      @param {{
     *          dimension: {width: number, height: number},
     *          position: {left: number, top: number}
     *      }} params.bound bound
     *      @param {string} params.chartType chart type
     *      @param {boolean} params.isVertical whether vertical or not
     */
    init: function(params) {
        this.chartType = params.chartType;
        this.isVertical = params.isVertical;
    },

    /**
     * To render event handle layer area
     * @param {HTMLElement} elCoordinateArea coordinate area element
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound bound of event handler layer
     * @param {object} data rendering data
     * @private
     */
    _renderCustomEventArea: function(elCoordinateArea, bound, data) {
        var expandedBound;
        this.bound = bound;
        this.tickBaseDataModel = new TickBaseDataModel(bound.dimension, data.tickCount, this.chartType, this.isVertical);
        expandedBound = renderUtil.expandBound(bound);
        renderUtil.renderDimension(elCoordinateArea, expandedBound.dimension);
        renderUtil.renderPosition(elCoordinateArea, expandedBound.position);
    },

    /**
     * To render event handle layer component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound bound of event handler layer
     * @param {object} data rendering data
     * @return {HTMLElement} coordinate area
     */
    render: function(bound, data) {
        var el = dom.create('DIV', 'tui-chart-series-custom-event-area');

        this._renderCustomEventArea(el, bound, data);
        this.attachEvent(el);
        this.elCoordinateArea = el;
        return el;
    },

    /**
     * Initialize data of custom event
     * @param {array.<object>} seriesInfos series infos
     */
    initCustomEventData: function(seriesInfos) {
        this.pointTypeDataModel = new PointTypeDataModel(seriesInfos);
    },

    /**
     * To resize event handle layer component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound bound for resizable
     * @param {{tickCount: number}} data data
     */
    resize: function(bound, data) {
        this._renderCustomEventArea(this.elCoordinateArea, bound, data);
    },

    /**
     * Whether changed or not.
     * @param {object} prev previous data
     * @param {object} cur current data
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChanged: function(prev, cur) {
        return !prev || !cur || prev.chartType !== cur.chartType ||
            prev.indexes.groupIndex !== cur.indexes.groupIndex || prev.indexes.index !== cur.indexes.index;
    },

    /**
     * Find point type data.
     * @param {HTMLElement} elTarget target element
     * @param {number} clientX mouse position x
     * @param {number} clientY mouse position y
     * @returns {object} found data
     * @private
     */
    _findPointTypeData: function(elTarget, clientX, clientY) {
        var bound = elTarget.getBoundingClientRect(),
            layerX = clientX - bound.left,
            layerY = clientY - bound.top,
            groupIndex = this.tickBaseDataModel.findIndex(this.isVertical ? layerX : layerY);
        return this.pointTypeDataModel.findData(groupIndex, layerX + chartConst.SERIES_EXPAND_SIZE, layerY);
    },

    /**
     * Unselect selected data.
     * @private
     */
    _unselectSelectedData: function() {
        var eventName = this.fire(renderUtil.makeCustomEventName('unselect', this.selectedData.chartType, 'series'), this.selectedData);
        this.fire(eventName, this.selectedData);
        delete this.selectedData;
    },

    /**
     * On click
     * @param {mouseevent} e mouse event
     */
    onClick: function(e) {
        var elTarget = e.target || e.srcElement,
            clientX = e.clientX - chartConst.SERIES_EXPAND_SIZE,
            foundData = this._findPointTypeData(elTarget, clientX, e.clientY);
        if (!this._isChanged(this.selectedData, foundData)) {
            this._unselectSelectedData();
            return;
        } else if (foundData) {
            if (this.selectedData) {
                this._unselectSelectedData();
            }
            this.fire(renderUtil.makeCustomEventName('select', foundData.chartType, 'series'), foundData);
            this.selectedData = foundData;
        }
    },

    /**
     * On mouse move
     * @abstract
     */
    onMousemove: function() {},

    /**
     * On mouse out
     * @abstract
     */
    onMouseout: function() {},

    /**
     * Attach event
     * @param {HTMLElement} el target element
     */
    attachEvent: function(el) {
        eventListener.bindEvent('click', el, tui.util.bind(this.onClick, this));
        eventListener.bindEvent('mousemove', el, tui.util.bind(this.onMousemove, this));
        eventListener.bindEvent('mouseout', el, tui.util.bind(this.onMouseout, this));
    }
});

tui.util.CustomEvents.mixin(CustomEventBase);

module.exports = CustomEventBase;

},{"../const":15,"../helpers/domHandler":30,"../helpers/eventListener":31,"../helpers/renderUtil":33,"./pointTypeDataModel":21,"./tickBaseDataModel":22}],19:[function(require,module,exports){
/**
 * @fileoverview GroupTypeCustomEvent is event handle layer for grouped toolip option.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    chartConst = require('../const');

var GroupTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends GroupTypeCustomEvent.prototype */ {
    /**
     * GroupTypeCustomEvent is event handle layer for grouped toolip option.
     * @constructs GroupTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function() {
        CustomEventBase.apply(this, arguments);
    },

    /**
     * Get layer position.
     * @param {MouseEvent} e mouse event object
     * @param {{top: number, right: number, bottom: number, left: number}} bound bound
     * @param {boolean} isVertical whether vertical or not
     * @returns {number} layer position (left or top)
     * @private
     */
    _getLayerPositionValue: function(e, bound, isVertical) {
        var layerPosition;
        if (isVertical) {
            layerPosition = e.clientX - chartConst.SERIES_EXPAND_SIZE - bound.left;
        } else {
            layerPosition = e.clientY - bound.top;
        }
        return layerPosition;
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e mouse event object
     * @override
     */
    onMousemove: function(e) {
        var elTarget = e.target || e.srcElement,
            bound = elTarget.getBoundingClientRect(),
            layerPositionValue = this._getLayerPositionValue(e, bound, this.isVertical),
            index = this.tickBaseDataModel.findIndex(layerPositionValue),
            prevIndex = this.prevIndex,
            sizeType = this.isVertical ? 'height' : 'width';

        if (index === -1) {
            this.onMouseout();
            return;
        }

        if (prevIndex === index) {
            return;
        }

        this.prevIndex = index;

        this.fire('showGroupTooltip', {
            index: index,
            range: this.tickBaseDataModel.makeRange(index, this.chartType),
            size: this.bound.dimension[sizeType],
            isVertical: this.isVertical
        });
    },

    /**
     * On mouseout.
     * @param {MouseEvent} e mouse event object
     * @override
     */
    onMouseout: function() {
        if (!tui.util.isUndefined(this.prevIndex)) {
            this.fire('hideGroupTooltip', this.prevIndex);
            delete this.prevIndex;
        }
    }
});

tui.util.CustomEvents.mixin(GroupTypeCustomEvent);

module.exports = GroupTypeCustomEvent;

},{"../const":15,"./customEventBase":18}],20:[function(require,module,exports){
/**
 * @fileoverview PointTypeCustomEven is event handle layer for line type chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    CustomEventBase = require('./customEventBase');

var PointTypeCustomEven = tui.util.defineClass(CustomEventBase, /** @lends PointTypeCustomEven.prototype */ {
    /**
     * PointTypeCustomEven is event handle layer for line type chart.
     * @constructs PointTypeCustomEven
     * @extends CustomEventBase
     */
    init: function() {
        CustomEventBase.apply(this, arguments);
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e mouse event object
     * @override
     */
    onMousemove: function(e) {
        var elTarget = e.target || e.srcElement,
            clientX = e.clientX - chartConst.SERIES_EXPAND_SIZE,
            foundData = this._findPointTypeData(elTarget, clientX, e.clientY);

        if (!this._isChanged(this.prevFoundData, foundData)) {
            return;
        }

        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
            delete this.prevFoundData;
        }

        if (foundData) {
            this.fire('showTooltip', foundData);
            this.prevFoundData = foundData;
        }
    },

    /**
     * On mouseout.
     * @param {MouseEvent} e mouse event object
     * @override
     */
    onMouseout: function() {
        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
            delete this.prevFoundData;
        }
    }
});

tui.util.CustomEvents.mixin(PointTypeCustomEven);

module.exports = PointTypeCustomEven;

},{"../const":15,"./customEventBase":18}],21:[function(require,module,exports){
/**
 * @fileoverview PointTypeDataModel is data mode for point type custom event.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate');

var PointTypeDataModel = tui.util.defineClass(/** @lends PointTypeDataModel.prototype */ {
    /**
     * PointTypeDataModel is data mode for point type custom event.
     * @constructs PointTypeDataModel
     * @param {array.<object>} seriesInfos series infos
     */
    init: function(seriesInfos) {
        this.data = this._makeData(seriesInfos);
    },

    /**
     * To make coordinate data about bar type graph
     * @param {array.<array.<object>>} groupBounds group bounds
     * @param {string} chartType chart type
     * @returns {array} coordinate data
     * @private
     */
    _makeRectTypeCoordinateData: function(groupBounds, chartType) {
        return tui.util.map(groupBounds, function(bounds, groupIndex) {
            return tui.util.map(bounds, function(_bound, index) {
                var bound;
                if (!_bound) {
                    return null;
                }

                bound = _bound.end;

                return {
                    sendData: {
                        chartType: chartType,
                        indexes: {
                            groupIndex: groupIndex,
                            index: index
                        },
                        allowNegativeTooltip: true,
                        bound: bound
                    },
                    bound: {
                        left: bound.left,
                        top: bound.top,
                        right: bound.left + bound.width,
                        bottom: bound.top + bound.height
                    }
                };
            });
        });
    },

    /**
     * To make coordinate data about dot type graph
     * @param {array.<array.<object>>} groupPositions group positions
     * @param {string} chartType chart type
     * @returns {array} coordinate data
     * @private
     */
    _makeDotTypeCoordinateData: function(groupPositions, chartType) {
        return tui.util.map(tui.util.pivot(groupPositions), function(positions, groupIndex) {
            return tui.util.map(positions, function(position, index) {
                return {
                    sendData: {
                        chartType: chartType,
                        indexes: {
                            groupIndex: groupIndex,
                            index: index
                        },
                        bound: position
                    },
                    bound: {
                        left: position.left - chartConst.DOT_RADIUS,
                        top: position.top - chartConst.DOT_RADIUS,
                        right: position.left + chartConst.DOT_RADIUS,
                        bottom: position.top + chartConst.DOT_RADIUS
                    }
                };
            });
        });
    },

    /**
     * To join data.
     * @param {array.<array.<array.<object>>>} groupData group data
     * @returns {array.<array.<object>>} joined data
     * @private
     */
    _joinData: function(groupData) {
        var results = [];
        tui.util.forEachArray(groupData, function(coordData) {
            tui.util.forEachArray(coordData, function(data, index) {
                if (!results[index]) {
                    results[index] = [];
                }
                results[index] = results[index].concat(data);
            });
        });

        return results;
    },

    /**
     * To make coordinate data.
     * @param {array.<object>} seriesInfos series infos
     * @returns {array.<array.<object>>} coordinate data
     * @private
     */
    _makeData: function(seriesInfos) {
        var coordinateData;
        seriesInfos.reverse();
        coordinateData = tui.util.map(seriesInfos, function(info) {
            var result;
            if (predicate.isLineTypeChart(info.chartType)) {
                result = this._makeDotTypeCoordinateData(info.data.groupPositions, info.chartType);
            } else {
                result = this._makeRectTypeCoordinateData(info.data.groupBounds, info.chartType);
            }
            return result;
        }, this);
        return this._joinData(coordinateData);
    },

    /**
     * Find tooltip data.
     * @param {number} groupIndex group index
     * @param {number} layerX mouse position x
     * @param {number} layerY mouse position y
     * @returns {object} tooltip data
     */
    findData: function(groupIndex, layerX, layerY) {
        var min = 10000,
            result = null,
            candidates;

        if (groupIndex === -1) {
            return result;
        }

        // layerX, layerY  data 
        candidates = tui.util.filter(this.data[groupIndex], function(data) {
            var bound = data && data.bound;
            return bound && bound.left <= layerX && bound.right >= layerX && bound.top <= layerY && bound.bottom >= layerY;
        });

        //  data  top layerY   data 
        tui.util.forEachArray(candidates, function(data) {
            var diff = Math.abs(layerY - data.sendData.bound.top);
            if (min > diff) {
                min = diff;
                result = data.sendData;
            }
        });

        return result;
    }
});

module.exports = PointTypeDataModel;

},{"../const":15,"../helpers/predicate":32}],22:[function(require,module,exports){
/**
 * @fileoverview TickBaseDataModel is tick base data model.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var predicate = require('../helpers/predicate');

var TickBaseDataModel = tui.util.defineClass(/** @lends TickBaseDataModel.prototype */ {
    /**
     * TickBaseDataModel is tick base data model.
     * @param {{width: number, height: number}} dimension dimension
     * @param {number} tickCount tick count
     * @param {string} chartType chart type
     * @param {boolan} isVertical whether vertical or not
     * @constructs TickBaseDataModel
     */
    init: function(dimension, tickCount, chartType, isVertical) {
        this.data = this._makeData(dimension, tickCount, chartType, isVertical);
    },

    /**
     * To make tick base data about line type chart.
     * @param {number} width width
     * @param {number} tickCount tick count
     * @returns {array} tick base data
     * @private
     */
    _makeLineTypeData: function(width, tickCount) {
        var tickInterval = width / (tickCount - 1),
            halfInterval = tickInterval / 2;
        return tui.util.map(tui.util.range(0, tickCount), function(index) {
            return {
                min: index * tickInterval - halfInterval,
                max: index * tickInterval + halfInterval
            };
        });
    },

    /**
     * To make tick base data about non line type chart.
     * @param {number} size width or height
     * @param {number} tickCount tick count
     * @returns {array} tick base data
     * @private
     */
    _makeNormalData: function(size, tickCount) {
        var len = tickCount - 1,
            tickInterval = size / len,
            prev = 0;
        return tui.util.map(tui.util.range(0, len), function(index) {
            var max = tui.util.min([size, (index + 1) * tickInterval]),
                scale = {
                    min: prev,
                    max: max
                };
            prev = max;
            return scale;
        });
    },

    /**
     * To make tick base data for custom event.
     * @param {{width: number, height: number}} dimension dimension
     * @param {number} tickCount tick count
     * @param {string} chartType chart type
     * @param {boolan} isVertical whether vertical or not
     * @returns {array.<object>} tick base data
     * @private
     */
    _makeData: function(dimension, tickCount, chartType, isVertical) {
        var sizeType = isVertical ? 'width' : 'height',
            data;
        if (predicate.isLineTypeChart(chartType)) {
            data = this._makeLineTypeData(dimension[sizeType], tickCount);
        } else {
            data = this._makeNormalData(dimension[sizeType], tickCount);
        }

        return data;
    },

    /**
     * Find index.
     * @param {number} pointValue mouse position point value
     * @returns {number} group index
     */
    findIndex: function(pointValue) {
        var foundIndex = -1;
        tui.util.forEachArray(this.data, function(scale, index) {
            if (scale.min < pointValue && scale.max >= pointValue) {
                foundIndex = index;
                return false;
            }
        });

        return foundIndex;
    },

    /**
     * Get tick base data length.
     * @returns {number} length
     */
    getLength: function() {
        return this.data.length;
    },

    /**
     * To make range of tooltip position.
     * @param {number} index index
     * @param {string} chartType chart type
     * @returns {{start: number, end: number}} range type value
     * @private
     */
    makeRange: function(index, chartType) {
        var scale = this.data[index],
            range, center;
        if (predicate.isLineTypeChart(chartType)) {
            center = parseInt(scale.max - (scale.max - scale.min) / 2, 10);
            range = {
                start: center,
                end: center
            };
        } else {
            range = {
                start: scale.min,
                end: scale.max
            };
        }

        return range;
    }
});

module.exports = TickBaseDataModel;

},{"../helpers/predicate":32}],23:[function(require,module,exports){
/**
 * @fileoverview  Chart factory play role register chart.
 *                Also, you can get chart from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var charts = {},
    factory = {
        /**
         * Get chart instance.
         * @param {string} chartType chart type
         * @param {object} data chart data
         * @param {object} theme chart options
         * @param {object} options chart options
         * @returns {object} chart instance;
         */
        get: function(chartType, data, theme, options) {
            var Chart = charts[chartType],
                chart;

            if (!Chart) {
                throw new Error('Not exist ' + chartType + ' chart.');
            }

            chart = new Chart(data, theme, options);

            return chart;
        },

        /**
         * Register chart.
         * @param {string} chartType char type
         * @param {class} ChartClass chart class
         */
        register: function(chartType, ChartClass) {
            charts[chartType] = ChartClass;
        }
    };

module.exports = factory;

},{}],24:[function(require,module,exports){
/**
 * @fileoverview  Plugin factory play role register rendering plugin.
 *                Also, you can get plugin from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var plugins = {},
    factory = {
        /**
         * Get graph renderer.
         * @param {string} libType type of graph library
         * @param {string} chartType chart type
         * @returns {object} renderer instance
         */
        get: function(libType, chartType) {
            var plugin = plugins[libType],
                Renderer, renderer;

            if (!plugin) {
                throw new Error('Not exist ' + libType + ' plugin.');
            }

            Renderer = plugin[chartType];
            if (!Renderer) {
                throw new Error('Not exist ' + chartType + ' chart renderer.');
            }

            renderer = new Renderer();

            return renderer;
        },
        /**
         * Plugin register.
         * @param {string} libType type of graph library
         * @param {object} plugin plugin to control library
         */
        register: function(libType, plugin) {
            plugins[libType] = plugin;
        }
    };

module.exports = factory;

},{}],25:[function(require,module,exports){
/**
 * @fileoverview  Theme factory play role register theme.
 *                Also, you can get theme from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    defaultTheme = require('../themes/defaultTheme');

var themes = {};

module.exports = {
    /**
     * Get theme.
     * @param {string} themeName theme name
     * @returns {object} theme object
     */
    get: function(themeName) {
        var theme = themes[themeName];

        if (!theme) {
            throw new Error('Not exist ' + themeName + ' theme.');
        }

        return theme;
    },

    /**
     * Theme register.
     * @param {string} themeName theme name
     * @param {object} theme theme
     */
    register: function(themeName, theme) {
        var targetItems;
        theme = JSON.parse(JSON.stringify(theme));

        if (themeName !== chartConst.DEFAULT_THEME_NAME) {
            theme = this._initTheme(theme);
        }

        targetItems = this._getInheritTargetThemeItems(theme);

        this._inheritThemeFont(theme, targetItems);
        this._copyColorInfo(theme);
        themes[themeName] = theme;
    },

    /**
     * Init theme.
     * @param {object} theme theme
     * @returns {object} theme
     * @private
     * @ignore
     */
    _initTheme: function(theme) {
        var cloneTheme = JSON.parse(JSON.stringify(defaultTheme)),
            newTheme;

        this._concatDefaultColors(theme, cloneTheme.series.colors)
        newTheme = this._overwriteTheme(theme, cloneTheme);

        newTheme = this._copyProperty({
            propName: 'yAxis',
            fromTheme: theme,
            toTheme: newTheme,
            rejectionProps: chartConst.YAXIS_PROPS
        });

        newTheme = this._copyProperty({
            propName: 'series',
            fromTheme: theme,
            toTheme: newTheme,
            rejectionProps: chartConst.SERIES_PROPS
        });

        return newTheme;
    },

    /**
     * Filter chart types.
     * @param {object} target target charts
     * @param {array.<string>} rejectionProps reject property
     * @returns {Object} filtered charts.
     * @private
     */
    _filterChartTypes: function(target, rejectionProps) {
        var result;
        if (!target) {
            return [];
        }

        result = tui.util.filter(target, function(item, name) {
            return tui.util.inArray(name, rejectionProps) === -1;
        });
        return result;
    },

    /**
     * Concat colors.
     * @param {object} theme theme
     * @param {array.<string>} seriesColors series colors
     * @private
     */
    _concatColors: function(theme, seriesColors) {
        if (theme.colors) {
            theme.colors = theme.colors.concat(seriesColors);
        }

        if (theme.singleColors) {
            theme.singleColors = theme.singleColors.concat(seriesColors);
        }
    },

    /**
     * Concat default colors.
     * @param {object} theme theme
     * @param {array.<string>} seriesColors series colors
     * @private
     */
    _concatDefaultColors: function(theme, seriesColors) {
        var chartTypes;

        if (!theme.series) {
            return;
        }

        chartTypes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(chartTypes).length) {
            this._concatColors(theme.series, seriesColors);
        } else {
            tui.util.forEach(chartTypes, function(item) {
                this._concatColors(item, seriesColors);
            }, this);
        }
    },

    /**
     * Overwrite theme
     * @param {object} from from theme property
     * @param {object} to to theme property
     * @returns {object} result property
     * @private
     */
    _overwriteTheme: function(from, to) {
        tui.util.forEach(to, function(item, key) {
            var fromItem = from[key];
            if (!fromItem) {
                return;
            }

            if (tui.util.isArray(fromItem)) {
                to[key] = fromItem.slice();
            } else if (tui.util.isObject(fromItem)) {
                this._overwriteTheme(fromItem, item);
            } else {
                to[key] = fromItem;
            }
        }, this);

        return to;
    },

    /**
     * Copy property.
     * @param {object} params parameters
     *      @param {string} params.propName property name
     *      @param {object} params.fromTheme from property
     *      @param {object} params.toTheme tp property
     *      @param {array.<string>} params.rejectionProps reject property name
     * @returns {object} copied property
     * @private
     */
    _copyProperty: function(params) {
        var chartTypes;

        if (!params.toTheme[params.propName]) {
            return params.toTheme;
        }

        chartTypes = this._filterChartTypes(params.fromTheme[params.propName], params.rejectionProps);
        if (tui.util.keys(chartTypes).length) {
            tui.util.forEach(chartTypes, function(item, key) {
                var cloneTheme = JSON.parse(JSON.stringify(defaultTheme[params.propName]));
                params.fromTheme[params.propName][key] = this._overwriteTheme(item, cloneTheme);
            }, this);

            params.toTheme[params.propName] = params.fromTheme[params.propName];
        }

        return params.toTheme;
    },

    /**
     * Copy color info to legend
     * @param {object} seriesTheme series theme
     * @param {object} legendTheme legend theme
     * @param {array.<string>} colors colors
     * @private
     */
    _copyColorInfoToOther: function(seriesTheme, legendTheme, colors) {
        legendTheme.colors = colors || seriesTheme.colors;
        if (seriesTheme.singleColors) {
            legendTheme.singleColors = seriesTheme.singleColors;
        }
        if (seriesTheme.borderColor) {
            legendTheme.borderColor = seriesTheme.borderColor;
        }
        if (seriesTheme.selectionColor) {
            legendTheme.selectionColor = seriesTheme.selectionColor;
        }
    },

    /**
     * Get target items about font inherit.
     * @param {object} theme theme
     * @returns {array.<object>} target items
     * @private
     */
    _getInheritTargetThemeItems: function(theme) {
        var items = [
                theme.title,
                theme.xAxis.title,
                theme.xAxis.label,
                theme.legend.label
            ],
            yAxisChartTypeThems = this._filterChartTypes(theme.yAxis, chartConst.YAXIS_PROPS),
            seriesChartTypeThemes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(yAxisChartTypeThems).length) {
            items.push(theme.yAxis.title);
            items.push(theme.yAxis.label);
        } else {
            tui.util.forEach(yAxisChartTypeThems, function(chatTypeTheme) {
                items.push(chatTypeTheme.title);
                items.push(chatTypeTheme.label);
            });
        }

        if (!tui.util.keys(seriesChartTypeThemes).length) {
            items.push(theme.series.label);
        } else {
            tui.util.forEach(seriesChartTypeThemes, function(chatTypeTheme) {
                items.push(chatTypeTheme.label);
            });
        }
        return items;
    },

    /**
     * Inherit theme font.
     * @param {object} theme theme
     * @param {array.<object>} targetItems target theme items
     * @private
     */
    _inheritThemeFont: function(theme, targetItems) {
        var baseFont = theme.chart.fontFamily;

        tui.util.forEachArray(targetItems, function(item) {
            if (!item.fontFamily) {
                item.fontFamily = baseFont;
            }
        });
    },

    /**
     * Copy color info.
     * @param {object} theme theme
     * @private
     * @ignore
     */
    _copyColorInfo: function(theme) {
        var seriesChartTypes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);
        if (!tui.util.keys(seriesChartTypes).length) {
            this._copyColorInfoToOther(theme.series, theme.legend);
            this._copyColorInfoToOther(theme.series, theme.tooltip);
        } else {
            tui.util.forEach(seriesChartTypes, function(item, chartType) {
                theme.legend[chartType] = {};
                theme.tooltip[chartType] = {};
                this._copyColorInfoToOther(item, theme.legend[chartType], item.colors || theme.legend.colors);
                this._copyColorInfoToOther(item, theme.tooltip[chartType], item.colors || theme.tooltip.colors);
                delete theme.legend.colors;
                delete theme.tooltip.colors;
            }, this);
        }
    }
};

},{"../const":15,"../themes/defaultTheme":59}],26:[function(require,module,exports){
/**
 * @fileoverview Axis Data Maker
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('./predicate'),
    calculator = require('./calculator');

var abs = Math.abs,
    concat = Array.prototype.concat;

/**
 * Axis data maker.
 * @module axisDataMaker
 */
var axisDataMaker = {
    /**
     * To make labels.
     * @param {array.<string>} labels labels
     * @param {number} labelInterval label interval
     * @returns {array.<string>} labels
     * @private
     */
    _makeLabels: function(labels, labelInterval) {
        var lastIndex;
        if (!labelInterval) {
            return labels;
        }

        lastIndex = labels.length - 1;
        return tui.util.map(labels, function(label, index) {
            if (index > 0 && index < lastIndex && (index % labelInterval) > 0) {
                label = chartConst.EMPTY_AXIS_LABEL;
            }
            return label;
        });
    },

    /**
     * To make data about label axis.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {array.<string>} labels chart labels
     *      @param {boolean} isVertical whether vertical or not
     * @returns {{
     *      labels: array.<string>,
     *      tickCount: number,
     *      validTickCount: number,
     *      isLabelAxis: boolean,
     *      isVertical: boolean
     * }} axis data
     */
    makeLabelAxisData: function(params) {
        var tickCount = params.labels.length,
            options = params.options || {};
        if (!params.aligned) {
            tickCount += 1;
        }

        return {
            labels: this._makeLabels(params.labels, options.labelInterval),
            tickCount: tickCount,
            validTickCount: 0,
            isLabelAxis: true,
            isVertical: !!params.isVertical,
            aligned: !!params.aligned
        };
    },

    /**
     * To make data about value axis.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {array.<array.<number>>} params.values chart values
     *      @param {{width:number, height:number}} params.seriesDimension series dimension
     *      @param {array.<function>} params.formatFunctions format functions
     *      @param {string} params.stacked stacked option
     *      @param {string} params.options axis options
     * @returns {{
     *      labels: array.<string>,
     *      tickCount: number,
     *      validTickCount: number,
     *      isLabelAxis: boolean,
     *      scale: {min: number, max: number},
     *      isVertical: boolean
     * }} axis data
     */
    makeValueAxisData: function(params) {
        var options = params.options || {},
            isVertical = !!params.isVertical,
            isPositionRight = !!params.isPositionRight,
            formatFunctions = params.formatFunctions,
            tickInfo;
        if (params.stacked === 'percent') {
            tickInfo = chartConst.PERCENT_STACKED_TICK_INFO;
            formatFunctions = [];
        } else {
            tickInfo = this._getTickInfo({
                values: this._makeBaseValues(params.values, params.stacked),
                seriesDimension: params.seriesDimension,
                isVertical: isVertical,
                isPositionRight: isPositionRight,
                chartType: params.chartType
            }, options);
        }

        return {
            labels: this.formatLabels(tickInfo.labels, formatFunctions),
            tickCount: tickInfo.tickCount,
            validTickCount: tickInfo.tickCount,
            scale: tickInfo.scale,
            step: tickInfo.step,
            isVertical: isVertical,
            isPositionRight: isPositionRight,
            aligned: !!params.aligned
        };
    },

    /**
     * To make base values.
     * @memberOf module:axisDataMaker
     * @param {array.<number>} groupValues group values
     * @param {string} stacked stacked option.
     * @returns {array.<number>} base values
     * @private
     */
    _makeBaseValues: function(groupValues, stacked) {
        var baseValues = concat.apply([], groupValues); // flatten array
        if (stacked === chartConst.STACKED_NORMAL_TYPE) {
            baseValues = baseValues.concat(tui.util.map(groupValues, function(values) {
                var plusValues = tui.util.filter(values, function(value) {
                    return value > 0;
                });
                return tui.util.sum(plusValues);
            }));
        }
        return baseValues;
    },

    /**
     * Get base size for get candidate tick counts.
     * @memberOf module:axisDataMaker
     * @param {{width: number, height: number}} dimension chat dimension
     * @param {boolean} isVertical whether vertical or not
     * @returns {number} base size
     * @private
     */
    _getBaseSize: function(dimension, isVertical) {
        var baseSize;
        if (isVertical) {
            baseSize = dimension.height;
        } else {
            baseSize = dimension.width;
        }
        return baseSize;
    },

    /**
     * Get candidate tick counts.
     * @memberOf module:axisDataMaker
     * @param {{width: number, height: number}} chartDimension chat dimension
     * @param {boolean} isVertical whether vertical or not
     * @returns {array.<number>} tick counts
     * @private
     */
    _getCandidateTickCounts: function(chartDimension, isVertical) {
        var baseSize = this._getBaseSize(chartDimension, isVertical),
            start = tui.util.max([3, parseInt(baseSize / chartConst.MAX_PIXEL_TYPE_STEP_SIZE, 10)]),
            end = tui.util.max([start, parseInt(baseSize / chartConst.MIN_PIXEL_TYPE_STEP_SIZE, 10)]) + 1,
            tickCounts = tui.util.range(start, end);
        return tickCounts;
    },

    /**
     * Get comparing value.
     * @memberOf module:axisDataMaker
     * @param {number} min minimum value of user data
     * @param {number} max maximum value of user data
     * @param {{scale: {min: number, max: number}, step: number}} tickInfo tick info
     * @returns {number} comparing value
     * @private
     */
    _getComparingValue: function(min, max, tickInfo) {
        var diffMax = abs(tickInfo.scale.max - max),
            diffMin = abs(min - tickInfo.scale.min),
            weight = Math.pow(10, tui.util.lengthAfterPoint(tickInfo.step));
        return (diffMax + diffMin) * weight;
    },

    /**
     * Select tick info.
     * @memberOf module:axisDataMaker
     * @param {number} min minimum value of user data
     * @param {number} max maximum value of user data
     * @param {array.<object>} candidates tick info candidates
     * @returns {{scale: {min: number, max: number}, tickCount: number, step: number, labels: array.<number>}} selected tick info
     * @private
     */
    _selectTickInfo: function(min, max, candidates) {
        var getComparingValue = tui.util.bind(this._getComparingValue, this, min, max),
            tickInfo = tui.util.min(candidates, getComparingValue);
        return tickInfo;
    },

    /**
     * Get tick count and scale.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {number} params.values base values
     *      @param {{width: number, height: number}} params.seriesDimension chat dimension
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {string} params.chartType chat type
     * @param {{min: number, max:number}} options axis options
     * @returns {{tickCount: number, scale: object}} tick info
     * @private
     */
    _getTickInfo: function(params, options) {
        var min = tui.util.min(params.values),
            max = tui.util.max(params.values),
            intTypeInfo, tickCounts, candidates, tickInfo;
        // 01. min, max, options   
        intTypeInfo = this._makeIntegerTypeInfo(min, max, options);

        // 02. tick count  
        tickCounts = params.tickCount ? [params.tickCount] : this._getCandidateTickCounts(params.seriesDimension, params.isVertical);

        // 03. tick info  
        candidates = this._getCandidateTickInfos({
            min: intTypeInfo.min,
            max: intTypeInfo.max,
            tickCounts: tickCounts,
            chartType: params.chartType
        }, intTypeInfo.options);

        // 04. tick info    
        tickInfo = this._selectTickInfo(intTypeInfo.min, intTypeInfo.max, candidates);

        // 05.   tick info   
        tickInfo = this._revertOriginalTypeTickInfo(tickInfo, intTypeInfo.divideNum);
        return tickInfo;
    },

    /**
     * To make integer type info
     * @memberOf module:axisDataMaker
     * @param {number} min minimum value of user data
     * @param {number} max maximum value of user data
     * @param {{min: number, max: number}} options axis options
     * @returns {{min: number, max: number, options: {min: number, max: number}, divideNum: number}} integer type info
     * @private
     */
    _makeIntegerTypeInfo: function(min, max, options) {
        var multipleNum, changedOptions;

        if (abs(min) >= 1 || abs(max) >= 1) {
            return {
                min: min,
                max: max,
                options: options,
                divideNum: 1
            };
        }

        multipleNum = tui.util.findMultipleNum(min, max);
        changedOptions = {};

        if (!tui.util.isUndefined(options.min)) {
            changedOptions.min = options.min * multipleNum;
        }

        if (!tui.util.isUndefined(options.max)) {
            changedOptions.max = options.max * multipleNum;
        }

        return {
            min: min * multipleNum,
            max: max * multipleNum,
            options: changedOptions,
            divideNum: multipleNum
        };
    },

    /**
     * Revert tick info to original type.
     * @memberOf module:axisDataMaker
     * @param {{step: number, scale: {min: number, max: number}, labels: array.<number>}} tickInfo tick info
     * @param {number} divideNum divide num
     * @returns {{step: number, scale: {min: number, max: number}, labels: array.<number>}} divided tick info
     * @private
     */
    _revertOriginalTypeTickInfo: function(tickInfo, divideNum) {
        if (divideNum === 1) {
            return tickInfo;
        }

        tickInfo.step = tui.util.division(tickInfo.step, divideNum);
        tickInfo.scale.min = tui.util.division(tickInfo.scale.min, divideNum);
        tickInfo.scale.max = tui.util.division(tickInfo.scale.max, divideNum);
        tickInfo.labels = tui.util.map(tickInfo.labels, function(label) {
            return tui.util.division(label, divideNum);
        });

        return tickInfo;
    },

    /**
     * Normalize step.
     * @memberOf module:axisDataMaker
     * @param {number} step original step
     * @returns {number} normalized step
     * @private
     */
    _normalizeStep: function(step) {
        return calculator.normalizeAxisNumber(step);
    },

    /**
     * To minimize tick scale.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {number} params.userMin user min
     *      @param {number} params.userMax user max
     *      @param {{tickCount: number, scale: object}} params.tickInfo tick info
     *      @param {{min: number, max:number}} params.options axis options
     * @returns {{tickCount: number, scale: object, labels: array}} corrected tick info
     * @private
     */
    _minimizeTickScale: function(params) {
        var tickInfo = params.tickInfo,
            ticks = tui.util.range(1, tickInfo.tickCount),
            options = params.options,
            step = tickInfo.step,
            scale = tickInfo.scale,
            tickMax = scale.max,
            tickMin = scale.min,
            isUndefinedMin = tui.util.isUndefined(options.min),
            isUndefinedMax = tui.util.isUndefined(options.max),
            labels;
        tui.util.forEachArray(ticks, function(tickIndex) {
            var curStep = (step * tickIndex),
                curMin = tickMin + curStep,
                curMax = tickMax - curStep;

            //     
            if (params.userMin <= curMin && params.userMax >= curMax) {
                return false;
            }

            // min     
            if ((isUndefinedMin && params.userMin > curMin) ||
                (!isUndefinedMin && options.min >= curMin)) {
                scale.min = curMin;
            }

            // max     
            if ((isUndefinedMin && params.userMax < curMax) ||
                (!isUndefinedMax && options.max <= curMax)) {
                scale.max = curMax;
            }
        });

        labels = calculator.makeLabelsFromScale(scale, step);
        tickInfo.labels = labels;
        tickInfo.step = step;
        tickInfo.tickCount = labels.length;
        return tickInfo;
    },

    /**
     * To divide tick step.
     * @memberOf module:axisDataMaker
     * @param {{scale: {min: number, max: number}, tickCount: number, step: number, labels: array.<number>}} tickInfo tick info
     * @param {number} orgTickCount original tickCount
     * @returns {{scale: {min: number, max: number}, tickCount: number, step: number, labels: array.<number>}} tick info
     * @private
     */
    _divideTickStep: function(tickInfo, orgTickCount) {
        var step = tickInfo.step,
            scale = tickInfo.scale,
            tickCount = tickInfo.tickCount;
        // step 2    tickCount -1 tickCount orgTickCount    step  .
        if ((step % 2 === 0) &&
            abs(orgTickCount - ((tickCount * 2) - 1)) <= abs(orgTickCount - tickCount)) {
            step = step / 2;
            tickInfo.labels = calculator.makeLabelsFromScale(scale, step);
            tickInfo.tickCount = tickInfo.labels.length;
            tickInfo.step = step;
        }
        return tickInfo;
    },

    /**
     * To make tick info
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {number} params.tickCount tick count
     *      @param {number} params.min scale min
     *      @param {number} params.max scale max
     *      @param {number} params.userMin minimum value of user data
     *      @param {number} params.userMax maximum value of user data
     *      @param {boolean} params.isMinus whether scale is minus or not
     *      @param {string} params.chartType chart type
     *      @param {{min: number, max: number}} params.options axis options
     * @returns {{
     *      scale: {min: number, max: number},
     *      tickCount: number,
     *      step: number,
     *      labels: array.<number>
     * }} tick info
     * @private
     */
    _makeTickInfo: function(params) {
        var scale = params.scale,
            step, tickInfo;

        // 01.  scale  step 
        step = calculator.getScaleStep(scale, params.tickCount);

        // 02. step   (ex: 0.3 --> 0.5, 7 --> 10)
        step = this._normalizeStep(step);

        // 03. scale  
        scale = this._normalizeScale(scale, step, params.tickCount);

        // 04. line   min scale min  , min 1 step  
        scale.min = this._addMinPadding({
            min: scale.min,
            step: step,
            userMin: params.userMin,
            minOption: params.options.min,
            chartType: params.chartType
        });

        // 04.  max scael max  , max 1 step  
        scale.max = this._addMaxPadding({
            max: scale.max,
            step: step,
            userMax: params.userMax,
            maxOption: params.options.max,
            chartType: params.chartType
        });

        // 05. axis scale  min, max    
        tickInfo = this._minimizeTickScale({
            userMin: params.userMin,
            userMax: params.userMax,
            tickInfo: {scale: scale, step: step, tickCount: params.tickCount},
            options: params.options
        });

        tickInfo = this._divideTickStep(tickInfo, params.tickCount);
        return tickInfo;
    },

    /**
     * Add scale min padding.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @prams {number} params.min scale min
     *      @param {number} params.userMin minimum value of user data
     *      @param {number} params.minOption min option
     *      @param {number} params.step tick step
     * @returns {number} scale min
     * @private
     */
    _addMinPadding: function(params) {
        var min = params.min;

        if ((!predicate.isLineChart(params.chartType) && params.userMin >= 0) || !tui.util.isUndefined(params.minOption)) {
            return min;
        }
        // normalize scale min user min   step 
        if (params.min === params.userMin) {
            min -= params.step;
        }
        return min;
    },

    /**
     * Add scale max padding.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @prams {number} params.max scale max
     *      @param {number} params.userMax maximum value of user data
     *      @param {number} params.maxOption max option
     *      @param {number} params.step tick step
     * @returns {number} scale max
     * @private
     */
    _addMaxPadding: function(params) {
        var max = params.max;

        if ((!predicate.isLineChart(params.chartType) && params.userMax <= 0) || !tui.util.isUndefined(params.maxOption)) {
            return max;
        }

        // normalize scale max user max   step 
        if (tui.util.isUndefined(params.maxOption) && (params.max === params.userMax)) {
            max += params.step;
        }
        return max;
    },

    /**
     * To normalize min.
     * @memberOf module:axisDataMaker
     * @param {number} min original min
     * @param {number} step tick step
     * @returns {number} normalized min
     * @private
     */
    _normalizeMin: function(min, step) {
        var mod = tui.util.mod(min, step),
            normalized;

        if (mod === 0) {
            normalized = min;
        } else {
            normalized = tui.util.subtraction(min, (min >= 0 ? mod : step + mod));
        }
        return normalized;
    },

    /**
     * To make normalized max.
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} scale scale
     * @param {number} step tick step
     * @param {number} tickCount tick count
     * @returns {number} normalized max
     * @private
     */
    _makeNormalizedMax: function(scale, step, tickCount) {
        var minMaxDiff = tui.util.multiplication(step, tickCount - 1),
            normalizedMax = tui.util.addition(scale.min, minMaxDiff),
            maxDiff = scale.max - normalizedMax,
            modDiff, divideDiff;
        // normalize max  max    step    
        if (maxDiff > 0) {
            modDiff = maxDiff % step;
            divideDiff = Math.floor(maxDiff / step);
            normalizedMax += step * (modDiff > 0 ? divideDiff + 1 : divideDiff);
        }
        return normalizedMax;
    },

    /**
     * To normalize scale.
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} scale base scale
     * @param {number} step tick step
     * @param {number} tickCount tick count
     * @returns {{min: number, max: number}} normalized scale
     * @private
     */
    _normalizeScale: function(scale, step, tickCount) {
        scale.min = this._normalizeMin(scale.min, step);
        scale.max = this._makeNormalizedMax(scale, step, tickCount);
        return scale;
    },

    /**
     * Get candidates about tick info.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {number} params.min minimum value of user data
     *      @param {number} params.max maximum value of user data
     *      @param {array.<number>} params.tickCounts tick counts
     *      @param {string} params.chartType chart type
     * @param {{min: number, max:number}} options axis options
     * @returns {array} candidates about tick info
     * @private
     */
    _getCandidateTickInfos: function(params, options) {
        var userMin = params.min,
            userMax = params.max,
            min = params.min,
            max = params.max,
            scale, candidates;

        // min, max  scale 
        scale = this._makeBaseScale(min, max, options);

        candidates = tui.util.map(params.tickCounts, function(tickCount) {
            return this._makeTickInfo({
                tickCount: tickCount,
                scale: tui.util.extend({}, scale),
                userMin: userMin,
                userMax: userMax,
                chartType: params.chartType,
                options: options
            });
        }, this);
        return candidates;
    },

    /**
     * To make base scale
     * @memberOf module:axisDataMaker
     * @param {number} min minimum value of user data
     * @param {number} max maximum value of user data
     * @param {{min: number, max: number}} options axis options
     * @returns {{min: number, max: number}} base scale
     * @private
     */
    _makeBaseScale: function(min, max, options) {
        var isMinus = false,
            tmpMin, scale;

        if (min < 0 && max <= 0) {
            isMinus = true;
            tmpMin = min;
            min = -max;
            max = -tmpMin;
        }

        scale = calculator.calculateScale(min, max);

        if (isMinus) {
            tmpMin = scale.min;
            scale.min = -scale.max;
            scale.max = -tmpMin;
        }

        scale.min = !tui.util.isUndefined(options.min) ? options.min : scale.min;
        scale.max = !tui.util.isUndefined(options.max) ? options.max : scale.max;

        return scale;
    },

    /**
     * Format labels.
     * @memberOf module:axisDataMaker
     * @param {string[]} labels target labels
     * @param {function[]} formatFunctions format functions
     * @returns {string[]} formatted labels
     */
    formatLabels: function(labels, formatFunctions) {
        var result;
        if (!formatFunctions || !formatFunctions.length) {
            return labels;
        }
        result = tui.util.map(labels, function(label) {
            var fns = concat.apply([label], formatFunctions);
            return tui.util.reduce(fns, function(stored, fn) {
                return fn(stored);
            });
        });
        return result;
    }
};

module.exports = axisDataMaker;

},{"../const":15,"./calculator":28,"./predicate":32}],27:[function(require,module,exports){
/**
 * @fileoverview Bounds maker.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    calculator = require('./calculator'),
    predicate = require('./predicate'),
    renderUtil = require('./renderUtil');

var concat = Array.prototype.concat;

/**
 * Bounds maker.
 * @module boundsMaker
 */
var boundsMaker = {
    /**
     * Get max label of value axis.
     * @memberOf module:boundsMaker
     * @param {object} convertedData convert data
     * @param {string} chartType chart type
     * @returns {number|string} max label
     * @private
     */
    _getValueAxisMaxLabel: function(convertedData, chartType) {
        var values = chartType && convertedData.values[chartType] || convertedData.joinValues,
            formatFunctions = convertedData.formatFunctions,
            flattenValues = concat.apply([], values),
            min = tui.util.min(flattenValues),
            max = tui.util.max(flattenValues),
            scale = calculator.calculateScale(min, max),
            minLabel = calculator.normalizeAxisNumber(scale.min),
            maxLabel = calculator.normalizeAxisNumber(scale.max),
            fns = formatFunctions && formatFunctions.slice() || [];
        maxLabel = (minLabel + '').length > (maxLabel + '').length ? minLabel : maxLabel;
        fns.unshift(maxLabel);
        maxLabel = tui.util.reduce(fns, function(stored, fn) {
            return fn(stored);
        });
        return maxLabel;
    },

    /**
     * Get height of x axis area.
     * @memberOf module:boundsMaker
     * @param {object} options x axis options,
     * @param {array.<string>} labels axis labels
     * @param {object} theme axis theme
     * @returns {number} height
     * @private
     */
    _getXAxisHeight: function(options, labels, theme) {
        var title = options && options.title,
            titleAreaHeight = renderUtil.getRenderedLabelHeight(title, theme.title) + chartConst.TITLE_PADDING,
            height = renderUtil.getRenderedLabelsMaxHeight(labels, theme.label) + titleAreaHeight;
        return height;
    },

    /**
     * Get width about y axis.
     * @param {object} options y axis options
     * @param {array.<string>} labels labels
     * @param {object} theme yAxis theme
     * @param {number} index options index
     * @returns {number} y axis width
     * @private
     */
    _getYAxisWidth: function(options, labels, theme, index) {
        var title = '',
            titleAreaWidth, width;

        if (options) {
            options = [].concat(options);
            title = options[index || 0].title;
        }

        titleAreaWidth = renderUtil.getRenderedLabelHeight(title, theme.title) + chartConst.TITLE_PADDING;
        width = renderUtil.getRenderedLabelsMaxWidth(labels, theme.label) + titleAreaWidth + chartConst.AXIS_LABEL_PADDING;

        return width;
    },

    /**
     * Get width about y right axis.
     * @memberOf module:boundsMaker
     * @param {object} params parameters
     *      @param {array.<string>} params.chartTypes y axis chart types
     *      @param {object} params.theme y axis theme
     *      @param {object} params.options y axis options
     * @returns {number} y right axis width
     * @private
     */
    _getYRAxisWidth: function(params) {
        var chartTypes = params.chartTypes || [],
            len = chartTypes.length,
            width = 0,
            index, chartType, theme, label;
        if (len > 0) {
            index = len - 1;
            chartType = chartTypes[index];
            theme = params.theme[chartType] || params.theme;
            label = this._getValueAxisMaxLabel(params.convertedData, chartType);
            width = this._getYAxisWidth(params.options, [label], theme, index);
        }
        return width;
    },

    /**
     * To make axes dimension.
     * @memberOf module:boundsMaker
     * @param {object} params parameters
     *      @param {object} params.convertedData converted data
     *      @param {object} params.theme chart theme
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {object} params.options chart options
     *      *      @param {object} params.axesLabelInfo axes label info
     * @returns {{
     *      yAxis: {width: number},
     *      yrAxis: {width: number},
     *      xAxis: {height: number}
     * }} axes dimension
     * @private
     */
    _makeAxesDimension: function(params) {
        var yAxisWidth = 0,
            xAxisHeight = 0,
            yrAxisWidth = 0,
            axesLabelInfo, chartType;

        // axis     
        if (params.hasAxes) {
            axesLabelInfo = params.axesLabelInfo;
            chartType = params.optionChartTypes && params.optionChartTypes[0] || '';
            yAxisWidth = this._getYAxisWidth(params.options.yAxis, axesLabelInfo.yAxis, params.theme.yAxis[chartType] || params.theme.yAxis);
            xAxisHeight = this._getXAxisHeight(params.options.xAxis, axesLabelInfo.xAxis, params.theme.xAxis);
            yrAxisWidth = this._getYRAxisWidth({
                convertedData: params.convertedData,
                chartTypes: params.optionChartTypes,
                theme: params.theme.yAxis,
                options: params.options.yAxis
            });
        }

        return {
            yAxis: {
                width: yAxisWidth
            },
            yrAxis: {
                width: yrAxisWidth
            },
            xAxis: {
                height: xAxisHeight
            }
        };
    },

    /**
     * Whether skipped legend sizing or not.
     * @param {string} chartType chart type
     * @param {?object} options legend options
     * @returns {boolean} result boolean
     * @private
     */
    _isSkippedLegendSizing: function(chartType, options) {
        return (predicate.isPieChart(chartType) && predicate.isPieLegendAlign(options.align)) || options.hidden;
    },

    /**
     * To make legend dimension.
     * @memberOf module:boundsMaker
     * @param {array.<string>} joinLegendLabels legend labels
     * @param {object} labelTheme label theme
     * @param {string} chartType chart type
     * @param {object} legendOptions series option
     * @returns {{width: number}} legend dimension
     * @private
     */
    _makeLegendDimension: function(joinLegendLabels, labelTheme, chartType, legendOptions) {
        var legendWidth = 0,
            legendLabels, maxLabelWidth;

        legendOptions = legendOptions || {};

        if (!this._isSkippedLegendSizing(chartType, legendOptions)) {
            legendLabels = tui.util.map(joinLegendLabels, function(item) {
                return item.label;
            });
            maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(legendLabels, labelTheme);
            legendWidth = maxLabelWidth + chartConst.LEGEND_RECT_WIDTH +
                chartConst.LEGEND_LABEL_LEFT_PADDING + (chartConst.LEGEND_AREA_PADDING * 2);
        }

        return {
            width: legendWidth
        };
    },

    /**
     * To make series dimension.
     * @memberOf module:boundsMaker
     * @param {object} params parameters
     *      @param {{width: number, height: number}} params.chartDimension chart dimension
     *      @param {{
     *          yAxis: {width: number, height:number},
     *          xAxis: {width: number, height:number},
     *          yrAxis: {width: number, height:number}
     *      }} params.axesDimension axes dimension
     *      @param {number} params.legendWidth legend width
     *      @param {number} params.titleHeight title height
     * @returns {{width: number, height: number}} series dimension
     * @private
     */
    _makeSeriesDimension: function(params) {
        var axesDimension = params.axesDimension,
            rightAreaWidth = params.legendWidth + axesDimension.yrAxis.width,
            width = params.chartDimension.width - (chartConst.CHART_PADDING * 2) - axesDimension.yAxis.width - rightAreaWidth,
            height = params.chartDimension.height - (chartConst.CHART_PADDING * 2) - params.titleHeight - axesDimension.xAxis.height;

        return {
            width: width,
            height: height
        };
    },

    /**
     * To make chart dimension.
     * @param {{width: number, height: number}} chartOptions chart options
     * @returns {{width: (number), height: (number)}} chart dimension
     * @private
     */
    _makeChartDimension: function(chartOptions) {
        return {
            width: chartOptions.width || chartConst.CHART_DEFAULT_WIDTH,
            height: chartOptions.height || chartConst.CHART_DEFAULT_HEIGHT
        };
    },

    /**
     * To make title dimension
     * @param {{title: string}} option title option
     * @param {{fontFamily: string, fontSize: number}} theme title theme
     * @returns {{height: number}} title dimension
     * @private
     */
    _makeTitleDimension: function(option, theme) {
        return {
            height: renderUtil.getRenderedLabelHeight(option, theme) + chartConst.TITLE_PADDING
        };
    },

    /**
     * To make plot dimention
     * @param {{width: number, height: number}} seriesDimension series dimension
     * @returns {{width: number, height: number}} plot dimension
     * @private
     */
    _makePlotDimension: function(seriesDimension) {
        return {
            width: seriesDimension.width + chartConst.HIDDEN_WIDTH,
            height: seriesDimension.height + chartConst.HIDDEN_WIDTH
        };
    },

    /**
     * Get components dimension
     * @memberOf module:boundsMaker
     * @param {object} params parameters
     *      @param {object} params.convertedData converted data
     *      @param {object} params.theme chart theme
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {object} params.options chart options
     *      @param {object} params.axesLabelInfo axes label info
     * @returns {Object} components dimensions
     * @private
     */
    _getComponentsDimensions: function(params) {
        var chartOptions = params.options.chart || {},
            chartDimension = this._makeChartDimension(chartOptions),
            titleDimension = this._makeTitleDimension(chartOptions.title, params.theme.title),
            axesDimension = this._makeAxesDimension(params),
            legendDimension = this._makeLegendDimension(params.convertedData.joinLegendLabels, params.theme.legend.label, params.options.chartType, params.options.legend),
            seriesDimension = this._makeSeriesDimension({
                chartDimension: chartDimension,
                axesDimension: axesDimension,
                legendWidth: legendDimension.width,
                titleHeight: titleDimension.height
            });

        return tui.util.extend({
            chart: chartDimension,
            title: titleDimension,
            series: seriesDimension,
            plot: this._makePlotDimension(seriesDimension),
            legend: legendDimension
        }, axesDimension);
    },

    /**
     * To make basic bound.
     * @param {{width: number, height: number}} dimension series dimension.
     * @param {number} top top
     * @param {number} left left
     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} series bound.
     * @private
     */
    _makeBasicBound: function(dimension, top, left) {
        return {
            dimension: dimension,
            position: {
                top: top,
                left: left
            }
        };
    },

    /**
     * To make yAxis bound.
     * @param {{yAxis: {width: number}, plot: {height: number}}} dimensions dimensions
     * @param {number} top top
     * @returns {{dimension: {width: number, height: (number)}, position: {top: number, left: number}}} yAxis bound
     * @private
     */
    _makeYAxisBound: function(dimensions, top) {
        return {
            dimension: {
                width: dimensions.yAxis.width,
                height: dimensions.plot.height
            },
            position: {
                top: top,
                left: this.chartLeftPadding
            }
        };
    },

    /**
     * To make xAxis bound.
     * @param {{xAxis: {height: number}, plot: {width: number}}} dimensions dimensions
     * @param {number} top top
     * @param {number} left left
     * @param {{degree: number}} rotationInfo rotation info
     * @returns {{dimension: {width: number, height: (number)}, position: {top: number, left: number}}} xAxis bound
     * @private
     */
    _makeXAxisBound: function(dimensions, top, left, rotationInfo) {
        var bound = {
            dimension: {
                width: dimensions.plot.width,
                height: dimensions.xAxis.height
            },
            position: {
                top: top + dimensions.series.height,
                left: left - chartConst.HIDDEN_WIDTH
            }
        };

        if (rotationInfo) {
            bound.degree = rotationInfo.degree;
        }

        return bound;
    },

    /**
     * To make yrAxis bound.
     * @param {{yrAxis: {width: number}, plot: {height: number}, legend: {width: number}}} dimensions dimensions
     * @param {number} top top
     * @returns {{dimension: {width: number, height: (number)}, position: {top: number, left: number}}} yrAxis bound
     * @private
     */
    _makeYRAxisBound: function(dimensions, top) {
        return {
            dimension: {
                width: dimensions.yrAxis.width,
                height: dimensions.plot.height
            },
            position: {
                top: top,
                right: dimensions.legend.width + chartConst.HIDDEN_WIDTH + chartConst.CHART_PADDING
            }
        };
    },

    /**
     * To make axes bounds.
     * @memberOf module:boundsMaker
     * @param {object} params parameters
     *      @param {boolean} params.hasAxes whether has axed or not
     *      @param {array.<string>} params.optionChartTypes y axis chart types
     *      @param {{width: number, height: number}} params.dimension chart dimension
     *      @param {number} params.top top position
     *      @param {number} params.right right position
     *      @param {{degree: number}} params.rotationInfo rotation info
     * @returns {object} axes bounds
     * @private
     */
    _makeAxesBounds: function(params) {
        var bounds;

        // pie  axis        
        if (!params.hasAxes) {
            return {};
        }

        bounds = {
            plot: this._makeBasicBound(params.dimensions.plot, params.top, params.left - chartConst.HIDDEN_WIDTH),
            yAxis: this._makeYAxisBound(params.dimensions, params.top),
            xAxis: this._makeXAxisBound(params.dimensions, params.top, params.left, params.rotationInfo)
        };

        //  y axis  bounds  
        if (params.optionChartTypes && params.optionChartTypes.length) {
            bounds.yrAxis = this._makeYRAxisBound(params.dimensions, params.top);
        }

        return bounds;
    },

    /**
     * To make chart bound.
     * @param {{width: number, height: number}} dimension chart dimension.
     * @returns {{dimension: {width: number, height: number}}} chart bound
     * @private
     */
    _makeChartBound: function(dimension) {
        return {
            dimension: dimension
        };
    },

    /**
     * To make legend bound.
     * @param {{title: {height: number}, series: {width: number}, yrAxis: {width: number}}} dimensions dimensions
     * @param {number} yAxisWidth yAxis width
     * @returns {{position: {top: number, left: number}}} legend bound
     * @private
     */
    _makeLegendBound: function(dimensions) {
        return {
            position: {
                top: dimensions.title.height,
                left: dimensions.yAxis.width + dimensions.series.width + dimensions.yrAxis.width + this.chartLeftPadding
            }
        };
    },

    /**
     * To make axes label info.
     * @param {object} params parameters
     *      @param {boolean} params.hasAxes whether has axes or not
     *      @param {array} params.optionChartTypes chart types
     *      @param {object} convertedData converted data
     *      @param {boolean} isVertical whether vertical or not
     * @returns {{xAxis: array, yAxis: array}} label info
     * @private
     */
    _makeAxesLabelInfo: function(params) {
        var chartType, maxValueLabel, yLabels, xLabels;

        if (!params.hasAxes) {
            return null;
        }

        chartType = params.optionChartTypes && params.optionChartTypes[0] || '';

        // value      value label  (lable    )
        maxValueLabel = this._getValueAxisMaxLabel(params.convertedData, chartType);

        //   x y    
        if (params.isVertical) {
            yLabels = [maxValueLabel];
            xLabels = params.convertedData.labels;
        } else {
            yLabels = params.convertedData.labels;
            xLabels = [maxValueLabel];
        }

        return {
            xAxis: xLabels,
            yAxis: yLabels
        };
    },

    /**
     * Find rotation degree.
     * @param {number} limitWidth limit width
     * @param {number} labelWidth label width
     * @param {number} labelHeight label height
     * @param {number} index candidates index
     * @returns {number} rotation degree
     * @private
     */
    _findRotationDegree: function(limitWidth, labelWidth, labelHeight) {
        var foundDegree,
            halfWidth = labelWidth / 2,
            halfHeight = labelHeight / 2;

        tui.util.forEachArray(chartConst.DEGREE_CANDIDATES, function(degree) {
            var compareWidth = (calculator.calculateAdjacent(degree, halfWidth) + calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, halfHeight)) * 2;
            foundDegree = degree;
            if (compareWidth <= limitWidth + chartConst.XAXIS_LABEL_COMPARE_MARGIN) {
                return false;
            }
        });

        return foundDegree;
    },

    /**
     * To make rotation info about horizontal label.
     * @param {number} seriesWidth series area width
     * @param {array.<string>} labels axis labels
     * @param {object} theme axis label theme
     * @returns {?object} rotation info
     * @private
     */
    _makeHorizontalLabelRotationInfo: function(seriesWidth, labels, theme) {
        var maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(labels, theme),
            limitWidth = seriesWidth / labels.length - chartConst.XAXIS_LABEL_GUTTER,
            degree, labelHeight;

        if (maxLabelWidth <= limitWidth) {
            return null;
        }

        labelHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme);
        degree = this._findRotationDegree(limitWidth, maxLabelWidth, labelHeight);

        return {
            maxLabelWidth: maxLabelWidth,
            labelHeight: labelHeight,
            degree: degree
        };
    },

    /**
     * To calculate overflow position left.
     * @param {number} yAxisWidth yAxis width
     * @param {{degree: number, labelHeight: number}} rotationInfo rotation info
     * @param {string} firstLabel firstLabel
     * @param {obejct} theme label theme
     * @returns {number} overflow position left
     * @private
     */
    _calculateOverflowLeft: function(yAxisWidth, rotationInfo, firstLabel, theme) {
        var degree = rotationInfo.degree,
            labelHeight = rotationInfo.labelHeight,
            firstLabelWidth = renderUtil.getRenderedLabelWidth(firstLabel, theme),
            newLabelWidth = (calculator.calculateAdjacent(degree, firstLabelWidth / 2) + calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2,
            diffLeft = newLabelWidth - yAxisWidth;
        return diffLeft;
    },


    /**
     * To calculate height of xAxis.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @returns {number} xAxis height
     * @private
     */
    _calculateXAxisHeight: function(rotationInfo) {
        var degree = rotationInfo.degree,
            maxLabelWidth = rotationInfo.maxLabelWidth,
            labelHeight = rotationInfo.labelHeight,
            axisHeight = (calculator.calculateOpposite(degree, maxLabelWidth / 2) + calculator.calculateOpposite(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2;
        return axisHeight;
    },

    /**
     * To calculate height difference between origin label and rotation label.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @returns {number} height difference
     * @private
     */
    _calculateHeightDifference: function(rotationInfo) {
        var xAxisHeight = this._calculateXAxisHeight(rotationInfo);
        return xAxisHeight - rotationInfo.labelHeight;
    },

    /**
     * Update degree of rotationInfo.
     * @param {number} seriesWidth series width
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @param {number} labelLength labelLength
     * @param {number} overflowLeft overflow left
     * @private
     */
    _updateDegree: function(seriesWidth, rotationInfo, labelLength, overflowLeft) {
        var limitWidth, newDegree;
        if (overflowLeft > 0) {
            limitWidth = seriesWidth / labelLength + chartConst.XAXIS_LABEL_GUTTER;
            newDegree = this._findRotationDegree(limitWidth, rotationInfo.maxLabelWidth, rotationInfo.labelHeight);
            rotationInfo.degree = newDegree;
        }
    },

    /**
     * Update width of dimentios.
     * @param {{plot: {width: number}, series: {width: number}, xAxis: {width: number}}} dimensions dimensions
     * @param {number} overflowLeft overflow left
     * @private
     */
    _updateDimensionsWidth: function(dimensions, overflowLeft) {
        if (overflowLeft > 0) {
            this.chartLeftPadding += overflowLeft;
            dimensions.plot.width -= overflowLeft;
            dimensions.series.width -= overflowLeft;
            dimensions.xAxis.width -= overflowLeft;
        }
    },

    /**
     * Update height of dimensions.
     * @param {{plot: {height: number}, series: {height: number}, xAxis: {height: number}}} dimensions dimensions
     * @param {number} diffHeight diff height
     * @private
     */
    _updateDimensionsHeight: function(dimensions, diffHeight) {
        dimensions.plot.height -= diffHeight;
        dimensions.series.height -= diffHeight;
        dimensions.xAxis.height += diffHeight;
    },

    /**
     * Update dimensions and degree.
     * @param {{plot: {width: number, height: number}, series: {width: number, height: number}, xAxis: {width: number, height: number}}} dimensions dimensions
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @param {array} labels labels
     * @param {object} theme theme
     * @private
     */
    _updateDimensionsAndDegree: function(dimensions, rotationInfo, labels, theme) {
        var overflowLeft, diffHeight;
        if (!rotationInfo) {
            return;
        }
        overflowLeft = this._calculateOverflowLeft(dimensions.yAxis.width, rotationInfo, labels[0], theme);
        this._updateDimensionsWidth(dimensions, overflowLeft);
        this._updateDegree(dimensions.series.width, rotationInfo, labels.length, overflowLeft);
        diffHeight = this._calculateHeightDifference(rotationInfo);
        this._updateDimensionsHeight(dimensions, diffHeight);
    },

    _makeCustomEventBound: function(bound) {
        var dimension = bound.dimension,
            position = bound.position;
        return {
            dimension: {
                width: dimension.width + chartConst.SERIES_EXPAND_SIZE * 2,
                height: dimension.height + chartConst.SERIES_EXPAND_SIZE
            },
            position: {
                left: position.left - chartConst.SERIES_EXPAND_SIZE,
                top: position.top
            }
        }
    },

    /**
     * To make bounds about chart components.
     * @memberOf module:boundsMaker
     * @param {object} params parameters
     *      @param {object} params.convertedData converted data
     *      @param {object} params.theme chart theme
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {object} params.options chart options
     *      @param {boolean} params.hasAxes whether has axes area or not
     *      @param {array} params.optionChartTypes y axis option chart types
     * @returns {{
     *   plot: {
     *     dimension: {width: number, height: number},
     *     position: {top: number, right: number}
     *   },
     *   yAxis: {
     *     dimension: {width: (number), height: number},
     *     position: {top: number}
     *   },
     *   xAxis: {
     *     dimension: {width: number, height: (number)},
     *     position: {right: number}
     *   },
     *   series: {
     *     dimension: {width: number, height: number},
     *     position: {top: number, right: number}
     *   },
     *   legend: {
     *     position: {top: number}
     *   },
     *   tooltip: {
     *     dimension: {width: number, height: number},
     *     position: {top: number, left: number}
     *   }
     * }} bounds
     */
    make: function(params) {
        var axesLabelInfo = this._makeAxesLabelInfo(params),
            dimensions = this._getComponentsDimensions(tui.util.extend({
                axesLabelInfo: axesLabelInfo
            }, params)),
            rotationInfo, top, left, seriesBound, axesBounds, bounds;

        this.chartLeftPadding = chartConst.CHART_PADDING;
        if (params.hasAxes) {
            rotationInfo = this._makeHorizontalLabelRotationInfo(dimensions.series.width, axesLabelInfo.xAxis, params.theme.label);
            this._updateDimensionsAndDegree(dimensions, rotationInfo, axesLabelInfo.xAxis, params.theme.label);
        }

        top = dimensions.title.height + chartConst.CHART_PADDING;
        left = dimensions.yAxis.width + this.chartLeftPadding;
        seriesBound = this._makeBasicBound(dimensions.series, top, left);

        axesBounds = this._makeAxesBounds({
            hasAxes: params.hasAxes,
            rotationInfo: rotationInfo,
            optionChartTypes: params.optionChartTypes,
            dimensions: dimensions,
            top: top,
            left: left
        });

        bounds = tui.util.extend({
            chart: this._makeChartBound(dimensions.chart),
            series: seriesBound,
            legend: this._makeLegendBound(dimensions),
            tooltip: this._makeBasicBound(dimensions.series, top, left - chartConst.SERIES_EXPAND_SIZE),
            customEvent: seriesBound
        }, axesBounds);
        return bounds;
    }
};

module.exports = boundsMaker;

},{"../const":15,"./calculator":28,"./predicate":32,"./renderUtil":33}],28:[function(require,module,exports){
/**
 * @fileoverview calculator.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * Calculator.
 * @module calculator
 */
var calculator = {
    /**
     * To calculate scale from chart min, max data.
     *  - http://peltiertech.com/how-excel-calculates-automatic-chart-axis-limits/
     * @memberOf module:calculator
     * @param {number} min min minimum value of user data
     * @param {number} max max maximum value of user data
     * @param {number} tickCount tick count
     * @returns {{min: number, max: number}} scale axis scale
     */
    calculateScale: function(min, max) {
        var saveMin = 0,
            scale = {},
            iodValue; // increase or decrease value;

        if (min < 0) {
            saveMin = min;
            max -= min;
            min = 0;
        }

        iodValue = (max - min) / 20;
        scale.max = max + iodValue + saveMin;

        if (max / 6 > min) {
            scale.min = 0 + saveMin;
        } else {
            scale.min = min - iodValue + saveMin;
        }
        return scale;
    },

    /**
     * To normalize number.
     * @memberOf module:calculator
     * @param {number} value target value
     * @returns {number} normalized number
     */
    normalizeAxisNumber: function(value) {
        var standard = 0,
            flag = 1,
            normalized, mod;

        if (value === 0) {
            return value;
        } else if (value < 0) {
            flag = -1;
        }

        value *= flag;

        tui.util.forEachArray(chartConst.AXIS_STANDARD_MULTIPLE_NUMS, function(num) {
            if (value < num) {
                if (num > 1) {
                    standard = num;
                }
                return false;
            } else if (num === 10) {
                standard = 10;
            }
        });

        if (standard < 1) {
            normalized = this.normalizeAxisNumber(value * 10) * 0.1;
        } else {
            mod = tui.util.mod(value, standard);
            normalized = tui.util.addition(value, (mod > 0 ? standard - mod : 0));
        }

        return normalized *= flag;
    },

    /**
     * To make tick positions of pixel type.
     * @memberOf module:calculator
     * @param {number} size area width or height
     * @param {number} count tick count
     * @returns {array.<number>} positions
     */
    makeTickPixelPositions: function(size, count) {
        var positions = [],
            pxScale, pxStep;

        if (count > 0) {
            pxScale = {min: 0, max: size - 1};
            pxStep = this.getScaleStep(pxScale, count);
            positions = tui.util.map(tui.util.range(0, size, pxStep), function(position) {
                return Math.round(position);
            });
            positions[positions.length - 1] = size - 1;
        }
        return positions;
    },

    /**
     * To make labels from scale.
     * @memberOf module:calculator
     * @param {{min: number, max: number}} scale axis scale
     * @param {number} step step between max and min
     * @returns {string[]} labels
     * @private
     */
    makeLabelsFromScale: function(scale, step) {
        var multipleNum = tui.util.findMultipleNum(step),
            min = scale.min * multipleNum,
            max = scale.max * multipleNum,
            labels = tui.util.range(min, max + 1, step * multipleNum);
        labels = tui.util.map(labels, function(label) {
            return label / multipleNum;
        });
        return labels;
    },

    /**
     * Get scale step.
     * @memberOf module:calculator
     * @param {{min: number, max: number}} scale axis scale
     * @param {number} count value count
     * @returns {number} scale step
     */
    getScaleStep: function(scale, count) {
        return (scale.max - scale.min) / (count - 1);
    },

    /**
     * To calculate adjacent.
     * @param {number} degree degree
     * @param {number} hypotenuse hypotenuse
     * @returns {number} adjacent
     *
     *   H : Hypotenuse
     *   A : Adjacent
     *   O : Opposite
     *   D : Degree
     *
     *        /|
     *       / |
     *    H /  | O
     *     /   |
     *    /\ D |
     *    -----
     *       A
     */
    calculateAdjacent: function(degree, hypotenuse) {
        return Math.cos(degree * chartConst.RAD) * hypotenuse;
    },

    /**
     * To calculate opposite.
     * @param {number} degree degree
     * @param {number} hypotenuse hypotenuse
     * @returns {number} opposite
     */
    calculateOpposite: function(degree, hypotenuse) {
        return Math.sin(degree * chartConst.RAD) * hypotenuse;
    }
};

module.exports = calculator;

},{"../const":15}],29:[function(require,module,exports){
/**
 * @fileoverview Data converter.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var concat = Array.prototype.concat;

/**
 * Data converter.
 * @module dataConverter
 */
var dataConverter = {
    /**
     * Convert user data.
     * @memberOf module:dataConverter
     * @param {array.<array>} userData user data
     * @param {object} chartOptions chart option
     * @param {string} chartType chart type
     * @param {array.<string>} seriesChartTypes chart types
     * @returns {{
     *      labels: array.<string>,
     *      values: array.<number>,
     *      legendLabels: array.<string>,
     *      formatFunctions: array.<function>,
     *      formattedValues: array.<string>
     * }} converted data
     */
    convert: function(userData, chartOptions, chartType, seriesChartTypes) {
        var labels = userData.categories,
            seriesData = userData.series,
            values = this._pickValues(seriesData),
            joinValues = this._joinValues(values, seriesChartTypes),
            legendLabels = this._pickLegendLabels(seriesData),
            joinLegendLabels = this._joinLegendLabels(legendLabels, chartType, seriesChartTypes),
            format = chartOptions && chartOptions.format || '',
            formatFunctions = this._findFormatFunctions(format),
            formattedValues = format ? this._formatValues(values, formatFunctions) : values,
            joinFormattedValues = this._joinValues(formattedValues, seriesChartTypes);
        return {
            labels: labels,
            values: values,
            joinValues: joinValues,
            legendLabels: legendLabels,
            joinLegendLabels: joinLegendLabels,
            formatFunctions: formatFunctions,
            formattedValues: formattedValues,
            joinFormattedValues: joinFormattedValues
        };
    },

    /**
     * Separate label.
     * @memberOf module:dataConverter
     * @param {array.<array.<array>>} userData user data
     * @returns {{labels: (array.<string>), sourceData: array.<array.<array>>}} result data
     * @private
     */
    _separateLabel: function(userData) {
        var labels = userData[0].pop();
        return {
            labels: labels,
            sourceData: userData
        };
    },

    /**
     * Pick value.
     * @memberOf module:dataConverter
     * @param {{name: string, data: (array.<number> | number)}} items items
     * @returns {array} picked value
     * @private
     */
    _pickValue: function(items) {
        return tui.util.map([].concat(items.data), parseFloat);
    },

    /**
     * Pick values from axis data.
     * @memberOf module:dataConverter
     * @param {array.<array>} seriesData series data
     * @returns {string[]} values
     */
    _pickValues: function(seriesData) {
        var values, result;
        if (tui.util.isArray(seriesData)) {
            values = tui.util.map(seriesData, this._pickValue, this);
            result = tui.util.pivot(values);
        } else {
            result = {};
            tui.util.forEach(seriesData, function(groupValues, type) {
                values = tui.util.map(groupValues, this._pickValue, this);
                result[type] = tui.util.pivot(values);
            }, this);
        }
        return result;
    },

    /**
     * Join values.
     * @memberOf module:dataConverter
     * @param {array.<array>} groupValues values
     * @param {array.<string>} seriesChartTypes chart types
     * @returns {array.<number>} join values
     * @private
     */
    _joinValues: function(groupValues, seriesChartTypes) {
        var joinValues;

        if (!seriesChartTypes) {
            return groupValues;
        }

        joinValues = tui.util.map(groupValues, function(values) {
            return values;
        }, this);

        joinValues = [];
        tui.util.forEachArray(seriesChartTypes, function(_chartType) {
            tui.util.forEach(groupValues[_chartType], function(values, index) {
                if (!joinValues[index]) {
                    joinValues[index] = [];
                }
                joinValues[index] = joinValues[index].concat(values);
            });
        });

        return joinValues;
    },

    /**
     * Pick legend label.
     * @memberOf module:dataConverter
     * @param {object} item item
     * @returns {string} label
     * @private
     */
    _pickLegendLabel: function(item) {
        return item.name;
    },

    /**
     * Pick legend labels from axis data.
     * @memberOf module:dataConverter
     * @param {array.<array>} seriesData series data
     * @returns {string[]} labels
     */
    _pickLegendLabels: function(seriesData) {
        var result;
        if (tui.util.isArray(seriesData)) {
            result = tui.util.map(seriesData, this._pickLegendLabel, this);
        } else {
            result = {};
            tui.util.forEach(seriesData, function(groupValues, type) {
                result[type] = tui.util.map(groupValues, this._pickLegendLabel, this);
            }, this);
        }
        return result;
    },

    /**
     * Join legend labels.
     * @memberOf module:dataConverter
     * @param {array} legendLabels legend labels
     * @param {string} chartType chart type
     * @param {array.<string>} seriesChartTypes chart types
     * @returns {array} labels
     * @private
     */
    _joinLegendLabels: function(legendLabels, chartType, seriesChartTypes) {
        var joinLabels;
        if (!seriesChartTypes || !seriesChartTypes.length) {
            joinLabels = tui.util.map(legendLabels, function(label) {
                return {
                    chartType: chartType,
                    label: label
                };
            });
        } else {
            joinLabels = [];
            tui.util.forEachArray(seriesChartTypes, function(_chartType) {
                var labels = tui.util.map(legendLabels[_chartType], function(label) {
                    return {
                        chartType: _chartType,
                        label: label
                    };
                });
                joinLabels = joinLabels.concat(labels);
            });
        }
        return joinLabels;
    },

    /**
     * To format group values.
     * @memberOf module:dataConverter
     * @param {array.<array>} groupValues group values
     * @param {function[]} formatFunctions format functions
     * @returns {string[]} formatted values
     * @private
     */
    _formatGroupValues: function(groupValues, formatFunctions) {
        return tui.util.map(groupValues, function(values) {
            return tui.util.map(values, function(value) {
                var fns = [value].concat(formatFunctions);
                return tui.util.reduce(fns, function(stored, fn) {
                    return fn(stored);
                });
            });
        });
    },

    /**
     * To format converted values.
     * @memberOf module:dataConverter
     * @param {array.<array>} chartValues chart values
     * @param {function[]} formatFunctions format functions
     * @returns {string[]} formatted values
     * @private
     */
    _formatValues: function(chartValues, formatFunctions) {
        var result;
        if (tui.util.isArray(chartValues)) {
            result = this._formatGroupValues(chartValues, formatFunctions);
        } else {
            result = {};
            tui.util.forEach(chartValues, function(groupValues, chartType) {
                result[chartType] = this._formatGroupValues(groupValues, formatFunctions);
            }, this);
        }
        return result;
    },

    /**
     * Pick max length under point.
     * @memberOf module:dataConverter
     * @param {string[]} values chart values
     * @returns {number} max length under point
     * @private
     */
    _pickMaxLenUnderPoint: function(values) {
        var max = 0;

        tui.util.forEachArray(values, function(value) {
            var len = tui.util.lengthAfterPoint(value);
            if (len > max) {
                max = len;
            }
        }, this);

        return max;
    },

    /**
     * Whether zero fill format or not.
     * @memberOf module:dataConverter
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isZeroFill: function(format) {
        return format.length > 2 && format.charAt(0) === '0';
    },

    /**
     * Whether decimal format or not.
     * @memberOf module:dataConverter
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isDecimal: function(format) {
        var indexOf = format.indexOf('.');
        return indexOf > -1 && indexOf < format.length - 1;
    },

    /**
     * Whether comma format or not.
     * @memberOf module:dataConverter
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isComma: function(format) {
        return format.indexOf(',') === format.split('.')[0].length - 4;
    },

    /**
     * Format zero fill.
     * @memberOf module:dataConverter
     * @param {number} len length of result
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatZeroFill: function(len, value) {
        var zero = '0',
            isMinus = value < 0;

        value = Math.abs(value) + '';

        if (value.length >= len) {
            return value;
        }

        while (value.length < len) {
            value = zero + value;
        }

        return (isMinus ? '-' : '') + value;
    },

    /**
     * Format Decimal.
     * @memberOf module:dataConverter
     * @param {number} len length of under decimal point
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatDecimal: function(len, value) {
        var pow;

        if (len === 0) {
            return Math.round(value, 10);
        }

        pow = Math.pow(10, len);
        value = Math.round(value * pow) / pow;
        value = parseFloat(value).toFixed(len);
        return value;
    },

    /**
     * Format Comma.
     * @memberOf module:dataConverter
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatComma: function(value) {
        var comma = ',',
            underPointValue = '',
            values, lastIndex;

        value += '';

        if (value.indexOf('.') > -1) {
            values = value.split('.');
            value = values[0];
            underPointValue = '.' + values[1];
        }

        if (value.length < 4) {
            return value + underPointValue;
        }

        values = (value).split('').reverse();
        lastIndex = values.length - 1;
        values = tui.util.map(values, function(char, index) {
            var result = [char];
            if (index < lastIndex && (index + 1) % 3 === 0) {
                result.push(comma);
            }
            return result;
        });

        return concat.apply([], values).reverse().join('') + underPointValue;
    },

    /**
     * Find format functions.
     * @memberOf module:dataConverter
     * @param {string} format format
     * @param {string[]} values chart values
     * @returns {function[]} functions
     */
    _findFormatFunctions: function(format) {
        var funcs = [],
            len;

        if (!format) {
            return [];
        }

        if (this._isDecimal(format)) {
            len = this._pickMaxLenUnderPoint([format]);
            funcs = [tui.util.bind(this._formatDecimal, this, len)];
        } else if (this._isZeroFill(format)) {
            len = format.length;
            funcs = [tui.util.bind(this._formatZeroFill, this, len)];
            return funcs;
        }

        if (this._isComma(format)) {
            funcs.push(this._formatComma);
        }

        return funcs;
    }
};

module.exports = dataConverter;

},{}],30:[function(require,module,exports){
/**
 * @fileoverview DOM Handler.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * DOM Handler.
 * @module domHandler
 */
var domHandler = {
    /**
     * Create element.
     * @memberOf module:domHandler
     * @param {string} tag html tag
     * @param {string} newClass class name
     * @returns {HTMLElement} created element
     */
    create: function(tag, newClass) {
        var el = document.createElement(tag);

        if (newClass) {
            this.addClass(el, newClass);
        }

        return el;
    },

    /**
     * Get class names.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @returns {array} names
     * @private
     */
    _getClassNames: function(el) {
        var className = el.className || '',
            classNames = className && tui.util.isString(className) ? className.split(' ') : [];
        return classNames;
    },

    /**
     * Add css class to target element.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} newClass add class name
     */
    addClass: function(el, newClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(newClass, classNames);

        if (index > -1) {
            return;
        }

        classNames.push(newClass);
        el.className = classNames.join(' ');
    },

    /**
     * Remove css class from target element.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} rmClass remove class name
     */
    removeClass: function(el, rmClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(rmClass, classNames);

        if (index === -1) {
            return;
        }

        classNames.splice(index, 1);
        el.className = classNames.join(' ');
    },

    /**
     * Whether class exist or not.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} findClass target css class
     * @returns {boolean} has class
     */
    hasClass: function(el, findClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(findClass, classNames);
        return index > -1;
    },

    /**
     * Find parent by class name.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} className target css class
     * @param {string} lastClass last css class
     * @returns {HTMLElement} result element
     */
    findParentByClass: function(el, className, lastClass) {
        var parent = el.parentNode;
        if (!parent) {
            return null;
        } else if (this.hasClass(parent, className)) {
            return parent;
        } else if (parent.nodeName === 'BODY' || this.hasClass(parent, lastClass)) {
            return null;
        } else {
            return this.findParentByClass(parent, className, lastClass);
        }
    },

    /**
     * Append child element.
     * @memberOf module:domHandler
     * @param {HTMLElement} container container element
     * @param {HTMLElement} children child element
     */
    append: function(container, children) {
        if (!container || !children) {
            return;
        }
        children = tui.util.isArray(children) ? children : [children];

        tui.util.forEachArray(children, function(child) {
            if (!child) {
                return;
            }
            container.appendChild(child);
        }, this);
    }
};

module.exports = domHandler;

},{}],31:[function(require,module,exports){
/**
 * @fileoverview Event listener.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Event listener.
 * @module eventListener
 */
var eventListener = {
    /**
     * Event listener for IE.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} el target element
     * @param {function} callback callback function
     * @private
     */
    _attachEvent: function (eventName, el, callback) {
        if (typeof callback == "object" && callback.handleEvent) {
            el.attachEvent("on" + eventName, function () {
                callback.handleEvent.call(callback);
            });
        } else {
            el.attachEvent("on" + eventName, callback);
        }
    },

    /**
     * Event listener for other browsers.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} el target element
     * @param {function} callback callback function
     * @private
     */
    _addEventListener: function (eventName, el, callback) {
        try {
            el.addEventListener(eventName, callback);
        } catch (e) {
            if (typeof callback == "object" && callback.handleEvent) {
                el.addEventListener(eventName, function (event) {
                    callback.handleEvent.call(callback, event);
                });
            } else {
                throw e;
            }
        }
    },
    /**
     * Bind event function.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} el target element
     * @param {function} callback callback function
     */
    bindEvent: function (eventName, el, callback) {
        var bindEvent;
        if ("addEventListener" in el) {
            bindEvent = this._addEventListener;
        } else if ("attachEvent" in el) {
            bindEvent = this._attachEvent;
        }
        this.bindEvent = bindEvent;
        bindEvent(eventName, el, callback);
    }
};

module.exports = eventListener;

},{}],32:[function(require,module,exports){
/**
 * @fileoverview Predicate.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * predicate.
 * @module predicate
 */
var predicate = {
    /**
     * Whether bar chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isBarChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_BAR;
    },

    /**
     * Whether line chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isLineChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_LINE;
    },

    /**
     * Whether line type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isLineTypeChart: function(chartType) {
        return this.isLineChart(chartType) || chartType === chartConst.CHART_TYPE_AREA;
    },

    /**
     * Whether pie chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isPieChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_PIE;
    },

    /**
     * Whether outer legend align or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isOuterLegendAlign: function(align) {
        return align === chartConst.LEGEND_ALIGN_OUTER;
    },

    /**
     * Whether center legend align or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isCenterLegendAlign: function(align) {
        return align === chartConst.LEGEND_TYPE_CENTER;
    },

    /**
     * Whether legend align of pie chart or not.
     * @memberOf module:predicate
     * @param {?string} align chart type
     * @returns {boolean} result boolean
     */
    isPieLegendAlign: function(align) {
        var result = false;
        if (align) {
            result = this.isOuterLegendAlign(align) || this.isCenterLegendAlign(align);
        }
        return result;
    }
};

module.exports = predicate;

},{"../const":15}],33:[function(require,module,exports){
/**
 * @fileoverview Util for rendering.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('./domHandler'),
    chartConst = require('./../const');

var browser = tui.util.browser,
    isOldBrowser = browser.msie && browser.version <= 8;

/**
 * Util for rendering.
 * @module renderUtil
 */
var renderUtil = {
    /**
     * Concat string.
     * @memberOf module:renderUtil
     * @params {...string} target strings
     * @returns {string} concat string
     */
    concatStr: function() {
        return String.prototype.concat.apply('', arguments);
    },

    /**
     * To make cssText for font.
     * @memberOf module:renderUtil
     * @param {{fontSize: number, fontFamily: string, color: string}} theme font theme
     * @returns {string} cssText
     */
    makeFontCssText: function(theme) {
        var cssTexts = [];

        if (!theme) {
            return '';
        }

        if (theme.fontSize) {
            cssTexts.push(this.concatStr('font-size:', theme.fontSize, 'px'));
        }

        if (theme.fontFamily) {
            cssTexts.push(this.concatStr('font-family:', theme.fontFamily));
        }

        if (theme.color) {
            cssTexts.push(this.concatStr('color:', theme.color));
        }

        return cssTexts.join(';');
    },

    checkEl: null,
    /**
     * Create element for size check.
     * @memberOf module:renderUtil
     * @returns {HTMLElement} element
     * @private
     */
    _createSizeCheckEl: function() {
        var elDiv, elSpan;
        if (this.checkEl) {
            return this.checkEl;
        }

        elDiv = dom.create('DIV', 'tui-chart-size-check-element');
        elSpan = dom.create('SPAN');

        elDiv.appendChild(elSpan);
        this.checkEl = elDiv;
        return elDiv;
    },

    /**
     * Get rendered label size (width or height).
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {object} theme theme
     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
     * @returns {number} size
     * @private
     */
    _getRenderedLabelSize: function(label, theme, offsetType) {
        var elDiv, elSpan, labelSize;

        if (tui.util.isUndefined(label) || label === '') {
            return 0;
        }

        elDiv = this._createSizeCheckEl();
        elSpan = elDiv.firstChild;

        theme = theme || {};
        elSpan.innerHTML = label;
        elSpan.style.fontSize = (theme.fontSize || chartConst.DEFAULT_LABEL_FONT_SIZE) + 'px';

        if (theme.fontFamily) {
            elSpan.style.padding = 0;
            elSpan.style.fontFamily = theme.fontFamily;
        }

        document.body.appendChild(elDiv);
        labelSize = elSpan[offsetType];
        document.body.removeChild(elDiv);
        return labelSize;
    },

    /**
     * Get rendered label width.
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} width
     */
    getRenderedLabelWidth: function(label, theme) {
        var labelWidth = this._getRenderedLabelSize(label, theme, 'offsetWidth');
        return labelWidth;
    },

    /**
     * Get rendered label height.
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} height
     */
    getRenderedLabelHeight: function(label, theme) {
        var labelHeight = this._getRenderedLabelSize(label, theme, 'offsetHeight');
        return labelHeight;
    },

    /**
     * Get Rendered Labels Max Size(width or height).
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @param {function} iteratee iteratee
     * @returns {number} max size (width or height)
     * @private
     */
    _getRenderedLabelsMaxSize: function(labels, theme, iteratee) {
        var sizes = tui.util.map(labels, function(label) {
                return iteratee(label, theme);
            }, this),
            maxSize = tui.util.max(sizes);
        return maxSize;
    },

    /**
     * Get rendered labels max width.
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} max width
     * @private
     */
    getRenderedLabelsMaxWidth: function(labels, theme) {
        var iteratee = tui.util.bind(this.getRenderedLabelWidth, this),
            maxWidth = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
        return maxWidth;
    },

    /**
     * Get rendered labels max height.
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} max height
     */
    getRenderedLabelsMaxHeight: function(labels, theme) {
        var iteratee = tui.util.bind(this.getRenderedLabelHeight, this),
            maxHeight = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
        return maxHeight;
    },

    /**
     * Render dimension.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {{width: number, height: number}} dimension dimension
     */
    renderDimension: function(el, dimension) {
        el.style.cssText = [
            this.concatStr('width:', dimension.width, 'px'),
            this.concatStr('height:', dimension.height, 'px')
        ].join(';');
    },

    /**
     * Render position(top, right).
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {{top: number, left: number, right: number}} position position
     */
    renderPosition: function(el, position) {
        if (tui.util.isUndefined(position)) {
            return;
        }

        if (position.top) {
            el.style.top = position.top + 'px';
        }

        if (position.left) {
            el.style.left = position.left + 'px';
        }

        if (position.right) {
            el.style.right = position.right + 'px';
        }
    },

    /**
     * Render background.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {string} background background option
     */
    renderBackground: function(el, background) {
        if (!background) {
            return;
        }

        el.style.background = background;
    },

    /**
     * Render font family.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {string} fontFamily font family option
     */
    renderFontFamily: function(el, fontFamily) {
        if (!fontFamily) {
            return;
        }

        el.style.fontFamily = fontFamily;
    },

    /**
     * Render title.
     * @memberOf module:renderUtil
     * @param {string} title title
     * @param {{fontSize: number, color: string, background: string}} theme title theme
     * @param {string} className css class name
     * @returns {HTMLElement} title element
     */
    renderTitle: function(title, theme, className) {
        var elTitle, cssText;

        if (!title) {
            return null;
        }

        elTitle = dom.create('DIV', className);
        elTitle.innerHTML = title;

        cssText = renderUtil.makeFontCssText(theme);

        if (theme.background) {
            cssText += ';' + this.concatStr('background:', theme.background);
        }

        elTitle.style.cssText = cssText;

        return elTitle;
    },

    /**
     * To expand dimension.
     * @param {{width: number, height: number}} dimension series dimension
     * @returns {{width: number, height: number}} expended dimension
     */
    expandBound: function(bound) {
        var dimension = bound.dimension,
            position = bound.position;
        return {
            dimension: {
                width: dimension.width + chartConst.SERIES_EXPAND_SIZE * 2,
                height: dimension.height + chartConst.SERIES_EXPAND_SIZE
            },
            position: {
                left: position.left - chartConst.SERIES_EXPAND_SIZE,
                top: position.top
            }
        };
    },

    makeCustomEventName: function(prefix, str, suffix) {
        return prefix + tui.util.properCase(str) + tui.util.properCase(suffix);
    },

    /**
     * Whether IE8 or not.
     * @memberOf module:renderUtil
     * @returns {boolean} result boolean
     */
    isOldBrowser: function() {
        return isOldBrowser;
    }
};

module.exports = renderUtil;

},{"./../const":15,"./domHandler":30}],34:[function(require,module,exports){
/**
 * @fileoverview This is template maker.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

module.exports = {
    /**
     * This is template maker.
     * @param {string} html html
     * @returns {function} template function
     * @eaxmple
     *
     *   var template = templateMaker.template('<span>{{ name }}</span>'),
     *       result = template({name: 'John');
     *   console.log(result); // <span>John</span>
     *
     */
    template: function (html) {
        return function (data) {
            var result = html;
            tui.util.forEach(data, function (value, key) {
                var regExp = new RegExp('{{\\s*' + key + '\\s*}}', 'g');
                result = result.replace(regExp, value);
            });
            return result;
        };
    }
};

},{}],35:[function(require,module,exports){
/**
 * @fileoverview UserEventListener is listener of user event.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var UserEventListener = tui.util.defineClass(/** @lends UserEventListener.prototype */ {
    /**
     * Register user event.
     * @param {string} eventName event name
     * @param {function} func event callback
     */
    register: function(eventName, func) {
        this.on(eventName, func);
    }
});

tui.util.CustomEvents.mixin(UserEventListener);

module.exports = UserEventListener;

},{}],36:[function(require,module,exports){
/**
 * @fileoverview  Legend component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    eventListener = require('../helpers/eventListener'),
    renderUtil = require('../helpers/renderUtil'),
    defaultTheme = require('../themes/defaultTheme'),
    legendTemplate = require('./../legends/legendTemplate');

var concat = Array.prototype.concat;

var Legend = tui.util.defineClass(/** @lends Legend.prototype */ {
    /**
     * Legend component.
     * @constructs Legend
     * @param {object} params parameters
     *      @param {number} params.legendLabels legend labels
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        tui.util.extend(this, params);
        /**
         * Legend view className
         */
        this.className = 'tui-chart-legend-area';
    },

    /**
     * To render legend area.
     * @param {HTMLElement} elLegnedArea legend area element
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound lengend bound
     * @private
     */
    _renderLegendArea: function(elLegnedArea, bound) {
        var legendData;
        this.bound = bound;
        this.legendData = legendData = this._makeLegendData();
        elLegnedArea.innerHTML = this._makeLegendHtml(legendData);
        renderUtil.renderPosition(elLegnedArea, bound.position);
        this._renderLabelTheme(elLegnedArea, this.theme.label);
    },

    /**
     * To render legend component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound lengend bound
     * @returns {HTMLElement} legend element
     */
    render: function(bound) {
        var el = dom.create('DIV', this.className);
        this._renderLegendArea(el, bound);
        this._attachEvent(el);
        this.elLegendArea = el;
        return el;
    },

    /**
     * To resize legend component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound lengend bound
     */
    resize: function(bound) {
        this._renderLegendArea(this.elLegendArea, bound);
    },

    /**
     * Set theme for legend labels
     * @param {array.<object>} labels labels
     * @param {object} theme legend theme
     * @returns {array.<object>} labels
     * @private
     */
    _setThemeForLabels: function(labels, theme) {
        var result;
        result = tui.util.map(labels, function(item, index) {
            var itemTheme = {
                color: theme.colors[index]
            };

            if (theme.singleColors) {
                itemTheme.singleColor = theme.singleColors[index];
            }
            if (theme.borderColor) {
                itemTheme.borderColor = theme.borderColor;
            }
            item.theme = itemTheme;
            item.index = index;
            return item;
        }, this);

        return result;
    },

    /**
     * To make legend labels.
     * @returns {array.<object>} legend labels.
     * @private
     */
    _makeLegendData: function() {
        var joinLegendLabels = this.joinLegendLabels,
            theme = this.theme,
            defaultLegendTheme = {
                colors: defaultTheme.series.colors
            },
            startIndex, result;

        if (!this.seriesChartTypes) {
            result = this._setThemeForLabels(joinLegendLabels, theme);
        } else {
            startIndex = 0;
            result = concat.apply([], tui.util.map(this.seriesChartTypes, function(chartType) {
                var chartTheme = theme[chartType] || defaultLegendTheme,
                    endIndex = startIndex + this.legendLabels[chartType].length,
                    data = this._setThemeForLabels(joinLegendLabels.slice(startIndex, endIndex), chartTheme);
                startIndex = endIndex;
                return data;
            }, this));
        }
        return result;
    },

    /**
     * To make legend html.
     * @param {array} legendData legend data
     * @returns {string} legend html
     * @private
     */
    _makeLegendHtml: function(legendData) {
        var template = legendTemplate.tplLegend,
            labelHeight = renderUtil.getRenderedLabelHeight(legendData[0].label, legendData[0].theme),
            height = labelHeight + (chartConst.LABEL_PADDING_TOP * 2),
            baseMarginTop = parseInt((height - chartConst.LEGEND_RECT_WIDTH) / 2, 10) - 1,
            html = tui.util.map(legendData, function(legendInfo, index) {
                var borderCssText = legendInfo.borderColor ? renderUtil.concatStr(';border:1px solid ', legendInfo.borderColor) : '',
                    rectMargin, marginTop, data;
                if (legendInfo.chartType === 'line') {
                    marginTop = baseMarginTop + chartConst.LINE_MARGIN_TOP;
                } else {
                    marginTop = baseMarginTop;
                }
                rectMargin = renderUtil.concatStr(';margin-top:', marginTop, 'px');

                data = {
                    cssText: renderUtil.concatStr('background-color:', legendInfo.theme.singleColor || legendInfo.theme.color, borderCssText, rectMargin),
                    height: height,
                    labelHeight: labelHeight,
                    chartType: legendInfo.chartType || 'rect',
                    label: legendInfo.label,
                    index: index
                };
                return template(data);
            }, this).join('');
        return html;
    },

    /**
     * Render css style of label area.
     * @param {HTMLElement} el label area element
     * @param {{fontSize:number, fontFamily: string, color: string}} theme label theme
     * @private
     */
    _renderLabelTheme: function(el, theme) {
        var cssText = renderUtil.makeFontCssText(theme);
        el.style.cssText += ';' + cssText;
    },

    /**
     * Find legend element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} legend element
     * @private
     */
    _findLegendElement: function(elTarget) {
        var elLegend;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_LEGEND)) {
            elLegend = elTarget;
        } else {
            elLegend = dom.findParentByClass(elTarget, chartConst.CLASS_NAME_LEGEND);
        }

        return elLegend;
    },

    /**
     * Select legend.
     * @param {number} index index
     * @private
     */
    _selectLegend: function(index) {
        var data = this.legendData[index];
        this.userEvent.fire('selectLegend', {
            legend: data.label,
            chartType: data.chartType,
            index: data.index
        });
    },

    /**
     * On click event handler.
     * @param {MouseEvent} e mouse event
     * @private
     */
    _onClick: function(e) {
        var elTarget = e.target || e.srcElement,
            elLegend = this._findLegendElement(elTarget),
            index;

        if (!elLegend) {
            return;
        }

        index = parseInt(elLegend.getAttribute('data-index'), 10);
        this._selectLegend(index);
    },

    /**
     * Attach browser event.
     * @param {HTMLElement} el target element
     * @private
     */
    _attachEvent: function(el) {
        eventListener.bindEvent('click', el, tui.util.bind(this._onClick, this));
    }
});

module.exports = Legend;

},{"../const":15,"../helpers/domHandler":30,"../helpers/eventListener":31,"../helpers/renderUtil":33,"../themes/defaultTheme":59,"./../legends/legendTemplate":37}],37:[function(require,module,exports){
/**
 * @fileoverview This is templates of legend view.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_LEGEND: '<div class="tui-chart-legend" style="height:{{ height }}px" data-index="{{ index }}">' +
        '<div class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></div>' +
        '<div class="tui-chart-legend-label" style="height:{{ labelHeight }}px">{{ label }}</div></div>'
};

module.exports = {
    tplLegend: templateMaker.template(tags.HTML_LEGEND)
};

},{"../helpers/templateMaker":34}],38:[function(require,module,exports){
/**
 * @fileoverview Plot component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    calculator = require('../helpers/calculator'),
    renderUtil = require('../helpers/renderUtil'),
    plotTemplate = require('./plotTemplate');

var Plot = tui.util.defineClass(/** @lends Plot.prototype */ {
    /**
     * Plot component.
     * @constructs Plot
     * @param {object} params parameters
     *      @param {number} params.vTickCount vertical tick count
     *      @param {number} params.hTickCount horizontal tick count
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        tui.util.extend(this, params);
        /**
         * Plot view className
         * @type {string}
         */
        this.className = 'tui-chart-plot-area';
    },

    /**
     * To render plot area.
     * @param {HTMLElement} elPlotArea plot area element
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound plot bound
     * @param {object} data rendering data
     * @private
     */
    _renderPlotArea: function(elPlotArea, bound, data) {
        this.bound = bound;
        this.data = data;

        renderUtil.renderDimension(elPlotArea, bound.dimension);
        renderUtil.renderPosition(elPlotArea, bound.position);
        this._renderLines(elPlotArea, bound.dimension);
    },

    /**
     * To render plot component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound plot bound
     * @param {object} data rendering data
     * @returns {HTMLElement} plot element
     */
    render: function(bound, data) {
        var el = dom.create('DIV', this.className);
        this._renderPlotArea(el, bound, data);
        this.elPlotArea = el;
        return el;
    },

    /**
     * To resize plot component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound plot bound
     * @param {object} data rendering data
     */
    resize: function(bound, data) {
        this.elPlotArea.innerHTML = '';
        this._renderPlotArea(this.elPlotArea, bound, data);
    },

    /**
     * Render plot lines.
     * @param {HTMLElement} el element
     * @param {{width: number, height: number}} dimension plot area dimension
     * @private
     */
    _renderLines: function(el, dimension) {
        var hPositions = this._makeHorizontalPixelPositions(dimension.width),
            vPositions = this._makeVerticalPixelPositions(dimension.height),
            theme = this.theme,
            lineHtml = '';

        lineHtml += this._makeLineHtml({
            positions: hPositions,
            size: dimension.height,
            className: 'vertical',
            positionType: 'left',
            sizeType: 'height',
            lineColor: theme.lineColor
        });
        lineHtml += this._makeLineHtml({
            positions: vPositions,
            size: dimension.width,
            className: 'horizontal',
            positionType: 'bottom',
            sizeType: 'width',
            lineColor: theme.lineColor
        });

        el.innerHTML = lineHtml;

        renderUtil.renderBackground(el, theme.background);
    },

    /**
     * To make html of plot line.
     * @param {object} params parameters
     *      @param {array.<object>} params.positions positions
     *      @param {number} params.size width or height
     *      @param {string} params.className line className
     *      @param {string} params.positionType position type (left or bottom)
     *      @param {string} params.sizeType size type (size or height)
     *      @param {string} params.lineColor line color
     * @returns {string} html
     * @private
     */
    _makeLineHtml: function(params) {
        var template = plotTemplate.tplPlotLine,
            lineHtml = tui.util.map(params.positions, function(position) {
                var cssTexts = [
                        renderUtil.concatStr(params.positionType, ':', position, 'px'),
                        renderUtil.concatStr(params.sizeType, ':', params.size, 'px')
                    ], data;

                if (params.lineColor) {
                    cssTexts.push(renderUtil.concatStr('background-color:', params.lineColor));
                }

                data = {className: params.className, cssText: cssTexts.join(';')};
                return template(data);
            }, this).join('');
        return lineHtml;
    },

    /**
     * To make pixel value of vertical positions
     * @param {number} height plot height
     * @returns {array.<number>} positions
     * @private
     */
    _makeVerticalPixelPositions: function(height) {
        var positions = calculator.makeTickPixelPositions(height, this.data.vTickCount);
        positions.shift();
        return positions;
    },

    /**
     * To make pixel value of horizontal positions.
     * @param {number} width plot width
     * @returns {array.<number>} positions
     * @private
     */
    _makeHorizontalPixelPositions: function(width) {
        var positions = calculator.makeTickPixelPositions(width, this.data.hTickCount);
        positions.shift();
        return positions;
    }
});

module.exports = Plot;

},{"../helpers/calculator":28,"../helpers/domHandler":30,"../helpers/renderUtil":33,"./plotTemplate":39}],39:[function(require,module,exports){
/**
 * @fileoverview This is templates of plot view .
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_PLOT_LINE: '<div class="tui-chart-plot-line {{ className }}" style="{{ cssText }}"></div>'
};

module.exports = {
    tplPlotLine: templateMaker.template(tags.HTML_PLOT_LINE)
};

},{"../helpers/templateMaker":34}],40:[function(require,module,exports){
/**
 * @fileoverview Raphael render plugin.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var BarChart = require('./raphaelBarChart'),
    LineChart = require('./raphaelLineChart'),
    AreaChart = require('./raphaelAreaChart'),
    PieChart = require('./raphaelPieChart');

var pluginName = 'raphael',
    pluginRaphael;

pluginRaphael = {
    bar: BarChart,
    column: BarChart,
    line: LineChart,
    area: AreaChart,
    pie: PieChart
};

tui.chart.registerPlugin(pluginName, pluginRaphael);

},{"./raphaelAreaChart":41,"./raphaelBarChart":42,"./raphaelLineChart":43,"./raphaelPieChart":45}],41:[function(require,module,exports){
/**
 * @fileoverview Raphael area chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var RaphaelLineBase = require('./raphaelLineTypeBase'),
    raphaelRenderUtil = require('./raphaelRenderUtil');

var Raphael = window.Raphael,
    ANIMATION_TIME = 700;

var concat = Array.prototype.concat;

/**
 * @classdesc RaphaelAreaChart is graph renderer for area chart.
 * @class RaphaelAreaChart
 * @extends RaphaelLineTypeBase
 */
var RaphaelAreaChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelAreaChart.prototype */ {
    /**
     * Render function of area chart.
     * @param {HTMLElement} container container
     * @param {{groupPositions: array.<array>, dimension: object, theme: object, options: object}} data render data
     * @return {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            groupPositions = data.groupPositions,
            theme = data.theme,
            colors = theme.colors,
            opacity = data.options.hasDot ? 1 : 0,
            groupPaths = this._getAreasPath(groupPositions, data.zeroTop),
            borderStyle = this.makeBorderStyle(theme.borderColor, opacity),
            outDotStyle = this.makeOutDotStyle(opacity, borderStyle),
            paper, groupAreas, tooltipLine, selectionDot, groupDots;

        this.paper = paper = Raphael(container, dimension.width, dimension.height);

        groupAreas = this._renderAreas(paper, groupPaths, colors);
        tooltipLine = this._renderTooltipLine(paper, dimension.height);
        selectionDot = this._makeSelectionDot(paper);
        groupDots = this._renderDots(paper, groupPositions, colors, borderStyle);

        if (data.options.hasSelection) {
            this.selectionDot = selectionDot;
            this.selectionColor = theme.selectionColor;
        }

        this.outDotStyle = outDotStyle;
        this.groupPositions = groupPositions;
        this.groupPaths = groupPaths;
        this.groupAreas = groupAreas;
        this.tooltipLine = tooltipLine;
        this.groupDots = groupDots;
        this.dotOpacity = opacity;

        return paper;
    },

    /**
     * Render area graph.
     * @param {object} paper paper
     * @param {{start: string, addStart: string}} path path
     * @param {string} color color
     * @returns {array.<object>} raphael object
     * @private
     */
    _renderArea: function(paper, path, color) {
        var result = [],
            area = paper.path([path.start]),
            fillStyle = {
                fill: color,
                opacity: 0.5,
                stroke: color,
                'stroke-opacity': 0
            },
            addArea;

        area.attr(fillStyle);
        result.push(area);

        if (path.addStart) {
            addArea = paper.path([path.addStart]);
            addArea.attr(fillStyle);
            result.push(addArea);
        }
        return result;
    },

    /**
     * Render area graphs.
     * @param {object} paper paper
     * @param {array.<object>} groupPaths group paths
     * @param {array.<string>} colors colors
     * @returns {array} raphael objects
     * @private
     */
    _renderAreas: function(paper, groupPaths, colors) {
        var groupAreas = tui.util.map(groupPaths, function(paths, groupIndex) {
            var color = colors[groupIndex] || 'transparent';
            return tui.util.map(paths, function(path) {
                var result = {
                    area: this._renderArea(paper, path.area, color),
                    line: raphaelRenderUtil.renderLine(paper, path.line.start, color)
                };
                return result;
            }, this);
        }, this);

        return groupAreas;
    },

    /**
     * Whether minus or not.
     * @param {number} value value
     * @returns {boolean} result boolean
     * @private
     */
    _isMinus: function(value) {
        return value < 0;
    },

    /**
     * Whether plus or not.
     * @param {number} value value
     * @returns {boolean} result boolean
     * @private
     */
    _isPlus: function(value) {
        return value >= 0;
    },

    /**
     * To make height.
     * @param {number} top top
     * @param {number} zeroTop zero position top
     * @returns {number} height
     * @private
     */
    _makeHeight: function(top, zeroTop) {
        return Math.abs(top - zeroTop);
    },

    /**
     * Find middle left
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} toPos to position
     * @param {number} zeroTop zero position top
     * @returns {number} middle left
     * @private
     */
    _findMiddleLeft: function(fromPos, toPos, zeroTop) {
        var tops = [zeroTop - fromPos.top, zeroTop - toPos.top],
            middleLeft, width, fromHeight, toHeight;

        if (tui.util.all(tops, this._isMinus) || tui.util.all(tops, this._isPlus)) {
            return -1;
        }

        fromHeight = this._makeHeight(fromPos.top, zeroTop);
        toHeight = this._makeHeight(toPos.top, zeroTop);
        width = toPos.left - fromPos.left;

        middleLeft = fromPos.left + (width * (fromHeight / (fromHeight + toHeight)));
        return middleLeft;
    },

    /**
     * To make area path.
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} toPos to position
     * @param {number} zeroTop zero position top
     * @returns {string} area path
     * @private
     */
    _makeAreaPath: function(fromPos, toPos, zeroTop) {
        var fromStartPoint = ['M', fromPos.left, ' ', zeroTop],
            fromEndPoint = zeroTop === fromPos.top ? [] : ['L', fromPos.left, ' ', fromPos.top],
            toStartPoint = ['L', toPos.left, ' ', toPos.top],
            toEndPoint = zeroTop === toPos.top ? [] : ['L', toPos.left, ' ', zeroTop];
        return concat.call([], fromStartPoint, fromEndPoint, toStartPoint, toEndPoint).join('');
    },

    /**
     * To make area paths.
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} toPos to position
     * @param {number} zeroTop zero position top
     * @returns {{
     *      start: string,
     *      end: string,
     *      addStart: string,
     *      addEnd: string
     * }} area paths
     * @private
     */
    _makeAreaPaths: function(fromPos, toPos, zeroTop) {
        var middleLeft = this._findMiddleLeft(fromPos, toPos, zeroTop),
            result = {
                start: this._makeAreaPath(fromPos, fromPos, zeroTop)
            },
            middlePos;

        if (this._isPlus(middleLeft)) {
            middlePos = {left: middleLeft, top: zeroTop};
            result.end = this._makeAreaPath(fromPos, middlePos, zeroTop);
            result.addStart = this._makeAreaPath(middlePos, middlePos, zeroTop);
            result.addEnd = this._makeAreaPath(middlePos, toPos, zeroTop);
        } else {
            result.end = this._makeAreaPath(fromPos, toPos, zeroTop);
        }

        return result;
    },

    /**
     * Get area path.
     * @param {array.<array.<object>>} groupPositions positions
     * @param {number} zeroTop zero top
     * @returns {array.<array.<string>>} paths
     * @private
     */
    _getAreasPath: function(groupPositions, zeroTop) {
        var groupPaths = tui.util.map(groupPositions, function(positions) {
            var fromPos = positions[0],
                rest = positions.slice(1);
            return tui.util.map(rest, function(position) {
                var result = {
                    area: this._makeAreaPaths(fromPos, position, zeroTop),
                    line: this.makeLinePath(fromPos, position)
                };
                fromPos = position;
                return result;
            }, this);
        }, this);
        return groupPaths;
    },

    /**
     * Animate area chart.
     * @param {object} area raphael object
     * @param {string} areaPath path
     * @param {number} time play time
     * @param {number} startTime start time
     * @private
     */
    _animateArea: function(area, areaPath, time, startTime) {
        var areaAddEndPath = areaPath.addEnd,
            areaEndPath = areaPath.end;
        if (areaAddEndPath) {
            time = time / 2;
            setTimeout(function() {
                area[1].animate({path: areaAddEndPath, 'stroke-opacity': 0.25}, time);
            }, startTime + time);
        }
        setTimeout(function() {
            area[0].animate({path: areaEndPath, 'stroke-opacity': 0.25}, time);
        }, startTime);
    },

    /**
     * Animate.
     * @param {function} callback callback
     */
    animate: function(callback) {
        var time = ANIMATION_TIME / this.groupAreas[0].length,
            that = this,
            startTime = 0;

        this.renderItems(function(dot, groupIndex, index) {
            var area, areaPath;
            if (index) {
                area = that.groupAreas[groupIndex][index - 1];
                areaPath = that.groupPaths[groupIndex][index - 1];
                that.animateLine(area.line, areaPath.line.end, time, startTime);
                that._animateArea(area.area, areaPath.area, time, startTime);
                startTime += time;
            } else {
                startTime = 0;
            }

            if (that.dotOpacity) {
                setTimeout(function() {
                    dot.attr({'fill-opacity': that.dotOpacity});
                }, startTime);
            }
        });

        if (callback) {
            setTimeout(callback, startTime);
        }
    },

    /**
     * To update area attribute
     * @param {object} area raphael object
     * @param {string} areaPath area path
     * @private
     */
    _updateAreaAttr: function(area, areaPath) {
        var areaAddEndPath = areaPath.addEnd;
        area[0].attr({path: areaPath.end});
        if (areaAddEndPath) {
            area[1].attr({path: areaAddEndPath});
        }
    },

    /**
     * To resize graph of area chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {array.<array.<{left:number, top:number}>>} params.groupPositions group positions
     */
    resize: function(params) {
        var dimension = params.dimension,
            groupPositions = params.groupPositions,
            that = this;

        this.groupPositions = groupPositions;
        this.groupPaths = this._getAreasPath(groupPositions, params.zeroTop);
        this.paper.setSize(dimension.width, dimension.height);
        this.tooltipLine.attr({top: dimension.height});

        this.renderItems(function(dot, groupIndex, index) {
            var position = groupPositions[groupIndex][index],
                dotAttrs = {
                    cx: position.left,
                    cy: position.top
                },
                area, areaPath;
            if (index) {
                area = that.groupAreas[groupIndex][index - 1];
                areaPath = that.groupPaths[groupIndex][index - 1];
                area.line.attr({path: areaPath.line.end});
                that._updateAreaAttr(area.area, areaPath.area);
            }

            if (that.dotOpacity) {
                dotAttrs = tui.util.extend({'fill-opacity': that.dotOpacity}, dotAttrs, that.borderStyle);
            }

            dot.attr(dotAttrs);
        });
    }
});

module.exports = RaphaelAreaChart;

},{"./raphaelLineTypeBase":44,"./raphaelRenderUtil":46}],42:[function(require,module,exports){
/**
 * @fileoverview Raphael bar chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';
var raphaelRenderUtil = require('./raphaelRenderUtil');

var Raphael = window.Raphael;

var ANIMATION_TIME = 700;

/**
 * @classdesc RaphaelBarChart is graph renderer for bar, column chart.
 * @class RaphaelBarChart
 */
var RaphaelBarChart = tui.util.defineClass(/** @lends RaphaelBarChart.prototype */ {
    /**
     * Render function of bar chart
     * @param {HTMLElement} container container element
     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data
     * @return {object} paper raphael paper
     */
    render: function(container, data) {
        var groupBounds = data.groupBounds,
            dimension = data.dimension,
            paper, baseParams;

        if (!groupBounds) {
            return null;
        }

        this.paper = paper = Raphael(container, dimension.width, dimension.height);

        baseParams = {
            paper: paper,
            theme: data.theme,
            groupBounds: groupBounds,
            groupValues: data.groupValues,
            chartType: data.chartType
        };

        this._renderBars(baseParams);

        this._renderBarBorders(baseParams);

        this.theme = data.theme;
        this.groupBounds = groupBounds;
        this.chartType = data.chartType;

        return paper;
    },

    /**
     * Render rect
     * @param {object} params parameters
     *      @param {object} params.paper raphael paper
     *      @param {string} params.color series color
     *      @param {string} params.borderColor series borderColor
     *      @param {{left: number, top: number, width: number, height: number}} params.bound bound
     * @returns {object} bar rect
     * @private
     */
    _renderBar: function(params) {
        var bound = params.bound,
            rect;
        if (bound.width < 0 || bound.height < 0) {
            return null;
        }

        rect = params.paper.rect(bound.left, bound.top, bound.width, bound.height);
        rect.attr({
            fill: params.color,
            stroke: 'none'
        });

        return rect;
    },

    /**
     * Render bars.
     * @param {object} params parameters
     *      @param {object} params.paper raphael paper
     *      @param {{colors: string[], singleColors: string[], borderColor: string}} params.theme bar chart theme
     *      @param {array.<array.<{left: number, top:number, width: number, height: number}>>} params.groupBounds bounds
     * @private
     */
    _renderBars: function(params) {
        var singleColors = (params.groupBounds[0].length === 1) && params.theme.singleColors || [],
            colors = params.theme.colors;
        this.groupBars = tui.util.map(params.groupBounds, function(bounds, groupIndex) {
            var singleColor = singleColors[groupIndex];
            return tui.util.map(bounds, function(bound, index) {
                var color, rect, value;

                if (!bound) {
                    return null;
                }

                color = singleColor || colors[index];
                value = params.groupValues[groupIndex][index];

                rect = this._renderBar({
                    paper: params.paper,
                    chartType: params.chartType,
                    color: color,
                    borderColor: params.theme.borderColor,
                    bound: bound.start,
                    value: value
                });

                return {
                    rect: rect,
                    color: color,
                    bound: bound.end,
                    value: value,
                    groupIndex: groupIndex,
                    index: index
                };
            }, this);
        }, this);
    },

    /**
     * To make rect points.
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @returns {{
     *      leftTop: {left: number, top: number},
     *      rightTop: {left: number, top: number},
     *      rightBottom: {left: number, top: number},
     *      leftBottom: {left: number, top: number}
     * }} rect points
     * @private
     */
    _makeRectPoints: function(bound) {
        return {
            leftTop: {
                left: Math.ceil(bound.left),
                top: Math.ceil(bound.top)
            },
            rightTop: {
                left: Math.ceil(bound.left + bound.width),
                top: Math.ceil(bound.top)
            },
            rightBottom: {
                left: Math.ceil(bound.left + bound.width),
                top: Math.ceil(bound.top + bound.height)
            },
            leftBottom: {
                left: Math.ceil(bound.left),
                top: Math.ceil(bound.top + bound.height)
            }
        };
    },

    /**
     * To make top line path.
     * @param {{left: numbrer, top: number}} leftTop left top
     * @param {{left: numbrer, top: number}} rightTop right top
     * @param {string} chartType chart type
     * @param {number} value value
     * @returns {string} top line path
     * @private
     */
    _makeTopLinePath: function(leftTop, rightTop, chartType, value) {
        var cloneLeftTop = tui.util.extend({}, leftTop);
        cloneLeftTop.left -= chartType === 'column' || value < 0 ? 1 : 0;
        return raphaelRenderUtil.makeLinePath(cloneLeftTop, rightTop);
    },

    /**
     * To make border lines paths.
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @param {string} chartType chart type
     * @param {number} value value
     * @returns {{top: string, right: string, bottom: string, left: string}} paths
     * @private
     */
    _makeBorderLinesPaths: function(bound, chartType, value) {
        var points = this._makeRectPoints(bound),
            paths = {};

        if (chartType === 'bar' || value >= 0) {
            paths.top = this._makeTopLinePath(points.leftTop, points.rightTop, chartType, value);
        }

        if (chartType === 'column' || value >= 0) {
            paths.right = raphaelRenderUtil.makeLinePath(points.rightTop, points.rightBottom);
        }

        if (chartType === 'bar' || value < 0) {
            paths.bottom = raphaelRenderUtil.makeLinePath(points.leftBottom, points.rightBottom);
        }

        if (chartType === 'column' || value < 0) {
            paths.left = raphaelRenderUtil.makeLinePath(points.leftTop, points.leftBottom);
        }

        return paths;
    },

    /**
     * Render border lines;
     * @param {object} params parameters
     *      @param {object} params.paper paper
     *      @param {{left: number, top:number, width: number, height: number}} params.bound bar bound
     *      @param {string} params.borderColor border color
     *      @param {string} params.chartType chart type
     *      @param {number} params.value value
     * @returns {object} raphael object
     * @private
     */
    _renderBorderLines: function(params) {
        var borderLinePaths = this._makeBorderLinesPaths(params.bound, params.chartType, params.value),
            lines = {};
        tui.util.forEach(borderLinePaths, function(path, name) {
            lines[name] = raphaelRenderUtil.renderLine(params.paper, path, params.borderColor, 1);
        });
        return lines;
    },

    /**
     * Render bar borders.
     * @param {object} params parameters
     *      @param {object} params.paper raphael paper
     *      @param {{colors: string[], singleColors: string[], borderColor: string}} params.theme bar chart theme
     *      @param {array.<array.<{left: number, top:number, width: number, height: number}>>} params.groupBounds bounds
     * @private
     */
    _renderBarBorders: function(params) {
        var borderColor = params.theme.borderColor;
        if (!borderColor) {
            return;
        }
        this.groupBorders = tui.util.map(params.groupBounds, function(bounds, groupIndex) {
            return tui.util.map(bounds, function(bound, index) {
                var value;

                if (!bound) {
                    return null;
                }

                value = params.groupValues[groupIndex][index];

                return this._renderBorderLines({
                    paper: params.paper,
                    bound: bound.start,
                    borderColor: borderColor,
                    chartType: params.chartType,
                    value: value
                });
            }, this);
        }, this);
    },

    /**
     * Animate rect.
     * @param {object} rect raphael object
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @private
     */
    _animateRect: function(rect, bound) {
        rect.animate({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        }, ANIMATION_TIME);
    },

    /**
     * Animate borders.
     * @param {array.<object>} lines raphael objects
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @param {string} chartType chart type
     * @param {number} value value
     * @private
     */
    _animateBorders: function(lines, bound, chartType, value) {
        var paths = this._makeBorderLinesPaths(bound, chartType, value);
        tui.util.forEach(lines, function(line, name) {
            line.animate({path: paths[name]}, ANIMATION_TIME);
        });
    },

    /**
     * Animate.
     * @param {function} callback callback
     */
    animate: function(callback) {
        tui.util.forEachArray(this.groupBars, function(bars, groupIndex) {
            var borders = this.groupBorders && this.groupBorders[groupIndex];
            tui.util.forEachArray(bars, function(bar, index) {
                var lines = borders && borders[index];
                this._animateRect(bar.rect, bar.bound);
                if (lines) {
                    this._animateBorders(lines, bar.bound, this.chartType, bar.value);
                }
            }, this);
        }, this);

        if (callback) {
            setTimeout(callback, ANIMATION_TIME);
        }
    },

    /**
     * To update rect attribute
     * @param {object} rect raphael object
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @private
     */
    _updateRectAttr: function(rect, bound) {
        rect.attr({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        });
    },

    /**
     * To update borders attribute
     * @param {array.<object>} lines raphael objects
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @param {string} chartType chart type
     * @param {number} value value
     * @private
     */
    _updateBordersAttr: function(lines, bound, chartType, value) {
        var paths = this._makeBorderLinesPaths(bound, chartType, value);
        tui.util.forEach(lines, function(line, name) {
            line.attr({path: paths[name]});
        });
    },

    /**
     * To resize graph of bar type chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {array.<array.<{left:number, top:number, width: number, height: number}>>} params.groupBounds group bounds
     */
    resize: function(params) {
        var dimension = params.dimension,
            groupBounds = params.groupBounds;

        this.groupBounds = groupBounds;
        this.paper.setSize(dimension.width, dimension.height);

        tui.util.forEachArray(this.groupBars, function(bars, groupIndex) {
            var borders = this.groupBorders && this.groupBorders[groupIndex];
            tui.util.forEachArray(bars, function(bar, index) {
                var lines = borders && borders[index],
                    bound = groupBounds[groupIndex][index].end;
                bar.bound = bound;
                this._updateRectAttr(bar.rect, bound);
                if (lines) {
                    this._updateBordersAttr(lines, bound, this.chartType, bar.value);
                }
            }, this);
        }, this);
    },

    /**
     * Change borders color.
     * @param {array.<object>} lines raphael objects
     * @param {borderColor} borderColor border color
     * @private
     */
    _changeBordersColor: function(lines, borderColor) {
        tui.util.forEach(lines, function(line) {
            line.attr({stroke: borderColor});
        });
    },

    /**
     * To change bar color.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} color fill color
     * @param {?string} borderColor stroke color
     * @private
     */
    _changeBarColor: function(indexes, color, borderColor) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            lines;

        bar.rect.attr({
            fill: color
        });

        if (borderColor) {
            lines = this.groupBorders[indexes.groupIndex][indexes.index];
            this._changeBordersColor(lines, borderColor);
        }
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            objColor = Raphael.color(bar.color),
            color = this.theme.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, 0.2),
            borderColor = this.theme.borderColor,
            objBorderColor;

        if (borderColor) {
            objBorderColor = Raphael.color(borderColor);
            borderColor = raphaelRenderUtil.makeChangedLuminanceColor(objBorderColor.hex, 0.2);
        }

        this._changeBarColor(indexes, color, borderColor);
    },

    /**
     * Unselect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            borderColor = this.theme.borderColor;
        this._changeBarColor(indexes, bar.color, borderColor);
    }
});

module.exports = RaphaelBarChart;

},{"./raphaelRenderUtil":46}],43:[function(require,module,exports){
/**
 * @fileoverview Raphael line chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var RaphaelLineBase = require('./raphaelLineTypeBase'),
    raphaelRenderUtil = require('./raphaelRenderUtil');

var Raphael = window.Raphael,
    ANIMATION_TIME = 700;

/**
 * @classdesc RaphaelLineCharts is graph renderer for line chart.
 * @class RaphaelLineChart
 * @extends RaphaelLineTypeBase
 */
var RaphaelLineChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelLineChart.prototype */ {
    /**
     * Render function of line chart.
     * @param {HTMLElement} container container
     * @param {{groupPositions: array.<array>, dimension: object, theme: object, options: object}} data render data
     * @return {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            groupPositions = data.groupPositions,
            theme = data.theme,
            colors = theme.colors,
            opacity = data.options.hasDot ? 1 : 0,
            groupPaths = this._getLinesPath(groupPositions),
            borderStyle = this.makeBorderStyle(theme.borderColor, opacity),
            outDotStyle = this.makeOutDotStyle(opacity, borderStyle),
            paper, groupLines, tooltipLine, selectionDot, groupDots;

        this.paper = paper = Raphael(container, dimension.width, dimension.height);

        groupLines = this._renderLines(paper, groupPaths, colors);
        tooltipLine = this._renderTooltipLine(paper, dimension.height);
        selectionDot = this._makeSelectionDot(paper);
        groupDots = this._renderDots(paper, groupPositions, colors, borderStyle);

        if (data.options.hasSelection) {
            this.selectionDot = selectionDot;
            this.selectionColor = theme.selectionColor;
        }

        this.borderStyle = borderStyle;
        this.outDotStyle = outDotStyle;
        this.groupPositions = groupPositions;
        this.groupPaths = groupPaths;
        this.groupLines = groupLines;
        this.tooltipLine = tooltipLine;
        this.groupDots = groupDots;
        this.dotOpacity = opacity;

        return paper;
    },

    /**
     * Get lines path.
     * @param {array.<array.<object>>} groupPositions positions
     * @returns {array.<array.<string>>} paths
     * @private
     */
    _getLinesPath: function(groupPositions) {
        var groupPaths = tui.util.map(groupPositions, function(positions) {
            var fromPos = positions[0],
                rest = positions.slice(1);
            return tui.util.map(rest, function(position) {
                var result = this.makeLinePath(fromPos, position);
                fromPos = position;
                return result;
            }, this);
        }, this);
        return groupPaths;
    },

    /**
     * Render lines.
     * @param {object} paper raphael paper
     * @param {array.<array.<string>>} groupPaths paths
     * @param {string[]} colors line colors
     * @param {number} strokeWidth stroke width
     * @returns {array.<array.<object>>} lines
     * @private
     */
    _renderLines: function(paper, groupPaths, colors, strokeWidth) {
        var groupLines = tui.util.map(groupPaths, function(paths, groupIndex) {
            var color = colors[groupIndex] || 'transparent';
            return tui.util.map(paths, function(path) {
                return raphaelRenderUtil.renderLine(paper, path.start, color, strokeWidth);
            }, this);
        }, this);

        return groupLines;
    },

    /**
     * Animate.
     * @param {function} callback callback
     */
    animate: function(callback) {
        var time = ANIMATION_TIME / this.groupLines[0].length,
            that = this,
            startTime = 0;
        this.renderItems(function(dot, groupIndex, index) {
            var line, path;

            if (index) {
                line = that.groupLines[groupIndex][index - 1];
                path = that.groupPaths[groupIndex][index - 1].end;
                that.animateLine(line, path, time, startTime);
                startTime += time;
            } else {
                startTime = 0;
            }

            if (that.dotOpacity) {
                setTimeout(function() {
                    dot.attr(tui.util.extend({'fill-opacity': that.dotOpacity}, that.borderStyle));
                }, startTime);
            }
        });

        if (callback) {
            setTimeout(callback, startTime);
        }
    },

    /**
     * To resize graph of line chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {array.<array.<{left:number, top:number}>>} params.groupPositions group positions
     */
    resize: function(params) {
        var dimension = params.dimension,
            groupPositions = params.groupPositions,
            that = this;

        this.groupPositions = groupPositions;
        this.groupPaths = this._getLinesPath(groupPositions);
        this.paper.setSize(dimension.width, dimension.height);
        this.tooltipLine.attr({top: dimension.height});

        this.renderItems(function(dot, groupIndex, index) {
            var position = groupPositions[groupIndex][index],
                dotAttrs = {
                    cx: position.left,
                    cy: position.top
                },
                line, path;
            if (index) {
                line = that.groupLines[groupIndex][index - 1];
                path = that.groupPaths[groupIndex][index - 1].end;
                line.attr({path: path});
            }

            if (that.dotOpacity) {
                dotAttrs = tui.util.extend({'fill-opacity': that.dotOpacity}, dotAttrs, that.borderStyle);
            }

            dot.attr(dotAttrs);
        });
    }
});

module.exports = RaphaelLineChart;

},{"./raphaelLineTypeBase":44,"./raphaelRenderUtil":46}],44:[function(require,module,exports){
/**
 * @fileoverview RaphaelLineTypeBase is base class for line type renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var DEFAULT_DOT_RADIUS = 3,
    HOVER_DOT_RADIUS = 4,
    SELECTION_DOT_RADIOUS = 7;

/**
 * @classdesc RaphaelLineTypeBase is base for line type renderer.
 * @class RaphaelLineTypeBase
 */
var RaphaelLineTypeBase = tui.util.defineClass(/** @lends RaphaelLineTypeBase.prototype */ {
    /**
     * To make line paths.
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} toPos to position
     * @returns {{start: string, end: string}} line paths.
     */
    makeLinePath: function(fromPos, toPos) {
        var startLinePath = raphaelRenderUtil.makeLinePath(fromPos, fromPos),
            endLinePath = raphaelRenderUtil.makeLinePath(fromPos, toPos);
        return {
            start: startLinePath,
            end: endLinePath
        };
    },

    /**
     * Render tooltip line.
     * @param {object} paper raphael paper
     * @param {number} height height
     * @returns {object} raphael object
     * @private
     */
    _renderTooltipLine: function(paper, height) {
        var linePath = raphaelRenderUtil.makeLinePath({
                left: 10,
                top: height
            }, {
                left: 10,
                top: 0
            });
        return raphaelRenderUtil.renderLine(paper, linePath, 'transparent', 1);
    },

    /**
     * To make border style.
     * @param {string} borderColor border color
     * @param {number} opacity opacity
     * @returns {{stroke: string, stroke-width: number, strike-opacity: number}} border style
     */
    makeBorderStyle: function(borderColor, opacity) {
        var borderStyle;
        if (borderColor) {
            borderStyle = {
                stroke: borderColor,
                'stroke-width': 1,
                'stroke-opacity': opacity
            };
        }
        return borderStyle;
    },

    /**
     * To make dot style for mouseout event.
     * @param {number} opacity opacity
     * @param {object} borderStyle border style
     * @returns {{fill-opacity: number, stroke-opacity: number, r: number}} style
     */
    makeOutDotStyle: function(opacity, borderStyle) {
        var outDotStyle = {
            'fill-opacity': opacity,
            'stroke-opacity': 0,
            r: DEFAULT_DOT_RADIUS
        };

        if (borderStyle) {
            tui.util.extend(outDotStyle, borderStyle);
        }

        return outDotStyle;
    },

    /**
     * Render dot.
     * @param {object} paper raphael papaer
     * @param {{left: number, top: number}} position dot position
     * @param {string} color dot color
     * @param {object} borderStyle border style
     * @returns {object} raphael dot
     */
    renderDot: function(paper, position, color) {
        var dot = paper.circle(position.left, position.top, DEFAULT_DOT_RADIUS),
            dotStyle = {
                fill: color,
                'fill-opacity': 0,
                'stroke-opacity': 0
            };

        dot.attr(dotStyle);

        return {
            dot: dot,
            color: color
        };
    },

    /**
     * Render dots.
     * @param {object} paper raphael paper
     * @param {array.<array.<object>>} groupPositions positions
     * @param {string[]} colors colors
     * @param {object} borderStyle border style
     * @returns {array.<object>} dots
     * @private
     */
    _renderDots: function(paper, groupPositions, colors) {
        var dots = tui.util.map(groupPositions, function(positions, groupIndex) {
            var color = colors[groupIndex];
            return tui.util.map(positions, function(position) {
                var dot = this.renderDot(paper, position, color);
                return dot;
            }, this);
        }, this);

        return dots;
    },

    /**
     * Get center position
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} toPos to position
     * @returns {{left: number, top: number}} position
     * @private
     */
    _getCenter: function(fromPos, toPos) {
        return {
            left: (fromPos.left + toPos.left) / 2,
            top: (fromPos.top + toPos.top) / 2
        };
    },

    /**
     * Show dot.
     * @param {object} dot raphael object
     * @private
     */
    _showDot: function(dot) {
        dot.attr({
            'fill-opacity': 1,
            'stroke-opacity': 0.3,
            'stroke-width': 2,
            r: HOVER_DOT_RADIUS
        });
    },

    /**
     * Show animation.
     * @param {{groupIndex: number, index:number}} data show info
     */
    showAnimation: function(data) {
        var index = data.groupIndex, // Line chart has pivot values.
            groupIndex = data.index,
            item = this.groupDots[groupIndex][index];
        this._showDot(item.dot);
    },

    /**
     * Get pivot group dots.
     * @returns {array.<array>} dots
     * @private
     */
    _getPivotGroupDots: function() {
        if (!this.pivotGroupDots) {
            this.pivotGroupDots = tui.util.pivot(this.groupDots);
        }

        return this.pivotGroupDots;
    },

    /**
     * Show group dots.
     * @param {number} index index
     * @private
     */
    _showGroupDots: function(index) {
        var groupDots = this._getPivotGroupDots();
        tui.util.forEachArray(groupDots[index], function(item) {
            this._showDot(item.dot);
        }, this);
    },

    /**
     * Show line for group tooltip.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound bound
     */
    showGroupTooltipLine: function(bound) {
        var linePath = raphaelRenderUtil.makeLinePath({
            left: bound.position.left,
            top: bound.dimension.height
        }, {
            left: bound.position.left,
            top: bound.position.top
        });
        this.tooltipLine.attr({
            path: linePath,
            stroke: '#999',
            'stroke-opacity': 1
        });
    },

    /**
     * Show group animation.
     * @param {number} index index
     */
    showGroupAnimation: function(index) {
        this._showGroupDots(index);
    },

    /**
     * Hide dot.
     * @param {object} dot raphael object
     * @private
     */
    _hideDot: function(dot) {
        dot.attr(this.outDotStyle);
    },

    /**
     * Hide animation.
     * @param {{groupIndex: number, index:number}} data hide info
     */
    hideAnimation: function(data) {
        var index = data.groupIndex, // Line chart has pivot values.
            groupIndex = data.index,
            item = this.groupDots[groupIndex][index];
        if (item) {
            this._hideDot(item.dot);
        }
    },

    /**
     * Hide group dots.
     * @param {number} index index
     * @private
     */
    _hideGroupDots: function(index) {
        var dots = this._getPivotGroupDots();
        tui.util.forEachArray(dots[index], function(item) {
            this._hideDot(item.dot);
        }, this);
    },

    /**
     * Hide line for group tooltip.
     * @private
     */
    hideGroupTooltipLine: function() {
        this.tooltipLine.attr({
            'stroke-opacity': 0
        });
    },

    /**
     * Hide group animation.
     * @param {number} index index
     */
    hideGroupAnimation: function(index) {
        this._hideGroupDots(index);
    },

    /**
     * Animate line.
     * @param {object} line raphael object
     * @param {string} linePath line path
     * @param {number} time play time
     * @param {number} startTime start time
     */
    animateLine: function(line, linePath, time, startTime) {
        setTimeout(function() {
            line.animate({path: linePath}, time);
        }, startTime);
    },

    /**
     * To render items of line type chart.
     * @param {function} funcRenderItem function
     */
    renderItems: function(funcRenderItem) {
        tui.util.forEachArray(this.groupDots, function(dots, groupIndex) {
            tui.util.forEachArray(dots, function(item, index) {
                funcRenderItem(item.dot, groupIndex, index);
            }, this);
        }, this);
    },

    /**
     * To make selection dot.
     * @param {object} paper raphael paper
     * @returns {object} selection dot
     * @private
     */
    _makeSelectionDot: function(paper) {
        var selectionDot = paper.circle(0, 0, SELECTION_DOT_RADIOUS);
        selectionDot.attr({
            'fill': '#ffffff',
            'fill-opacity': 0,
            'stroke-opacity': 0,
            'stroke-width': 2
        });
        return selectionDot;
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var item = this.groupDots[indexes.index][indexes.groupIndex],
            position = this.groupPositions[indexes.index][indexes.groupIndex];
        this.selectedItem = item;
        this.selectionDot.attr({
            cx: position.left,
            cy: position.top,
            'fill-opacity': 0.5,
            'stroke-opacity': 1,
            stroke: this.selectionColor || item.color
        });
    },

    /**
     * Unselect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var item = this.groupDots[indexes.index][indexes.groupIndex];

        if (this.selectedItem === item) {
            this.selectionDot.attr({
                'fill-opacity': 0,
                'stroke-opacity': 0
            });
        }
    }
});

module.exports = RaphaelLineTypeBase;

},{"./raphaelRenderUtil":46}],45:[function(require,module,exports){
/**
 * @fileoverview RaphaelPieCharts is graph renderer for pie chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var Raphael = window.Raphael,
    ANGLE_180 = 180,
    RAD = Math.PI / ANGLE_180,
    ANIMATION_TIME = 500,
    LOADING_ANIMATION_TIME = 700;

/**
 * @classdesc RaphaelPieCharts is graph renderer for pie chart.
 * @class RaphaelPieChart
 */
var RaphaelPieChart = tui.util.defineClass(/** @lends RaphaelPieChart.prototype */ {
    /**
     * Render function of pie chart.
     * @param {HTMLElement} container container
     * @param {{sectorsInfo: array.<object>, circleBound: {cx: number, cy: number, r: number}, dimension: object, theme: object, options: object}} data render data
     * @param {object} callbacks callbacks
     *      @param {function} callbacks.funcShowTooltip show tooltip function
     *      @param {function} callbacks.funcHideTooltip hide tooltip function
     *      @param {function} callbacks.funcSelectSeries select series function
     * @return {object} paper raphael paper
     */
    render: function(container, data, callbacks) {
        var dimension = data.dimension,
            paper;

        this.paper = paper = Raphael(container, dimension.width, dimension.height);

        if (!paper.customAttributes.sector) {
            paper.customAttributes.sector = tui.util.bind(this._makeSectorPath, this);
        }

        this.selectionColor = data.theme.selectionColor;
        this.circleBound = data.circleBound;
        this._renderPie(paper, data, callbacks);

        return paper;
    },

    /**
     * To make sector path.
     * @param {number} cx center x
     * @param {number} cy center y
     * @param {number} r radius
     * @param {number} startAngle start angle
     * @param {number} endAngle end angel
     * @returns {{path: array}} sector path
     * @private
     */
    _makeSectorPath: function(cx, cy, r, startAngle, endAngle) {
        var x1 = cx + r * Math.sin(startAngle * RAD), //    x 
            y1 = cy - r * Math.cos(startAngle * RAD), //    y 
            x2 = cx + r * Math.sin(endAngle * RAD),//    x 
            y2 = cy - r * Math.cos(endAngle * RAD), //    y 
            largeArcFlag = endAngle - startAngle > ANGLE_180 ? 1 : 0,
            path = ["M", cx, cy,
                "L", x1, y1,
                "A", r, r, 0, largeArcFlag, 1, x2, y2,
                "Z"
            ];
        // path      
        // http://www.w3schools.com/svg/svg_path.asp
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
        return {path: path};
    },

    /**
     * Render sector
     * @param {object} params parameters
     *      @param {object} params.paper raphael paper
     *      @param {{cx: number, cy: number, r:number}} params.circleBound circle bounds
     *      @param {number} params.startAngle start angle
     *      @param {number} params.endAngle end angle
     *      @param {{fill: string, stroke: string, strike-width: string}} params.attrs attrs
     * @returns {object} raphael object
     * @private
     */
    _renderSector: function (params) {
        var circleBound = params.circleBound,
            angles = params.angles;
        return params.paper.path().attr({
            sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
        }).attr(params.attrs);
    },

    /**
     * Render pie graph.
     * @param {object} paper raphael paper
     * @param {{sectorsInfo: array.<object>, circleBound: {cx: number, cy: number, r: number}, dimension: object, theme: object, options: object}} data render data
     * @param {object} callbacks callbacks
     *      @param {function} callbacks.funcShowTooltip show tooltip function
     *      @param {function} callbacks.funcHideTooltip hide tooltip function
     *      @param {function} callbacks.funcSelectSeries select series function
     * @private
     */
    _renderPie: function(paper, data, callbacks) {
        var circleBound = data.circleBound,
            colors = data.theme.colors,
            chartBackground = data.chartBackground,
            sectors = [];

        tui.util.forEachArray(data.sectorsInfo, function(sectorInfo, index) {
            var percentValue = sectorInfo.percentValue,
                color = colors[index],
                sector = this._renderSector({
                    paper: paper,
                    circleBound: circleBound,
                    angles: sectorInfo.angles.start,
                    attrs: {
                        fill: color,
                        stroke: chartBackground,
                        'stroke-width': 1
                    }
                });

            this._bindHoverEvent(sector, index, callbacks);

            sectors.push({
                sector: sector,
                color: color,
                angles: sectorInfo.angles.end,
                percentValue: percentValue
            });
        }, this);

        this.sectors = sectors;
    },

    /**
     * Render legend lines.
     * @param {array.<object>} outerPositions outer position
     */
    renderLegendLines: function(outerPositions) {
        var that = this,
            paths;

        if (this.legendLines) {
            return;
        }

        paths = this._makeLinePaths(outerPositions);
        this.legendLines = tui.util.map(paths, function(path) {
            return raphaelRenderUtil.renderLine(that.paper, path, 'transparent', 1);
        });
    },

    /**
     * To make line paths.
     * @param {array.<object>} outerPositions outer positions
     * @returns {Array} line paths.
     * @private
     */
    _makeLinePaths: function(outerPositions) {
        var paths = tui.util.map(outerPositions, function(positions) {
            return [
                raphaelRenderUtil.makeLinePath(positions.start, positions.middle),
                raphaelRenderUtil.makeLinePath(positions.middle, positions.end),
                'Z'
            ].join('');
        }, this);
        return paths;
    },

    /**
     * Bind hover event.
     * @param {object} target raphael item
     * @param {number} index index
     * @param {object} callbacks callbacks
     *      @param {function} callbacks.funcShowTooltip show tooltip function
     *      @param {function} callbacks.funcHideTooltip hide tooltip function
     *      @param {function} callbacks.funcSelectSeries select series function
     * @private
     */
    _bindHoverEvent: function(target, index, callbacks) {
        var args = [{}, 0, index],
            isOn = false,
            throttled = tui.util.throttle(function() {
                if (!isOn) {
                    return;
                }
                callbacks.funcShowTooltip.apply(null, arguments);
            }, 100);

        target.mouseover(function (e) {
            var _args = args.concat({
                clientX: e.clientX,
                clientY: e.clientY
            });
            isOn = true;
            callbacks.funcShowTooltip.apply(null, _args);
        }).mousemove(function(e) {
            var _args = args.concat({
                clientX: e.clientX,
                clientY: e.clientY - 10
            });
            throttled.apply(null, _args);
        }).mouseout(function () {
            isOn = false;
            callbacks.funcHideTooltip();
        }).click(function() {
            callbacks.funcSelectSeries(index);
        });
    },

    /**
     * To expand selector radius.
     * @param {object} sector pie sector
     */
    _expandSector: function(sector) {
        var cx = this.circleBound.cx,
            cy = this.circleBound.cy;
        sector.animate({
            transform: "s1.1 1.1 " + cx + " " + cy
        }, ANIMATION_TIME, "elastic");
    },

    /**
     * To restore selector radius.
     * @param {object} sector pie sector
     */
    _restoreSector: function(sector) {
        sector.animate({transform: ""}, ANIMATION_TIME, "elastic");
    },

    /**
     * Show animation.
     * @param {{index: number}} data data
     */
    showAnimation: function(data) {
        var sector = this.sectors[data.index].sector;
        this._expandSector(sector);
    },

    /**
     * Hide animation.
     * @param {{index: number}} data data
     */
    hideAnimation: function(data) {
        var sector = this.sectors[data.index].sector;
        this._restoreSector(sector);
    },

    /**
     * Animate.
     * @param {function} callback callback
     */
    animate: function(callback) {
        var delayTime = 0,
            circleBound = this.circleBound;
        tui.util.forEachArray(this.sectors, function(item) {
            var angles = item.angles,
                animationTime = LOADING_ANIMATION_TIME * item.percentValue,
                anim = Raphael.animation({
                    sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
                }, animationTime);
            item.sector.animate(anim.delay(delayTime));
            delayTime += animationTime;
        }, this);

        if (callback) {
            setTimeout(callback, delayTime);
        }
    },

    /**
     * Animate legend lines.
     */
    animateLegendLines: function() {
        if (!this.legendLines) {
            return;
        }
        tui.util.forEachArray(this.legendLines, function(line) {
            line.animate({
                'stroke': 'black',
                'stroke-opacity': 1
            });
        });
    },


    /**
     * To resize graph of pie chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {{cx:number, cy:number, r: number}} params.circleBound circle bound
     */
    resize: function(params) {
        var dimension = params.dimension,
            circleBound = params.circleBound;

        this.circleBound = circleBound;
        this.paper.setSize(dimension.width, dimension.height);

        tui.util.forEachArray(this.sectors, function(item) {
            var angles = item.angles;
            item.sector.attr({
                sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
            });
        }, this);
    },

    /**
     * To move legend lines.
     * @param {array.<object>} outerPositions outer positions
     */
    moveLegendLines: function(outerPositions) {
        var paths;
        if (!this.legendLines) {
            return;
        }

        paths = this._makeLinePaths(outerPositions)
        tui.util.forEachArray(this.legendLines, function(line, index) {
            line.attr({path: paths[index]});
            return line;
        });
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var item = this.sectors[indexes.index],
            objColor = Raphael.color(item.color),
            color = this.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, 0.2);
        item.sector.attr({
            fill: color
        });
    },

    /**
     * Unelect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var sector = this.sectors[indexes.index];
        sector.sector.attr({
            fill: sector.color
        });
    }
});

module.exports = RaphaelPieChart;

},{"./raphaelRenderUtil":46}],46:[function(require,module,exports){
/**
 * @fileoverview Util for raphael rendering.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Util for raphael rendering.
 * @module raphaelRenderUtil
 */
var raphaelRenderUtil = {
    /**
     * To make line path.
     * @memberOf module:raphaelRenderUtil
     * @param {{top: number, left: number}} fromPos from position
     * @param {{top: number, left: number}} toPos to position
     * @param {number} width width
     * @returns {string} path
     */
    makeLinePath: function(fromPos, toPos, width) {
        var fromPoint = [fromPos.left, fromPos.top],
            toPoint = [toPos.left, toPos.top];

        width = width || 1;

        tui.util.forEachArray(fromPoint, function(from, index) {
            if (from === toPoint[index]) {
                fromPoint[index] = toPoint[index] = Math.round(from) - (width % 2 / 2);
            }
        });
        return 'M' + fromPoint.join(' ') + 'L' + toPoint.join(' ');
    },

    /**
     * Render line.
     * @memberOf module:raphaelRenderUtil
     * @param {object} paper raphael paper
     * @param {string} path line path
     * @param {string} color line color
     * @param {number} strokeWidth stroke width
     * @returns {object} raphael line
     */
    renderLine: function(paper, path, color, strokeWidth) {
        var line = paper.path([path]),
            strokeStyle = {
                stroke: color,
                'stroke-width': strokeWidth || 2
            };

        if (color === 'transparent') {
            strokeStyle.stroke = '#fff';
            strokeStyle['stroke-opacity'] = 0;
        }
        line.attr(strokeStyle);

        return line;
    },

    /**
     * To make changed luminance color.
     * http://www.sitepoint.com/javascript-generate-lighter-darker-color/
     * @param {string} hex hax color
     * @param {number} lum luminance
     * @returns {string} changed color
     */
    makeChangedLuminanceColor: function (hex, lum) {
        // validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');

        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }

        lum = lum || 0;

        // convert to decimal and change luminosity
        return '#' + tui.util.map(tui.util.range(3), function(index) {
            var c = parseInt(hex.substr(index * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            return ("00" + c).substr(c.length);
        }).join('');
    }
};

module.exports = raphaelRenderUtil;

},{}],47:[function(require,module,exports){
if (!window.JSON) {
    window.JSON = {
        parse: function(sJSON) { return eval('(' + sJSON + ')'); },
        stringify: (function () {
            var toString = Object.prototype.toString;
            var isArray = Array.isArray || function (a) { return toString.call(a) === '[object Array]'; };
            var escMap = {'"': '\\"', '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'};
            var escFunc = function (m) { return escMap[m] || '\\u' + (m.charCodeAt(0) + 0x10000).toString(16).substr(1); };
            var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
            return function stringify(value) {
                if (value == null) {
                    return 'null';
                } else if (typeof value === 'number') {
                    return isFinite(value) ? value.toString() : 'null';
                } else if (typeof value === 'boolean') {
                    return value.toString();
                } else if (typeof value === 'object') {
                    if (typeof value.toJSON === 'function') {
                        return stringify(value.toJSON());
                    } else if (isArray(value)) {
                        var res = '[';
                        for (var i = 0; i < value.length; i++)
                            res += (i ? ', ' : '') + stringify(value[i]);
                        return res + ']';
                    } else if (toString.call(value) === '[object Object]') {
                        var tmp = [];
                        for (var k in value) {
                            if (value.hasOwnProperty(k))
                                tmp.push(stringify(k) + ': ' + stringify(value[k]));
                        }
                        return '{' + tmp.join(', ') + '}';
                    }
                }
                return '"' + value.toString().replace(escRE, escFunc) + '"';
            };
        })()
    };
}

},{}],48:[function(require,module,exports){
'use strict';

var chartConst = require('./const'),
    chartFactory = require('./factories/chartFactory'),
    BarChart = require('./charts/barChart'),
    ColumnChart = require('./charts/columnChart'),
    LineChart = require('./charts/lineChart'),
    AreaChart = require('./charts/areaChart'),
    ComboChart = require('./charts/comboChart'),
    PieChart = require('./charts/pieChart');

chartFactory.register(chartConst.CHART_TYPE_BAR, BarChart);
chartFactory.register(chartConst.CHART_TYPE_COLUMN, ColumnChart);
chartFactory.register(chartConst.CHART_TYPE_LINE, LineChart);
chartFactory.register(chartConst.CHART_TYPE_AREA, AreaChart);
chartFactory.register(chartConst.CHART_TYPE_COMBO, ComboChart);
chartFactory.register(chartConst.CHART_TYPE_PIE, PieChart);

},{"./charts/areaChart":4,"./charts/barChart":6,"./charts/columnChart":8,"./charts/comboChart":9,"./charts/lineChart":10,"./charts/pieChart":12,"./const":15,"./factories/chartFactory":23}],49:[function(require,module,exports){
'use strict';

var chartConst = require('./const'),
    themeFactory = require('./factories/themeFactory'),
    defaultTheme = require('./themes/defaultTheme');

themeFactory.register(chartConst.DEFAULT_THEME_NAME, defaultTheme);

},{"./const":15,"./factories/themeFactory":25,"./themes/defaultTheme":59}],50:[function(require,module,exports){
/**
 * @fileoverview Area chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    LineTypeSeriesBase = require('./lineTypeSeriesBase');

var AreaChartSeries = tui.util.defineClass(Series, /** @lends AreaChartSeries.prototype */ {
    /**
     * Area chart series component.
     * @constructs AreaChartSeries
     * @extends Series
     * @mixes LineTypeSeriesBase
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * To make series data.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @returns {object} series data
     */
    makeSeriesData: function(bound) {
        var dimension = bound.dimension,
            scaleDistance = this.getScaleDistanceFromZeroPoint(dimension.height, this.data.scale),
            zeroTop = scaleDistance.toMax;
        if (this.data.scale.min >= 0 && !zeroTop) {
            zeroTop = dimension.height;
        }

        return {
            groupPositions: this.makePositions(dimension),
            zeroTop: zeroTop
        };
    }
});

LineTypeSeriesBase.mixin(AreaChartSeries);

module.exports = AreaChartSeries;

},{"./lineTypeSeriesBase":55,"./series":57}],51:[function(require,module,exports){
/**
 * @fileoverview Bar chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    BarTypeSeriesBase = require('./barTypeSeriesBase'),
    chartConst = require('../const'),
    renderUtil = require('../helpers/renderUtil');

var BarChartSeries = tui.util.defineClass(Series, /** @lends BarChartSeries.prototype */ {
    /**
     * Bar chart series component.
     * @constructs BarChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * To make bound of bar chart.
     * @param {object} params parameters
     *      @param {{top: number, height: number}} params.baseBound base bound
     *      @param {number} params.startLeft start left
     *      @param {number} params.endLeft end left
     *      @param {number} params.endWidth end width
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeBarChartBound: function(params) {
        return {
            start: tui.util.extend({
                left: params.startLeft,
                width: 0
            }, params.baseBound),
            end: tui.util.extend({
                left: params.endLeft,
                width: params.endWidth
            }, params.baseBound)
        };
    },

    /**
     * To make normal bar chart bound.
     * @param {{
     *      dimension: {width: number, height: number},
     *      groupValues: array.<array.<number>>,
     *      groupSize: number, barSize: number, step: number,
     *      distanceToMin: number, isMinus: boolean
     * }} baseInfo base info
     * @param {number} value value
     * @param {number} paddingTop padding top
     * @param {number} index index
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeNormalBarChartBound: function(baseInfo, value, paddingTop, index) {
        var startLeft, endWidth, bound, baseBound;

        startLeft = baseInfo.distanceToMin + chartConst.SERIES_EXPAND_SIZE;
        endWidth = Math.abs(value * baseInfo.dimension.width);
        baseBound = {
            top: paddingTop + ((baseInfo.step) * index),
            height: baseInfo.barSize
        };
        bound = this._makeBarChartBound({
            baseBound: baseBound,
            startLeft: startLeft,
            endLeft: startLeft + (value < 0 ? -endWidth : 0),
            endWidth: endWidth
        });

        return bound;
    },

    /**
     * To make bounds of normal bar chart.
     * @param {{width: number, height:number}} dimension bar chart dimension
     * @returns {array.<array.<object>>} bounds
     * @private
     */
    _makeNormalBarChartBounds: function(dimension) {
        var baseInfo = this.makeBaseInfoForNormalChartBounds(dimension, 'width', 'height'),
            bounds;

        bounds = tui.util.map(baseInfo.groupValues, function(values, groupIndex) {
            var paddingTop = (baseInfo.groupSize * groupIndex) + baseInfo.additionPadding;
            return tui.util.map(values, function (value, index) {
                return this._makeNormalBarChartBound(baseInfo, value, paddingTop, index);
            }, this);
        }, this);

        return bounds;
    },

    /**
     * To make bounds of stacked bar chart.
     * @param {{width: number, height:number}} dimension bar chart dimension
     * @returns {array.<array.<object>>} bounds
     * @private
     */
    _makeStackedBarChartBounds: function(dimension) {
        var groupValues, groupHeight, barHeight,
            optionHeight, additionPadding, bounds;
        groupValues = this.percentValues;
        groupHeight = (dimension.height / groupValues.length);
        barHeight = groupHeight / 2;
        optionHeight = this._makeOptionSize(barHeight, this.options.barWidth);
        additionPadding = this._makeAdditionPadding(barHeight, optionHeight, 1);
        barHeight = optionHeight || barHeight;
        bounds = tui.util.map(groupValues, function (values, groupIndex) {
            var paddingTop = (groupHeight * groupIndex) + additionPadding,
                endLeft = chartConst.SERIES_EXPAND_SIZE;
            return tui.util.map(values, function (value) {
                var endWidth, baseBound, bound;

                if (value < 0) {
                    return null;
                }

                endWidth = value * dimension.width;
                baseBound = {
                    top: paddingTop,
                    height: optionHeight || barHeight
                };
                bound = this._makeBarChartBound({
                    baseBound: baseBound,
                    startLeft: chartConst.SERIES_EXPAND_SIZE,
                    endLeft: endLeft,
                    endWidth: endWidth
                });

                endLeft = endLeft + endWidth;
                return bound;
            }, this);
        }, this);
        return bounds;
    },


    /**
     * To make bounds of bar chart.
     * @param {{width: number, height:number}} dimension bar chart dimension
     * @returns {array.<array.<object>>} bounds
     * @private
     */
    _makeBounds: function(dimension) {
        if (!this.options.stacked) {
            return this._makeNormalBarChartBounds(dimension);
        } else {
            return this._makeStackedBarChartBounds(dimension);
        }
    },

    /**
     * To make series rendering position
     * @param {obeject} params parameters
     *      @param {number} params.value value
     *      @param {{left: number, top: number, width:number, height: number}} params.bound bound
     *      @param {string} params.formattedValue formatted value
     *      @param {number} params.labelHeight label height
     * @returns {{left: number, top: number}} rendering position
     */
    makeSeriesRenderingPosition: function(params) {
        var labelWidth = renderUtil.getRenderedLabelWidth(params.formattedValue, this.theme.label),
            bound = params.bound,
            left = bound.left,
            top = bound.top + (bound.height - params.labelHeight + chartConst.TEXT_PADDING) / 2;

        if (params.value >= 0) {
            left += bound.width + chartConst.SERIES_LABEL_PADDING;
        } else {
            left -= labelWidth + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * To make sum label html.
     * @param {object} params parameters
     *      @param {array.<number>} params.values values
     *      @param {array.<function>} params.formatFunctions formatting functions
     *      @param {{left: number, top: number}} params.bound bound
     *      @param {number} params.labelHeight label height
     * @returns {string} sum label html
     */
    makeSumLabelHtml: function(params) {
        var sum = this.makeSumValues(params.values, params.formatFunctions),
            bound = params.bound,
            labelHeight = renderUtil.getRenderedLabelHeight(sum, this.theme.label),
            top = bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2),
            left = bound.left + bound.width + chartConst.SERIES_LABEL_PADDING;

        return this.makeSeriesLabelHtml({
            left: left,
            top: top
        }, sum, -1, -1);
    }
});

BarTypeSeriesBase.mixin(BarChartSeries);

module.exports = BarChartSeries;

},{"../const":15,"../helpers/renderUtil":33,"./barTypeSeriesBase":52,"./series":57}],52:[function(require,module,exports){
/**
 * @fileoverview Column chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    renderUtil = require('../helpers/renderUtil');

var BarTypeSeriesBase = tui.util.defineClass(/** @lends BarTypeSeriesBase.prototype */ {
    /**
     * To make series data.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @returns {object} add data
     */
    makeSeriesData: function(bound) {
        var groupBounds = this._makeBounds(bound.dimension);

        this.groupBounds = groupBounds;

        return {
            groupBounds: groupBounds,
            groupValues: this.percentValues
        };
    },

    /**
     * To make bar gutter.
     * @param {number} groupSize bar group size
     * @param {number} itemCount group item count
     * @returns {number} bar gutter
     * @private
     */
    _makeBarGutter: function(groupSize, itemCount) {
        var baseSize = groupSize / (itemCount + 1) / 2,
            gutter;
        if (baseSize <= 2) {
            gutter = 0;
        } else if (baseSize <= 6) {
            gutter = 2;
        } else {
            gutter = 4;
        }
        return gutter;
    },

    /**
     * To make bar size.
     * @param {number} groupSize bar group size
     * @param {number} barGutter bar padding
     * @param {number} itemCount group item count
     * @returns {number} bar size (width or height)
     * @private
     */
    _makeBarSize: function(groupSize, barGutter, itemCount) {
        return (groupSize - (barGutter * (itemCount - 1))) / (itemCount + 1);
    },

    /**
     * To make option size.
     * @param {number} barSize bar size
     * @param {?number} optionBarWidth barWidth option
     * @returns {number} option size
     * @private
     */
    _makeOptionSize: function(barSize, optionBarWidth) {
        var optionsSize = 0;
        if (optionBarWidth) {
            optionsSize = tui.util.min([barSize, optionBarWidth]);
        }
        return optionsSize;
    },

    /**
     * To make addition padding.
     * @param {number} barSize bar size
     * @param {number} optionSize option size
     * @param {number} itemCount item count
     * @returns {number} addition padding
     * @private
     */
    _makeAdditionPadding: function(barSize, optionSize, itemCount) {
        var padding = 0;
        if (optionSize && optionSize < barSize) {
            padding = (barSize - optionSize) * itemCount / 2;
        }
        return (barSize / 2) + padding;
    },

    /**
     * To make base info for normal chart bounds.
     * @param {{width: number, height: number}} dimension series dimension
     * @param {string} sizeType size type (width or height)
     * @param {string} anotherSizeType another size type (width or height)
     * @returns {{
     *      dimension: {width: number, height: number},
     *      groupValues: array.<array.<number>>,
     *      groupSize: number, barSize: number, step: number,
     *      distanceToMin: number, isMinus: boolean
     * }} base info
     */
    makeBaseInfoForNormalChartBounds: function(dimension, sizeType, anotherSizeType) {
        var groupValues = this.percentValues,
            groupSize = dimension[anotherSizeType] / groupValues.length,
            itemCount = groupValues[0] && groupValues[0].length || 0,
            barGutter = this._makeBarGutter(groupSize, itemCount),
            barSize = this._makeBarSize(groupSize, barGutter, itemCount),
            optionSize = this._makeOptionSize(barSize, this.options.barWidth),
            additionPadding = this._makeAdditionPadding(barSize, optionSize, itemCount),
            scaleDistance = this.getScaleDistanceFromZeroPoint(dimension[sizeType], this.data.scale);
        barSize = optionSize || barSize;
        return {
            dimension: dimension,
            groupValues: groupValues,
            groupSize: groupSize,
            barSize: barSize,
            additionPadding: additionPadding,
            step: barSize + barGutter,
            distanceToMin: scaleDistance.toMin,
            isMinus: this.data.scale.min < 0 && this.data.scale.max <= 0
        };
    },

    /**
     * Render normal series label.
     * @param {object} params parameters
     *      @param {HTMLElement} params.container container
     *      @param {array.<array>} params.groupBounds group bounds
     *      @param {array.<array>} params.formattedValues formatted values
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderNormalSeriesLabel: function(params, elSeriesLabelArea) {
        var groupBounds = params.groupBounds,
            formattedValues = params.formattedValues,
            labelHeight = renderUtil.getRenderedLabelHeight(formattedValues[0][0], this.theme.label),
            html;
        html = tui.util.map(params.values, function(values, groupIndex) {
            return tui.util.map(values, function(value, index) {
                var bound, formattedValue, renderingPosition;
                bound = groupBounds[groupIndex][index].end;
                formattedValue = formattedValues[groupIndex][index];
                renderingPosition = this.makeSeriesRenderingPosition({
                    value: value,
                    bound: bound,
                    formattedValue: formattedValue,
                    labelHeight: labelHeight
                });
                return this.makeSeriesLabelHtml(renderingPosition, formattedValue, groupIndex, index);
            }, this).join('');
        }, this).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * To make sum values.
     * @param {array.<number>} values values
     * @param {array.<function>} formatFunctions format functions
     * @returns {number} sum result.
     */
    makeSumValues: function(values, formatFunctions) {
        var sum = tui.util.sum(tui.util.filter(values, function(value) {
                return value > 0;
            })),
            fns = [sum].concat(formatFunctions || []);

        return tui.util.reduce(fns, function(stored, fn) {
            return fn(stored);
        });
    },

    /**
     * To make stacked labels html.
     * @param {object} params parameters
     *      @param {number} params.groupIndex group index
     *      @param {array.<number>} params.values values,
     *      @param {array.<function>} params.formatFunctions formatting functions,
     *      @param {array.<object>} params.bounds bounds,
     *      @param {array} params.formattedValues formatted values,
     *      @param {number} params.labelHeight label height
     * @returns {string} labels html
     * @private
     */
    _makeStackedLabelsHtml: function(params) {
        var values = params.values,
            bound, htmls;

        htmls = tui.util.map(values, function(value, index) {
            var labelWidth, left, top, labelHtml, formattedValue;

            if (value < 0) {
                return '';
            }

            bound = params.bounds[index].end;
            formattedValue = params.formattedValues[index];
            labelWidth = renderUtil.getRenderedLabelWidth(formattedValue, this.theme.label);
            left = bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2);
            top = bound.top + ((bound.height - params.labelHeight + chartConst.TEXT_PADDING) / 2);
            labelHtml = this.makeSeriesLabelHtml({
                left: left,
                top: top
            }, formattedValue, params.groupIndex, index);
            return labelHtml;
        }, this);

        if (this.options.stacked === 'normal' && bound) {
            htmls.push(this.makeSumLabelHtml({
                values: values,
                formatFunctions: params.formatFunctions,
                bound: bound,
                labelHeight: params.labelHeight
            }));
        }
        return htmls.join('');
    },

    /**
     * Render stacked series label.
     * @param {object} params parameters
     *      @param {array.<array>} params.groupBounds group bounds
     *      @param {array.<array>} params.formattedValues formatted values
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderStackedSeriesLabel: function(params, elSeriesLabelArea) {
        var groupBounds = params.groupBounds,
            formattedValues = params.formattedValues,
            formatFunctions = params.formatFunctions || [],
            labelHeight = renderUtil.getRenderedLabelHeight(formattedValues[0][0], this.theme.label),
            html;
        html = tui.util.map(params.values, function(values, index) {
            var labelsHtml = this._makeStackedLabelsHtml({
                groupIndex: index,
                values: values,
                formatFunctions: formatFunctions,
                bounds: groupBounds[index],
                formattedValues: formattedValues[index],
                labelHeight: labelHeight
            });
            return labelsHtml;
        }, this).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Render series label.
     * @param {object} params parameters
     *      @param {array.<array>} params.groupBounds group bounds
     *      @param {array.<array>} params.formattedValues formatted values
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(params, elSeriesLabelArea) {
        if (!this.options.showLabel) {
            return;
        }

        if (this.options.stacked) {
            this._renderStackedSeriesLabel(params, elSeriesLabelArea);
        } else {
            this._renderNormalSeriesLabel(params, elSeriesLabelArea);
        }
    },

    /**
     * Get bound.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @returns {{left: number, top: number}} bound
     * @private
     */
    _getBound: function(groupIndex, index) {
        if (groupIndex === -1 || index === -1) {
            return null;
        }
        return this.groupBounds[groupIndex][index].end;
    }
});

BarTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, BarTypeSeriesBase.prototype);
};

module.exports = BarTypeSeriesBase;

},{"../const":15,"../helpers/renderUtil":33}],53:[function(require,module,exports){
/**
 * @fileoverview Column chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    BarTypeSeriesBase = require('./barTypeSeriesBase'),
    chartConst = require('../const'),
    renderUtil = require('../helpers/renderUtil');

var ColumnChartSeries = tui.util.defineClass(Series, /** @lends ColumnChartSeries.prototype */ {
    /**
     * Column chart series component.
     * @constructs ColumnChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * To make start end tops.
     * @param {number} endTop end top
     * @param {number} endHeight end height
     * @param {number} value value
     * @param {boolean} isMinus whether minus or not
     * @returns {{startTop: number, endTop: number}} start end tops
     * @private
     */
    _makeStartEndTops: function(endTop, endHeight, value) {
        var startTop;
        if (value < 0) {
            startTop = endTop;
        } else {
            startTop = endTop;
            endTop -= endHeight;
        }

        return {
            startTop: startTop,
            endTop: endTop
        };
    },

    /**
     * To make bound of column chart.
     * @param {object} params parameters
     *      @param {{left: number, width: number}} params.baseBound base bound
     *      @param {number} params.startTop start top
     *      @param {number} params.endTop end top
     *      @param {number} params.endHeight end height
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeColumnChartBound: function(params) {
        return {
            start: tui.util.extend({
                top: params.startTop,
                height: 0
            }, params.baseBound),
            end: tui.util.extend({
                top: params.endTop,
                height: params.endHeight
            }, params.baseBound)
        };
    },

    /**
     * To make normal column chart bound.
     * @param {{
     *      dimension: {width: number, height: number},
     *      groupValues: array.<array.<number>>,
     *      groupSize: number, barSize: number, step: number,
     *      distanceToMin: number, isMinus: boolean
     * }} baseInfo base info
     * @param {number} value value
     * @param {number} paddingLeft padding left
     * @param {number} index index
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeNormalColumnChartBound: function(baseInfo, value, paddingLeft, index) {
        var endHeight, endTop, startEndTops, bound;

        endHeight = Math.abs(value * baseInfo.dimension.height);
        endTop = baseInfo.isMinus ? 0 : baseInfo.dimension.height - baseInfo.distanceToMin;
        startEndTops = this._makeStartEndTops(endTop, endHeight, value);
        bound = this._makeColumnChartBound(tui.util.extend({
            baseBound: {
                left: paddingLeft + (baseInfo.step * index) + chartConst.SERIES_EXPAND_SIZE,
                width: baseInfo.barSize
            },
            endHeight: endHeight
        }, startEndTops));
        return bound;
    },

    /**
     * To make bounds of normal column chart.
     * @param {{width: number, height:number}} dimension column chart dimension
     * @returns {array.<array.<object>>} bounds
     * @private
     */
    _makeNormalColumnChartBounds: function(dimension) {
        var baseInfo = this.makeBaseInfoForNormalChartBounds(dimension, 'height', 'width'),
            bounds;

        bounds = tui.util.map(baseInfo.groupValues, function(values, groupIndex) {
            var paddingLeft = (baseInfo.groupSize * groupIndex) + baseInfo.additionPadding;
            return tui.util.map(values, function (value, index) {
                return this._makeNormalColumnChartBound(baseInfo, value, paddingLeft, index);
            }, this);
        }, this);

        return bounds;
    },

    /**
     * To make bounds of stacked column chart.
     * @param {{width: number, height:number}} dimension column chart dimension
     * @returns {array.<array.<object>>} bounds
     * @private
     */
    _makeStackedColumnChartBounds: function(dimension) {
        var groupValues, groupWidth, barWidth,
            optionWidth, additionPadding, bounds;

        groupValues = this.percentValues;
        groupWidth = (dimension.width / groupValues.length);
        barWidth = groupWidth / 2;
        optionWidth = this._makeOptionSize(barWidth, this.options.barWidth);
        additionPadding = this._makeAdditionPadding(barWidth, optionWidth, 1);
        barWidth = optionWidth || barWidth;
        bounds = tui.util.map(groupValues, function(values, groupIndex) {
            var paddingLeft = (groupWidth * groupIndex) + additionPadding + chartConst.SERIES_EXPAND_SIZE,
                top = 0;
            return tui.util.map(values, function (value) {
                var endHeight, baseBound, bound;
                if (value < 0) {
                    return null;
                }

                endHeight = value * dimension.height;
                baseBound = {
                    left: paddingLeft,
                    width: barWidth
                };
                bound = this._makeColumnChartBound({
                    baseBound: baseBound,
                    startTop: dimension.height,
                    endTop: dimension.height - endHeight - top,
                    endHeight: endHeight
                });

                top += endHeight;
                return bound;
            }, this);
        }, this);
        return bounds;
    },

    /**
     * To make bounds of column chart.
     * @param {{width: number, height:number}} dimension column chart dimension
     * @returns {array.<array.<object>>} bounds
     * @private
     */
    _makeBounds: function(dimension) {
        if (!this.options.stacked) {
            return this._makeNormalColumnChartBounds(dimension);
        } else {
            return this._makeStackedColumnChartBounds(dimension);
        }
    },

    /**
     * To make series rendering position
     * @param {obeject} params parameters
     *      @param {number} params.value value
     *      @param {{left: number, top: number, width:number, width:number, height: number}} params.bound bound
     *      @param {string} params.formattedValue formatted value
     *      @param {number} params.labelHeight label height
     * @returns {{left: number, top: number}} rendering position
     */
    makeSeriesRenderingPosition: function(params) {
        var labelWidth = renderUtil.getRenderedLabelWidth(params.formattedValue, this.theme.label),
            bound = params.bound,
            top = bound.top,
            left = bound.left + (bound.width - labelWidth) / 2;

        if (params.value >= 0) {
            top -= params.labelHeight + chartConst.SERIES_LABEL_PADDING;
        } else {
            top += bound.height + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * To make sum label html.
     * @param {object} params parameters
     *      @param {array.<number>} params.values values
     *      @param {array.<function>} params.formatFunctions formatting functions
     *      @param {{left: number, top: number}} params.bound bound
     *      @param {number} params.labelHeight label height
     * @returns {string} sum label html
     */
    makeSumLabelHtml: function(params) {
        var sum = this.makeSumValues(params.values, params.formatFunctions),
            bound = params.bound,
            labelWidth = renderUtil.getRenderedLabelWidth(sum, this.theme.label),
            left = bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2),
            top = bound.top - params.labelHeight - chartConst.SERIES_LABEL_PADDING;

        return this.makeSeriesLabelHtml({
            left: left,
            top: top
        }, sum, -1, -1);
    }
});

BarTypeSeriesBase.mixin(ColumnChartSeries);

module.exports = ColumnChartSeries;

},{"../const":15,"../helpers/renderUtil":33,"./barTypeSeriesBase":52,"./series":57}],54:[function(require,module,exports){
/**
 * @fileoverview Line chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    LineTypeSeriesBase = require('./lineTypeSeriesBase');

var LineChartSeries = tui.util.defineClass(Series, /** @lends LineChartSeries.prototype */ {
    /**
     * Line chart series component.
     * @constructs LineChartSeries
     * @extends Series
     * @mixes LineTypeSeriesBase
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * To make series data.
     * @param {{dimension: {width: number, height: number}}} bound bound
     * @returns {object} series data
     */
    makeSeriesData: function(bound) {
        return {
            groupPositions: this.makePositions(bound.dimension)
        };
    }
});

LineTypeSeriesBase.mixin(LineChartSeries);

module.exports = LineChartSeries;

},{"./lineTypeSeriesBase":55,"./series":57}],55:[function(require,module,exports){
/**
 * @fileoverview LineTypeSeriesBase is base class for line type series.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    renderUtil = require('../helpers/renderUtil');
/**
 * @classdesc LineTypeSeriesBase is base class for line type series.
 * @class LineTypeSeriesBase
 * @mixin
 */
var LineTypeSeriesBase = tui.util.defineClass(/** @lends LineTypeSeriesBase.prototype */ {
    /**
     * To make positions of line chart.
     * @param {{width: number, height:nunber}} dimension line chart dimension
     * @returns {array.<array.<object>>} positions
     */
    makePositions: function(dimension) {
        var groupValues = this.percentValues,
            width = dimension.width,
            height = dimension.height,
            len = groupValues[0].length,
            start = chartConst.SERIES_EXPAND_SIZE,
            step, result;

        if (this.data.aligned) {
            step = width / (len - 1);
        } else {
            step = width / len;
            start += (step / 2);
        }

        result = tui.util.map(groupValues, function(values) {
            return tui.util.map(values, function(value, index) {
                return {
                    left: start + (step * index),
                    top: height - (value * height)
                };
            });
        });
        this.groupPositions = result;
        return result;
    },

    /**
     * Render series label.
     * @param {object} params parameters
     *      @param {HTMLElement} params.container container
     *      @param {array.<array>} params.groupPositions group positions
     *      @param {array.<array>} params.formattedValues formatted values
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(params, elSeriesLabelArea) {
        var groupPositions, labelHeight, html;
        if (!this.options.showLabel) {
            return;
        }
        groupPositions = params.groupPositions;
        labelHeight = renderUtil.getRenderedLabelHeight(params.formattedValues[0][0], this.theme.label);

        html = tui.util.map(params.formattedValues, function(values, groupIndex) {
            return tui.util.map(values, function(value, index) {
                var position = groupPositions[groupIndex][index],
                    labelWidth = renderUtil.getRenderedLabelWidth(value, this.theme.label),
                    labelHtml = this.makeSeriesLabelHtml({
                        left: position.left - (labelWidth / 2),
                        top: position.top - labelHeight - chartConst.SERIES_LABEL_PADDING
                    }, value, index, groupIndex);
                return labelHtml;
            }, this).join('');
        }, this).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Get bound.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @returns {{left: number, top: number}} bound
     * @private
     */
    _getBound: function(groupIndex, index) {
        return this.groupPositions[index][groupIndex];
    },

    /**
     * Find index.
     * @param {number} groupIndex group index
     * @param {number} layerY mouse position
     * @returns {number} index
     * @private
     */
    _findIndex: function(groupIndex, layerY) {
        var foundIndex = -1,
            diff = 1000;

        if (!this.tickItems) {
            this.tickItems = tui.util.pivot(this.groupPositions);
        }

        tui.util.forEach(this.tickItems[groupIndex], function(position, index) {
            var compare = Math.abs(layerY - position.top);
            if (diff > compare) {
                diff = compare;
                foundIndex = index;
            }
        });
        return foundIndex;
    },

    /**
     * Whether changed or not.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChanged: function(groupIndex, index) {
        var prevIndexes = this.prevIndexes;

        this.prevIndexes = {
            groupIndex: groupIndex,
            index: index
        };

        return !prevIndexes || (prevIndexes.groupIndex !== groupIndex) || (prevIndexes.index !== index);
    },

    /**
     * To call showGroupTooltipLine function of graphRenderer.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound bound
     */
    onShowGroupTooltipLine: function(bound) {
        if (!this.graphRenderer.showGroupTooltipLine) {
            return;
        }
        this.graphRenderer.showGroupTooltipLine(bound);
    },

    /**
     * To call hideGroupTooltipLine function of graphRenderer.
     */
    onHideGroupTooltipLine: function() {
        if (!this.graphRenderer.hideGroupTooltipLine) {
            return;
        }
        this.graphRenderer.hideGroupTooltipLine();
    }
});

LineTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, LineTypeSeriesBase.prototype);
};

module.exports = LineTypeSeriesBase;

},{"../const":15,"../helpers/renderUtil":33}],56:[function(require,module,exports){
/**
 * @fileoverview Pie chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    eventListener = require('../helpers/eventListener');

var PieChartSeries = tui.util.defineClass(Series, /** @lends PieChartSeries.prototype */ {
    /**
     * Line chart series component.
     * @constructs PieChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * To make percent value.
     * @param {{values: array, scale: {min: number, max: number}}} data series data
     * @returns {array.<array.<number>>} percent values
     * @private
     */
    _makePercentValues: function(data) {
        var result = tui.util.map(data.values, function(values) {
            var sum = tui.util.sum(values);
            return tui.util.map(values, function(value) {
                return value / sum;
            });
        });
        return result;
    },

    /**
     * To make sectors information.
     * @param {array.<number>} percentValues percent values
     * @param {{cx: number, cy: number, r: number}} circleBound circle bound
     * @returns {array.<object>} sectors information
     * @private
     */
    _makeSectorsInfo: function(percentValues, circleBound) {
        var cx = circleBound.cx,
            cy = circleBound.cy,
            r = circleBound.r,
            angle = 0,
            delta = 10,
            paths;

        paths = tui.util.map(percentValues, function(percentValue) {
            var addAngle = chartConst.ANGLE_360 * percentValue,
                endAngle = angle + addAngle,
                popupAngle = angle + (addAngle / 2),
                angles = {
                    start: {
                        startAngle: angle,
                        endAngle: angle
                    },
                    end: {
                        startAngle: angle,
                        endAngle: endAngle
                    }
                },
                positionData = {
                    cx: cx,
                    cy: cy,
                    angle: popupAngle
                };
            angle = endAngle;
            return {
                percentValue: percentValue,
                angles: angles,
                centerPosition: this._getArcPosition(tui.util.extend({
                    r: (r / 2) + delta
                }, positionData)),
                outerPosition: {
                    start: this._getArcPosition(tui.util.extend({
                        r: r
                    }, positionData)),
                    middle: this._getArcPosition(tui.util.extend({
                        r: r + delta
                    }, positionData))
                }
            };
        }, this);

        return paths;
    },

    /**
     * To make series data.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @returns {{
     *      chartBackground: string,
     *      circleBound: ({cx: number, cy: number, r: number}),
     *      sectorsInfo: array.<object>
     * }} add data for graph rendering
     */
    makeSeriesData: function(bound) {
        var circleBound = this._makeCircleBound(bound.dimension, {
                showLabel: this.options.showLabel,
                legendAlign: this.legendAlign
            }),
            sectorsInfo = this._makeSectorsInfo(this.percentValues[0], circleBound);
        return {
            chartBackground: this.chartBackground,
            circleBound: circleBound,
            sectorsInfo: sectorsInfo
        };
    },

    /**
     * To make circle bound
     * @param {{width: number, height:number}} dimension chart dimension
     * @param {{showLabel: boolean, legendAlign: string}} options options
     * @returns {{cx: number, cy: number, r: number}} circle bounds
     * @private
     */
    _makeCircleBound: function(dimension, options) {
        var width = dimension.width,
            height = dimension.height,
            isSmallPie = predicate.isOuterLegendAlign(options.legendAlign) && options.showLabel,
            radiusRate = isSmallPie ? chartConst.PIE_GRAPH_SMALL_RATE : chartConst.PIE_GRAPH_DEFAULT_RATE,
            diameter = tui.util.multiplication(tui.util.min([width, height]), radiusRate);
        return {
            cx: tui.util.division(width, 2),
            cy: tui.util.division(height, 2),
            r: tui.util.division(diameter, 2)
        };
    },

    /**
     * Get arc position.
     * @param {object} params parameters
     *      @param {number} params.cx center x
     *      @param {number} params.cy center y
     *      @param {number} params.r radius
     *      @param {number} params.angle angle(degree)
     * @returns {{left: number, top: number}} arc position
     * @private
     */
    _getArcPosition: function(params) {
        return {
            left: params.cx + (params.r * Math.sin(params.angle * chartConst.RAD)),
            top: params.cy - (params.r * Math.cos(params.angle * chartConst.RAD))
        };
    },


    /**
     * To make add data for series label.
     * @param {object} seriesData series data
     * @returns {{
     *      container: HTMLElement,
     *      legendLabels: array.<string>,
     *      options: {legendAlign: string, showLabel: boolean},
     *      chartWidth: number,
     *      formattedValues: array
     * }} add data for make series label
     * @private
     */
    _makeSeriesDataForSeriesLabel: function(seriesData) {
        return tui.util.extend({
            legendLabels: this.data.legendLabels,
            options: {
                legendAlign: this.legendAlign,
                showLabel: this.options.showLabel
            },
            chartWidth: this.data.chartWidth,
            formattedValues: this.data.formattedValues[0]
        }, seriesData);
    },

    /**
     * To render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     * @override
     */
    _renderGraph: function(dimension, seriesData) {
        var funcShowTooltip = tui.util.bind(this.showTooltip, this, {
                allowNegativeTooltip: !!this.allowNegativeTooltip,
                chartType: this.chartType
            }),
            callbacks = {
                funcShowTooltip: funcShowTooltip,
                funcHideTooltip: tui.util.bind(this.hideTooltip, this),
                funcSelectSeries: tui.util.bind(this.selectSeries, this)
            },
            params = this._makeParamsForGraphRendering(dimension, seriesData);

        this.graphRenderer.render(this.elSeriesArea, params, callbacks);

        // series label mouse event   
        this.showTooltip = funcShowTooltip;
    },

    /**
     * To render series component of pie chart.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @param {object} data data for rendering
     * @returns {HTMLElement} series element
     * @override
     */
    render: function() {
        var el = Series.prototype.render.apply(this, arguments);
        this.attachEvent(el);

        return el;
    },

    /**
     * showTooltip is mouseover event callback on series graph.
     * @param {object} params parameters
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {{clientX: number, clientY: number}} eventPosition mouse event position
     */
    showTooltip: function(params, bound, groupIndex, index, eventPosition) {
        this.fire('showTooltip', tui.util.extend({
            indexes: {
                groupIndex: groupIndex,
                index: index
            },
            bound: bound,
            eventPosition: eventPosition
        }, params));
    },

    /**
     * hideTooltip is mouseout event callback on series graph.
     * @param {string} id tooltip id
     */
    hideTooltip: function() {
        this.fire('hideTooltip');
    },

    /**
     * To make series data by selection.
     * @param {number} index index
     * @returns {{indexes: {index: number, groupIndex: number}}} series data
     * @private
     */
    _makeSeriesDataBySelection: function(index) {
        return {
            indexes: {
                index: index,
                groupIndex: index
            }
        };
    },

    /**
     * selectSeries is click event callback on series graph.
     * @param {number} index index
     */
    selectSeries: function(index) {
        var seriesData = this._makeSeriesDataBySelection(index);
        if (this.selectedIndex === index) {
            this.onUnselectSeries(seriesData);
            delete this.selectedIndex;
        } else {
            if (!tui.util.isUndefined(this.selectedIndex)) {
                this.onUnselectSeries(this._makeSeriesDataBySelection(this.selectedIndex));
            }
            this.onSelectSeries(seriesData);
            this.selectedIndex = index;
        }
    },

    /**
     * Get series label.
     * @param {object} params parameters
     *      @param {string} params.legend legend
     *      @param {string} params.label label
     *      @param {string} params.separator separator
     *      @param {{legendAlign: ?string, showLabel: boolean}} params.options options
     * @returns {string} series label
     * @private
     */
    _getSeriesLabel: function(params) {
        var seriesLabel = '';
        if (params.options.legendAlign) {
            seriesLabel = '<span class="tui-chart-series-legend">' + params.legend + '</span>';
        }

        if (params.options.showLabel) {
            seriesLabel += (seriesLabel ? params.separator : '') + params.label;
        }

        return seriesLabel;
    },

    /**
     * Render center legend.
     * @param {object} params parameters
     *      @param {array.<object>} params.positions positions
     *      @param {array.<string>} params.legends legendLabels
     *      @param {array.<string>} params.formattedValues formatted values
     *      @param {string} params.separator separator
     *      @param {object} params.options options
     *      @param {function} params.funcMoveToPosition function
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderLegendLabel: function(params, elSeriesLabelArea) {
        var positions = params.positions,
            formattedValues = params.formattedValues,
            html;
        html = tui.util.map(params.legendLabels, function(legend, index) {
            var label = this._getSeriesLabel({
                    legend: legend,
                    label: formattedValues[index],
                    separator: params.separator,
                    options: params.options
                }),
                position = params.funcMoveToPosition(positions[index], label);
            return this.makeSeriesLabelHtml(position, label, 0, index);
        }, this).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Move to center position.
     * @param {{left: number, top: number}} position position
     * @param {string} label label
     * @returns {{left: number, top: number}} center position
     * @private
     */
    _moveToCenterPosition: function(position, label) {
        var left = position.left - (renderUtil.getRenderedLabelWidth(label, this.theme.label) / 2),
            top = position.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);
        return {
            left: left,
            top: top
        };
    },

    /**
     * Render center legend.
     * @param {object} params parameters
     *      @param {object} params.sectorsInfo sector info
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderCenterLegend: function(params, elSeriesLabelArea) {
        this._renderLegendLabel(tui.util.extend({
            positions: tui.util.pluck(params.sectorsInfo, 'centerPosition'),
            funcMoveToPosition: tui.util.bind(this._moveToCenterPosition, this),
            separator: '<br>'
        }, params), elSeriesLabelArea);
    },

    /**
     * Add end position.
     * @param {number} centerLeft center left
     * @param {array.<object>} positions positions
     * @private
     */
    _addEndPosition: function(centerLeft, positions) {
        tui.util.forEach(positions, function(position) {
            var end = tui.util.extend({}, position.middle);
            if (end.left < centerLeft) {
                end.left -= chartConst.SERIES_OUTER_LABEL_PADDING;
            } else {
                end.left += chartConst.SERIES_OUTER_LABEL_PADDING;
            }
            position.end = end;
        });
    },

    /**
     * Move to outer position.
     * @param {number} centerLeft center left
     * @param {object} position position
     * @param {string} label label
     * @returns {{left: number, top: number}} outer position
     * @private
     */
    _moveToOuterPosition: function(centerLeft, position, label) {
        var positionEnd = position.end,
            left = positionEnd.left,
            top = positionEnd.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);

        if (left < centerLeft) {
            left -= renderUtil.getRenderedLabelWidth(label, this.theme.label) + chartConst.SERIES_LABEL_PADDING;
        } else {
            left += chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * Render outer legend.
     * @param {object} params parameters
     *      @param {object} params.sectorsInfo sector info
     *      @param {number} params.chartWidth chart width
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderOuterLegend: function(params, elSeriesLabelArea) {
        var outerPositions = tui.util.pluck(params.sectorsInfo, 'outerPosition'),
            centerLeft = params.chartWidth / 2;
        this._addEndPosition(centerLeft, outerPositions);
        this._renderLegendLabel(tui.util.extend({
            positions: outerPositions,
            funcMoveToPosition: tui.util.bind(this._moveToOuterPosition, this, centerLeft),
            separator: ':&nbsp;'
        }, params), elSeriesLabelArea);
        this.graphRenderer.renderLegendLines(outerPositions);
    },

    /**
     * Render series label.
     * @param {object} params parameters
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(params, elSeriesLabelArea) {
        var legendAlign = params.options.legendAlign;
        if (predicate.isOuterLegendAlign(legendAlign)) {
            this._renderOuterLegend(params, elSeriesLabelArea);
        } else if (predicate.isCenterLegendAlign(legendAlign)) {
            this._renderCenterLegend(params, elSeriesLabelArea);
        }
    },

    /**
     * Get bound.
     * @returns {null} bound
     * @private
     */
    _getBound: function() {
        return null;
    },

    /**
     * Animate showing about series label area.
     * @override
     */
    animateShowingAboutSeriesLabelArea: function() {
        this.graphRenderer.animateLegendLines();
        Series.prototype.animateShowingAboutSeriesLabelArea.call(this);
    },

    /**
     * Show series label area.
     * @param {object} seriesData series data
     * @override
     */
    showSeriesLabelArea: function(seriesData) {
        var outerPositions = tui.util.pluck(seriesData.sectorsInfo, 'outerPosition'),
            centerLeft = this.data.chartWidth / 2;
        this._addEndPosition(centerLeft, outerPositions);
        this.graphRenderer.moveLegendLines(outerPositions);
        Series.prototype.showSeriesLabelArea.call(this);
    },

    /**
     * To handle mouse event.
     * @param {MouseEvent} e mouse event
     * @param {function} callback callback
     * @private
     */
    _handleMouseEvent: function(e, callback) {
        var elTarget = e.target || e.srcElement,
            elLabel = this._findLabelElement(elTarget),
            groupIndex, index;

        if (!elLabel) {
            return;
        }

        groupIndex = parseInt(elLabel.getAttribute('data-group-index'), 10);
        index = parseInt(elLabel.getAttribute('data-index'), 10);

        if (groupIndex === -1 || index === -1) {
            return;
        }

        callback(groupIndex, index, elTarget);
    },

    /**
     * Find legend element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} legend element
     * @private
     */
    _findLegendElement: function(elTarget) {
        var elLegend;
        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_SERIES_LEGEND)) {
            elLegend = elTarget;
        }

        return elLegend;
    },

    /**
     * On click event handler.
     * @param {MouseEvent} e mouse event
     * @override
     */
    onClick: function(e) {
        var that = this;
        this._handleMouseEvent(e, function(groupIndex, index, elTarget) {
            var elLegend = that._findLegendElement(elTarget),
                legendData;

            if (!elLegend) {
                that.selectSeries(index);
            } else {
                legendData = that.data.joinLegendLabels[index];
                that.userEvent.fire('selectLegend', {
                    legend: legendData.label,
                    chartType: legendData.chartType,
                    legendIndex: index,
                    index: index
                });
            }
        });
    },

    /**
     * This is event handler for mouseover.
     * @param {MouseEvent} e mouse event
     */
    onMouseover: function(e) {
        var that = this;
        this._handleMouseEvent(e, function(groupIndex, index) {
            var bound = that._getBound(groupIndex, index) || that._makeLabelBound(e.clientX, e.clientY - 10);
            that.showTooltip(bound, groupIndex, index);
        });
    },

    /**
     * This is event handler for mouseout.
     * @param {MouseEvent} e mouse event
     */
    onMouseout: function(e) {
        var that = this;
        this._handleMouseEvent(e, function(groupIndex, index) {
            that.hideTooltip(groupIndex, index);
        });
    },

    /**
     * Attach event
     * @param {HTMLElement} el target element
     */
    attachEvent: function(el) {
        eventListener.bindEvent('click', el, tui.util.bind(this.onClick, this));
        eventListener.bindEvent('mouseover', el, tui.util.bind(this.onMouseover, this));
        eventListener.bindEvent('mouseout', el, tui.util.bind(this.onMouseout, this));
    }
});

tui.util.CustomEvents.mixin(PieChartSeries);

module.exports = PieChartSeries;

},{"../const":15,"../helpers/domHandler":30,"../helpers/eventListener":31,"../helpers/predicate":32,"../helpers/renderUtil":33,"./series":57}],57:[function(require,module,exports){
/**
 * @fileoverview Series base component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var seriesTemplate = require('./seriesTemplate'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    pluginFactory = require('../factories/pluginFactory');

var Series = tui.util.defineClass(/** @lends Series.prototype */ {
    /**
     * Series base component.
     * @constructs Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function(params) {
        var libType;

        tui.util.extend(this, params);
        libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, params.chartType);

        /**
         * Series view className
         * @type {string}
         */
        this.className = 'tui-chart-series-area';
    },

    /**
     * To make series data.
     * @returns {object} add data
     */
    makeSeriesData: function() {
        return {};
    },

    /**
     * Get seriesData
     * @returns {object} series data
     */
    getSeriesData: function() {
        return this.seriesData;
    },

    /**
     * Render series label.
     * @private
     * @abstract
     */
    _renderSeriesLabel: function() {},

    /**
     * Set base data.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @param {object} data data for rendering
     * @private
     */
    _setBaseData: function(bound, data) {
        this.data = tui.util.extend(this.data, data);
        this.bound = bound;
        this.percentValues = this._makePercentValues(this.data, this.options.stacked);
    },

    /**
     * To render series label area
     * @param {{width: number, height: number}} dimension series dimension
     * @param {object} seriesData series data
     * @param {?HTMLElement} elSeriesLabelArea series label area element
     * @returns {HTMLElement} series label area element
     * @private
     */
    _renderSeriesLabelArea: function(dimension, seriesData, elSeriesLabelArea) {
        var addDataForSeriesLabel = this._makeSeriesDataForSeriesLabel(seriesData, dimension);
        if (!elSeriesLabelArea) {
            elSeriesLabelArea = dom.create('div', 'tui-chart-series-label-area');
        }

        this._renderSeriesLabel(addDataForSeriesLabel, elSeriesLabelArea);
        return elSeriesLabelArea;
    },

    /**
     * To render series area.
     * @param {HTMLElement} elSeriesArea series area element
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @param {object} data data for rendering
     * @param {function} funcRenderGraph function for graph rendering
     * @private
     */
    _renderSeriesArea: function(elSeriesArea, bound, data, funcRenderGraph) {
        var expandedBound, seriesData, elSeriesLabelArea;

        this._setBaseData(bound, data);

        expandedBound = renderUtil.expandBound(bound);
        this.seriesData = seriesData = this.makeSeriesData(bound);

        renderUtil.renderDimension(elSeriesArea, expandedBound.dimension);
        this._renderPosition(elSeriesArea, expandedBound.position, this.chartType);
        funcRenderGraph(expandedBound.dimension, seriesData);

        elSeriesLabelArea = this._renderSeriesLabelArea(expandedBound.dimension, seriesData, this.elSeriesLabelArea);

        if (!this.elSeriesLabelArea) {
            this.elSeriesLabelArea = elSeriesLabelArea;
            dom.append(elSeriesArea, elSeriesLabelArea);
        }
    },

    /**
     * To make parameters for graph rendering.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @returns {object} parameters for graph rendering
     * @private
     */
    _makeParamsForGraphRendering: function(dimension, seriesData) {
        return tui.util.extend({
            dimension: dimension,
            chartType: this.chartType,
            theme: this.theme,
            options: this.options
        }, seriesData);
    },

    /**
     * To render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     */
    _renderGraph: function(dimension, seriesData) {
        var params = this._makeParamsForGraphRendering(dimension, seriesData);
        this.graphRenderer.render(this.elSeriesArea, params);
    },

    /**
     * To render series component.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @param {object} data data for rendering
     * @returns {HTMLElement} series element
     */
    render: function(bound, data) {
        var el = dom.create('DIV', this.className);

        this.elSeriesArea = el;

        this._renderSeriesArea(el, bound, data, tui.util.bind(this._renderGraph, this));

        return el;
    },

    /**
     * To resize raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     */
    _resizeGraph: function(dimension, seriesData) {
        this.graphRenderer.resize(tui.util.extend({
            dimension: dimension
        }, seriesData));
        this.showSeriesLabelArea(seriesData);
    },

    /**
     * To resize series component.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @param {object} data data for rendering
     */
    resize: function(bound, data) {
        var el = this.elSeriesArea;

        this._renderSeriesArea(el, bound, data, tui.util.bind(this._resizeGraph, this));
    },

    /**
     * To make add data for series label.
     * @param {object} seriesData series data
     * @param {{width: number, height: number}} dimension dimension
     * @returns {{
     *      container: HTMLElement,
     *      values: array.<array>,
     *      formattedValues: array.<array>,
     *      formatFunctions: array.<function>,
     *      dimension: {width: number, height: number}
     * }} add data for series label
     * @private
     */
    _makeSeriesDataForSeriesLabel: function(seriesData, dimension) {
        return tui.util.extend({
            values: this.data.values,
            formattedValues: this.data.formattedValues,
            formatFunctions: this.data.formatFunctions,
            dimension: dimension
        }, seriesData);
    },

    /**
     * Render bounds
     * @param {HTMLElement} el series element
     * @param {{top: number, left: number}} position series position
     * @private
     */
    _renderPosition: function(el, position) {
        var hiddenWidth = renderUtil.isOldBrowser() ? chartConst.HIDDEN_WIDTH : 0;
        renderUtil.renderPosition(el, {
            top: position.top - (hiddenWidth * 2),
            left: position.left - hiddenWidth
        });
    },

    /**
     * To make percent value.
     * @param {{values: array, scale: {min: number, max: number}}} data series data
     * @param {string} stacked stacked option
     * @returns {array.<array.<number>>} percent values
     * @private
     */
    _makePercentValues: function(data, stacked) {
        var result;
        if (stacked === chartConst.STACKED_NORMAL_TYPE) {
            result = this._makeNormalStackedPercentValues(data);
        } else if (stacked === chartConst.STACKED_PERCENT_TYPE) {
            result = this._makePercentStackedPercentValues(data);
        } else {
            result = this._makeNormalPercentValues(data);
        }

        return result;
    },

    /**
     * To make percent values about normal stacked option.
     * @param {{values: array, scale: {min: number, max: number}}} data series data
     * @returns {array} percent values about normal stacked option.
     * @private
     */
    _makeNormalStackedPercentValues: function(data) {
        var min = data.scale.min,
            max = data.scale.max,
            distance = max - min,
            percentValues = tui.util.map(data.values, function(values) {
                var plusValues = tui.util.filter(values, function(value) {
                        return value > 0;
                    }),
                    sum = tui.util.sum(plusValues),
                    groupPercent = (sum - min) / distance;
                return tui.util.map(values, function(value) {
                    return value === 0 ? 0 : groupPercent * (value / sum);
                });
            });
        return percentValues;
    },

    /**
     * To make percent values about percent stacked option.
     * @param {{values: array, scale: {min: number, max: number}}} data series data
     * @returns {array} percent values about percent stacked option
     * @private
     */
    _makePercentStackedPercentValues: function(data) {
        var percentValues = tui.util.map(data.values, function(values) {
            var plusValues = tui.util.filter(values, function(value) {
                    return value > 0;
                }),
                sum = tui.util.sum(plusValues);
            return tui.util.map(values, function(value) {
                return value === 0 ? 0 : value / sum;
            });
        });
        return percentValues;
    },

    /**
     * To make normal percent value.
     * @param {{values: array, scale: {min: number, max: number}}} data series data
     * @returns {array.<array.<number>>} percent values
     * @private
     */
    _makeNormalPercentValues: function(data) {
        var min = data.scale.min,
            max = data.scale.max,
            distance = max - min,
            isLineTypeChart = predicate.isLineTypeChart(this.chartType),
            flag = 1,
            subValue = 0,
            percentValues;

        if (!isLineTypeChart && min < 0 && max <= 0) {
            flag = -1;
            subValue = max;
            distance = min - max;
        } else if (isLineTypeChart || min >= 0) {
            subValue = min;
        }

        percentValues = tui.util.map(data.values, function(values) {
            return tui.util.map(values, function(value) {
                return (value - subValue) * flag / distance;
            });
        });

        return percentValues;
    },

    /**
     * Get scale distance from zero point.
     * @param {number} size chart size (width or height)
     * @param {{min: number, max: number}} scale scale
     * @returns {{toMax: number, toMin: number}} pixel distance
     */
    getScaleDistanceFromZeroPoint: function(size, scale) {
        var min = scale.min,
            max = scale.max,
            distance = max - min,
            toMax = 0,
            toMin = 0;

        if (min < 0 && max > 0) {
            toMax = (distance + min) / distance * size;
            toMin = (distance - max) / distance * size;
        }

        return {
            toMax: toMax,
            toMin: toMin
        };
    },

    /**
     * To make label bound.
     * @param {number} clientX clientX
     * @param {number} clientY clientY
     * @returns {{left: number, top: number}} bound
     * @private
     */
    _makeLabelBound: function(clientX, clientY) {
        return {
            left: clientX - this.bound.position.left,
            top: clientY - this.bound.position.top
        };
    },

    /**
     * Find label element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} label element
     * @private
     */
    _findLabelElement: function(elTarget) {
        var elLabel = null;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_SERIES_LABEL)) {
            elLabel = elTarget;
        } else {
            elLabel = dom.findParentByClass(elTarget, chartConst.CLASS_NAME_SERIES_LABEL);
        }

        return elLabel;
    },

    /**
     * To call showAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} data data
     */
    onShowAnimation: function(data) {
        if (!this.graphRenderer.showAnimation) {
            return;
        }
        this.graphRenderer.showAnimation(data);
    },

    /**
     * To call hideAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} data data
     */
    onHideAnimation: function(data) {
        if (!this.graphRenderer.hideAnimation) {
            return;
        }
        this.graphRenderer.hideAnimation(data);
    },

    /**
     * To call showGroupAnimation function of graphRenderer.
     * @param {number} index index
     */
    onShowGroupAnimation: function(index) {
        if (!this.graphRenderer.showGroupAnimation) {
            return;
        }
        this.graphRenderer.showGroupAnimation(index);
    },

    /**
     * To call hideGroupAnimation function of graphRenderer.
     * @param {number} index index
     */
    onHideGroupAnimation: function(index) {
        if (!this.graphRenderer.hideGroupAnimation) {
            return;
        }
        this.graphRenderer.hideGroupAnimation(index);
    },

    /**
     * Animate component.
     */
    animateComponent: function() {
        if (this.graphRenderer.animate) {
            this.graphRenderer.animate(tui.util.bind(this.animateShowingAboutSeriesLabelArea, this));
        }
    },

    /**
     * To make html about series label.
     * @param {{left: number, top: number}} position position
     * @param {string} value value
     * @param {number} groupIndex group index
     * @param {number} index index
     * @returns {string} html string
     */
    makeSeriesLabelHtml: function(position, value, groupIndex, index) {
        var cssObj = tui.util.extend(position, this.theme.label);
        return seriesTemplate.tplSeriesLabel({
            cssText: seriesTemplate.tplCssText(cssObj),
            value: value,
            groupIndex: groupIndex,
            index: index
        });
    },

    /**
     * Show series label area.
     */
    showSeriesLabelArea: function() {
        if (renderUtil.isOldBrowser()) {
            this.elSeriesLabelArea.style.filter = 'alpha(opacity=' + 100 + ')';
        } else {
            this.elSeriesLabelArea.style.opacity = 1;
        }
        dom.addClass(this.elSeriesLabelArea, 'show');
    },

    /**
     * Animate showing about series label area.
     */
    animateShowingAboutSeriesLabelArea: function() {
        if ((!this.options.showLabel && !this.legendAlign) || !this.elSeriesLabelArea) {
            return;
        }

        dom.addClass(this.elSeriesLabelArea, 'show');

        (new tui.component.Effects.Fade({
            element: this.elSeriesLabelArea,
            duration: 300
        })).action({
            start: 0,
            end: 1,
            complete: function() {}
        });
    },

    /**
     * To make exportation data for series type userEvent.
     * @param {object} seriesData series data
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} export data
     * @private
     */
    _makeExportationSeriesData: function(seriesData) {
        var legendIndex = seriesData.indexes.index,
            legendData = this.data.joinLegendLabels[legendIndex];
        return {
            chartType: legendData.chartType,
            legend: legendData.label,
            legendIndex: legendIndex,
            index: seriesData.indexes.groupIndex
        };
    },

    /**
     * To call selectSeries callback of userEvent.
     * @param {object} seriesData series data
     */
    onSelectSeries: function(seriesData) {
        this.userEvent.fire('selectSeries', this._makeExportationSeriesData(seriesData));
        if (this.options.hasSelection) {
            this.graphRenderer.selectSeries(seriesData.indexes);
        }
    },

    /**
     * To call unselectSeries callback of userEvent.
     * @param {object} seriesData series data.
     */
    onUnselectSeries: function(seriesData) {
        this.userEvent.fire('unselectSeries', seriesData.indexes);
        if (this.options.hasSelection) {
            this.graphRenderer.unselectSeries(seriesData.indexes);
        }
    }
});

module.exports = Series;

},{"../const":15,"../factories/pluginFactory":24,"../helpers/domHandler":30,"../helpers/predicate":32,"../helpers/renderUtil":33,"./seriesTemplate":58}],58:[function(require,module,exports){
/**
 * @fileoverview This is templates of series.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_SERIES_LABEL: '<div class="tui-chart-series-label" style="{{ cssText }}" data-group-index="{{ groupIndex }}" data-index="{{ index }}">{{ value }}</div>',
    TEXT_CSS_TEXT: 'left:{{ left }}px;top:{{ top }}px;font-family:{{ fontFamily }};font-size:{{ fontSize }}px'
};

module.exports = {
    tplSeriesLabel: templateMaker.template(tags.HTML_SERIES_LABEL),
    tplCssText: templateMaker.template(tags.TEXT_CSS_TEXT)
};

},{"../helpers/templateMaker":34}],59:[function(require,module,exports){
var DEFAULT_COLOR = '#000000',
    DEFAULT_BACKGROUND = '#ffffff',
    EMPTY = '',
    DEFAULT_AXIS = {
        tickColor: DEFAULT_COLOR,
        title: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        },
        label: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        }
    };

var defaultTheme = {
    chart: {
        background: DEFAULT_BACKGROUND,
        fontFamily: 'Verdana'
    },
    title: {
        fontSize: 18,
        fontFamily: EMPTY,
        color: DEFAULT_COLOR
    },
    yAxis: DEFAULT_AXIS,
    xAxis: DEFAULT_AXIS,
    plot: {
        lineColor: '#dddddd',
        background: '#ffffff'
    },
    series: {
        label: {
            fontSize: 11,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        },
        colors: ['#ac4142', '#d28445', '#f4bf75', '#90a959', '#75b5aa', '#6a9fb5', '#aa759f', '#8f5536'],
        borderColor: EMPTY,
        selectionColor: EMPTY
    },
    legend: {
        label: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        }
    },
    tooltip: {}
};

module.exports = defaultTheme;

},{}],60:[function(require,module,exports){
/**
 * @fileoverview Group tooltip component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var TooltipBase = require('./tooltipBase'),
    GroupTooltipPositionModel = require('./groupTooltipPositionModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    defaultTheme = require('../themes/defaultTheme'),
    tooltipTemplate = require('./tooltipTemplate');

var GroupTooltip = tui.util.defineClass(TooltipBase, /** @lends GroupTooltip.prototype */ {
    /**
     * Group tooltip component.
     * @constructs GroupTooltip
     * @param {object} params parameters
     *      @param {array.<number>} params.values converted values
     *      @param {array} params.labels labels
     *      @param {array} params.legendLabels legend labels
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        TooltipBase.call(this, params);
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (this.options.align) {
            return;
        }

        if (this.isVertical) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION;
        } else {
            this.options.align = chartConst.TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION;
        }
    },

    /**
     * To render tooltip component.
     * @param {{position: object}} bound tooltip bound
     * @param {?{seriesPosition: {left: number, top: number}}} data rendering data
     * @returns {HTMLElement} tooltip element
     * @override
     */
    render: function(bound, data) {
        var el = TooltipBase.prototype.render.call(this, bound, data);

        this.positionModel = new GroupTooltipPositionModel(this.chartDimension, bound, this.isVertical, this.options);
        return el;
    },

    /**
     * To make tooltip data.
     * @returns {array.<object>} tooltip data
     * @override
     */
    makeTooltipData: function() {
        return tui.util.map(this.joinFormattedValues, function(values, index) {
            return {
                category: this.labels[index],
                values: values
            };
        }, this);
    },

    /**
     * To make colors.
     * @param {array.<string>} legendLabels legend labels
     * @param {object} theme tooltip theme
     * @returns {array.<string>} colors
     * @private
     */
    _makeColors: function(legendLabels, theme) {
        var colorIndex = 0,
            defaultColors, colors, prevChartType;
        if (theme.colors) {
            return theme.colors;
        }

        defaultColors = defaultTheme.series.colors.slice(0, legendLabels.length);

        return tui.util.map(tui.util.pluck(legendLabels, 'chartType'), function(chartType) {
            var color;
            if (prevChartType !== chartType) {
                colors = theme[chartType] ? theme[chartType].colors : defaultColors;
                colorIndex = 0;
            }
            prevChartType = chartType;
            color = colors[colorIndex];
            colorIndex += 1;
            return color;
        });
    },

    /**
     * To make tooltip html.
     * @param {number} groupIndex group index
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(groupIndex) {
        var item = this.data[groupIndex],
            template = tooltipTemplate.tplGroupItem,
            cssTextTemplate = tooltipTemplate.tplGroupCssText,
            colors = this._makeColors(this.joinLegendLabels, this.theme),
            itemsHtml;

        itemsHtml = tui.util.map(item.values, function(value, index) {
            var legendLabel = this.joinLegendLabels[index];
            return template({
                value: value,
                legend: legendLabel.label,
                chartType: legendLabel.chartType,
                cssText: cssTextTemplate({color: colors[index]}),
                suffix: this.suffix
            });
        }, this).join('');

        return tooltipTemplate.tplGroup({
            category: item.category,
            items: itemsHtml
        });
    },

    /**
     * Get tooltip sector element.
     * @returns {HTMLElement} sector element
     * @private
     */
    _getTooltipSectorElement: function() {
        var elTooltipSector;
        if (!this.elTooltipSector) {
            this.elTooltipSector = elTooltipSector = dom.create('DIV', 'tui-chart-group-tooltip-sector');
            dom.append(this.elTooltipArea, elTooltipSector);
        }
        return this.elTooltipSector;
    },

    /**
     * To make bound about tooltip sector of vertical type chart.
     * @param {number} height height
     * @param {{start: number, end: number}} range range
     * @param {boolean} isLine whether line or not
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeVerticalTooltipSectorBound: function(height, range, isLine) {
        var width;
        if (isLine) {
            width = 1;
            height += 6;
        } else {
            width = range.end - range.start;
        }
        return {
            dimension: {
                width: width,
                height: height
            },
            position: {
                left: range.start + chartConst.SERIES_EXPAND_SIZE,
                top: 0
            }
        };
    },

    /**
     * To make bound about tooltip sector of horizontal type chart.
     * @param {number} width width
     * @param {{start: number, end:number}} range range
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeHorizontalTooltipSectorBound: function(width, range) {
        return {
            dimension: {
                width: width,
                height: range.end - range.start + chartConst.HIDDEN_WIDTH
            },
            position: {
                left: chartConst.SERIES_EXPAND_SIZE - chartConst.HIDDEN_WIDTH,
                top: range.start
            }
        };
    },

    /**
     * To make bound about tooltip sector.
     * @param {number} size width or height
     * @param {{start: number, end:number}} range range
     * @param {boolean} isVertical whether vertical or not
     * @param {boolean} isLine whether line type or not
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeTooltipSectorBound: function(size, range, isVertical, isLine) {
        var bound;
        if (isVertical) {
            bound = this._makeVerticalTooltipSectorBound(size, range, isLine);
        } else {
            bound = this._makeHorizontalTooltipSectorBound(size, range);
        }
        return bound;
    },

    /**
     * Show tooltip sector.
     * @param {number} size width or height
     * @param {{start: number, end:number}} range range
     * @param {boolean} isVertical whether vertical or not
     * @param {number} index index
     * @private
     */
    _showTooltipSector: function(size, range, isVertical, index) {
        var elTooltipSector = this._getTooltipSectorElement(),
            isLine = (range.start === range.end),
            bound = this._makeTooltipSectorBound(size, range, isVertical, isLine);
        if (isLine) {
            this.fire('showGroupTooltipLine', bound);
        } else {
            renderUtil.renderDimension(elTooltipSector, bound.dimension);
            renderUtil.renderPosition(elTooltipSector, bound.position);
            dom.addClass(elTooltipSector, 'show');
        }

        this.fire('showGroupAnimation', index);
    },

    /**
     * Hide tooltip sector.
     * @param {number} index index
     * @private
     */
    _hideTooltipSector: function(index) {
        var elTooltipSector = this._getTooltipSectorElement();
        dom.removeClass(elTooltipSector, 'show');
        this.fire('hideGroupAnimation', index);
        this.fire('hideGroupTooltipLine');
    },

    /**
     * Show tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{index: number, range: {start: number, end: number},
     *          size: number, direction: string, isVertical: boolean
     *        }} params coordinate event parameters
     * @param {{left: number, top: number}} prevPosition prev position
     */
    showTooltip: function(elTooltip, params, prevPosition) {
        var dimension, position;

        if (!tui.util.isUndefined(this.prevIndex)) {
            this.fire('hideGroupAnimation', this.prevIndex);
        }
        elTooltip.innerHTML = this._makeTooltipHtml(params.index);

        this._fireBeforeShowTooltip(params.index, params.range);

        dom.addClass(elTooltip, 'show');

        this._showTooltipSector(params.size, params.range, params.isVertical, params.index);

        dimension = this.getTooltipDimension(elTooltip);
        position = this.positionModel.calculatePosition(dimension, params.range);
        this.moveToPosition(elTooltip, position, prevPosition);

        this._fireAfterShowTooltip(params.index, params.range, {
            element: elTooltip,
            position: position
        });

        this.prevIndex = params.index;
    },

    /**
     * To call beforeShowTooltip callback of userEvent.
     * @param {number} index index
     * @param {{start: number, end: number}} range range
     * @private
     */
    _fireBeforeShowTooltip: function(index, range) {
        this.userEvent.fire('beforeShowTooltip', {
            index: index,
            range: range
        });
    },

    /**
     * To call afterShowTooltip callback of userEvent.
     * @param {number} index index
     * @param {{start: number, end: number}} range range
     * @param {object} additionParams addition parameters
     * @private
     */
    _fireAfterShowTooltip: function(index, range, additionParams) {
        this.userEvent.fire('afterShowTooltip', tui.util.extend({
            index: index,
            range: range
        }, additionParams));
    },

    /**
     * Hide tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {number} index index
     */
    hideTooltip: function(elTooltip, index) {
        delete this.prevIndex;
        this._hideTooltipSector(index);
        this.hideAnimation(elTooltip);
    }
});

tui.util.CustomEvents.mixin(GroupTooltip);

module.exports = GroupTooltip;

},{"../const":15,"../helpers/domHandler":30,"../helpers/renderUtil":33,"../themes/defaultTheme":59,"./groupTooltipPositionModel":61,"./tooltipBase":63,"./tooltipTemplate":64}],61:[function(require,module,exports){
/**
 * @fileoverview GroupTooltipPositionModel is position model for group tooltip..
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

var GroupTooltipPositionModel = tui.util.defineClass(/** @lends GroupTooltipPositionModel.prototype */ {
    /**
     * GroupTooltipPositionModel is position model for group tooltip.
     * @constructs GroupTooltipPositionModel
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {boolean} isVertical whether vertical or not
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     */
    init: function(chartDimension, areaBound, isVertical, options) {
        /**
         * chart dimension
         * @type {{width: number, height: number}}
         */
        this.chartDimension = chartDimension;

        /**
         * tooltip area bound
         * @type {{dimension: {width: number, height: number}, position: {left: number, top: number}}}
         */
        this.areaBound = areaBound;

        /**
         * Whether vertical or not
         * @type {boolean}
         */
        this.isVertical = isVertical;

        /**
         * tooltip options
         * @type {{align: ?string, position: {left: number, top: number}}}
         */
        this.options = options;

        /**
         * For caching
         * @type {object}
         */
        this.positions;

        this._setData(chartDimension, areaBound, isVertical, options);
    },

    /**
     * Get horizontal direction.
     * @param {?string} alignOption align option
     * @returns {string} direction
     * @private
     */
    _getHorizontalDirection: function(alignOption) {
        var direction;
        alignOption = alignOption || '';
        if (alignOption.indexOf('left') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_BACKWARD;
        } else if (alignOption.indexOf('center') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_CENTER;
        } else {
            direction = chartConst.TOOLTIP_DIRECTION_FORWARD;
        }
        return direction;
    },

    /**
     * To make vertical data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {?string} alignOption align option
     * @returns {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} vertical data
     * @private
     */
    _makeVerticalData: function(chartDimension, areaBound, alignOption) {
        var hDirection = this._getHorizontalDirection(alignOption);
        return {
            positionType: 'left',
            sizeType: 'width',
            direction: hDirection,
            areaPosition: areaBound.position.left,
            areaSize: areaBound.dimension.width,
            chartSize: chartDimension.width,
            basePosition: chartConst.SERIES_EXPAND_SIZE
        };
    },

    /**
     * Get vertical direction.
     * @param {?string} alignOption align option
     * @returns {string} direction
     * @private
     */
    _getVerticalDirection: function(alignOption) {
        var direction;
        alignOption = alignOption || '';
        if (alignOption.indexOf('top') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_BACKWARD;
        } else if (alignOption.indexOf('bottom') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_FORWARD;
        } else {
            direction = chartConst.TOOLTIP_DIRECTION_CENTER;
        }
        return direction;
    },

    /**
     * To make horizontal data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {?string} alignOption align option
     * @returns {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} vertical data
     * @private
     */
    _makeHorizontalData: function(chartDimension, areaBound, alignOption) {
        var vDirection = this._getVerticalDirection(alignOption);
        return {
            positionType: 'top',
            sizeType: 'height',
            direction: vDirection,
            areaPosition: areaBound.position.top,
            areaSize: areaBound.dimension.height,
            chartSize: chartDimension.height,
            basePosition: 0
        };
    },

    /**
     * Set data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {boolean} isVertical whether vertical or not
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     * @private
     */
    _setData: function(chartDimension, areaBound, isVertical, options) {
        var verticalData = this._makeVerticalData(chartDimension, areaBound, options.align),
            horizontalData = this._makeHorizontalData(chartDimension, areaBound, options.align);
        if (isVertical) {
            this.mainData = verticalData;
            this.subData = horizontalData;
        } else {
            this.mainData = horizontalData;
            this.subData = verticalData;
        }

        this.positionOption = tui.util.extend({
            left: 0,
            top: 0
        }, options.position);

        this.positions = {};
    },

    /**
     * To calculate main position value.
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {{start: number, end: number}} range range
     * @param {object} data data
     *      @param {string} data.direction direction
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _calculateMainPositionValue: function(tooltipSize, range, data) {
        var isLine = (range.start === range.end),
            padding = isLine ? 9 : 5,
            value = data.basePosition;
        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value += range.end + padding;
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value += range.start - tooltipSize - padding;
        } else if (isLine) {
            value += range.start - tooltipSize / 2;
        } else {
            value += range.start + ((range.end - range.start - tooltipSize) / 2);
        }
        return value;
    },

    /**
     * To calculate sub position value.
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.areaSize tooltip area size (width or height)
     *      @param {string} data.direction direction
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _calculateSubPositionValue: function(tooltipSize, data) {
        var middle = data.areaSize / 2,
            value;
        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = middle + data.basePosition;
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value = middle - tooltipSize + data.basePosition;
        } else {
            value = middle - (tooltipSize / 2) + data.basePosition;
        }
        return value;
    },

    /**
     * To make position value diff.
     * @param {number} value positoin value
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     * @returns {number} diff
     * @private
     */
    _makePositionValueDiff: function(value, tooltipSize, data) {
        return value + data.areaPosition + tooltipSize - data.chartSize;
    },

    /**
     * Adjust backward position value.
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustBackwardPositionValue: function(value, range, tooltipSize, data) {
        var changedValue;
        if (value < -data.areaPosition) {
            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                direction: chartConst.TOOLTIP_DIRECTION_FORWARD,
                basePosition: data.basePosition
            });
            if (this._makePositionValueDiff(changedValue, tooltipSize, data) > 0) {
                value = -data.areaPosition;
            } else {
                value = changedValue;
            }
        }
        return value;
    },

    /**
     * Adjust forward position value.
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustForwardPositionValue: function(value, range, tooltipSize, data) {
        var diff = this._makePositionValueDiff(value, tooltipSize, data),
            changedValue;
        if (diff > 0) {
            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                direction: chartConst.TOOLTIP_DIRECTION_BACKWARD,
                basePosition: data.basePosition
            });
            if (changedValue < -data.areaPosition) {
                value -= diff;
            } else {
                value = changedValue;
            }
        }
        return value;
    },

    /**
     * Adjust main position value
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     * @returns {number} position value
     * @private
     */
    _adjustMainPositionValue: function(value, range, tooltipSize, data) {
        if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value = this._adjustBackwardPositionValue(value, range, tooltipSize, data);
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = this._adjustForwardPositionValue(value, range, tooltipSize, data);
        } else {
            value = tui.util.max([value, -data.areaPosition]);
            value = tui.util.min([value, data.chartSize - data.areaPosition - tooltipSize]);
        }
        return value;
    },

    /**
     * Adjust sub position value.
     * @param {number} value position value
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustSubPositionValue: function(value, tooltipSize, data) {
        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = tui.util.min([value, data.chartSize - data.areaPosition - tooltipSize]);
        } else {
            value = tui.util.max([value, -data.areaPosition]);
        }
        return value;
    },

    /**
     * To make caching key.
     * @param {{start: number, end: number}} range range
     * @returns {string} key
     * @private
     */
    _makeCachingKey: function(range) {
        return range.start + '-' + range.end;
    },

    /**
     * Add position option.
     * @param {number} position position
     * @param {string} positionType position type (left or top)
     * @returns {number} position
     * @private
     */
    _addPositionOptionValue: function(position, positionType) {
        return position + this.positionOption[positionType];
    },

    /**
     * To calculate group tooltip position.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{start: number, end: number}} range tooltip sector range
     * @returns {{left: number, top: number}} group tooltip position
     */
    calculatePosition: function(tooltipDimension, range) {
        var key = this._makeCachingKey(range),
            main = this.mainData,
            sub = this.subData,
            position = this.positions[key],
            mainPosition, subPosition;

        if (!position) {
            position = {};
            mainPosition = this._calculateMainPositionValue(tooltipDimension[main.sizeType], range, main);
            subPosition = this._calculateSubPositionValue(tooltipDimension[sub.sizeType], sub);

            mainPosition = this._addPositionOptionValue(mainPosition, main.positionType);
            subPosition = this._addPositionOptionValue(subPosition, sub.positionType);

            position[main.positionType] = this._adjustMainPositionValue(mainPosition, range, tooltipDimension[main.sizeType], main);
            position[sub.positionType] = this._adjustSubPositionValue(subPosition, tooltipDimension[sub.sizeType], sub);
            this.positions[key] = position;
        }

        return position;
    },

    /**
     * Update tooltip options for position calculation.
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     */
    updateOptions: function(options) {
        this.options = options;
        this._setData(this.chartDimension, this.areaBound, this.isVertical, options);
    },

    /**
     * Update tooltip bound for position calculation.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound tooltip area bound
     */
    updateBound: function(bound) {
        this.areaBound = bound;
        this._setData(this.chartDimension, bound, this.isVertical, this.options);
    }
});

module.exports = GroupTooltipPositionModel;

},{"../const":15}],62:[function(require,module,exports){
/**
 * @fileoverview Tooltip component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var TooltipBase = require('./tooltipBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    dom = require('../helpers/domHandler'),
    eventListener = require('../helpers/eventListener'),
    renderUtil = require('../helpers/renderUtil'),
    templateMaker = require('../helpers/templateMaker'),
    tooltipTemplate = require('./tooltipTemplate');

var Tooltip = tui.util.defineClass(TooltipBase, /** @lends Tooltip.prototype */ {
    /**
     * Tooltip component.
     * @constructs Tooltip
     * @param {object} params parameters
     *      @param {array.<number>} params.values converted values
     *      @param {array} params.labels labels
     *      @param {array} params.legendLabels legend labels
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        var values;
        TooltipBase.call(this, params);
        this.tplTooltip = this._getTooltipTemplate(this.options.template);
        if (tui.util.isArray(this.values)) {
            values = this.values;
            this.values = {};
            this.values[this.chartType] = values;
        }
    },

    /**
     * Get tooltip template.
     * @param {object} optionTemplate template option
     * @returns {object} template
     * @private
     */
    _getTooltipTemplate: function(optionTemplate) {
        return optionTemplate ? templateMaker.template(optionTemplate) : tooltipTemplate.tplDefault;
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (this.options.align) {
            return;
        }

        if (this.isVertical) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        } else {
            this.options.align = chartConst.TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION;
        }
    },

    /**
     * To render tooltip component.
     * @param {{position: object}} bound tooltip bound
     * @param {?{seriesPosition: {left: number, top: number}}} data rendering data
     * @returns {HTMLElement} tooltip element
     * @override
     */
    render: function(bound, data) {
        var el = TooltipBase.prototype.render.call(this, bound, data);

        if (data) {
            this.seriesPosition = data.seriesPosition;
        }

        this.attachEvent(el);
        return el;
    },

    /**
     * To resize tooltip component.
     * @param {{position: object}} bound tooltip bound
     * @param {?{seriesPosition: {left: number, top: number}}} data rendering data
     * @override
     */
    resize: function(bound, data) {
        if (data) {
            this.seriesPosition = data.seriesPosition;
        }
        TooltipBase.prototype.resize.call(this, bound);
    },

    /**
     * To make tooltip data.
     * @returns {array.<object>} tooltip data
     * @override
     */
    makeTooltipData: function() {
        var labels = this.labels,
            tooltipData = {},
            legendLabels = {};

        if (tui.util.isArray(this.formattedValues)) {
            tooltipData[this.chartType] = this.formattedValues;
            legendLabels[this.chartType] = this.legendLabels;
        } else {
            tooltipData = this.formattedValues;
            legendLabels = this.legendLabels;
        }

        tui.util.forEach(tooltipData, function(groupValues, chartType) {
            tooltipData[chartType] = tui.util.map(groupValues, function(values, groupIndex) {
                return tui.util.map(values, function(value, index) {
                    return {
                        category: labels ? labels[groupIndex] : '',
                        legend: legendLabels[chartType][index],
                        value: value
                    };
                });
            });
        });
        return tooltipData;
    },

    /**
     * Fire custom event showAnimation.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @private
     */
    _fireShowAnimation: function(indexes, chartType) {
        var eventName = renderUtil.makeCustomEventName('show', chartType, 'animation');
        this.fire(eventName, indexes);
    },

    /**
     * Fire custom event hideAnimation.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @private
     */
    _fireHideAnimation: function(indexes, chartType) {
        var eventName = renderUtil.makeCustomEventName('hide', chartType, 'animation');
        this.fire(eventName, indexes);
    },

    /**
     * Set data indexes.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{groupIndex: number, index:number}} indexes indexes
     * @private
     */
    _setIndexesCustomAttribute: function(elTooltip, indexes) {
        elTooltip.setAttribute('data-groupIndex', indexes.groupIndex);
        elTooltip.setAttribute('data-index', indexes.index);
    },

    /**
     * Get data indexes
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {{groupIndex: number, index: number}} indexes
     * @private
     */
    _getIndexesCustomAttribute: function(elTooltip) {
        var groupIndex = elTooltip.getAttribute('data-groupIndex'),
            index = elTooltip.getAttribute('data-index'),
            indexes = null;

        if (!tui.util.isNull(groupIndex) && !tui.util.isNull(index)) {
            indexes = {
                groupIndex: parseInt(groupIndex, 10),
                index: parseInt(index, 10)
            };
        }
        return indexes;
    },

    /**
     * Set showed custom attribute.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {boolean} status whether showed or not
     * @private
     */
    _setShowedCustomAttribute: function(elTooltip, status) {
        elTooltip.setAttribute('data-showed', status);
    },

    /**
     * Whether showed tooltip or not.
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {boolean} whether showed tooltip or not
     * @private
     */
    _isShowedTooltip: function(elTooltip) {
        var isShowed = elTooltip.getAttribute('data-showed');
        return isShowed === 'true' || isShowed === true; // ie7 boolean true 
    },

    /**
     * On mouseover event handler for tooltip area
     * @param {MouseEvent} e mouse event
     */
    onMouseover: function(e) {
        var elTarget = e.target || e.srcElement,
            indexes, chartType;

        if (!dom.hasClass(elTarget, chartConst.TOOLTIP_PREFIX)) {
            elTarget = dom.findParentByClass(elTarget, chartConst.TOOLTIP_PREFIX);
        }

        indexes = this._getIndexesCustomAttribute(elTarget);
        chartType = elTarget.getAttribute('data-chart-type');

        this._setShowedCustomAttribute(elTarget, true);
        this._fireShowAnimation(indexes, chartType);
    },

    /**
     * On mouseout event handler for tooltip area
     * @param {MouseEvent} e mouse event
     */
    onMouseout: function(e) {
        var elTarget = e.target || e.srcElement;


        if (!dom.hasClass(elTarget, chartConst.TOOLTIP_PREFIX)) {
            elTarget = dom.findParentByClass(elTarget, chartConst.TOOLTIP_PREFIX);
        }

        this.hideTooltip(elTarget);
    },

    /**
     * To calculate tooltip position abount pie chart.
     * @param {object} params parameters
     *      @param {{left: number, top: number}} params.bound bound
     *      @param {{clientX: number, clientY: number}} params.eventPosition mouse position
     * @returns {{top: number, left: number}} position
     * @private
     */
    _calculateTooltipPositionAboutPieChart: function(params) {
        params.bound.left = params.eventPosition.clientX - this.seriesPosition.left;
        params.bound.top = params.eventPosition.clientY - this.seriesPosition.top;
        return this._calculateTooltipPositionAboutNotBarChart(params);
    },

    /**
     * To calculate tooltip position about not bar chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data graph information
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _calculateTooltipPositionAboutNotBarChart: function(params) {
        var bound = params.bound,
            positionOption = params.positionOption,
            minusWidth = params.dimension.width - (bound.width || 0),
            lineGap = bound.width ? 0 : chartConst.TOOLTIP_GAP,
            alignOption = params.alignOption || '',
            tooltipHeight = params.dimension.height,
            result = {};
        result.left = bound.left + positionOption.left;
        result.top = bound.top - tooltipHeight + positionOption.top;

        if (alignOption.indexOf('left') > -1) {
            result.left -= minusWidth + lineGap;
        } else if (alignOption.indexOf('center') > -1) {
            result.left -= minusWidth / 2;
        } else {
            result.left += lineGap;
        }

        if (alignOption.indexOf('bottom') > -1) {
            result.top += tooltipHeight + lineGap;
        } else if (alignOption.indexOf('middle') > -1) {
            result.top += tooltipHeight / 2;
        } else {
            result.top -= chartConst.TOOLTIP_GAP;
        }

        return result;
    },

    /**
     * To calculate tooltip position about bar chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data graph information
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _calculateTooltipPositionAboutBarChart: function(params) {
        var bound = params.bound,
            positionOption = params.positionOption,
            minusHeight = params.dimension.height - (bound.height || 0),
            alignOption = params.alignOption || '',
            tooltipWidth = params.dimension.width,
            result = {};

        result.left = bound.left + bound.width + positionOption.left;
        result.top = bound.top + positionOption.top;

        // TODO : alignOptions     ex) alignOption.left = true
        if (alignOption.indexOf('left') > -1) {
            result.left -= tooltipWidth;
        } else if (alignOption.indexOf('center') > -1) {
            result.left -= tooltipWidth / 2;
        } else {
            result.left += chartConst.TOOLTIP_GAP;
        }

        if (alignOption.indexOf('top') > -1) {
            result.top -= minusHeight;
        } else if (alignOption.indexOf('middle') > -1) {
            result.top -= minusHeight / 2;
        }

        return result;
    },

    /**
     * Adjust position.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{left: number, top: number}} areaPosition area position
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{left: number, top: number}} position position
     * @returns {{left: number, top: number}} adjusted position
     * @private
     */
    _adjustPosition: function(chartDimension, areaPosition, tooltipDimension, position) {
        position.left = tui.util.max([position.left, -areaPosition.left]);
        position.left = tui.util.min([position.left, chartDimension.width - areaPosition.left - tooltipDimension.width]);
        position.top = tui.util.max([position.top, -areaPosition.top]);
        position.top = tui.util.min([position.top, chartDimension.height - areaPosition.top - tooltipDimension.height]);
        return position;
    },

    /**
     * Calculate tooltip position.
     * @param {object} params parameters
     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
     *      @param {string} params.chartType chart type
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _calculateTooltipPosition: function(params) {
        var position = {},
            sizeType, positionType, addPadding;

        if (params.eventPosition) {
            return this._calculateTooltipPositionAboutPieChart(params);
        }

        if (predicate.isBarChart(params.chartType)) {
            position = this._calculateTooltipPositionAboutBarChart(params);
            sizeType = 'width';
            positionType = 'left';
            addPadding = 1;
        } else {
            position = this._calculateTooltipPositionAboutNotBarChart(params);
            sizeType = 'height';
            positionType = 'top';
            addPadding = -1;
        }

        if (params.allowNegativeTooltip) {
            position = this._moveToSymmetry(position, {
                bound: params.bound,
                indexes: params.indexes,
                dimension: params.dimension,
                chartType: params.chartType,
                sizeType: sizeType,
                positionType: positionType,
                addPadding: addPadding
            });
        }

        position = this._adjustPosition(this.chartDimension, this.bound.position, params.dimension, position);
        return position;
    },

    /**
     * Get value by indexes.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @returns {(string | number)} value
     * @private
     */
    _getValueByIndexes: function(indexes, chartType) {
        return this.values[chartType][indexes.groupIndex][indexes.index];
    },

    /**
     * Move to symmetry.
     * @param {{left: number, top: number}} position tooltip position
     * @param {object} params parameters
     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
     *      @param {string} params.id tooltip id
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.sizeType size type (width or height)
     *      @param {string} params.positionType position type (left or top)
     *      @param {number} params.addPadding add padding
     * @returns {{left: number, top: number}} moved position
     * @private
     */
    _moveToSymmetry: function(position, params) {
        var bound = params.bound,
            sizeType = params.sizeType,
            positionType = params.positionType,
            value = this._getValueByIndexes(params.indexes, params.chartType),
            center;
        if (value < 0) {
            center = bound[positionType] + (bound[sizeType] / 2) + (params.addPadding || 0);
            position[positionType] = position[positionType] - (position[positionType] - center) * 2 - params.dimension[sizeType];
        }
        return position;
    },

    /**
     * To make tooltip html.
     * @param {string} chartType chart type
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(chartType, indexes) {
        var data = this.data[chartType][indexes.groupIndex][indexes.index];
        data.suffix = this.suffix;
        return this.tplTooltip(data);
    },

    /**
     * Whether changed indexes or not.
     * @param {{groupIndex: number, index: number}} prevIndexes prev indexes
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChangedIndexes: function(prevIndexes, indexes) {
        return !!prevIndexes && (prevIndexes.groupIndex !== indexes.groupIndex || prevIndexes.index !== indexes.index);
    },

    /**
     * Show tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{indexes: {groupIndex: number, index: number}, bound: object}} params tooltip data
     * @param {{left: number, top: number}} prevPosition prev position
     */
    showTooltip: function(elTooltip, params, prevPosition) {
        var indexes = params.indexes,
            prevIndexes = this._getIndexesCustomAttribute(elTooltip),
            prevChartType, position;
        if (this._isChangedIndexes(prevIndexes, indexes)) {
            prevChartType = elTooltip.getAttribute('data-chart-type');
            this._fireHideAnimation(prevIndexes, prevChartType);
        }

        elTooltip.innerHTML = this._makeTooltipHtml(params.chartType, indexes);

        elTooltip.setAttribute('data-chart-type', params.chartType);
        this._setIndexesCustomAttribute(elTooltip, indexes);
        this._setShowedCustomAttribute(elTooltip, true);

        this._fireBeforeShowTooltip(indexes);

        dom.addClass(elTooltip, 'show');

        position = this._calculateTooltipPosition(tui.util.extend({
            dimension: this.getTooltipDimension(elTooltip),
            positionOption: tui.util.extend({
                left: 0,
                top: 0
            }, this.options.position),
            alignOption: this.options.align || ''
        }, params));

        this.moveToPosition(elTooltip, position, prevPosition);
        this._fireShowAnimation(indexes, params.chartType);
        this._fireAfterShowTooltip(indexes, {
            element: elTooltip,
            position: position
        });
    },

    /**
     * To make parameters for show tooltip user event.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
     * @private
     */
    _makeShowTooltipParams: function(indexes, additionParams) {
        var legendIndex = indexes.index,
            legendData = this.joinLegendLabels[legendIndex],
            params;
        params = tui.util.extend({
            chartType: legendData.chartType,
            legend: legendData.label,
            legendIndex: legendIndex,
            index: indexes.groupIndex
        }, additionParams);
        return params;
    },

    /**
     * To call beforeShowTooltip callback of userEvent.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @private
     */
    _fireBeforeShowTooltip: function(indexes) {
        var params = this._makeShowTooltipParams(indexes);
        this.userEvent.fire('beforeShowTooltip', params);
    },

    /**
     * To call afterShowTooltip callback of userEvent.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @private
     */
    _fireAfterShowTooltip: function(indexes, additionParams) {
        var params = this._makeShowTooltipParams(indexes, additionParams);
        this.userEvent.fire('afterShowTooltip', params);
    },

    /**
     * Hide tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {function} callback callback
     */
    hideTooltip: function(elTooltip) {
        var that = this,
            indexes = this._getIndexesCustomAttribute(elTooltip),
            chartType = elTooltip.getAttribute('data-chart-type');

        this._setShowedCustomAttribute(elTooltip, false);
        this._fireHideAnimation(indexes, chartType);

        if (this._isChangedIndexes(this.prevIndexes, indexes)) {
            delete this.prevIndexes;
        }

        setTimeout(function() {
            if (that._isShowedTooltip(elTooltip)) {
                return;
            }
            that.hideAnimation(elTooltip);

            that = null;
            indexes = null;
        }, chartConst.HIDE_DELAY);
    },

    /**
     * Attach event
     * @param {HTMLElement} el target element
     */
    attachEvent: function(el) {
        eventListener.bindEvent('mouseover', el, tui.util.bind(this.onMouseover, this));
        eventListener.bindEvent('mouseout', el, tui.util.bind(this.onMouseout, this));
    }
});

tui.util.CustomEvents.mixin(Tooltip);

module.exports = Tooltip;

},{"../const":15,"../helpers/domHandler":30,"../helpers/eventListener":31,"../helpers/predicate":32,"../helpers/renderUtil":33,"../helpers/templateMaker":34,"./tooltipBase":63,"./tooltipTemplate":64}],63:[function(require,module,exports){
/**
 * @fileoverview TooltipBase is base class of tooltip components.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var TooltipBase = tui.util.defineClass(/** @lends TooltipBase.prototype */ {
    /**
     * TooltipBase is base class of tooltip components.
     * @constructs TooltipBase
     * @param {object} params parameters
     *      @param {array.<number>} params.values converted values
     *      @param {array} params.labels labels
     *      @param {array} params.legendLabels legend labels
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        tui.util.extend(this, params);
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-chart-tooltip-area';

        /**
         * TooltipBase container.
         * @type {HTMLElement}
         */
        this.elLayout = null;

        /**
         * TooltipBase base data.
         * @type {array.<array.<object>>}
         */
        this.data = this.makeTooltipData();


        this.suffix = this.options.suffix ? '&nbsp;' + this.options.suffix : '';

        this._setDefaultTooltipPositionOption();
        this._saveOriginalPositionOptions();
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @abstract
     */
    _setDefaultTooltipPositionOption: function() {},

    /**
     * To save position options.
     * @private
     */
    _saveOriginalPositionOptions: function() {
        this.orgPositionOptions = {
            align: this.options.align,
            position: this.options.position
        };
    },

    /**
     * To make tooltip data.
     * @abstract
     */
    makeTooltipData: function() {},

    /**
     * To render tooltip component.
     * @param {{position: object}} bound tooltip bound
     * @param {?{seriesPosition: {left: number, top: number}}} data rendering data
     * @returns {HTMLElement} tooltip element
     */
    render: function(bound, data) {
        var el = dom.create('DIV', this.className);

        renderUtil.renderPosition(el, bound.position);

        this.bound = bound;
        this.chartDimension = data.chartDimension;
        this.elTooltipArea = el;

        return el;
    },

    /**
     * To resize tooltip component.
     * @param {{position: object}} bound tooltip bound
     * @override
     */
    resize: function(bound) {
        this.bound = bound;
        renderUtil.renderPosition(this.elTooltipArea, bound.position);
        if (this.positionModel) {
            this.positionModel.updateBound(bound);
        }
    },

    /**
     * Get tooltip element.
     * @returns {HTMLElement} tooltip element
     * @private
     */
    _getTooltipElement: function() {
        var elTooltip;
        if (!this.elTooltip) {
            this.elTooltip = elTooltip = dom.create('DIV', 'tui-chart-tooltip');
            dom.append(this.elTooltipArea, elTooltip);
        }
        return this.elTooltip;
    },

    /**
     * onShow is callback of custom event showTooltip for SeriesView.
     * @param {object} params coordinate event parameters
     */
    onShow: function(params) {
        var elTooltip = this._getTooltipElement(),
            prevPosition;
        if (elTooltip.offsetWidth) {
            prevPosition = {
                left: elTooltip.offsetLeft,
                top: elTooltip.offsetTop
            };
        }

        this.showTooltip(elTooltip, params, prevPosition);
    },

    /**
     * Get tooltip dimension
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {{width: number, height: number}} rendered tooltip dimension
     */
    getTooltipDimension: function(elTooltip) {
        return {
            width: elTooltip.offsetWidth,
            height: elTooltip.offsetHeight
        };
    },

    /**
     * Cancel hide tooltip.
     * @private
     */
    _cancelHide: function() {
        if (!this.activeHider) {
            return;
        }
        clearInterval(this.activeHider.timerId);
        this.activeHider.setOpacity(1);
    },

    /**
     * Cancel slide tooltip.
     * @private
     */
    _cancelSlide: function() {
        if (!this.activeSliders) {
            return;
        }

        tui.util.forEach(this.activeSliders, function(slider) {
            clearInterval(slider.timerId);
        });

        this._completeSlide();
    },

    /**
     * Move to Position.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{left: number, top: number}} position position
     * @param {{left: number, top: number}} prevPosition prev position
     */
    moveToPosition: function(elTooltip, position, prevPosition) {
        if (prevPosition) {
            this._cancelHide();
            this._cancelSlide();
            this._slideTooltip(elTooltip, prevPosition, position);
        } else {
            renderUtil.renderPosition(elTooltip, position);
        }
    },

    /**
     * Get slider.
     * @param {HTMLElement} element element
     * @param {string} type slide type (horizontal or vertical)
     * @returns {object} effect object
     * @private
     */
    _getSlider: function(element, type) {
        if (!this.slider) {
            this.slider = {};
        }

        if (!this.slider[type]) {
            this.slider[type] = new tui.component.Effects.Slide({
                flow: type,
                element: element,
                duration: 100
            });
        }
        return this.slider[type];
    },

    /**
     * Complete slide tooltip.
     * @private
     */
    _completeSlide: function() {
        delete this.activeSliders;
    },

    /**
     * Slide tooltip
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{left: number, top: number}} prevPosition prev position
     * @param {{left: number, top: number}} position position
     * @private
     */
    _slideTooltip: function(elTooltip, prevPosition, position) {
        var vSlider = this._getSlider(elTooltip, 'vertical'),
            hSlider = this._getSlider(elTooltip, 'horizontal'),
            moveTop = prevPosition.top - position.top,
            moveLeft = prevPosition.left - position.left,
            vDirection = moveTop > 0 ? 'forword' : 'backword',
            hDirection = moveTop > 0 ? 'forword' : 'backword',
            activeSliders = [],
            complate = tui.util.bind(this._completeSlide, this);

        if (moveTop) {
            vSlider.setDistance(moveTop);
            vSlider.action({
                direction: vDirection,
                start: prevPosition.top,
                complete: complate
            });
            activeSliders.push(vSlider);
        }

        if (moveLeft) {
            hSlider.setDistance(moveLeft);
            hSlider.action({
                direction: hDirection,
                start: prevPosition.left,
                complete: complate
            });
            activeSliders.push(vSlider);
        }

        if (activeSliders.length) {
            this.activeSliders = activeSliders;
        }
    },

    /**
     * onHide is callback of custom event hideTooltip for SeriesView
     * @param {number} index index
     */
    onHide: function(index) {
        var elTooltip = this._getTooltipElement();
        this.hideTooltip(elTooltip, index);
    },

    /**
     * Get hider.
     * @param {HTMLElement} element element
     * @returns {object} effect object
     * @private
     */
    _getHider: function(element) {
        if (!this.hider) {
            this.hider = new tui.component.Effects.Fade({
                element: element,
                duration: 100
            });
        }

        return this.hider;
    },

    /**
     * To hide animation.
     * @param {HTMLElement} elTooltip tooltip element
     */
    hideAnimation: function(elTooltip) {
        this.activeHider = this._getHider(elTooltip);
        this.activeHider.action({
            start: 1,
            end: 0,
            complete: function() {
                dom.removeClass(elTooltip, 'show');
                elTooltip.style.cssText = '';
            }
        });
    },

    /**
     * Set tooltip align option.
     * @param {string} align align
     */
    setAlign: function(align) {
        this.options.align = align;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Set position option.
     * @param {{left: number, top: number}} position moving position
     */
    setPosition: function(position) {
        this.options.position = tui.util.extend({}, this.options.position, position);
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Reset tooltip align option.
     */
    resetAlign: function() {
        var align = this.orgPositionOptions.align;
        this.options.align = align;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Reset tooltip position.
     */
    resetPosition: function() {
        var position = this.orgPositionOptions.position;
        this.options.position = position;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    }
});

tui.util.CustomEvents.mixin(TooltipBase);

module.exports = TooltipBase;

},{"../helpers/domHandler":30,"../helpers/renderUtil":33}],64:[function(require,module,exports){
/**
 * @fileoverview This is templates of tooltip.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div>{{ category }}</div>' +
        '<div>' +
            '<span>{{ legend }}</span>:' +
            '&nbsp;<span>{{ value }}</span>' +
            '<span>{{ suffix }}</span>' +
        '</div>' +
    '</div>',
    HTML_GROUP: '<div class="tui-chart-default-tooltip tui-chart-group-tooltip">' +
        '<div>{{ category }}</div>' +
        '{{ items }}' +
    '</div>',
    HTML_GROUP_ITEM: '<div>' +
        '<div class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></div>&nbsp;<span>{{ legend }}</span>:' +
        '&nbsp;<span>{{ value }}</span>' +
        '<span>{{ suffix }}</span>' +
    '</div>',
    GROUP_CSS_TEXT: 'background-color:{{ color }}'
};

module.exports = {
    tplDefault: templateMaker.template(tags.HTML_DEFAULT_TEMPLATE),
    tplGroup: templateMaker.template(tags.HTML_GROUP),
    tplGroupItem: templateMaker.template(tags.HTML_GROUP_ITEM),
    tplGroupCssText: templateMaker.template(tags.GROUP_CSS_TEXT)
};

},{"../helpers/templateMaker":34}]},{},[3,40])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvYXhlcy9heGlzLmpzIiwic3JjL2pzL2F4ZXMvYXhpc1RlbXBsYXRlLmpzIiwic3JjL2pzL2NoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9hcmVhQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2F4aXNUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2JhckNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9jaGFydEJhc2UuanMiLCJzcmMvanMvY2hhcnRzL2NvbHVtbkNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9jb21ib0NoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9saW5lQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2xpbmVUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL3BpZUNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy92ZXJ0aWNhbFR5cGVNaXhlci5qcyIsInNyYy9qcy9jb2RlLXNuaXBwZXQtdXRpbC5qcyIsInNyYy9qcy9jb25zdC5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvYXJlYVR5cGVDdXN0b21FdmVudC5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvYXJlYVR5cGVEYXRhTW9kZWwuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL2N1c3RvbUV2ZW50QmFzZS5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvZ3JvdXBUeXBlQ3VzdG9tRXZlbnQuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL3BvaW50VHlwZUN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9wb2ludFR5cGVEYXRhTW9kZWwuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL3RpY2tCYXNlRGF0YU1vZGVsLmpzIiwic3JjL2pzL2ZhY3Rvcmllcy9jaGFydEZhY3RvcnkuanMiLCJzcmMvanMvZmFjdG9yaWVzL3BsdWdpbkZhY3RvcnkuanMiLCJzcmMvanMvZmFjdG9yaWVzL3RoZW1lRmFjdG9yeS5qcyIsInNyYy9qcy9oZWxwZXJzL2F4aXNEYXRhTWFrZXIuanMiLCJzcmMvanMvaGVscGVycy9ib3VuZHNNYWtlci5qcyIsInNyYy9qcy9oZWxwZXJzL2NhbGN1bGF0b3IuanMiLCJzcmMvanMvaGVscGVycy9kYXRhQ29udmVydGVyLmpzIiwic3JjL2pzL2hlbHBlcnMvZG9tSGFuZGxlci5qcyIsInNyYy9qcy9oZWxwZXJzL2V2ZW50TGlzdGVuZXIuanMiLCJzcmMvanMvaGVscGVycy9wcmVkaWNhdGUuanMiLCJzcmMvanMvaGVscGVycy9yZW5kZXJVdGlsLmpzIiwic3JjL2pzL2hlbHBlcnMvdGVtcGxhdGVNYWtlci5qcyIsInNyYy9qcy9oZWxwZXJzL3VzZXJFdmVudExpc3RlbmVyLmpzIiwic3JjL2pzL2xlZ2VuZHMvbGVnZW5kLmpzIiwic3JjL2pzL2xlZ2VuZHMvbGVnZW5kVGVtcGxhdGUuanMiLCJzcmMvanMvcGxvdHMvcGxvdC5qcyIsInNyYy9qcy9wbG90cy9wbG90VGVtcGxhdGUuanMiLCJzcmMvanMvcGx1Z2lucy9wbHVnaW5SYXBoYWVsLmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbEFyZWFDaGFydC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxCYXJDaGFydC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxMaW5lQ2hhcnQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsTGluZVR5cGVCYXNlLmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbFBpZUNoYXJ0LmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbFJlbmRlclV0aWwuanMiLCJzcmMvanMvcG9seWZpbGwuanMiLCJzcmMvanMvcmVnaXN0ZXJDaGFydHMuanMiLCJzcmMvanMvcmVnaXN0ZXJUaGVtZXMuanMiLCJzcmMvanMvc2VyaWVzL2FyZWFDaGFydFNlcmllcy5qcyIsInNyYy9qcy9zZXJpZXMvYmFyQ2hhcnRTZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL2JhclR5cGVTZXJpZXNCYXNlLmpzIiwic3JjL2pzL3Nlcmllcy9jb2x1bW5DaGFydFNlcmllcy5qcyIsInNyYy9qcy9zZXJpZXMvbGluZUNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9saW5lVHlwZVNlcmllc0Jhc2UuanMiLCJzcmMvanMvc2VyaWVzL3BpZUNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9zZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL3Nlcmllc1RlbXBsYXRlLmpzIiwic3JjL2pzL3RoZW1lcy9kZWZhdWx0VGhlbWUuanMiLCJzcmMvanMvdG9vbHRpcHMvZ3JvdXBUb29sdGlwLmpzIiwic3JjL2pzL3Rvb2x0aXBzL2dyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwuanMiLCJzcmMvanMvdG9vbHRpcHMvdG9vbHRpcC5qcyIsInNyYy9qcy90b29sdGlwcy90b29sdGlwQmFzZS5qcyIsInNyYy9qcy90b29sdGlwcy90b29sdGlwVGVtcGxhdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2prQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBBeGlzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGN1bGF0b3InKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgYXhpc1RlbXBsYXRlID0gcmVxdWlyZSgnLi9heGlzVGVtcGxhdGUnKTtcblxudmFyIEF4aXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIEF4aXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBBeGlzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBBeGlzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tcbiAgICAgKiAgICAgICAgICBsYWJlbHM6IGFycmF5LjxzdHJpbmc+LFxuICAgICAqICAgICAgICAgIHRpY2tDb3VudDogbnVtYmVyLFxuICAgICAqICAgICAgICAgIGlzTGFiZWxBeGlzOiBib29sZWFuLFxuICAgICAqICAgICAgICAgIGlzVmVydGljYWw6IGJvb2xlYW5cbiAgICAgKiAgICAgIH19IHBhcmFtcy5kYXRhIGF4aXMgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5ib3VuZCBheGlzIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBheGlzIG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIHZpZXcgY2xhc3NOYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY2hhcnQtYXhpcy1hcmVhJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVuZGVyIGF4aXMgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbEF4aXNBcmVhIGF4aXMgYXJlYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgYXhpcyBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQXhpc0FyZWE6IGZ1bmN0aW9uKGVsQXhpc0FyZWEsIGJvdW5kLCBkYXRhKSB7XG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudGhlbWUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsID0gISFkYXRhLmlzVmVydGljYWwsXG4gICAgICAgICAgICBpc1Bvc2l0aW9uUmlnaHQgPSAhIWRhdGEuaXNQb3NpdGlvblJpZ2h0LFxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IGJvdW5kLmRpbWVuc2lvbixcbiAgICAgICAgICAgIHNpemUgPSBpc1ZlcnRpY2FsID8gZGltZW5zaW9uLmhlaWdodCA6IGRpbWVuc2lvbi53aWR0aCxcbiAgICAgICAgICAgIGVsVGl0bGVBcmVhID0gdGhpcy5fcmVuZGVyVGl0bGVBcmVhKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9ucy50aXRsZSxcbiAgICAgICAgICAgICAgICB0aGVtZTogdGhlbWUudGl0bGUsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgICAgICBpc1Bvc2l0aW9uUmlnaHQ6IGlzUG9zaXRpb25SaWdodCxcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVsTGFiZWxBcmVhID0gdGhpcy5fcmVuZGVyTGFiZWxBcmVhKGRhdGEsIHNpemUsIGRpbWVuc2lvbi53aWR0aCwgYm91bmQuZGVncmVlKSxcbiAgICAgICAgICAgIGVsVGlja0FyZWE7XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5ib3VuZCA9IGJvdW5kO1xuXG4gICAgICAgIGlmICghaXNWZXJ0aWNhbCB8fCAhZGF0YS5hbGlnbmVkKSB7XG4gICAgICAgICAgICBlbFRpY2tBcmVhID0gdGhpcy5fcmVuZGVyVGlja0FyZWEoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oZWxBeGlzQXJlYSwgZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihlbEF4aXNBcmVhLCBib3VuZC5wb3NpdGlvbik7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbEF4aXNBcmVhLCBpc1ZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbEF4aXNBcmVhLCBpc1Bvc2l0aW9uUmlnaHQgPyAncmlnaHQnIDogJycpO1xuICAgICAgICBkb20uYXBwZW5kKGVsQXhpc0FyZWEsIFtlbFRpdGxlQXJlYSwgZWxUaWNrQXJlYSwgZWxMYWJlbEFyZWFdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVuZGVyIGF4aXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGJvdW5kIGF4aXMgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gYXhpcyBhcmVhIGJhc2UgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oYm91bmQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB0aGlzLl9yZW5kZXJBeGlzQXJlYShlbCwgYm91bmQsIGRhdGEpO1xuICAgICAgICB0aGlzLmVsQXhpc0FyZWEgPSBlbDtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZXNpemUgYXhpcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgYXhpcyBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihib3VuZCwgZGF0YSkge1xuICAgICAgICB0aGlzLmVsQXhpc0FyZWEuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMuX3JlbmRlckF4aXNBcmVhKHRoaXMuZWxBeGlzQXJlYSwgYm91bmQsIGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgY3NzIHN0eWxlIG9mIHRpdGxlIGFyZWFcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRpdGxlQXJlYSB0aXRsZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUG9zaXRpb25SaWdodCB3aGV0aGVyIHJpZ2h0IHBvc2l0aW9uIG9yIG5vdD9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUaXRsZUFyZWFTdHlsZTogZnVuY3Rpb24oZWxUaXRsZUFyZWEsIHNpemUsIGlzUG9zaXRpb25SaWdodCkge1xuICAgICAgICB2YXIgY3NzVGV4dHMgPSBbXG4gICAgICAgICAgICByZW5kZXJVdGlsLmNvbmNhdFN0cignd2lkdGg6Jywgc2l6ZSwgJ3B4JylcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoaXNQb3NpdGlvblJpZ2h0KSB7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHJlbmRlclV0aWwuY29uY2F0U3RyKCdyaWdodDonLCAtc2l6ZSwgJ3B4JykpO1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cigndG9wOicsIDAsICdweCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2gocmVuZGVyVXRpbC5jb25jYXRTdHIoJ2xlZnQ6JywgMCwgJ3B4JykpO1xuICAgICAgICAgICAgaWYgKCFyZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpKSB7XG4gICAgICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cigndG9wOicsIHNpemUsICdweCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsVGl0bGVBcmVhLnN0eWxlLmNzc1RleHQgKz0gJzsnICsgY3NzVGV4dHMuam9pbignOycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaXRsZSBhcmVhIHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnRpdGxlIGF4aXMgdGl0bGVcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgdGl0bGUgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3Q/XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1Bvc2l0aW9uUmlnaHQgd2hldGhlciByaWdodCBwb3NpdGlvbiBvciBub3Q/XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRpdGxlIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUaXRsZUFyZWE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgZWxUaXRsZUFyZWEgPSByZW5kZXJVdGlsLnJlbmRlclRpdGxlKHBhcmFtcy50aXRsZSwgcGFyYW1zLnRoZW1lLCAndHVpLWNoYXJ0LXRpdGxlLWFyZWEnKTtcblxuICAgICAgICBpZiAoZWxUaXRsZUFyZWEgJiYgcGFyYW1zLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRpdGxlQXJlYVN0eWxlKGVsVGl0bGVBcmVhLCBwYXJhbXMuc2l6ZSwgcGFyYW1zLmlzUG9zaXRpb25SaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxUaXRsZUFyZWE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZG5lciB0aWNrIGFyZWEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgc2l6ZSBvciBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRpY2sgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyVGlja0FyZWE6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0aWNrQ291bnQgPSBkYXRhLnRpY2tDb3VudCxcbiAgICAgICAgICAgIHRpY2tDb2xvciA9IHRoaXMudGhlbWUudGlja0NvbG9yLFxuICAgICAgICAgICAgcG9zaXRpb25zID0gY2FsY3VsYXRvci5tYWtlVGlja1BpeGVsUG9zaXRpb25zKHNpemUsIHRpY2tDb3VudCksXG4gICAgICAgICAgICBlbFRpY2tBcmVhID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC10aWNrLWFyZWEnKSxcbiAgICAgICAgICAgIHBvc1R5cGUgPSBkYXRhLmlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yVHlwZSA9IGRhdGEuaXNWZXJ0aWNhbCA/IChkYXRhLmlzUG9zaXRpb25SaWdodCA/ICdib3JkZXJMZWZ0Q29sb3InIDogJ2JvcmRlclJpZ2h0Q29sb3InKSA6ICdib3JkZXJUb3BDb2xvcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IGF4aXNUZW1wbGF0ZS50cGxBeGlzVGljayxcbiAgICAgICAgICAgIHRpY2tzSHRtbCA9IHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjc3NUZXh0O1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmFsaWduZWQgJiYgZGF0YS5sYWJlbHNbaW5kZXhdID09PSBjaGFydENvbnN0LkVNUFRZX0FYSVNfTEFCRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjc3NUZXh0ID0gW1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJVdGlsLmNvbmNhdFN0cignYmFja2dyb3VuZC1jb2xvcjonLCB0aWNrQ29sb3IpLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJVdGlsLmNvbmNhdFN0cihwb3NUeXBlLCAnOiAnLCBwb3NpdGlvbiwgJ3B4JylcbiAgICAgICAgICAgICAgICBdLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUoe2Nzc1RleHQ6IGNzc1RleHR9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpLmpvaW4oJycpO1xuXG4gICAgICAgIGVsVGlja0FyZWEuaW5uZXJIVE1MID0gdGlja3NIdG1sO1xuICAgICAgICBlbFRpY2tBcmVhLnN0eWxlW2JvcmRlckNvbG9yVHlwZV0gPSB0aWNrQ29sb3I7XG5cbiAgICAgICAgcmV0dXJuIGVsVGlja0FyZWE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgY3NzVGV4dCBvZiB2ZXJ0aWNhbCBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc1dpZHRoIGF4aXMgd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGl0bGVBcmVhV2lkdGggdGl0bGUgYXJlYSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNzc1RleHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxMYWJlbENzc1RleHQ6IGZ1bmN0aW9uKGF4aXNXaWR0aCwgdGl0bGVBcmVhV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuICc7d2lkdGg6JyArIChheGlzV2lkdGggLSB0aXRsZUFyZWFXaWR0aCArIGNoYXJ0Q29uc3QuVl9MQUJFTF9SSUdIVF9QQURESU5HKSArICdweCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBsYWJlbCBhcmVhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgbGFiZWwgYXJlYSBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNXaWR0aCBheGlzIGFyZWEgd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIHJvdGF0aW9uIGRlZ3JlZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGFiZWxBcmVhOiBmdW5jdGlvbihkYXRhLCBzaXplLCBheGlzV2lkdGgsIGRlZ3JlZSkge1xuICAgICAgICB2YXIgdGlja1BpeGVsUG9zaXRpb25zID0gY2FsY3VsYXRvci5tYWtlVGlja1BpeGVsUG9zaXRpb25zKHNpemUsIGRhdGEudGlja0NvdW50KSxcbiAgICAgICAgICAgIGxhYmVsU2l6ZSA9IHRpY2tQaXhlbFBvc2l0aW9uc1sxXSAtIHRpY2tQaXhlbFBvc2l0aW9uc1swXSxcbiAgICAgICAgICAgIHBvc1R5cGUgPSAnbGVmdCcsXG4gICAgICAgICAgICBjc3NUZXh0cyA9IHRoaXMuX21ha2VMYWJlbENzc1RleHRzKHtcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiBkYXRhLmlzVmVydGljYWwsXG4gICAgICAgICAgICAgICAgaXNMYWJlbEF4aXM6IGRhdGEuaXNMYWJlbEF4aXMsXG4gICAgICAgICAgICAgICAgbGFiZWxTaXplOiBsYWJlbFNpemVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZWxMYWJlbEFyZWEgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LWxhYmVsLWFyZWEnKSxcbiAgICAgICAgICAgIGFyZWFDc3NUZXh0ID0gcmVuZGVyVXRpbC5tYWtlRm9udENzc1RleHQodGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBsYWJlbHNIdG1sLCB0aXRsZUFyZWFXaWR0aDtcblxuICAgICAgICBpZiAoZGF0YS5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBwb3NUeXBlID0gZGF0YS5pc0xhYmVsQXhpcyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICAgICAgICB0aXRsZUFyZWFXaWR0aCA9IHRoaXMuX2dldFJlbmRlcmVkVGl0bGVIZWlnaHQoKSArIGNoYXJ0Q29uc3QuVElUTEVfQVJFQV9XSURUSF9QQURESU5HO1xuICAgICAgICAgICAgYXJlYUNzc1RleHQgKz0gdGhpcy5fbWFrZVZlcnRpY2FsTGFiZWxDc3NUZXh0KGF4aXNXaWR0aCwgdGl0bGVBcmVhV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlja1BpeGVsUG9zaXRpb25zLmxlbmd0aCA9IGRhdGEubGFiZWxzLmxlbmd0aDtcblxuICAgICAgICBsYWJlbHNIdG1sID0gdGhpcy5fbWFrZUxhYmVsc0h0bWwoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiB0aWNrUGl4ZWxQb3NpdGlvbnMsXG4gICAgICAgICAgICBsYWJlbHM6IGRhdGEubGFiZWxzLFxuICAgICAgICAgICAgcG9zVHlwZTogcG9zVHlwZSxcbiAgICAgICAgICAgIGNzc1RleHRzOiBjc3NUZXh0cyxcbiAgICAgICAgICAgIGxhYmVsU2l6ZTogbGFiZWxTaXplLFxuICAgICAgICAgICAgZGVncmVlOiBkZWdyZWUsXG4gICAgICAgICAgICB0aGVtZTogdGhpcy50aGVtZS5sYWJlbFxuICAgICAgICB9KTtcblxuICAgICAgICBlbExhYmVsQXJlYS5pbm5lckhUTUwgPSBsYWJlbHNIdG1sO1xuICAgICAgICBlbExhYmVsQXJlYS5zdHlsZS5jc3NUZXh0ID0gYXJlYUNzc1RleHQ7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlTGFiZWxBcmVhUG9zaXRpb24oe1xuICAgICAgICAgICAgZWxMYWJlbEFyZWE6IGVsTGFiZWxBcmVhLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogZGF0YS5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgaXNMYWJlbEF4aXM6IGRhdGEuaXNMYWJlbEF4aXMsXG4gICAgICAgICAgICB0aGVtZTogdGhpcy50aGVtZS5sYWJlbCxcbiAgICAgICAgICAgIGxhYmVsU2l6ZTogbGFiZWxTaXplLFxuICAgICAgICAgICAgYWxpZ25lZDogZGF0YS5hbGlnbmVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbExhYmVsQXJlYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGhlaWdodCBvZiB0aXRsZSBhcmVhIDtcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSZW5kZXJlZFRpdGxlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLnRoZW1lLnRpdGxlLFxuICAgICAgICAgICAgcmVzdWx0ID0gdGl0bGUgPyByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQodGl0bGUsIHRoZW1lKSA6IDA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgY3NzVGV4dHMgb2YgbGFiZWwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzTGFiZWxBeGlzIHdoZXRoZXIgbGFiZWwgYXhpcyBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxTaXplIGxhYmVsIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGNzc1RleHRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsQ3NzVGV4dHM6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgY3NzVGV4dHMgPSBbXTtcblxuICAgICAgICBpZiAocGFyYW1zLmlzVmVydGljYWwgJiYgcGFyYW1zLmlzTGFiZWxBeGlzKSB7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHJlbmRlclV0aWwuY29uY2F0U3RyKCdoZWlnaHQ6JywgcGFyYW1zLmxhYmVsU2l6ZSwgJ3B4JykpO1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cignbGluZS1oZWlnaHQ6JywgcGFyYW1zLmxhYmVsU2l6ZSwgJ3B4JykpO1xuICAgICAgICB9IGVsc2UgaWYgKCFwYXJhbXMuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cignd2lkdGg6JywgcGFyYW1zLmxhYmVsU2l6ZSwgJ3B4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNzc1RleHRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxjdWxhdGUgcm90YXRpb24gbW92aW5nIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5kZWdyZWUgcm90YXRpb24gZGVncmVlXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sZWZ0IG5vcm1hbCBsZWZ0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1vdmVMZWZ0IG1vdmUgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50b3AgdG9wXG4gICAgICogQHJldHVybnMge3t0b3A6bnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVJvdGF0aW9uTW92aW5nUG9zaXRpb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbW92ZUxlZnQgPSBwYXJhbXMubW92ZUxlZnQ7XG4gICAgICAgIGlmIChwYXJhbXMuZGVncmVlID09PSBjaGFydENvbnN0LkFOR0xFXzg1KSB7XG4gICAgICAgICAgICBtb3ZlTGVmdCArPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGNoYXJ0Q29uc3QuQU5HTEVfOTAgLSBwYXJhbXMuZGVncmVlLCBwYXJhbXMubGFiZWxIZWlnaHQgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHBhcmFtcy50b3AsXG4gICAgICAgICAgICBsZWZ0OiBwYXJhbXMubGVmdCAtIG1vdmVMZWZ0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGN1bGF0ZSByb3RhdGlvbiBtb3ZpbmcgcG9zaXRpb24gZm9yIGllOC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZGVncmVlIHJvdGF0aW9uIGRlZ3JlZVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbFdpZHRoIGxhYmVsIHdpZHRoXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sZWZ0IG5vcm1hbCBsZWZ0XG4gICAgICogICAgICBAcGFyYW0geyhzdHJpbmcgfCBudW1iZXIpfSBwYXJhbXMubGFiZWwgbGFiZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHt7dG9wOm51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVSb3RhdGlvbk1vdmluZ1Bvc2l0aW9uRm9ySUU4OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChwYXJhbXMubGFiZWwsIHBhcmFtcy50aGVtZSksXG4gICAgICAgICAgICBzbWFsbEFyZWFXaWR0aCA9IGNhbGN1bGF0b3IuY2FsY3VsYXRlQWRqYWNlbnQoY2hhcnRDb25zdC5BTkdMRV85MCAtIHBhcmFtcy5kZWdyZWUsIHBhcmFtcy5sYWJlbEhlaWdodCAvIDIpLFxuICAgICAgICAgICAgbmV3TGFiZWxXaWR0aCA9IChjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KHBhcmFtcy5kZWdyZWUsIGxhYmVsV2lkdGggLyAyKSArIHNtYWxsQXJlYVdpZHRoKSAqIDIsXG4gICAgICAgICAgICBjb2xsZWN0TGVmdCA9IGxhYmVsV2lkdGggLSBuZXdMYWJlbFdpZHRoLFxuICAgICAgICAgICAgbW92ZUxlZnQgPSAocGFyYW1zLmxhYmVsV2lkdGggLyAyKSAtIChzbWFsbEFyZWFXaWR0aCAqIDIpO1xuXG4gICAgICAgIGlmIChwYXJhbXMuZGVncmVlID09PSBjaGFydENvbnN0LkFOR0xFXzg1KSB7XG4gICAgICAgICAgICBtb3ZlTGVmdCArPSBzbWFsbEFyZWFXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IGNoYXJ0Q29uc3QuWEFYSVNfTEFCRUxfVE9QX01BUkdJTixcbiAgICAgICAgICAgIGxlZnQ6IHBhcmFtcy5sZWZ0ICsgY29sbGVjdExlZnQgLSBtb3ZlTGVmdFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGNzc1RleHQgZm9yIHJvdGF0aW9uIG1vdmluZy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZGVncmVlIHJvdGF0aW9uIGRlZ3JlZVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbFdpZHRoIGxhYmVsIHdpZHRoXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sZWZ0IG5vcm1hbCBsZWZ0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1vdmVMZWZ0IG1vdmUgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50b3AgdG9wXG4gICAgICogICAgICBAcGFyYW0geyhzdHJpbmcgfCBudW1iZXIpfSBwYXJhbXMubGFiZWwgbGFiZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNzc1RleHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ3NzVGV4dEZvclJvdGF0aW9uTW92aW5nOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uO1xuICAgICAgICBpZiAocmVuZGVyVXRpbC5pc09sZEJyb3dzZXIoKSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVSb3RhdGlvbk1vdmluZ1Bvc2l0aW9uRm9ySUU4KHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZVJvdGF0aW9uTW92aW5nUG9zaXRpb24ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyVXRpbC5jb25jYXRTdHIoJ2xlZnQ6JywgcG9zaXRpb24ubGVmdCwgJ3B4JywgJzt0b3A6JywgcG9zaXRpb24udG9wLCAncHgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBodG1sIG9mIHJvdGF0aW9uIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IHBhcmFtcy5wb3NpdGlvbnMgbGFiZWwgcG9zaXRpb24gYXJyYXlcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5sYWJlbHMgbGFiZWwgYXJyYXlcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucG9zVHlwZSBwb3NpdGlvbiB0eXBlIChsZWZ0IG9yIGJvdHRvbSlcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5jc3NUZXh0cyBjc3MgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsYWJlbHMgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VSb3RhdGlvbkxhYmVsc0h0bWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBheGlzVGVtcGxhdGUudHBsQXhpc0xhYmVsLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQocGFyYW1zLmxhYmVsc1swXSwgcGFyYW1zLnRoZW1lKSxcbiAgICAgICAgICAgIGxhYmVsQ3NzVGV4dCA9IHBhcmFtcy5jc3NUZXh0cy5sZW5ndGggPyBwYXJhbXMuY3NzVGV4dHMuam9pbignOycpICsgJzsnIDogJycsXG4gICAgICAgICAgICBhZGRDbGFzcyA9ICcgcm90YXRpb24nICsgcGFyYW1zLmRlZ3JlZSxcbiAgICAgICAgICAgIGhhbGZXaWR0aCA9IHBhcmFtcy5sYWJlbFNpemUgLyAyLFxuICAgICAgICAgICAgbW92ZUxlZnQgPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KHBhcmFtcy5kZWdyZWUsIGhhbGZXaWR0aCksXG4gICAgICAgICAgICB0b3AgPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZU9wcG9zaXRlKHBhcmFtcy5kZWdyZWUsIGhhbGZXaWR0aCkgKyBjaGFydENvbnN0LlhBWElTX0xBQkVMX1RPUF9NQVJHSU4sXG4gICAgICAgICAgICBsYWJlbHNIdG1sID0gdHVpLnV0aWwubWFwKHBhcmFtcy5wb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHBhcmFtcy5sYWJlbHNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbkNzc1RleHQgPSB0aGlzLl9tYWtlQ3NzVGV4dEZvclJvdGF0aW9uTW92aW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZ3JlZTogcGFyYW1zLmRlZ3JlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0OiBsYWJlbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsV2lkdGg6IHBhcmFtcy5sYWJlbFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZUxlZnQ6IG1vdmVMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6IHBhcmFtcy50aGVtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogbGFiZWxDc3NUZXh0ICsgcm90YXRpb25Dc3NUZXh0LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiBsYWJlbHNIdG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGh0bWwgb2Ygbm9ybWFsIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IHBhcmFtcy5wb3NpdGlvbnMgbGFiZWwgcG9zaXRpb24gYXJyYXlcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5sYWJlbHMgbGFiZWwgYXJyYXlcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucG9zVHlwZSBwb3NpdGlvbiB0eXBlIChsZWZ0IG9yIGJvdHRvbSlcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5jc3NUZXh0cyBjc3MgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsYWJlbHMgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxMYWJlbHNIdG1sOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gYXhpc1RlbXBsYXRlLnRwbEF4aXNMYWJlbCxcbiAgICAgICAgICAgIGxhYmVsQ3NzVGV4dCA9IHBhcmFtcy5jc3NUZXh0cy5sZW5ndGggPyBwYXJhbXMuY3NzVGV4dHMuam9pbignOycpICsgJzsnIDogJycsXG4gICAgICAgICAgICBsYWJlbHNIdG1sID0gdHVpLnV0aWwubWFwKHBhcmFtcy5wb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBhZGRDc3NUZXh0ID0gcmVuZGVyVXRpbC5jb25jYXRTdHIocGFyYW1zLnBvc1R5cGUsICc6JywgcG9zaXRpb24sICdweCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogbGFiZWxDc3NUZXh0ICsgYWRkQ3NzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHBhcmFtcy5sYWJlbHNbaW5kZXhdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsc0h0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgaHRtbCBvZiBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxvYmplY3Q+fSBwYXJhbXMucG9zaXRpb25zIGxhYmVsIHBvc2l0aW9uIGFycmF5XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMubGFiZWxzIGxhYmVsIGFycmF5XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBvc1R5cGUgcG9zaXRpb24gdHlwZSAobGVmdCBvciBib3R0b20pXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuY3NzVGV4dHMgY3NzIGFycmF5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gbGFiZWxzIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzSHRtbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsYWJlbHNIdG1sO1xuICAgICAgICBpZiAocGFyYW1zLmRlZ3JlZSkge1xuICAgICAgICAgICAgbGFiZWxzSHRtbCA9IHRoaXMuX21ha2VSb3RhdGlvbkxhYmVsc0h0bWwocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsc0h0bWwgPSB0aGlzLl9tYWtlTm9ybWFsTGFiZWxzSHRtbChwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsc0h0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBwb3NpdGlvbiBvZiBsYWJlbCBhcmVhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyXG4gICAgICogICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJhbXMuZWxMYWJlbEFyZWEgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc0xhYmVsQXhpcyB3aGV0aGVyIGxhYmVsIGF4aXMgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSBwYXJhbXMudGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxTaXplIGxhYmVsIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGFuZ2VMYWJlbEFyZWFQb3NpdGlvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodDtcblxuICAgICAgICBpZiAocGFyYW1zLmlzTGFiZWxBeGlzICYmICFwYXJhbXMuYWxpZ25lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodCgnQUJDJywgcGFyYW1zLnRoZW1lKTtcbiAgICAgICAgICAgIHBhcmFtcy5lbExhYmVsQXJlYS5zdHlsZS50b3AgPSByZW5kZXJVdGlsLmNvbmNhdFN0cihwYXJzZUludChsYWJlbEhlaWdodCAvIDIsIDEwKSwgJ3B4Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMuZWxMYWJlbEFyZWEuc3R5bGUubGVmdCA9IHJlbmRlclV0aWwuY29uY2F0U3RyKCctJywgcGFyc2VJbnQocGFyYW1zLmxhYmVsU2l6ZSAvIDIsIDEwKSwgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgdGVtcGxhdGVzIG9yIGF4aXMgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbnZhciB0ZW1wbGF0ZU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy90ZW1wbGF0ZU1ha2VyJyk7XG5cbnZhciB0YWdzID0ge1xuICAgIEhUTUxfQVhJU19USUNLOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC10aWNrXCIgc3R5bGU9XCJ7eyBjc3NUZXh0IH19XCI+PC9kaXY+JyxcbiAgICBIVE1MX0FYSVNfTEFCRUw6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWxhYmVse3sgYWRkQ2xhc3MgfX1cIiBzdHlsZT1cInt7IGNzc1RleHQgfX1cIj48c3Bhbj57eyBsYWJlbCB9fTwvc3Bhbj48L2Rpdj4nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0cGxBeGlzVGljazogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZSh0YWdzLkhUTUxfQVhJU19USUNLKSxcbiAgICB0cGxBeGlzTGFiZWw6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUodGFncy5IVE1MX0FYSVNfTEFCRUwpXG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGNoYXJ0LmpzIGlzIGVudHJ5IHBvaW50IG9mIFRvYXN0IFVJIENoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuL2NvbnN0JyksXG4gICAgY2hhcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3JpZXMvY2hhcnRGYWN0b3J5JyksXG4gICAgcGx1Z2luRmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzL3BsdWdpbkZhY3RvcnknKSxcbiAgICB0aGVtZUZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3Rvcmllcy90aGVtZUZhY3RvcnknKTtcblxudmFyIF9jcmVhdGVDaGFydDtcblxucmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xucmVxdWlyZSgnLi9jb2RlLXNuaXBwZXQtdXRpbCcpO1xucmVxdWlyZSgnLi9yZWdpc3RlckNoYXJ0cycpO1xucmVxdWlyZSgnLi9yZWdpc3RlclRoZW1lcycpO1xuXG4vKipcbiAqIE5ITiBFbnRlcnRhaW5tZW50IFRvYXN0IFVJIENoYXJ0LlxuICogQG5hbWVzcGFjZSB0dWkuY2hhcnRcbiAqL1xudHVpLnV0aWwuZGVmaW5lTmFtZXNwYWNlKCd0dWkuY2hhcnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgY2hhcnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyXG4gKiBAcGFyYW0ge2FycmF5LjxhcnJheT59IGRhdGEgY2hhcnQgZGF0YVxuICogQHBhcmFtIHt7XG4gKiAgIGNoYXJ0OiB7XG4gKiAgICAgd2lkdGg6IG51bWJlcixcbiAqICAgICBoZWlnaHQ6IG51bWJlcixcbiAqICAgICB0aXRsZTogc3RyaW5nLFxuICogICAgIGZvcm1hdDogc3RyaW5nXG4gKiAgIH0sXG4gKiAgIHlBeGlzOiB7XG4gKiAgICAgdGl0bGU6IHN0cmluZyxcbiAqICAgICBtaW46IG51bWJlclxuICogICB9LFxuICogICB4QXhpczoge1xuICogICAgIHRpdGxlOiBzdHJpZyxcbiAqICAgICBtaW46IG51bWJlclxuICogICB9LFxuICogICB0b29sdGlwOiB7XG4gKiAgICAgc3VmZml4OiBzdHJpbmcsXG4gKiAgICAgdGVtcGxhdGU6IHN0cmluZ1xuICogICB9LFxuICogICB0aGVtZTogc3RyaW5nXG4gKiB9fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IGNoYXJ0IGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqIEBpZ25vcmVcbiAqL1xuX2NyZWF0ZUNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoZW1lTmFtZSwgdGhlbWUsIGNoYXJ0O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoZW1lTmFtZSA9IG9wdGlvbnMudGhlbWUgfHwgY2hhcnRDb25zdC5ERUZBVUxUX1RIRU1FX05BTUU7XG4gICAgdGhlbWUgPSB0aGVtZUZhY3RvcnkuZ2V0KHRoZW1lTmFtZSk7XG5cbiAgICBjaGFydCA9IGNoYXJ0RmFjdG9yeS5nZXQob3B0aW9ucy5jaGFydFR5cGUsIGRhdGEsIHRoZW1lLCBvcHRpb25zKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hhcnQucmVuZGVyKCkpO1xuICAgIGNoYXJ0LmFuaW1hdGVDaGFydCgpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxuLyoqXG4gKiBCYXIgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGNoYXJ0IGRhdGFcbiAqICAgICAgQHBhcmFtIHthcnJheS48c3RyaW5nPn0gZGF0YS5jYXRlZ29yaWVzIGNhdGVnb3JpZXNcbiAqICAgICAgQHBhcmFtIHthcnJheS48YXJyYXk+fSBkYXRhLnNlcmllcyBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCBjaGFydCBvcHRpb25zXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LmZvcm1hdCB2YWx1ZSBmb3JtYXRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueUF4aXMgb3B0aW9ucyBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55QXhpcy50aXRsZSB0aXRsZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5sYWJlbEludGVydmFsIGxhYmVsIGludGVydmFsIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueEF4aXMgb3B0aW9ucyBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnhBeGlzLnRpdGxlIHRpdGxlIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubWluIG1pbmltYWwgdmFsdWUgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5tYXggbWF4aW11bSB2YWx1ZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIG9wdGlvbnMgb2Ygc2VyaWVzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zZXJpZXMuc3RhY2tlZCBzdGFja2VkIHR5cGVcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNlcmllcy5iYXJXaWR0aCBiYXIgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzU2VsZWN0aW9uIHdoZXRoZXIgaGFzIHNlbGVjdGlvbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlIHRlbXBsYXRlIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gdG9vbHRpcCBhbGlnbiBvcHRpb25cbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCB3aGV0aGVyIGdyb3VwIHRvb2x0aXAgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCBvcHRpb25zIG9mIGxlZ2VuZFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIGxlZ2VuZCBhbGlnblxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aGVtZSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgZ3JhcGggbGlicmFyeSB0eXBlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgY2hhcnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIGRhdGEgPSB7XG4gKiAgICAgICBjYXRlZ29yaWVzOiBbJ2NhdGUxJywgJ2NhdGUyJywgJ2NhdGUzJ10sXG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICBkYXRhOiBbMjAsIDMwLCA1MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICBkYXRhOiBbNDAsIDQwLCA2MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQzJyxcbiAqICAgICAgICAgICBkYXRhOiBbNjAsIDUwLCAxMF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQ0JyxcbiAqICAgICAgICAgICBkYXRhOiBbODAsIDEwLCA3MF1cbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnQmFyIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIHlBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWSBBeGlzJ1xuICogICAgICAgfSxcbiAqICAgICAgIHhBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWCBBeGlzJ1xuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQuYmFyQ2hhcnQoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LmJhckNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQkFSO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29sdW1uIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gKiAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGRhdGEuY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gZGF0YS5zZXJpZXMgc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgY2hhcnQgb3B0aW9uc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC5mb3JtYXQgdmFsdWUgZm9ybWF0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIG9wdGlvbnMgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgdGl0bGUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWluIG1pbmltYWwgdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWF4IG1heGltdW0gdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy54QXhpcyBvcHRpb25zIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGl0bGUgdGl0bGUgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5sYWJlbEludGVydmFsIGxhYmVsIGludGVydmFsIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgb3B0aW9ucyBvZiBzZXJpZXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnNlcmllcy5zdGFja2VkIHN0YWNrZWQgdHlwZVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaG93TGFiZWwgd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2VyaWVzLmJhcldpZHRoIGJhciB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5oYXNTZWxlY3Rpb24gd2hldGhlciBoYXMgc2VsZWN0aW9uIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIG9wdGlvbnMgb2YgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggc3VmZml4IG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAudGVtcGxhdGUgdGVtcGxhdGUgb2YgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5hbGlnbiB0b29sdGlwIGFsaWduIG9wdGlvblxuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbiByZWxhdGl2ZSBwb3NpdGlvblxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24ubGVmdCBwb3NpdGlvbiBsZWZ0XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi50b3AgcG9zaXRpb24gdG9wXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudG9vbHRpcC5ncm91cGVkIHdoZXRoZXIgZ3JvdXAgdG9vbHRpcCBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIG9wdGlvbnMgb2YgbGVnZW5kXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gbGVnZW5kIGFsaWduXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGNvbHVtbiBjaGFydFxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgZGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IFs4MCwgMTAsIDcwXVxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdDb2x1bW4gQ2hhcnQnXG4gKiAgICAgICB9LFxuICogICAgICAgeUF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdZIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5jb2x1bW5DaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQuY29sdW1uQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT0xVTU47XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBMaW5lIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gKiAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGRhdGEuY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gZGF0YS5zZXJpZXMgc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgY2hhcnQgb3B0aW9uc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC5mb3JtYXQgdmFsdWUgZm9ybWF0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIG9wdGlvbnMgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgdGl0bGUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWluIG1pbmltYWwgdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWF4IG1heGltdW0gdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy54QXhpcyBvcHRpb25zIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGl0bGUgdGl0bGUgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5sYWJlbEludGVydmFsIGxhYmVsIGludGVydmFsIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgb3B0aW9ucyBvZiBzZXJpZXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzRG90IHdoZXRoZXIgaGFzIGRvdCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzU2VsZWN0aW9uIHdoZXRoZXIgaGFzIHNlbGVjdGlvbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlIHRlbXBsYXRlIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gdG9vbHRpcCBhbGlnbiBvcHRpb25cbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCB3aGV0aGVyIGdyb3VwIHRvb2x0aXAgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCBvcHRpb25zIG9mIGxlZ2VuZFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIGxlZ2VuZCBhbGlnblxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aGVtZSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgZ3JhcGggbGlicmFyeSB0eXBlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgY2hhcnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIGRhdGEgPSB7XG4gKiAgICAgICBjYXRlZ29yaWVzOiBbJ2NhdGUxJywgJ2NhdGUyJywgJ2NhdGUzJ10sXG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICBkYXRhOiBbMjAsIDMwLCA1MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICBkYXRhOiBbNDAsIDQwLCA2MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQzJyxcbiAqICAgICAgICAgICBkYXRhOiBbNjAsIDUwLCAxMF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQ0JyxcbiAqICAgICAgICAgICBkYXRhOiBbODAsIDEwLCA3MF1cbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnTGluZSBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICB5QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1kgQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICB4QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1ggQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICBzZXJpZXM6IHtcbiAqICAgICAgICAgaGFzRG90OiB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5saW5lQ2hhcnQoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0LmxpbmVDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0xJTkU7XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBcmVhIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gKiAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGRhdGEuY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gZGF0YS5zZXJpZXMgc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgY2hhcnQgb3B0aW9uc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC5mb3JtYXQgdmFsdWUgZm9ybWF0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIG9wdGlvbnMgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgdGl0bGUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWluIG1pbmltYWwgdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWF4IG1heGltdW0gdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy54QXhpcyBvcHRpb25zIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGl0bGUgdGl0bGUgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5sYWJlbEludGVydmFsIGxhYmVsIGludGVydmFsIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgb3B0aW9ucyBvZiBzZXJpZXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzRG90IHdoZXRoZXIgaGFzIGRvdCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzU2VsZWN0aW9uIHdoZXRoZXIgaGFzIHNlbGVjdGlvbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlIHRlbXBsYXRlIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gdG9vbHRpcCBhbGlnbiBvcHRpb25cbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCB3aGV0aGVyIGdyb3VwIHRvb2x0aXAgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCBvcHRpb25zIG9mIGxlZ2VuZFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIGxlZ2VuZCBhbGlnblxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aGVtZSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgZ3JhcGggbGlicmFyeSB0eXBlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgY2hhcnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIGRhdGEgPSB7XG4gKiAgICAgICBjYXRlZ29yaWVzOiBbJ2NhdGUxJywgJ2NhdGUyJywgJ2NhdGUzJ10sXG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICBkYXRhOiBbMjAsIDMwLCA1MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICBkYXRhOiBbNDAsIDQwLCA2MF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQzJyxcbiAqICAgICAgICAgICBkYXRhOiBbNjAsIDUwLCAxMF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQ0JyxcbiAqICAgICAgICAgICBkYXRhOiBbODAsIDEwLCA3MF1cbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnQXJlYSBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICB5QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1kgQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICB4QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1ggQXhpcydcbiAqICAgICAgIH1cbiAqICAgICB9O1xuICogdHVpLmNoYXJ0LmFyZWFDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQuYXJlYUNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQVJFQTtcbiAgICByZXR1cm4gX2NyZWF0ZUNoYXJ0KGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbWJvIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gKiAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGRhdGEuY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gZGF0YS5zZXJpZXMgc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgY2hhcnQgb3B0aW9uc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC5mb3JtYXQgdmFsdWUgZm9ybWF0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0W119IG9wdGlvbnMueUF4aXMgb3B0aW9ucyBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55QXhpc1tdLnRpdGxlIHRpdGxlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzW10ubWluIG1pbmltYWwgdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXNbXS5tYXggbWF4aW11bSB2YWx1ZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIG9wdGlvbnMgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aXRsZSB0aXRsZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLmxhYmVsSW50ZXJ2YWwgbGFiZWwgaW50ZXJ2YWwgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyBvcHRpb25zIG9mIHNlcmllc1xuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzLmNvbHVtbiBvcHRpb25zIG9mIGNvbHVtbiBzZXJpZXNcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zZXJpZXMuY29sdW1uLnN0YWNrZWQgc3RhY2tlZCB0eXBlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5jb2x1bW4uc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZXJpZXMuY29sdW1uLmJhcldpZHRoIGJhciB3aWR0aFxuICogICAgICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuY29sdW1uLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMubGluZSBvcHRpb25zIG9mIGxpbmUgc2VyaWVzXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLmhhc0RvdCB3aGV0aGVyIGhhcyBkb3Qgb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAgb3B0aW9ucyBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLmNvbHVtbiBvcHRpb25zIG9mIGNvbHVtbiB0b29sdGlwXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4uc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4udGVtcGxhdGUgdGVtcGxhdGUgb2YgdG9vbHRpcFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuY29sdW1uLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4ucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4ucG9zaXRpb24ubGVmdCBwb3NpdGlvbiBsZWZ0XG4gKiAgICAgICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAuY29sdW1uLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ25cbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIGdyYXBoIGxpYnJhcnkgdHlwZVxuICogQHJldHVybnMge29iamVjdH0gYmFyIGNoYXJ0XG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICBkYXRhID0ge1xuICogICAgICAgY2F0ZWdvcmllczogWydjYXRlMScsICdjYXRlMicsICdjYXRlMyddLFxuICogICAgICAgc2VyaWVzOiB7XG4gKiAgICAgICAgIGNvbHVtbjogW1xuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXV1cbiAqICAgICAgICAgICB9LFxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdMZWdlbmQyJyxcbiAqICAgICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICAgIH0sXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgICAgZGF0YTogWzYwLCA1MCwgMTBdXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnTGVnZW5kNCcsXG4gKiAgICAgICAgICAgICBkYXRhOiBbODAsIDEwLCA3MF1cbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIGxpbmU6IFtcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnTGVnZW5kNScsXG4gKiAgICAgICAgICAgICBkYXRhOiBbMSwgMiwgM11cbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgIF1cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ0NvbWJvIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIHlBeGlzOltcbiAqICAgICAgICAge1xuICogICAgICAgICAgIHRpdGxlOiAnWSBBeGlzJyxcbiAqICAgICAgICAgICBjaGFydFR5cGU6ICdsaW5lJ1xuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgdGl0bGU6ICdZIFJpZ2h0IEF4aXMnXG4gKiAgICAgICAgIH1cbiAqICAgICAgIF0sXG4gKiAgICAgICB4QXhpczoge1xuICogICAgICAgICB0aXRsZTogJ1ggQXhpcydcbiAqICAgICAgIH0sXG4gKiAgICAgICBzZXJpZXM6IHtcbiAqICAgICAgICAgaGFzRG90OiB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5jb21ib0NoYXJ0KGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5jb21ib0NoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfQ09NQk87XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQaWUgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGNoYXJ0IGRhdGFcbiAqICAgICAgQHBhcmFtIHthcnJheS48YXJyYXk+fSBkYXRhLnNlcmllcyBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCBjaGFydCBvcHRpb25zXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LmZvcm1hdCB2YWx1ZSBmb3JtYXRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIG9wdGlvbnMgb2Ygc2VyaWVzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAgb3B0aW9ucyBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLnN1ZmZpeCBzdWZmaXggb2YgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC50ZW1wbGF0ZSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIG9wdGlvbnMgb2YgbGVnZW5kXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gbGVnZW5kIGFsaWduXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgZGF0YSA9IHtcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IDIwXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMicsXG4gKiAgICAgICAgICAgZGF0YTogNDBcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQzJyxcbiAqICAgICAgICAgICBkYXRhOiA2MFxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IDgwXG4gKiAgICAgICAgIH1cbiAqICAgICAgIF1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ1BpZSBDaGFydCdcbiAqICAgICAgIH1cbiAqICAgICB9O1xuICogdHVpLmNoYXJ0LnBpZUNoYXJ0KGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5waWVDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX1BJRTtcbiAgICByZXR1cm4gX2NyZWF0ZUNoYXJ0KGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZW1lLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lTmFtZSB0aGVtZSBuYW1lXG4gKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgYXBwbGljYXRpb24gY2hhcnQgdGhlbWVcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLmNoYXJ0IGNoYXJ0IHRoZW1lXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUuY2hhcnQuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLmNoYXJ0LmJhY2tncm91bmQgYmFja2dyb3VuZCBvZiBjaGFydFxuICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUudGl0bGUgY2hhcnQgdGhlbWVcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSB0aGVtZS50aXRsZS5mb250U2l6ZSBmb250IHNpemUgb2YgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS50aXRsZS5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUudGl0bGUuY29sb3IgZm9udCBjb2xvciBvZiBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnRpdGxlLmJhY2tncm91bmQgYmFja2dyb3VuZCBvZiBjaGFydCB0aXRsZVxuICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUueUF4aXMgdGhlbWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnlBeGlzLnRpdGxlIHRoZW1lIG9mIHZlcnRpY2FsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gdGhlbWUueUF4aXMudGl0bGUuZm9udFNpemUgZm9udCBzaXplIG9mIHZlcnRpY2FsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueUF4aXMudGl0bGUuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiB2ZXJ0aWNhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnlBeGlzLnRpdGxlLmNvbG9yIGZvbnQgY29sb3Igb2YgdmVydGljYWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnlBeGlzLmxhYmVsIHRoZW1lIG9mIHZlcnRpY2FsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gdGhlbWUueUF4aXMubGFiZWwuZm9udFNpemUgZm9udCBzaXplIG9mIHZlcnRpY2FsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueUF4aXMubGFiZWwuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiB2ZXJ0aWNhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnlBeGlzLmxhYmVsLmNvbG9yIGZvbnQgY29sb3Igb2YgdmVydGljYWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnlBeGlzLnRpY2tjb2xvciBjb2xvciBvZiB2ZXJ0aWNhbCBheGlzIHRpY2tcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnhBeGlzIHRoZW1lIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnhBeGlzLnRpdGxlIHRoZW1lIG9mIGhvcml6b250YWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSB0aGVtZS54QXhpcy50aXRsZS5mb250U2l6ZSBmb250IHNpemUgb2YgaG9yaXpvbnRhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnhBeGlzLnRpdGxlLmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgaG9yaXpvbnRhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnhBeGlzLnRpdGxlLmNvbG9yIGZvbnQgY29sb3Igb2YgaG9yaXpvbnRhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUueEF4aXMubGFiZWwgdGhlbWUgb2YgaG9yaXpvbnRhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLnhBeGlzLmxhYmVsLmZvbnRTaXplIGZvbnQgc2l6ZSBvZiBob3Jpem9udGFsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueEF4aXMubGFiZWwuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiBob3Jpem9udGFsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueEF4aXMubGFiZWwuY29sb3IgZm9udCBjb2xvciBvZiBob3Jpem9udGFsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS54QXhpcy50aWNrY29sb3IgY29sb3Igb2YgaG9yaXpvbnRhbCBheGlzIHRpY2tcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnBsb3QgcGxvdCB0aGVtZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnBsb3QubGluZUNvbG9yIHBsb3QgbGluZSBjb2xvclxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnBsb3QuYmFja2dyb3VuZCBwbG90IGJhY2tncm91bmRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnNlcmllcyBzZXJpZXMgdGhlbWVcbiAqICAgICAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IHRoZW1lLnNlcmllcy5jb2xvcnMgc2VyaWVzIGNvbG9yc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnNlcmllcy5ib3JkZXJDb2xvciBzZXJpZXMgYm9yZGVyIGNvbG9yXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5sZWdlbmQgbGVnZW5kIHRoZW1lXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUubGVnZW5kLmxhYmVsIHRoZW1lIG9mIGxlZ2VuZCBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSB0aGVtZS5sZWdlbmQubGFiZWwuZm9udFNpemUgZm9udCBzaXplIG9mIGxlZ2VuZCBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5sZWdlbmQubGFiZWwuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiBsZWdlbmQgbGFiZWxcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUubGVnZW5kLmxhYmVsLmNvbG9yIGZvbnQgY29sb3Igb2YgbGVnZW5kIGxhYmVsXG4gKiBAZXhhbXBsZVxuICogdmFyIHRoZW1lID0ge1xuICogICB5QXhpczoge1xuICogICAgIHRpY2tDb2xvcjogJyNjY2JkOWEnLFxuICogICAgICAgdGl0bGU6IHtcbiAqICAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICogICAgICAgfSxcbiAqICAgICAgIGxhYmVsOiB7XG4gKiAgICAgICAgIGNvbG9yOiAnIzZmNDkxZCdcbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHhBeGlzOiB7XG4gKiAgICAgICB0aWNrQ29sb3I6ICcjY2NiZDlhJyxcbiAqICAgICAgIHRpdGxlOiB7XG4gKiAgICAgICAgIGNvbG9yOiAnIzMzMzMzMydcbiAqICAgICAgIH0sXG4gKiAgICAgICBsYWJlbDoge1xuICogICAgICAgICBjb2xvcjogJyM2ZjQ5MWQnXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICBwbG90OiB7XG4gKiAgICAgICBsaW5lQ29sb3I6ICcjZTVkYmM0JyxcbiAqICAgICAgIGJhY2tncm91bmQ6ICcjZjZmMWU1J1xuICogICAgIH0sXG4gKiAgICAgc2VyaWVzOiB7XG4gKiAgICAgICBjb2xvcnM6IFsnIzQwYWJiNCcsICcjZTc4YTMxJywgJyNjMWM0NTInLCAnIzc5NTIyNCcsICcjZjVmNWY1J10sXG4gKiAgICAgICBib3JkZXJDb2xvcjogJyM4ZTY1MzUnLFxuICogICAgICAgc2VsZWN0aW9uQ29sb3I6ICcjY2NjY2NjJyxcbiAqICAgICB9LFxuICogICAgIGxlZ2VuZDoge1xuICogICAgICAgbGFiZWw6IHtcbiAqICAgICAgICAgY29sb3I6ICcjNmY0OTFkJ1xuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfTtcbiAqIGNoYXJ0LnJlZ2lzdGVyVGhlbWUoJ25ld1RoZW1lJywgdGhlbWUpO1xuICovXG50dWkuY2hhcnQucmVnaXN0ZXJUaGVtZSA9IGZ1bmN0aW9uKHRoZW1lTmFtZSwgdGhlbWUpIHtcbiAgICB0aGVtZUZhY3RvcnkucmVnaXN0ZXIodGhlbWVOYW1lLCB0aGVtZSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGdyYXBoIHBsdWdpbi5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaWJUeXBlIHR5cGUgb2YgZ3JhcGggbGlicmFyeVxuICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbiBwbHVnaW4gdG8gY29udHJvbCBsaWJyYXJ5XG4gKiBAZXhhbXBsZVxuICogdmFyIHBsdWdpblJhcGhhZWwgPSB7XG4gKiAgIGJhcjogZnVuY3Rpb24oKSB7fSAvLyBSZW5kZXIgY2xhc3NcbiAqIH07XG4gKiB0dWkuY2hhcnQucmVnaXN0ZXJQbHVnaW4oJ3JhcGhhZWwnLCBwbHVnaW5SYXBoYWVsKTtcbiAqL1xudHVpLmNoYXJ0LnJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24obGliVHlwZSwgcGx1Z2luKSB7XG4gICAgcGx1Z2luRmFjdG9yeS5yZWdpc3RlcihsaWJUeXBlLCBwbHVnaW4pO1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBBcmVhIGNoYXJ0XG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGxpbmVUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2xpbmVUeXBlTWl4ZXInKSxcbiAgICBheGlzVHlwZU1peGVyID0gcmVxdWlyZSgnLi9heGlzVHlwZU1peGVyJyksXG4gICAgdmVydGljYWxUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL3ZlcnRpY2FsVHlwZU1peGVyJyksXG4gICAgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2FyZWFDaGFydFNlcmllcycpO1xuXG52YXIgQXJlYUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIExpbmVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIGNsYXNzTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgY2xhc3NOYW1lOiAndHVpLWFyZWEtY2hhcnQnLFxuXG4gICAgLyoqXG4gICAgICogU2VyaWVzIGNsYXNzXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIFNlcmllczogU2VyaWVzLFxuXG4gICAgLyoqXG4gICAgICogQXJlYSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBBcmVhQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAbWl4ZXMgYXhpc1R5cGVNaXhlclxuICAgICAqIEBtaXhlcyB2ZXJ0aWNhbFR5cGVNaXhlclxuICAgICAqIEBtaXhlcyBsaW5lVHlwZU1peGVyXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xpbmVUeXBlSW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKEFyZWFDaGFydCk7XG52ZXJ0aWNhbFR5cGVNaXhlci5taXhpbihBcmVhQ2hhcnQpO1xubGluZVR5cGVNaXhlci5taXhpbihBcmVhQ2hhcnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWFDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBheGlzVHlwZU1peGVyIGlzIG1peGVyIG9mIGF4aXMgdHlwZSBjaGFydChiYXIsIGNvbHVtbiwgbGluZSwgYXJlYSkuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBBeGlzID0gcmVxdWlyZSgnLi4vYXhlcy9heGlzJyksXG4gICAgUGxvdCA9IHJlcXVpcmUoJy4uL3Bsb3RzL3Bsb3QnKSxcbiAgICBMZWdlbmQgPSByZXF1aXJlKCcuLi9sZWdlbmRzL2xlZ2VuZCcpLFxuICAgIEdyb3VwVHlwZUN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnLi4vY3VzdG9tRXZlbnRzL2dyb3VwVHlwZUN1c3RvbUV2ZW50JyksXG4gICAgUG9pbnRUeXBlQ3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvcG9pbnRUeXBlQ3VzdG9tRXZlbnQnKSxcbiAgICBUb29sdGlwID0gcmVxdWlyZSgnLi4vdG9vbHRpcHMvdG9vbHRpcCcpLFxuICAgIEdyb3VwVG9vbHRpcCA9IHJlcXVpcmUoJy4uL3Rvb2x0aXBzL2dyb3VwVG9vbHRpcCcpO1xuXG4vKipcbiAqIGF4aXNUeXBlTWl4ZXIgaXMgYmFzZSBjbGFzcyBvZiBheGlzIHR5cGUgY2hhcnQoYmFyLCBjb2x1bW4sIGxpbmUsIGFyZWEpLlxuICogQG1peGluXG4gKi9cbnZhciBheGlzVHlwZU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCBheGlzIGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gYXhpc05hbWVzIGF4aXMgbmFtZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsaWduZWQgd2hldGhlciBhbGlnbmVkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEF4aXNDb21wb25lbnRzOiBmdW5jdGlvbihheGlzTmFtZXMsIGFsaWduZWQpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChheGlzTmFtZXMsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBheGlzUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGFsaWduZWQ6IGFsaWduZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3lyQXhpcycpIHtcbiAgICAgICAgICAgICAgICBheGlzUGFyYW1zLmNvbXBvbmVudFR5cGUgPSAneUF4aXMnO1xuICAgICAgICAgICAgICAgIGF4aXNQYXJhbXMuaW5kZXggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50KG5hbWUsIEF4aXMsIGF4aXNQYXJhbXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHNlcmllcyBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSBzZXJpZXNlcyBzZXJpZXNlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsaWduZWQgd2hldGhlciBhbGlnbmVkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZFNlcmllc0NvbXBvbmVudHM6IGZ1bmN0aW9uKHNlcmllc2VzLCBvcHRpb25zLCBhbGlnbmVkKSB7XG4gICAgICAgIHZhciBzZXJpZXNCYXNlUGFyYW1zID0ge1xuICAgICAgICAgICAgbGliVHlwZTogb3B0aW9ucy5saWJUeXBlLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBvcHRpb25zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIHBhcmVudENoYXJ0VHlwZTogb3B0aW9ucy5wYXJlbnRDaGFydFR5cGUsXG4gICAgICAgICAgICBhbGlnbmVkOiBhbGlnbmVkLFxuICAgICAgICAgICAgaGFzR3JvdXBUb29sdGlwOiB0aGlzLmhhc0dyb3VwVG9vbHRpcCxcbiAgICAgICAgICAgIHVzZXJFdmVudDogdGhpcy51c2VyRXZlbnQsXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiAnc2VyaWVzJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzZXMsIGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgdmFyIHNlcmllc1BhcmFtcyA9IHR1aS51dGlsLmV4dGVuZChzZXJpZXNCYXNlUGFyYW1zLCBzZXJpZXMuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRDb21wb25lbnQoc2VyaWVzLm5hbWUsIHNlcmllcy5TZXJpZXNDbGFzcywgc2VyaWVzUGFyYW1zKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCB0b29sdGlwIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb252ZXJ0ZWREYXRhIGNvbnZlcnRlZERhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkVG9vbHRpcENvbXBvbmVudDogZnVuY3Rpb24oY29udmVydGVkRGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5oYXNHcm91cFRvb2x0aXApIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZENvbXBvbmVudCgndG9vbHRpcCcsIEdyb3VwVG9vbHRpcCwge1xuICAgICAgICAgICAgICAgIGxhYmVsczogY29udmVydGVkRGF0YS5sYWJlbHMsXG4gICAgICAgICAgICAgICAgam9pbkZvcm1hdHRlZFZhbHVlczogY29udmVydGVkRGF0YS5qb2luRm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICAgICAgICAgIGpvaW5MZWdlbmRMYWJlbHM6IGNvbnZlcnRlZERhdGEuam9pbkxlZ2VuZExhYmVscyxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWwsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRDb21wb25lbnQoJ3Rvb2x0aXAnLCBUb29sdGlwLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBjb252ZXJ0ZWREYXRhLnZhbHVlcyxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXM6IGNvbnZlcnRlZERhdGEuZm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICAgICAgICAgIGxhYmVsczogY29udmVydGVkRGF0YS5sYWJlbHMsXG4gICAgICAgICAgICAgICAgbGVnZW5kTGFiZWxzOiBjb252ZXJ0ZWREYXRhLmxlZ2VuZExhYmVscyxcbiAgICAgICAgICAgICAgICBqb2luTGVnZW5kTGFiZWxzOiBjb252ZXJ0ZWREYXRhLmpvaW5MZWdlbmRMYWJlbHMsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBvcHRpb25zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWwsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGxlZ2VuZCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnZlcnRlZERhdGEgY29udmVydGVkRGF0YVxuICAgICAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IHNlcmllc0NoYXJ0VHlwZXMgc2VyaWVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydFR5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGVnZW5kT3B0aW9ucyBsZWdlbmQgb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZExlZ2VuZENvbXBvbmVudDogZnVuY3Rpb24oY29udmVydGVkRGF0YSwgc2VyaWVzQ2hhcnRUeXBlcywgY2hhcnRUeXBlLCBsZWdlbmRPcHRpb25zKSB7XG4gICAgICAgIGlmICghbGVnZW5kT3B0aW9ucyB8fCAhbGVnZW5kT3B0aW9ucy5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZENvbXBvbmVudCgnbGVnZW5kJywgTGVnZW5kLCB7XG4gICAgICAgICAgICAgICAgam9pbkxlZ2VuZExhYmVsczogY29udmVydGVkRGF0YS5qb2luTGVnZW5kTGFiZWxzLFxuICAgICAgICAgICAgICAgIGxlZ2VuZExhYmVsczogY29udmVydGVkRGF0YS5sZWdlbmRMYWJlbHMsXG4gICAgICAgICAgICAgICAgc2VyaWVzQ2hhcnRUeXBlczogc2VyaWVzQ2hhcnRUeXBlcyxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50cyBmb3IgYXhpcyB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5jb252ZXJ0ZWREYXRhIGNvbnZlcnRlZCBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmF4ZXMgYXhlcyBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnBsb3REYXRhIHBsb3QgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gcGFyYW1zLnNlcmllc2VzIHNlcmllc2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlZERhdGEgPSBwYXJhbXMuY29udmVydGVkRGF0YSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBhbGlnbmVkID0gISFwYXJhbXMuYWxpZ25lZDtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnQoJ3Bsb3QnLCBQbG90KTtcbiAgICAgICAgdGhpcy5fYWRkQXhpc0NvbXBvbmVudHMocGFyYW1zLmF4ZXMsIGFsaWduZWQpO1xuICAgICAgICB0aGlzLl9hZGRMZWdlbmRDb21wb25lbnQoY29udmVydGVkRGF0YSwgcGFyYW1zLnNlcmllc0NoYXJ0VHlwZXMsIHBhcmFtcy5jaGFydFR5cGUsIHRoaXMub3B0aW9ucy5sZWdlbmQpO1xuICAgICAgICB0aGlzLl9hZGRTZXJpZXNDb21wb25lbnRzKHBhcmFtcy5zZXJpZXNlcywgb3B0aW9ucywgYWxpZ25lZCk7XG4gICAgICAgIHRoaXMuX2FkZFRvb2x0aXBDb21wb25lbnQoY29udmVydGVkRGF0YSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzY2FsZXMuXG4gICAgICogQHBhcmFtIHt7eUF4aXM6IG9iamVjdCwgeEF4aXM6IG9iamVjdH19IGF4ZXNEYXRhIGF4ZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9Pn0gc2NhbGVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2NhbGVzOiBmdW5jdGlvbihheGVzRGF0YSwgY2hhcnRUeXBlcywgaXNWZXJ0aWNhbCkge1xuICAgICAgICB2YXIgc2NhbGVzID0ge30sXG4gICAgICAgICAgICB5QXhpc1NjYWxlID0gYXhlc0RhdGEueUF4aXMuc2NhbGU7XG5cbiAgICAgICAgc2NhbGVzW2NoYXJ0VHlwZXNbMF1dID0gaXNWZXJ0aWNhbCA/IHlBeGlzU2NhbGUgOiBheGVzRGF0YS54QXhpcy5zY2FsZTtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBzY2FsZXNbY2hhcnRUeXBlc1sxXV0gPSBheGVzRGF0YS55ckF4aXMgPyBheGVzRGF0YS55ckF4aXMuc2NhbGUgOiB5QXhpc1NjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjYWxlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBzZXJpZXMgZGF0YSBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7e3lBeGlzOiBvYmplY3QsIHhBeGlzOiBvYmplY3R9fSBheGVzRGF0YSBheGVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YUZvclJlbmRlcmluZzogZnVuY3Rpb24oYXhlc0RhdGEsIGNoYXJ0VHlwZXMsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdmFyIHNjYWxlcyA9IHRoaXMuX2dldFNjYWxlcyhheGVzRGF0YSwgY2hhcnRUeXBlcywgaXNWZXJ0aWNhbCksXG4gICAgICAgICAgICBhbGlnbmVkID0gYXhlc0RhdGEueEF4aXMuYWxpZ25lZCxcbiAgICAgICAgICAgIHNlcmllc0RhdGEgPSB7fTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hhcnRUeXBlcy5sZW5ndGggPiAxID8gY2hhcnRUeXBlICsgJ1NlcmllcycgOiAnc2VyaWVzJztcbiAgICAgICAgICAgIHNlcmllc0RhdGFba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGVzW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgYWxpZ25lZDogYWxpZ25lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXJpZXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHJlbmRlcmluZyBkYXRhIGZvciBheGlzIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvdW5kcyBjaGFydCBib3VuZHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udmVydGVkRGF0YSBjb252ZXJ0ZWREYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge29iamVjdH0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKGJvdW5kcywgY29udmVydGVkRGF0YSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXhlc0RhdGEgPSB0aGlzLl9tYWtlQXhlc0RhdGEoY29udmVydGVkRGF0YSwgYm91bmRzLCBvcHRpb25zKSxcbiAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXMgPSB0aGlzLmNoYXJ0VHlwZXMgfHwgW3RoaXMuY2hhcnRUeXBlXSxcbiAgICAgICAgICAgIHNlcmllc0RhdGEgPSB0aGlzLl9tYWtlU2VyaWVzRGF0YUZvclJlbmRlcmluZyhheGVzRGF0YSwgb3B0aW9uQ2hhcnRUeXBlcywgdGhpcy5pc1ZlcnRpY2FsKTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHBsb3Q6IHtcbiAgICAgICAgICAgICAgICB2VGlja0NvdW50OiBheGVzRGF0YS55QXhpcy52YWxpZFRpY2tDb3VudCxcbiAgICAgICAgICAgICAgICBoVGlja0NvdW50OiBheGVzRGF0YS54QXhpcy52YWxpZFRpY2tDb3VudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdGlja0NvdW50OiB0aGlzLmlzVmVydGljYWwgPyBheGVzRGF0YS54QXhpcy50aWNrQ291bnQgOiBheGVzRGF0YS55QXhpcy50aWNrQ291bnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgY2hhcnREaW1lbnNpb246IGJvdW5kcy5jaGFydC5kaW1lbnNpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VyaWVzRGF0YSwgYXhlc0RhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZ3JvdXBlZCBldmVudCBoYW5kbGVyIGxheWVyLlxuICAgICAqIEBwYXJhbSB7e3lBeGlzOiBvYmVqY3QsIHhBeGlzOiBvYmplY3R9fSBheGVzRGF0YSBheGVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9hZGRDdXN0b21FdmVudENvbXBvbmVudEZvckdyb3VwVG9vbHRpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudCgnY3VzdG9tRXZlbnQnLCBHcm91cFR5cGVDdXN0b21FdmVudCwge1xuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRoaXMuaXNWZXJ0aWNhbFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGN1c3RvbSBldmVudCBjb21wb25lbnQgZm9yIG5vcm1hbCB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50Rm9yTm9ybWFsVG9vbHRpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudCgnY3VzdG9tRXZlbnQnLCBQb2ludFR5cGVDdXN0b21FdmVudCwge1xuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRoaXMuaXNWZXJ0aWNhbFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGN1c3RvbSBldmVudCBjb21wb25lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNHcm91cFRvb2x0aXApIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50Rm9yR3JvdXBUb29sdGlwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRDdXN0b21FdmVudENvbXBvbmVudEZvck5vcm1hbFRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggY29vcmRpbmF0ZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudEZvckdyb3VwVG9vbHRpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXN0b21FdmVudCA9IHRoaXMuY29tcG9uZW50TWFwLmN1c3RvbUV2ZW50LFxuICAgICAgICAgICAgdG9vbHRpcCA9IHRoaXMuY29tcG9uZW50TWFwLnRvb2x0aXAsXG4gICAgICAgICAgICBzZXJpZXNlcyA9IHR1aS51dGlsLmZpbHRlcih0aGlzLmNvbXBvbmVudE1hcCwgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5jb21wb25lbnRUeXBlID09PSAnc2VyaWVzJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjdXN0b21FdmVudC5vbignc2hvd0dyb3VwVG9vbHRpcCcsIHRvb2x0aXAub25TaG93LCB0b29sdGlwKTtcbiAgICAgICAgY3VzdG9tRXZlbnQub24oJ2hpZGVHcm91cFRvb2x0aXAnLCB0b29sdGlwLm9uSGlkZSwgdG9vbHRpcCk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzLm9uU2hvd0dyb3VwVG9vbHRpcExpbmUpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLm9uKCdzaG93R3JvdXBUb29sdGlwTGluZScsIHNlcmllcy5vblNob3dHcm91cFRvb2x0aXBMaW5lLCBzZXJpZXMpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAub24oJ2hpZGVHcm91cFRvb2x0aXBMaW5lJywgc2VyaWVzLm9uSGlkZUdyb3VwVG9vbHRpcExpbmUsIHNlcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29sdGlwLm9uKCdzaG93R3JvdXBBbmltYXRpb24nLCBzZXJpZXMub25TaG93R3JvdXBBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgICAgICB0b29sdGlwLm9uKCdoaWRlR3JvdXBBbmltYXRpb24nLCBzZXJpZXMub25IaWRlR3JvdXBBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBhdHRhY2ggY3VzdG9tIGV2ZW50IGZvciBub3JtYWwgdG9vbHRpcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudEZvck5vcm1hbFRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3VzdG9tRXZlbnQgPSB0aGlzLmNvbXBvbmVudE1hcC5jdXN0b21FdmVudCxcbiAgICAgICAgICAgIHRvb2x0aXAgPSB0aGlzLmNvbXBvbmVudE1hcC50b29sdGlwLFxuICAgICAgICAgICAgc2VyaWVzZXMgPSB0dWkudXRpbC5maWx0ZXIodGhpcy5jb21wb25lbnRNYXAsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQuY29tcG9uZW50VHlwZSA9PT0gJ3Nlcmllcyc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjdXN0b21FdmVudC5vbignc2hvd1Rvb2x0aXAnLCB0b29sdGlwLm9uU2hvdywgdG9vbHRpcCk7XG4gICAgICAgIGN1c3RvbUV2ZW50Lm9uKCdoaWRlVG9vbHRpcCcsIHRvb2x0aXAub25IaWRlLCB0b29sdGlwKTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXMub25TaG93QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5vbihyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3Nob3cnLCBzZXJpZXMuY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyksIHNlcmllcy5vblNob3dBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5vbihyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ2hpZGUnLCBzZXJpZXMuY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyksIHNlcmllcy5vbkhpZGVBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBhdHRhY2ggY3VzdG9tIGV2ZW50IGZvciBzZXJpZXMgc2VsZWN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50Rm9yU2VyaWVzU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYXAuY3VzdG9tRXZlbnQsXG4gICAgICAgICAgICBzZXJpZXNlcyA9IHR1aS51dGlsLmZpbHRlcih0aGlzLmNvbXBvbmVudE1hcCwgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5jb21wb25lbnRUeXBlID09PSAnc2VyaWVzJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50Lm9uKHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgnc2VsZWN0Jywgc2VyaWVzLmNoYXJ0VHlwZSwgJ3NlcmllcycpLCBzZXJpZXMub25TZWxlY3RTZXJpZXMsIHNlcmllcyk7XG4gICAgICAgICAgICBjdXN0b21FdmVudC5vbihyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3Vuc2VsZWN0Jywgc2VyaWVzLmNoYXJ0VHlwZSwgJ3NlcmllcycpLCBzZXJpZXMub25VbnNlbGVjdFNlcmllcywgc2VyaWVzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjdXN0b20gZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNHcm91cFRvb2x0aXApIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaEN1c3RvbUV2ZW50Rm9yR3JvdXBUb29sdGlwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hDdXN0b21FdmVudEZvck5vcm1hbFRvb2x0aXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2F0dGFjaEN1c3RvbUV2ZW50Rm9yU2VyaWVzU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIHRhcmdldCBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB0dWkudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpc1R5cGVNaXhlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCYXIgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKSxcbiAgICBheGlzRGF0YU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzRGF0YU1ha2VyJyksXG4gICAgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2JhckNoYXJ0U2VyaWVzJyk7XG5cbnZhciBCYXJDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBCYXJDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEJhciBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBCYXJDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBtaXhlcyBheGlzVHlwZU1peGVyXG4gICAgICogQHBhcmFtIHthcnJheS48YXJyYXk+fSB1c2VyRGF0YSBjaGFydCBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHVzZXJEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogY2xhc3NOYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktYmFyLWNoYXJ0JztcblxuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICB1c2VyRGF0YTogdXNlckRhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgaGFzQXhlczogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKHRoaXMuY29udmVydGVkRGF0YSwgb3B0aW9ucy5jaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGF4ZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb252ZXJ0ZWREYXRhIGNvbnZlcnRlZCBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvdW5kcyBjaGFydCBib3VuZHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogQHJldHVybnMge29iamVjdH0gYXhlcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4ZXNEYXRhOiBmdW5jdGlvbihjb252ZXJ0ZWREYXRhLCBib3VuZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHhBeGlzRGF0YSA9IGF4aXNEYXRhTWFrZXIubWFrZVZhbHVlQXhpc0RhdGEoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogY29udmVydGVkRGF0YS52YWx1ZXMsXG4gICAgICAgICAgICAgICAgc2VyaWVzRGltZW5zaW9uOiBib3VuZHMuc2VyaWVzLmRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICBzdGFja2VkOiBvcHRpb25zLnNlcmllcyAmJiBvcHRpb25zLnNlcmllcy5zdGFja2VkIHx8ICcnLFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogb3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zOiBjb252ZXJ0ZWREYXRhLmZvcm1hdEZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLnhBeGlzXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHlBeGlzRGF0YSA9IGF4aXNEYXRhTWFrZXIubWFrZUxhYmVsQXhpc0RhdGEoe1xuICAgICAgICAgICAgICAgIGxhYmVsczogY29udmVydGVkRGF0YS5sYWJlbHMsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhBeGlzOiB4QXhpc0RhdGEsXG4gICAgICAgICAgICB5QXhpczogeUF4aXNEYXRhXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnZlcnRlZERhdGEgY29udmVydGVkIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjb252ZXJ0ZWREYXRhLCBjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIHNlcmllc0RhdGEgPSB7XG4gICAgICAgICAgICBhbGxvd05lZ2F0aXZlVG9vbHRpcDogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNvbnZlcnRlZERhdGEudmFsdWVzLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlczogY29udmVydGVkRGF0YS5mb3JtYXR0ZWRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zOiBjb252ZXJ0ZWREYXRhLmZvcm1hdEZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgICBqb2luTGVnZW5kTGFiZWxzOiBjb252ZXJ0ZWREYXRhLmpvaW5MZWdlbmRMYWJlbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzRm9yQXhpc1R5cGUoe1xuICAgICAgICAgICAgY29udmVydGVkRGF0YTogY29udmVydGVkRGF0YSxcbiAgICAgICAgICAgIGF4ZXM6IFsneUF4aXMnLCAneEF4aXMnXSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgc2VyaWVzZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzZXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICBTZXJpZXNDbGFzczogU2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZXJpZXNEYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuYXhpc1R5cGVNaXhlci5taXhpbihCYXJDaGFydCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFyQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hhcnRCYXNlXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgZGF0YUNvbnZlcnRlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZGF0YUNvbnZlcnRlcicpLFxuICAgIGJvdW5kc01ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9ib3VuZHNNYWtlcicpLFxuICAgIFVzZXJFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi4vaGVscGVycy91c2VyRXZlbnRMaXN0ZW5lcicpO1xuXG52YXIgQ2hhcnRCYXNlID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBDaGFydEJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDaGFydCBiYXNlLlxuICAgICAqIEBjb25zdHJ1Y3RzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5ib3VuZHMgY2hhcnQgYm91bmRzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge3t5QXhpczogb2JlamN0LCB4QXhpczogb2JqZWN0fX0gYXhlc0RhdGEgYXhlcyBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbS5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb252ZXJ0ZWQgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb252ZXJ0ZWREYXRhID0gdGhpcy5fbWFrZUNvbnZlcnRlZERhdGEocGFyYW1zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY29tcG9uZW50IGFycmF5XG4gICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb21wb25lbnQgaW5zdGFuY2UgbWFwXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogb3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgY2hhcnQgaGFzIGF4ZXMgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNBeGVzID0gcGFyYW1zLmhhc0F4ZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gISFwYXJhbXMuaXNWZXJ0aWNhbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBjaGFydCBoYXMgZ3JvdXAgdG9vbHRpcCBvciBub3RcbiAgICAgICAgICogQHR5cGUgeyp8Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzR3JvdXBUb29sdGlwID0gcGFyYW1zLm9wdGlvbnMudG9vbHRpcCAmJiBwYXJhbXMub3B0aW9ucy50b29sdGlwLmdyb3VwZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVzZXIgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlckV2ZW50ID0gbmV3IFVzZXJFdmVudExpc3RlbmVyKCk7XG5cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSB0aGlzLm9wdGlvbnMuY2hhcnRUeXBlO1xuXG4gICAgICAgIHRoaXMuX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgY29udmVydGVkIGRhdGEuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW1zIHtvYmplY3R9IHVzZXJEYXRhIHVzZXIgZGF0YVxuICAgICAqICAgICAgQHBhcmFtcyB7e2NoYXJ0OiBvYmplY3QsIGNoYXJ0VHlwZTogc3RyaW5nfX0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW1zIHthcnJheX0gc2VyaWVzQ2hhcnRUeXBlcyBzZXJpZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjb252ZXJ0ZWQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDb252ZXJ0ZWREYXRhOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyxcbiAgICAgICAgICAgIGNvbnZlcnRlZERhdGEgPSBkYXRhQ29udmVydGVyLmNvbnZlcnQocGFyYW1zLnVzZXJEYXRhLCBvcHRpb25zLmNoYXJ0LCBvcHRpb25zLmNoYXJ0VHlwZSwgcGFyYW1zLnNlcmllc0NoYXJ0VHlwZXMpO1xuICAgICAgICByZXR1cm4gY29udmVydGVkRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYmFzdHJhY3RcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBUbyBhZGQgY29tcG9uZW50LlxuICAgICAqIFRoZSBjb21wb25lbnQgcmVmZXJzIHRvIGEgY29tcG9uZW50IG9mIHRoZSBjaGFydC5cbiAgICAgKiBUaGUgY29tcG9uZW50IHR5cGVzIGFyZSBheGlzLCBsZWdlbmQsIHBsb3QsIHNlcmllcyBhbmQgY3VzdG9tRXZlbnQuXG4gICAgICogQ2hhcnQgQ29tcG9uZW50IERlc2NyaXB0aW9uIDogaHR0cHM6Ly9pLW1zZG4uc2VjLnMtbXNmdC5jb20vZHluaW1nL0lDMjY3OTk3LmdpZlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbXBvbmVudCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudDogZnVuY3Rpb24obmFtZSwgQ29tcG9uZW50LCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIGNvbW1vblBhcmFtcyA9IHt9LFxuICAgICAgICAgICAgb3B0aW9ucywgaW5kZXgsIHRoZW1lLCBjb21wb25lbnQ7XG5cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgICAgIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB0aGlzLm9wdGlvbnNbcGFyYW1zICYmIHBhcmFtcy5jb21wb25lbnRUeXBlIHx8IG5hbWVdO1xuICAgICAgICB0aGVtZSA9IHBhcmFtcy50aGVtZSB8fCB0aGlzLnRoZW1lW3BhcmFtcyAmJiBwYXJhbXMuY29tcG9uZW50VHlwZSB8fCBuYW1lXTtcbiAgICAgICAgaW5kZXggPSBwYXJhbXMgJiYgcGFyYW1zLmluZGV4IHx8IDA7XG5cbiAgICAgICAgY29tbW9uUGFyYW1zLnRoZW1lID0gdHVpLnV0aWwuaXNBcnJheSh0aGVtZSkgPyB0aGVtZVtpbmRleF0gOiB0aGVtZTtcbiAgICAgICAgY29tbW9uUGFyYW1zLm9wdGlvbnMgPSB0dWkudXRpbC5pc0FycmF5KG9wdGlvbnMpID8gb3B0aW9uc1tpbmRleF0gOiBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHBhcmFtcyA9IHR1aS51dGlsLmV4dGVuZChwYXJhbXMsIGNvbW1vblBhcmFtcyk7XG5cbiAgICAgICAgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudChwYXJhbXMpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBwYXJhbXMuY29tcG9uZW50VHlwZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBjb21wb25lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFwW25hbWVdID0gY29tcG9uZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGJvdW5kcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYm91bmRzUGFyYW1zIHBhcmFtZXRlcnMgZm9yIG1ha2luZyBib3VuZHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjaGFydCBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQm91bmRzOiBmdW5jdGlvbihib3VuZHNQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kc01ha2VyLm1ha2UodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGNvbnZlcnRlZERhdGE6IHRoaXMuY29udmVydGVkRGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgaGFzQXhlczogdGhpcy5oYXNBeGVzLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsXG4gICAgICAgIH0sIGJvdW5kc1BhcmFtcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHJlbmRlcmluZyBkYXRhIGZvciBheGlzIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvdW5kcyBjaGFydCBib3VuZHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udmVydGVkRGF0YSBjb252ZXJ0ZWREYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX21ha2VSZW5kZXJpbmdEYXRhOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGN1c3RvbSBldm5ldC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYm91bmRzUGFyYW1zIHBhcmFtZXRlcnMgZm9yIG1ha2luZyBib3VuZHNcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNoYXJ0IGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGJvdW5kc1BhcmFtcykge1xuICAgICAgICB2YXIgZWwgPSBkb20uY3JlYXRlKCdESVYnLCB0aGlzLmNsYXNzTmFtZSksXG4gICAgICAgICAgICBib3VuZHMsIHJlbmRlcmluZ0RhdGE7XG5cbiAgICAgICAgaWYgKGJvdW5kc1BhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5fbWFrZUJvdW5kcyA9IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZUJvdW5kcywgdGhpcywgYm91bmRzUGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbCwgJ3R1aS1jaGFydCcpO1xuICAgICAgICBib3VuZHMgPSB0aGlzLl9tYWtlQm91bmRzKCk7XG4gICAgICAgIHJlbmRlcmluZ0RhdGEgPSB0aGlzLl9tYWtlUmVuZGVyaW5nRGF0YShib3VuZHMsIHRoaXMuY29udmVydGVkRGF0YSwgdGhpcy5vcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJUaXRsZShlbCk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGVsLCBib3VuZHMuY2hhcnQuZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJCYWNrZ3JvdW5kKGVsLCB0aGlzLnRoZW1lLmNoYXJ0LmJhY2tncm91bmQpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckZvbnRGYW1pbHkoZWwsIHRoaXMudGhlbWUuY2hhcnQuZm9udEZhbWlseSk7XG4gICAgICAgIHRoaXMuX3JlbmRlckNvbXBvbmVudHMoZWwsIHRoaXMuY29tcG9uZW50cywgYm91bmRzLCByZW5kZXJpbmdEYXRhKTtcbiAgICAgICAgdGhpcy5fc2VuZFNlcmllc0RhdGEoKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoQ3VzdG9tRXZlbnQoKTtcbiAgICAgICAgdGhpcy5lbENoYXJ0ID0gZWw7XG5cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGl0bGUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUaXRsZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGNoYXJ0T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5jaGFydCB8fCB7fSxcbiAgICAgICAgICAgIGVsVGl0bGUgPSByZW5kZXJVdGlsLnJlbmRlclRpdGxlKGNoYXJ0T3B0aW9ucy50aXRsZSwgdGhpcy50aGVtZS50aXRsZSwgJ3R1aS1jaGFydC10aXRsZScpO1xuICAgICAgICBkb20uYXBwZW5kKGVsLCBlbFRpdGxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBib3VuZCBhYm91dCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYm91bmRzIGNvbXBvbmVudHMgYm91bmRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50VHlwZSBjb21wb25lbnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gZm91bmQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kQm91bmQ6IGZ1bmN0aW9uKGJvdW5kcywgbmFtZSwgY29tcG9uZW50VHlwZSkge1xuICAgICAgICByZXR1cm4gYm91bmRzW25hbWVdIHx8IChjb21wb25lbnRUeXBlICYmIGJvdW5kc1tjb21wb25lbnRUeXBlXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjb21wb25lbnRzLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IGNvbXBvbmVudHMgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IGJvdW5kcyBib3VuZHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVuZGVyaW5nRGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDb21wb25lbnRzOiBmdW5jdGlvbihjb250YWluZXIsIGNvbXBvbmVudHMsIGJvdW5kcywgcmVuZGVyaW5nRGF0YSkge1xuICAgICAgICB2YXIgZWxlbWVudHM7XG4gICAgICAgIGVsZW1lbnRzID0gdHVpLnV0aWwubWFwKGNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBjb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgICAgICBib3VuZCA9IHRoaXMuX2ZpbmRCb3VuZChib3VuZHMsIG5hbWUsIGNvbXBvbmVudC5jb21wb25lbnRUeXBlKSxcbiAgICAgICAgICAgICAgICBkYXRhID0gcmVuZGVyaW5nRGF0YVtuYW1lXSxcbiAgICAgICAgICAgICAgICBlbENvbXBvbmVudDtcbiAgICAgICAgICAgIGlmICghYm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxDb21wb25lbnQgPSBjb21wb25lbnQuaW5zdGFuY2UucmVuZGVyKGJvdW5kLCBkYXRhKTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsQ29tcG9uZW50O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgZG9tLmFwcGVuZChjb250YWluZXIsIGVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBzZXJpZXMgZGF0YSB0byBjdXN0b20gZXZlbnQgY29tcG9uZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbmRTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc0luZm9zLCBjaGFydFR5cGVzO1xuXG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnRNYXAuY3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0VHlwZXMgPSB0aGlzLmNoYXJ0VHlwZXMgfHwgW3RoaXMuY2hhcnRUeXBlXTtcbiAgICAgICAgc2VyaWVzSW5mb3MgPSB0dWkudXRpbC5tYXAoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hhcnRUeXBlcy5sZW5ndGggPT09IDEgPyAnc2VyaWVzJyA6IGNoYXJ0VHlwZSArICdTZXJpZXMnO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmNvbXBvbmVudE1hcFtrZXldLmdldFNlcmllc0RhdGEoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFwLmN1c3RvbUV2ZW50LmluaXRDdXN0b21FdmVudERhdGEoc2VyaWVzSW5mb3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGV2ZW50IG5hbWUgZm9yIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHByZWZpeFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGV2ZW50IG5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQW5pbWF0aW9uRXZlbnROYW1lOiBmdW5jdGlvbihjaGFydFR5cGUsIHByZWZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgY2hhcnRUeXBlLnN1YnN0cmluZygwLCAxKS50b1VwcGVyQ2FzZSgpICsgY2hhcnRUeXBlLnN1YnN0cmluZygxKSArICdBbmltYXRpb24nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGNoYXJ0LlxuICAgICAqL1xuICAgIGFuaW1hdGVDaGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5pbnN0YW5jZS5hbmltYXRlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lmluc3RhbmNlLmFuaW1hdGVDb21wb25lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlZ2lzdGVyIG9mIHVzZXIgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBldmVudCBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudE5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQucmVnaXN0ZXIoZXZlbnROYW1lLCBmdW5jKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBjaGFuZ2VkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZURpbWVuc2lvbjogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChkaW1lbnNpb24ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jaGFydC53aWR0aCA9IGRpbWVuc2lvbi53aWR0aDtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpbWVuc2lvbi5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jaGFydC5oZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0O1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHthcnJheS48e25hbWU6IHN0cmluZywgaW5zdGFuY2U6IG9iamVjdH0+fSBjb21wb25lbnRzIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxvYmplY3Q+fSBib3VuZHMgYm91bmRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlbmRlcmluZ0RhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzaXplQ29tcG9uZW50czogZnVuY3Rpb24oY29tcG9uZW50cywgYm91bmRzLCByZW5kZXJpbmdEYXRhKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gY29tcG9uZW50Lm5hbWUsXG4gICAgICAgICAgICAgICAgYm91bmQgPSB0aGlzLl9maW5kQm91bmQoYm91bmRzLCBuYW1lLCBjb21wb25lbnQuY29tcG9uZW50VHlwZSksXG4gICAgICAgICAgICAgICAgZGF0YSA9IHJlbmRlcmluZ0RhdGFbbmFtZV07XG5cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50Lmluc3RhbmNlLnJlc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tcG9uZW50Lmluc3RhbmNlLnJlc2l6ZShib3VuZCwgZGF0YSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJIGZvciByZXNpemFibGUuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIGNoYW5nZWQsIGJvdW5kcywgcmVuZGVyaW5nRGF0YTtcblxuICAgICAgICBpZiAoIWRpbWVuc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlZCA9IHRoaXMuX3VwZGF0ZURpbWVuc2lvbihkaW1lbnNpb24pO1xuXG4gICAgICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRzID0gdGhpcy5fbWFrZUJvdW5kcygpO1xuXG4gICAgICAgIHJlbmRlcmluZ0RhdGEgPSB0aGlzLl9tYWtlUmVuZGVyaW5nRGF0YShib3VuZHMsIHRoaXMuY29udmVydGVkRGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24odGhpcy5lbENoYXJ0LCBib3VuZHMuY2hhcnQuZGltZW5zaW9uKTtcbiAgICAgICAgdGhpcy5fcmVzaXplQ29tcG9uZW50cyh0aGlzLmNvbXBvbmVudHMsIGJvdW5kcywgcmVuZGVyaW5nRGF0YSk7XG4gICAgICAgIHRoaXMuX3NlbmRTZXJpZXNEYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gYWxpZ25cbiAgICAgKi9cbiAgICBzZXRUb29sdGlwQWxpZ246IGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFwLnRvb2x0aXAuc2V0QWxpZ24oYWxpZ24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgcG9zaXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3ZpbmcgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzZXRUb29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFwLnRvb2x0aXAuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKi9cbiAgICByZXNldFRvb2x0aXBBbGlnbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFwLnRvb2x0aXAucmVzZXRBbGlnbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0b29sdGlwIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHJlc2V0VG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYXAudG9vbHRpcC5yZXNldFBvc2l0aW9uKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRCYXNlO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbHVtbiBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpLFxuICAgIHZlcnRpY2FsVHlwZU1peGVyID0gcmVxdWlyZSgnLi92ZXJ0aWNhbFR5cGVNaXhlcicpLFxuICAgIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9jb2x1bW5DaGFydFNlcmllcycpO1xuXG52YXIgQ29sdW1uQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgQ29sdW1uQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDb2x1bW4gY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgQ29sdW1uQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAbWl4ZXMgYXhpc1R5cGVNaXhlclxuICAgICAqIEBtaXhlcyB2ZXJ0aWNhbFR5cGVNaXhlclxuICAgICAqIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gdXNlckRhdGEgY2hhcnQgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5pdGVkRGF0YSBpbml0aWFsaXplZCBkYXRhIGZyb20gY29tYm8gY2hhcnRcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbih1c2VyRGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNvbHVtbi1jaGFydCc7XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgdXNlckRhdGE6IHVzZXJEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGhhc0F4ZXM6IHRydWUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHModGhpcy5jb252ZXJ0ZWREYXRhLCBvcHRpb25zLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnZlcnRlZERhdGEgY29udmVydGVkIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjb252ZXJ0ZWREYXRhLCBjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIHNlcmllc0RhdGEgPSB7XG4gICAgICAgICAgICBhbGxvd05lZ2F0aXZlVG9vbHRpcDogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNvbnZlcnRlZERhdGEudmFsdWVzLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlczogY29udmVydGVkRGF0YS5mb3JtYXR0ZWRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zOiBjb252ZXJ0ZWREYXRhLmZvcm1hdEZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgICBqb2luTGVnZW5kTGFiZWxzOiBjb252ZXJ0ZWREYXRhLmpvaW5MZWdlbmRMYWJlbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlKHtcbiAgICAgICAgICAgIGNvbnZlcnRlZERhdGE6IGNvbnZlcnRlZERhdGEsXG4gICAgICAgICAgICBheGVzOiBbJ3lBeGlzJywgJ3hBeGlzJ10sXG4gICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgIHNlcmllc2VzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2VyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgU2VyaWVzQ2xhc3M6IFNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VyaWVzRGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbmF4aXNUeXBlTWl4ZXIubWl4aW4oQ29sdW1uQ2hhcnQpO1xudmVydGljYWxUeXBlTWl4ZXIubWl4aW4oQ29sdW1uQ2hhcnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbWJvIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsY3VsYXRvcicpLFxuICAgIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpLFxuICAgIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpLFxuICAgIGRlZmF1bHRUaGVtZSA9IHJlcXVpcmUoJy4uL3RoZW1lcy9kZWZhdWx0VGhlbWUnKSxcbiAgICBDb2x1bW5DaGFydFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9jb2x1bW5DaGFydFNlcmllcycpLFxuICAgIExpbmVDaGFydFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9saW5lQ2hhcnRTZXJpZXMnKTtcblxudmFyIENvbWJvQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgQ29tYm9DaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIENvbWJvIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIENvbWJvQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxhcnJheT59IHVzZXJEYXRhIGNoYXJ0IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24odXNlckRhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZXJpZXNDaGFydFR5cGVzID0gdHVpLnV0aWwua2V5cyh1c2VyRGF0YS5zZXJpZXMpLnNvcnQoKSxcbiAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXMgPSB0aGlzLl9nZXRZQXhpc09wdGlvbkNoYXJ0VHlwZXMoc2VyaWVzQ2hhcnRUeXBlcywgb3B0aW9ucy55QXhpcyksXG4gICAgICAgICAgICBjaGFydFR5cGVzID0gb3B0aW9uQ2hhcnRUeXBlcy5sZW5ndGggPyBvcHRpb25DaGFydFR5cGVzIDogc2VyaWVzQ2hhcnRUeXBlcztcblxuICAgICAgICB0aGlzLmNoYXJ0VHlwZXMgPSBjaGFydFR5cGVzO1xuICAgICAgICB0aGlzLnNlcmllc0NoYXJ0VHlwZXMgPSBzZXJpZXNDaGFydFR5cGVzO1xuICAgICAgICB0aGlzLm9wdGlvbkNoYXJ0VHlwZXMgPSBvcHRpb25DaGFydFR5cGVzO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY29tYm8tY2hhcnQnO1xuXG4gICAgICAgIENoYXJ0QmFzZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHVzZXJEYXRhOiB1c2VyRGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVzOiBzZXJpZXNDaGFydFR5cGVzLFxuICAgICAgICAgICAgaGFzQXhlczogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50cyh0aGlzLmNvbnZlcnRlZERhdGEsIHRoaXMub3B0aW9ucywgdGhpcy50aGVtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugb3B0aW9ucyBtYXBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3JkZXJJbmZvIGNoYXJ0IG9yZGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gb3B0aW9ucyBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlT3B0aW9uc01hcDogZnVuY3Rpb24oY2hhcnRUeXBlcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uc01hcCA9IHt9O1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zTWFwW2NoYXJ0VHlwZV0gPSBvcHRpb25zLnNlcmllcyAmJiBvcHRpb25zLnNlcmllc1tjaGFydFR5cGVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgdGhlbWUgbWFwXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGVnZW5kTGFiZWxzIGxlZ2VuZCBsYWJlbHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGVtZSBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVGhlbWVNYXA6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMsIHRoZW1lLCBsZWdlbmRMYWJlbHMpIHtcbiAgICAgICAgdmFyIHRoZW1lTWFwID0ge30sXG4gICAgICAgICAgICBjb2xvckNvdW50ID0gMDtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0VGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoZW1lKSksXG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvbG9ycztcblxuICAgICAgICAgICAgaWYgKGNoYXJ0VGhlbWUuc2VyaWVzW2NoYXJ0VHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGVtZU1hcFtjaGFydFR5cGVdID0gY2hhcnRUaGVtZS5zZXJpZXNbY2hhcnRUeXBlXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycykge1xuICAgICAgICAgICAgICAgIHRoZW1lTWFwW2NoYXJ0VHlwZV0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZmF1bHRUaGVtZS5zZXJpZXMpKTtcbiAgICAgICAgICAgICAgICB0aGVtZU1hcFtjaGFydFR5cGVdLmxhYmVsLmZvbnRGYW1pbHkgPSBjaGFydFRoZW1lLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRDb2xvcnMgPSBjaGFydFRoZW1lLnNlcmllcy5jb2xvcnMuc3BsaWNlKDAsIGNvbG9yQ291bnQpO1xuICAgICAgICAgICAgICAgIGNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycyA9IGNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycy5jb25jYXQocmVtb3ZlZENvbG9ycyk7XG4gICAgICAgICAgICAgICAgdGhlbWVNYXBbY2hhcnRUeXBlXSA9IGNoYXJ0VGhlbWUuc2VyaWVzO1xuICAgICAgICAgICAgICAgIGNvbG9yQ291bnQgKz0gbGVnZW5kTGFiZWxzW2NoYXJ0VHlwZV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoZW1lTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHNlcmllc2VzXG4gICAgICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb252ZXJ0ZWREYXRhIGNvbnZlcnRlZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPG9iamVjdD59IHNlcmllc2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc2VzOiBmdW5jdGlvbihjaGFydFR5cGVzLCBjb252ZXJ0ZWREYXRhLCBvcHRpb25zLCB0aGVtZSkge1xuICAgICAgICB2YXIgc2VyaWVzQ2xhc3NlcyA9IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IENvbHVtbkNoYXJ0U2VyaWVzLFxuICAgICAgICAgICAgICAgIGxpbmU6IExpbmVDaGFydFNlcmllc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAgPSB0aGlzLl9tYWtlT3B0aW9uc01hcChjaGFydFR5cGVzLCBvcHRpb25zKSxcbiAgICAgICAgICAgIHRoZW1lTWFwID0gdGhpcy5fbWFrZVRoZW1lTWFwKGNoYXJ0VHlwZXMsIHRoZW1lLCBjb252ZXJ0ZWREYXRhLmxlZ2VuZExhYmVscyksXG4gICAgICAgICAgICBzZXJpZXNlcztcbiAgICAgICAgc2VyaWVzZXMgPSB0dWkudXRpbC5tYXAoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gY29udmVydGVkRGF0YS52YWx1ZXNbY2hhcnRUeXBlXSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXMgPSBjb252ZXJ0ZWREYXRhLmZvcm1hdHRlZFZhbHVlc1tjaGFydFR5cGVdLFxuICAgICAgICAgICAgICAgIGRhdGE7XG5cbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KGNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB0dWkudXRpbC5waXZvdCh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlcyA9IHR1aS51dGlsLnBpdm90KGZvcm1hdHRlZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ3NlcmllcycsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc01hcFtjaGFydFR5cGVdLFxuICAgICAgICAgICAgICAgIHRoZW1lOiB0aGVtZU1hcFtjaGFydFR5cGVdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlczogZm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnM6IGNvbnZlcnRlZERhdGEuZm9ybWF0RnVuY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICBqb2luTGVnZW5kTGFiZWxzOiBjb252ZXJ0ZWREYXRhLmpvaW5MZWdlbmRMYWJlbHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGNoYXJ0VHlwZSArICdTZXJpZXMnLFxuICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiBzZXJpZXNDbGFzc2VzW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb252ZXJ0ZWREYXRhIGNvbnZlcnRlZCBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudHM6IGZ1bmN0aW9uKGNvbnZlcnRlZERhdGEsIG9wdGlvbnMsIHRoZW1lKSB7XG4gICAgICAgIHZhciBheGVzID0gWyd5QXhpcycsICd4QXhpcyddLFxuICAgICAgICAgICAgc2VyaWVzZXMgPSB0aGlzLl9tYWtlU2VyaWVzZXModGhpcy5zZXJpZXNDaGFydFR5cGVzLCBjb252ZXJ0ZWREYXRhLCBvcHRpb25zLCB0aGVtZSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uQ2hhcnRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF4ZXMucHVzaCgneXJBeGlzJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzRm9yQXhpc1R5cGUoe1xuICAgICAgICAgICAgY29udmVydGVkRGF0YTogY29udmVydGVkRGF0YSxcbiAgICAgICAgICAgIGF4ZXM6IGF4ZXMsXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVzOiB0aGlzLnNlcmllc0NoYXJ0VHlwZXMsXG4gICAgICAgICAgICBjaGFydFR5cGU6IG9wdGlvbnMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgc2VyaWVzZXM6IHNlcmllc2VzXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgeSBheGlzIG9wdGlvbiBjaGFydCB0eXBlcy5cbiAgICAgKiBAcGFyYW0ge2FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHlBeGlzT3B0aW9ucyB5IGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHthcnJheS48c3RyaW5nPn0gY2hhcnQgdHlwZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRZQXhpc09wdGlvbkNoYXJ0VHlwZXM6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMsIHlBeGlzT3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0Q2hhcnRUeXBlcyA9IGNoYXJ0VHlwZXMuc2xpY2UoKSxcbiAgICAgICAgICAgIGlzUmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9uQ2hhcnRUeXBlcztcblxuICAgICAgICB5QXhpc09wdGlvbnMgPSB5QXhpc09wdGlvbnMgPyBbXS5jb25jYXQoeUF4aXNPcHRpb25zKSA6IFtdO1xuXG4gICAgICAgIGlmICh5QXhpc09wdGlvbnMubGVuZ3RoID09PSAxICYmICF5QXhpc09wdGlvbnNbMF0uY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICByZXN1bHRDaGFydFR5cGVzID0gW107XG4gICAgICAgIH0gZWxzZSBpZiAoeUF4aXNPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgb3B0aW9uQ2hhcnRUeXBlcyA9IHR1aS51dGlsLm1hcCh5QXhpc09wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24uY2hhcnRUeXBlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShvcHRpb25DaGFydFR5cGVzLCBmdW5jdGlvbihjaGFydFR5cGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaXNSZXZlcnNlID0gaXNSZXZlcnNlIHx8IChjaGFydFR5cGUgJiYgcmVzdWx0Q2hhcnRUeXBlc1tpbmRleF0gIT09IGNoYXJ0VHlwZSB8fCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzUmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdENoYXJ0VHlwZXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdENoYXJ0VHlwZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgeSBheGlzIGRhdGEuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmluZGV4IGNoYXJ0IGluZGV4XG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmNvbnZlcnRlZERhdGEgY29udmVydGVkIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLnNlcmllc0RpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmVZQXhpcyB3aGV0aGVyIG9uZSBzZXJpZXMgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gYWRkUGFyYW1zIGFkZCBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB5IGF4aXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VZQXhpc0RhdGE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgY29udmVydGVkRGF0YSA9IHBhcmFtcy5jb252ZXJ0ZWREYXRhLFxuICAgICAgICAgICAgaW5kZXggPSBwYXJhbXMuaW5kZXgsXG4gICAgICAgICAgICBjaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlc1tpbmRleF0sXG4gICAgICAgICAgICBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnMsXG4gICAgICAgICAgICB5QXhpc1ZhbHVlcywgeUF4aXNPcHRpb25zLCBzZXJpZXNPcHRpb247XG5cbiAgICAgICAgaWYgKHBhcmFtcy5pc09uZVlBeGlzKSB7XG4gICAgICAgICAgICB5QXhpc1ZhbHVlcyA9IGNvbnZlcnRlZERhdGEuam9pblZhbHVlcztcbiAgICAgICAgICAgIHlBeGlzT3B0aW9ucyA9IFtvcHRpb25zLnlBeGlzXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlBeGlzVmFsdWVzID0gY29udmVydGVkRGF0YS52YWx1ZXNbY2hhcnRUeXBlXTtcbiAgICAgICAgICAgIHlBeGlzT3B0aW9ucyA9IG9wdGlvbnMueUF4aXMgfHwgW107XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpZXNPcHRpb24gPSBvcHRpb25zLnNlcmllcyAmJiBvcHRpb25zLnNlcmllc1tjaGFydFR5cGVdIHx8IG9wdGlvbnMuc2VyaWVzO1xuXG4gICAgICAgIHJldHVybiBheGlzRGF0YU1ha2VyLm1ha2VWYWx1ZUF4aXNEYXRhKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICB2YWx1ZXM6IHlBeGlzVmFsdWVzLFxuICAgICAgICAgICAgc3RhY2tlZDogc2VyaWVzT3B0aW9uICYmIHNlcmllc09wdGlvbi5zdGFja2VkIHx8ICcnLFxuICAgICAgICAgICAgb3B0aW9uczogeUF4aXNPcHRpb25zW2luZGV4XSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgc2VyaWVzRGltZW5zaW9uOiBwYXJhbXMuc2VyaWVzRGltZW5zaW9uLFxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zOiBjb252ZXJ0ZWREYXRhLmZvcm1hdEZ1bmN0aW9ucyxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcbiAgICAgICAgfSwgcGFyYW1zLmFkZFBhcmFtcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGF4ZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb252ZXJ0ZWREYXRhIGNvbnZlcnRlZCBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvdW5kcyBjaGFydCBib3VuZHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogQHJldHVybnMge29iamVjdH0gYXhlcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4ZXNEYXRhOiBmdW5jdGlvbihjb252ZXJ0ZWREYXRhLCBib3VuZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IGNvbnZlcnRlZERhdGEuZm9ybWF0RnVuY3Rpb25zLFxuICAgICAgICAgICAgeUF4aXNQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVkRGF0YTogY29udmVydGVkRGF0YSxcbiAgICAgICAgICAgICAgICBzZXJpZXNEaW1lbnNpb246IGJvdW5kcy5zZXJpZXMuZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZXM6IHRoaXMuY2hhcnRUeXBlcyxcbiAgICAgICAgICAgICAgICBpc09uZVlBeGlzOiAhdGhpcy5vcHRpb25DaGFydFR5cGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeEF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlTGFiZWxBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiBjb252ZXJ0ZWREYXRhLmxhYmVsc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB5QXhpc0RhdGEgPSB0aGlzLl9tYWtlWUF4aXNEYXRhKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgIH0sIHlBeGlzUGFyYW1zKSksXG4gICAgICAgICAgICBheGVzRGF0YSwgeXJBeGlzRGF0YTtcblxuICAgICAgICBheGVzRGF0YSA9IHtcbiAgICAgICAgICAgIHlBeGlzOiB5QXhpc0RhdGEsXG4gICAgICAgICAgICB4QXhpczogeEF4aXNEYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF5QXhpc1BhcmFtcy5pc09uZVlBeGlzKSB7XG4gICAgICAgICAgICB5ckF4aXNEYXRhID0gdGhpcy5fbWFrZVlBeGlzRGF0YSh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGluZGV4OiAxLFxuICAgICAgICAgICAgICAgIGFkZFBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBpc1Bvc2l0aW9uUmlnaHQ6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB5QXhpc1BhcmFtcykpO1xuICAgICAgICAgICAgaWYgKHlBeGlzRGF0YS50aWNrQ291bnQgPCB5ckF4aXNEYXRhLnRpY2tDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlYXNlWUF4aXNUaWNrQ291bnQoeXJBeGlzRGF0YS50aWNrQ291bnQgLSB5QXhpc0RhdGEudGlja0NvdW50LCB5QXhpc0RhdGEsIGZvcm1hdEZ1bmN0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHlBeGlzRGF0YS50aWNrQ291bnQgPiB5ckF4aXNEYXRhLnRpY2tDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlYXNlWUF4aXNUaWNrQ291bnQoeUF4aXNEYXRhLnRpY2tDb3VudCAtIHlyQXhpc0RhdGEudGlja0NvdW50LCB5ckF4aXNEYXRhLCBmb3JtYXRGdW5jdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5ckF4aXNEYXRhLmFsaWduZWQgPSB4QXhpc0RhdGEuYWxpZ25lZDtcbiAgICAgICAgICAgIGF4ZXNEYXRhLnlyQXhpcyA9IHlyQXhpc0RhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXhlc0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluY3JlYXNlIHkgYXhpcyB0aWNrIGNvdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmNyZWFzZVRpY2tDb3VudCBpbmNyZWFzZSB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRvRGF0YSB0byB0aWNrIGluZm9cbiAgICAgKiBAcGFyYW0ge2FycmF5LjxmdW5jdGlvbj59IGZvcm1hdEZ1bmN0aW9ucyBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5jcmVhc2VZQXhpc1RpY2tDb3VudDogZnVuY3Rpb24oaW5jcmVhc2VUaWNrQ291bnQsIHRvRGF0YSwgZm9ybWF0RnVuY3Rpb25zKSB7XG4gICAgICAgIHRvRGF0YS5zY2FsZS5tYXggKz0gdG9EYXRhLnN0ZXAgKiBpbmNyZWFzZVRpY2tDb3VudDtcbiAgICAgICAgdG9EYXRhLmxhYmVscyA9IGF4aXNEYXRhTWFrZXIuZm9ybWF0TGFiZWxzKGNhbGN1bGF0b3IubWFrZUxhYmVsc0Zyb21TY2FsZSh0b0RhdGEuc2NhbGUsIHRvRGF0YS5zdGVwKSwgZm9ybWF0RnVuY3Rpb25zKTtcbiAgICAgICAgdG9EYXRhLnRpY2tDb3VudCArPSBpbmNyZWFzZVRpY2tDb3VudDtcbiAgICAgICAgdG9EYXRhLnZhbGlkVGlja0NvdW50ICs9IGluY3JlYXNlVGlja0NvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNoYXJ0IGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RoaXMuX2F0dGFjaENvbWJvQ2hhcnRDb29yZGluYXRlRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIENoYXJ0QmFzZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgc2VyaWVzQ2hhcnRUeXBlczogdGhpcy5zZXJpZXNDaGFydFR5cGVzLFxuICAgICAgICAgICAgb3B0aW9uQ2hhcnRUeXBlczogdGhpcy5vcHRpb25DaGFydFR5cGVzXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKENvbWJvQ2hhcnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbWJvQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGluZSBjaGFydFxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcnRCYXNlID0gcmVxdWlyZSgnLi9jaGFydEJhc2UnKSxcbiAgICBsaW5lVHlwZU1peGVyID0gcmVxdWlyZSgnLi9saW5lVHlwZU1peGVyJyksXG4gICAgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpLFxuICAgIHZlcnRpY2FsVHlwZU1peGVyID0gcmVxdWlyZSgnLi92ZXJ0aWNhbFR5cGVNaXhlcicpLFxuICAgIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9saW5lQ2hhcnRTZXJpZXMnKTtcblxudmFyIExpbmVDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBMaW5lQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBjbGFzc05hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogJ3R1aS1saW5lLWNoYXJ0JyxcblxuICAgIC8qKlxuICAgICAqIFNlcmllcyBjbGFzc1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICBTZXJpZXM6IFNlcmllcyxcblxuICAgIC8qKlxuICAgICAqIExpbmUgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgTGluZUNoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQG1peGVzIGF4aXNUeXBlTWl4ZXJcbiAgICAgKiBAbWl4ZXMgdmVydGljYWxUeXBlTWl4ZXJcbiAgICAgKiBAbWl4ZXMgbGluZVR5cGVNaXhlclxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9saW5lVHlwZUluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59KTtcblxuYXhpc1R5cGVNaXhlci5taXhpbihMaW5lQ2hhcnQpO1xudmVydGljYWxUeXBlTWl4ZXIubWl4aW4oTGluZUNoYXJ0KTtcbmxpbmVUeXBlTWl4ZXIubWl4aW4oTGluZUNoYXJ0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgbGluZVR5cGVNaXhlciBpcyBtaXhlciBvZiBsaW5lIHR5cGUgY2hhcnQobGluZSwgYXJlYSkuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIEFyZWFUeXBlQ3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvYXJlYVR5cGVDdXN0b21FdmVudCcpO1xuXG4vKipcbiAqIGxpbmVUeXBlTWl4ZXIgaXMgbWl4ZXIgb2YgbGluZSB0eXBlIGNoYXJ0KGxpbmUsIGFyZWEpLlxuICogQG1peGluXG4gKi9cbnZhciBsaW5lVHlwZU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gdXNlckRhdGEgY2hhcnQgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5pdGVkRGF0YSBpbml0aWFsaXplZCBkYXRhIGZyb20gY29tYm8gY2hhcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9saW5lVHlwZUluaXQ6IGZ1bmN0aW9uKHVzZXJEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICB1c2VyRGF0YTogdXNlckRhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgaGFzQXhlczogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50cyh0aGlzLmNvbnZlcnRlZERhdGEsIG9wdGlvbnMuY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50Rm9yTm9ybWFsVG9vbHRpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudCgnY3VzdG9tRXZlbnQnLCBBcmVhVHlwZUN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb252ZXJ0ZWREYXRhIGNvbnZlcnRlZCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ29tcG9uZW50czogZnVuY3Rpb24oY29udmVydGVkRGF0YSwgY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhID0ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHZhbHVlczogdHVpLnV0aWwucGl2b3QoY29udmVydGVkRGF0YS52YWx1ZXMpLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlczogdHVpLnV0aWwucGl2b3QoY29udmVydGVkRGF0YS5mb3JtYXR0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uczogY29udmVydGVkRGF0YS5mb3JtYXRGdW5jdGlvbnMsXG4gICAgICAgICAgICAgICAgam9pbkxlZ2VuZExhYmVsczogY29udmVydGVkRGF0YS5qb2luTGVnZW5kTGFiZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHNGb3JBeGlzVHlwZSh7XG4gICAgICAgICAgICBjb252ZXJ0ZWREYXRhOiBjb252ZXJ0ZWREYXRhLFxuICAgICAgICAgICAgYXhlczogWyd5QXhpcycsICd4QXhpcyddLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICBzZXJpZXNlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlcmllcycsXG4gICAgICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiB0aGlzLlNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VyaWVzRGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlclxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY2hhcnQgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBDaGFydEJhc2UucHJvdG90eXBlLnJlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXggaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyB0YXJnZXQgZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVUeXBlTWl4ZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGllIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcnRCYXNlID0gcmVxdWlyZSgnLi9jaGFydEJhc2UnKSxcbiAgICBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBMZWdlbmQgPSByZXF1aXJlKCcuLi9sZWdlbmRzL2xlZ2VuZCcpLFxuICAgIFRvb2x0aXAgPSByZXF1aXJlKCcuLi90b29sdGlwcy90b29sdGlwJyksXG4gICAgU2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL3BpZUNoYXJ0U2VyaWVzJyk7XG5cbnZhciBQaWVDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBQaWVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBQaWVDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gdXNlckRhdGEgY2hhcnQgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbih1c2VyRGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLXBpZS1jaGFydCc7XG5cbiAgICAgICAgb3B0aW9ucy50b29sdGlwID0gb3B0aW9ucy50b29sdGlwIHx8IHt9O1xuXG4gICAgICAgIGlmICghb3B0aW9ucy50b29sdGlwLmFsaWduKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRvb2x0aXAuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9BTElHTl9PUFRJT047XG4gICAgICAgIH1cblxuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICB1c2VyRGF0YTogdXNlckRhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHModGhpcy5jb252ZXJ0ZWREYXRhLCB0aGVtZS5jaGFydC5iYWNrZ3JvdW5kLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udmVydGVkRGF0YSBjb252ZXJ0ZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydEJhY2tncm91bmQgY2hhcnQgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjb252ZXJ0ZWREYXRhLCBjaGFydEJhY2tncm91bmQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGxlZ2VuZEFsaWduLCBpc1BpZUxlZ2VuZFR5cGU7XG4gICAgICAgIG9wdGlvbnMubGVnZW5kID0gb3B0aW9ucy5sZWdlbmQgfHwge307XG4gICAgICAgIGxlZ2VuZEFsaWduID0gb3B0aW9ucy5sZWdlbmQgJiYgb3B0aW9ucy5sZWdlbmQuYWxpZ247XG4gICAgICAgIGlzUGllTGVnZW5kVHlwZSA9IHByZWRpY2F0ZS5pc1BpZUxlZ2VuZEFsaWduKGxlZ2VuZEFsaWduKTtcbiAgICAgICAgaWYgKGNvbnZlcnRlZERhdGEuam9pbkxlZ2VuZExhYmVscyAmJiAhaXNQaWVMZWdlbmRUeXBlICYmICFvcHRpb25zLmxlZ2VuZC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZENvbXBvbmVudCgnbGVnZW5kJywgTGVnZW5kLCB7XG4gICAgICAgICAgICAgICAgam9pbkxlZ2VuZExhYmVsczogY29udmVydGVkRGF0YS5qb2luTGVnZW5kTGFiZWxzLFxuICAgICAgICAgICAgICAgIGxlZ2VuZExhYmVsczogY29udmVydGVkRGF0YS5sZWdlbmRMYWJlbHMsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBvcHRpb25zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudCgndG9vbHRpcCcsIFRvb2x0aXAsIHtcbiAgICAgICAgICAgIHZhbHVlczogY29udmVydGVkRGF0YS52YWx1ZXMsXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXM6IGNvbnZlcnRlZERhdGEuZm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICAgICAgbGFiZWxzOiBjb252ZXJ0ZWREYXRhLmxhYmVscyxcbiAgICAgICAgICAgIGxlZ2VuZExhYmVsczogY29udmVydGVkRGF0YS5sZWdlbmRMYWJlbHMsXG4gICAgICAgICAgICBqb2luTGVnZW5kTGFiZWxzOiBjb252ZXJ0ZWREYXRhLmpvaW5MZWdlbmRMYWJlbHMsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50LFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBvcHRpb25zLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnQoJ3NlcmllcycsIFNlcmllcywge1xuICAgICAgICAgICAgbGliVHlwZTogb3B0aW9ucy5saWJUeXBlLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBvcHRpb25zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdzZXJpZXMnLFxuICAgICAgICAgICAgY2hhcnRCYWNrZ3JvdW5kOiBjaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IHRoaXMudXNlckV2ZW50LFxuICAgICAgICAgICAgbGVnZW5kQWxpZ246IGlzUGllTGVnZW5kVHlwZSAmJiAhb3B0aW9ucy5sZWdlbmQuaGlkZGVuID8gbGVnZW5kQWxpZ24gOiBudWxsLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHZhbHVlczogY29udmVydGVkRGF0YS52YWx1ZXMsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVzOiBjb252ZXJ0ZWREYXRhLmZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgICAgICAgICBsZWdlbmRMYWJlbHM6IGNvbnZlcnRlZERhdGEubGVnZW5kTGFiZWxzLFxuICAgICAgICAgICAgICAgIGpvaW5MZWdlbmRMYWJlbHM6IGNvbnZlcnRlZERhdGEuam9pbkxlZ2VuZExhYmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSByZW5kZXJpbmcgZGF0YSBmb3IgcGllIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHMgY2hhcnQgYm91bmRzXG4gICAgICogKiBAcGFyYW0ge29iamVjdH0gYm91bmRzIGNoYXJ0IGJvdW5kc1xuICAgICAqIEByZXR1cm4ge29iamVjdH0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIHNlcmllc1Bvc2l0aW9uOiBib3VuZHMuc2VyaWVzLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGNoYXJ0RGltZW5zaW9uOiBib3VuZHMuY2hhcnQuZGltZW5zaW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgY2hhcnRXaWR0aDogYm91bmRzLmNoYXJ0LmRpbWVuc2lvbi53aWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggY3VzdG9tIGV2bmV0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRvb2x0aXAgPSB0aGlzLmNvbXBvbmVudE1hcC50b29sdGlwLFxuICAgICAgICAgICAgc2VyaWVzZXMgPSB0dWkudXRpbC5maWx0ZXIodGhpcy5jb21wb25lbnRNYXAsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LmNvbXBvbmVudFR5cGUgPT09ICdzZXJpZXMnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgIHNlcmllcy5vbignc2hvd1Rvb2x0aXAnLCB0b29sdGlwLm9uU2hvdywgdG9vbHRpcCk7XG4gICAgICAgICAgICBzZXJpZXMub24oJ2hpZGVUb29sdGlwJywgdG9vbHRpcC5vbkhpZGUsIHRvb2x0aXApO1xuXG4gICAgICAgICAgICBpZiAoc2VyaWVzLm9uU2hvd0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAub24ocmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzaG93Jywgc2VyaWVzLmNoYXJ0VHlwZSwgJ2FuaW1hdGlvbicpLCBzZXJpZXMub25TaG93QW5pbWF0aW9uLCBzZXJpZXMpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAub24ocmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdoaWRlJywgc2VyaWVzLmNoYXJ0VHlwZSwgJ2FuaW1hdGlvbicpLCBzZXJpZXMub25IaWRlQW5pbWF0aW9uLCBzZXJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWVDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyB2ZXJ0aWNhbFR5cGVNaXhlciBpcyBtaXhlciBvZiB2ZXJ0aWNhbCB0eXBlIGNoYXJ0KGNvbHVtbiwgbGluZSwgYXJlYSkuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBheGlzRGF0YU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzRGF0YU1ha2VyJyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcblxuLyoqXG4gKiB2ZXJ0aWNhbFR5cGVNaXhlciBpcyBtaXhlciBvZiB2ZXJ0aWNhbCB0eXBlIGNoYXJ0KGNvbHVtbiwgbGluZSwgYXJlYSkuXG4gKiBAbWl4aW5cbiAqL1xudmFyIHZlcnRpY2FsVHlwZU1peGVyID0ge1xuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYXhlcyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnZlcnRlZERhdGEgY29udmVydGVkIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYm91bmRzIGNoYXJ0IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBheGVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0RhdGE6IGZ1bmN0aW9uKGNvbnZlcnRlZERhdGEsIGJvdW5kcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgYWxpZ25lZCA9IHByZWRpY2F0ZS5pc0xpbmVUeXBlQ2hhcnQob3B0aW9ucy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgeEF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlTGFiZWxBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiBjb252ZXJ0ZWREYXRhLmxhYmVscyxcbiAgICAgICAgICAgICAgICBhbGlnbmVkOiBhbGlnbmVkLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMueEF4aXNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeUF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlVmFsdWVBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBjb252ZXJ0ZWREYXRhLnZhbHVlcyxcbiAgICAgICAgICAgICAgICBzZXJpZXNEaW1lbnNpb246IGJvdW5kcy5zZXJpZXMuZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgIHN0YWNrZWQ6IG9wdGlvbnMuc2VyaWVzICYmIG9wdGlvbnMuc2VyaWVzLnN0YWNrZWQgfHwgJycsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBvcHRpb25zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnM6IGNvbnZlcnRlZERhdGEuZm9ybWF0RnVuY3Rpb25zLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMueUF4aXMsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGlnbmVkOiBhbGlnbmVkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeEF4aXM6IHhBeGlzRGF0YSxcbiAgICAgICAgICAgIHlBeGlzOiB5QXhpc0RhdGFcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4IGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgdGFyZ2V0IGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHR1aS51dGlsLmV4dGVuZChmdW5jLnByb3RvdHlwZSwgdGhpcyk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJ0aWNhbFR5cGVNaXhlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQaWNrIG1pbmltdW0gdmFsdWUgZnJvbSB2YWx1ZSBhcnJheS5cbiAqIEBwYXJhbSB7YXJyYXl9IGFyciB2YWx1ZSBhcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIGNvbmRpdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgdGFyZ2V0IGNvbnRleHRcbiAqIEByZXR1cm5zIHsqfSBtaW5pbXVtIHZhbHVlXG4gKi9cbnZhciBtaW4gPSBmdW5jdGlvbihhcnIsIGNvbmRpdGlvbiwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQsIG1pblZhbHVlLCByZXN0O1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXN1bHQgPSBhcnJbMF07XG4gICAgbWluVmFsdWUgPSBjb25kaXRpb24uY2FsbChjb250ZXh0LCByZXN1bHQpO1xuICAgIHJlc3QgPSBhcnIuc2xpY2UoMSk7XG4gICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHJlc3QsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIGNvbXBhcmVWYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0pO1xuICAgICAgICBpZiAoY29tcGFyZVZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gY29tcGFyZVZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBpY2sgbWF4aW11bSB2YWx1ZSBmcm9tIHZhbHVlIGFycmF5LlxuICogQHBhcmFtIHthcnJheX0gYXJyIHZhbHVlIGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gY29uZGl0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCB0YXJnZXQgY29udGV4dFxuICogQHJldHVybnMgeyp9IG1heGltdW0gdmFsdWVcbiAqL1xudmFyIG1heCA9IGZ1bmN0aW9uKGFyciwgY29uZGl0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCwgbWF4VmFsdWUsIHJlc3Q7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlc3VsdCA9IGFyclswXTtcbiAgICBtYXhWYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIHJlc3VsdCk7XG4gICAgcmVzdCA9IGFyci5zbGljZSgxKTtcbiAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkocmVzdCwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgY29tcGFyZVZhbHVlID0gY29uZGl0aW9uLmNhbGwoY29udGV4dCwgaXRlbSk7XG4gICAgICAgIGlmIChjb21wYXJlVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgbWF4VmFsdWUgPSBjb21wYXJlVmFsdWU7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogV2hldGhlciBvbmUgb2YgdGhlbSBpcyB0cnVlIG9yIG5vdC5cbiAqIEBwYXJhbSB7YXJyYXl9IGFyciB0YXJnZXQgYXJyYXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBjb25kaXRpb24gZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICovXG52YXIgYW55ID0gZnVuY3Rpb24oYXJyLCBjb25kaXRpb24pIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGFyciwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQWxsIG9mIHRoZW0gaXMgdHJ1ZSBvciBub3QuXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgdGFyZ2V0IGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gY29uZGl0aW9uIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAqL1xudmFyIGFsbCA9IGZ1bmN0aW9uKGFyciwgY29uZGl0aW9uKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGFyciwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbihpdGVtKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBcnJheSBwaXZvdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6Y2FsY3VsYXRvclxuICogQHBhcmFtIHthcnJheS48YXJyYXk+fSBhcnIyZCB0YXJnZXQgMmQgYXJyYXlcbiAqIEByZXR1cm5zIHthcnJheS48YXJyYXk+fSBwaXZvdGVkIDJkIGFycmF5XG4gKi9cbnZhciBwaXZvdCA9IGZ1bmN0aW9uKGFycjJkKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShhcnIyZCwgZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShhcnIsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2luZGV4XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IGFmdGVyIHBvaW50IGxlbmd0aC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJlc3VsdCBsZW5ndGhcbiAqL1xudmFyIGxlbmd0aEFmdGVyUG9pbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB2YWx1ZUFyciA9ICh2YWx1ZSArICcnKS5zcGxpdCgnLicpO1xuICAgIHJldHVybiB2YWx1ZUFyci5sZW5ndGggPT09IDIgPyB2YWx1ZUFyclsxXS5sZW5ndGggOiAwO1xufTtcblxuLyoqXG4gKiBGaW5kIG11bHRpcGxlIG51bS5cbiAqIEBwYXJhbSB7Li4uYXJyYXl9IHRhcmdldCB2YWx1ZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG11bHRpcGxlIG51bVxuICovXG52YXIgZmluZE11bHRpcGxlTnVtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHVuZGVyUG9pbnRMZW5zID0gdHVpLnV0aWwubWFwKGFyZ3MsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubGVuZ3RoQWZ0ZXJQb2ludCh2YWx1ZSk7XG4gICAgICAgIH0pLFxuICAgICAgICB1bmRlclBvaW50TGVuID0gdHVpLnV0aWwubWF4KHVuZGVyUG9pbnRMZW5zKSxcbiAgICAgICAgbXVsdGlwbGVOdW0gPSBNYXRoLnBvdygxMCwgdW5kZXJQb2ludExlbik7XG4gICAgcmV0dXJuIG11bHRpcGxlTnVtO1xufTtcblxuLyoqXG4gKiBNb2R1bG8gb3BlcmF0aW9uIGZvciBmbG9hdGluZyBwb2ludCBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0IHRhcmdldCB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2ROdW0gbW9kIG51bVxuICogQHJldHVybnMge251bWJlcn0gcmVzdWx0IG1vZFxuICovXG52YXIgbW9kID0gZnVuY3Rpb24odGFyZ2V0LCBtb2ROdW0pIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSB0dWkudXRpbC5maW5kTXVsdGlwbGVOdW0obW9kTnVtKTtcbiAgICByZXR1cm4gKCh0YXJnZXQgKiBtdWx0aXBsZU51bSkgJSAobW9kTnVtICogbXVsdGlwbGVOdW0pKSAvIG11bHRpcGxlTnVtO1xufTtcblxuLyoqXG4gKiBBZGRpdGlvbiBmb3IgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGEgdGFyZ2V0IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIHRhcmdldCBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhZGRpdGlvbiByZXN1bHRcbiAqL1xudmFyIGFkZGl0aW9uID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBtdWx0aXBsZU51bSA9IGZpbmRNdWx0aXBsZU51bShhLCBiKTtcbiAgICByZXR1cm4gKChhICogbXVsdGlwbGVOdW0pICsgKGIgKiBtdWx0aXBsZU51bSkpIC8gbXVsdGlwbGVOdW07XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0aW9uIGZvciBmbG9hdGluZyBwb2ludCBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYSB0YXJnZXQgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgdGFyZ2V0IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHN1YnRyYWN0aW9uIHJlc3VsdFxuICovXG52YXIgc3VidHJhY3Rpb24gPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIG11bHRpcGxlTnVtID0gZmluZE11bHRpcGxlTnVtKGEsIGIpO1xuICAgIHJldHVybiAoKGEgKiBtdWx0aXBsZU51bSkgLSAoYiAqIG11bHRpcGxlTnVtKSkgLyBtdWx0aXBsZU51bTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGljYXRpb24gZm9yIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIHRhcmdldCBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiB0YXJnZXQgYlxuICogQHJldHVybnMge251bWJlcn0gbXVsdGlwbGljYXRpb24gcmVzdWx0XG4gKi9cbnZhciBtdWx0aXBsaWNhdGlvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oYSwgYik7XG4gICAgcmV0dXJuICgoYSAqIG11bHRpcGxlTnVtKSAqIChiICogbXVsdGlwbGVOdW0pKSAvIChtdWx0aXBsZU51bSAqIG11bHRpcGxlTnVtKTtcbn07XG5cbi8qKlxuICogRGl2aXNpb24gZm9yIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIHRhcmdldCBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiB0YXJnZXQgYlxuICogQHJldHVybnMge251bWJlcn0gZGl2aXNpb24gcmVzdWx0XG4gKi9cbnZhciBkaXZpc2lvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oYSwgYik7XG4gICAgcmV0dXJuIChhICogbXVsdGlwbGVOdW0pIC8gKGIgKiBtdWx0aXBsZU51bSk7XG59O1xuXG4vKipcbiAqIFN1bS5cbiAqIEBwYXJhbSB7YXJyYXkuPG51bWJlcj59IHZhbHVlcyB0YXJnZXQgdmFsdWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByZXN1bHQgdmFsdWVcbiAqL1xudmFyIHN1bSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHZhciBjb3B5QXJyID0gdmFsdWVzLnNsaWNlKCk7XG4gICAgY29weUFyci51bnNoaWZ0KDApO1xuICAgIHJldHVybiB0dWkudXRpbC5yZWR1Y2UoY29weUFyciwgZnVuY3Rpb24oYmFzZSwgYWRkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGJhc2UpICsgcGFyc2VGbG9hdChhZGQpO1xuICAgIH0pO1xufTtcblxuXG52YXIgcHJvcGVyQ2FzZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxudHVpLnV0aWwubWluID0gbWluO1xudHVpLnV0aWwubWF4ID0gbWF4O1xudHVpLnV0aWwuYW55ID0gYW55O1xudHVpLnV0aWwuYWxsID0gYWxsO1xudHVpLnV0aWwucGl2b3QgPSBwaXZvdDtcbnR1aS51dGlsLmxlbmd0aEFmdGVyUG9pbnQgPSBsZW5ndGhBZnRlclBvaW50O1xudHVpLnV0aWwubW9kID0gbW9kO1xudHVpLnV0aWwuZmluZE11bHRpcGxlTnVtID0gZmluZE11bHRpcGxlTnVtO1xudHVpLnV0aWwuYWRkaXRpb24gPSBhZGRpdGlvbjtcbnR1aS51dGlsLnN1YnRyYWN0aW9uID0gc3VidHJhY3Rpb247XG50dWkudXRpbC5tdWx0aXBsaWNhdGlvbiA9IG11bHRpcGxpY2F0aW9uO1xudHVpLnV0aWwuZGl2aXNpb24gPSBkaXZpc2lvbjtcbnR1aS51dGlsLnN1bSA9IHN1bTtcbnR1aS51dGlsLnByb3BlckNhc2UgPSBwcm9wZXJDYXNlO1xuXG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgZm4gdW50aWwgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkXG4gKiBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdWNlZCBmdW5jdGlvbiB3YXMgaW52b2tlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXlcbiAqIEBtZW1iZXJvZiB0dWkudXRpbFxuICogQHJldHVybnMge2Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCgpIHt9XG4gKlxuICogdmFyIGRlYm91bmNlZCA9IHR1aS51dGlsLmRlYm91bmNlKHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCwgMzAwKTtcbiAqXG4gKiAvLyBpbnZva2UgcmVwZWF0ZWRseVxuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpOyAgICAvLyBsYXN0IGludm9rZSBvZiBkZWJvdW5jZWQoKVxuICpcbiAqIC8vIGludm9rZSBzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQoKSBhZnRlciAzMDAgbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgICB2YXIgdGltZXIsXG4gICAgICAgIGFyZ3M7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBmbiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGludGVydmFsIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIHRocm90dGxlIHNob3J0IHRpbWUgcmVwZWF0ZWRseSBpbnZva2luZyBmdW5jdGlvbnMuIChlLmcgTW91c2VNb3ZlLCBSZXNpemUgLi4uKVxuICpcbiAqIGlmIHlvdSBuZWVkIHJldXNlIHRocm90dGxlZCBtZXRob2QuIHlvdSBtdXN0IHJlbW92ZSBzbHVncyAoZS5nLiBmbGFnIHZhcmlhYmxlKSByZWxhdGVkIHdpdGggdGhyb3R0bGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIHRocm90dGxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVydmFsPTBdIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQG1lbWJlcm9mIHR1aS51dGlsXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQoKSB7fVxuICpcbiAqIHZhciB0aHJvdHRsZWQgPSB0dWkudXRpbC50aHJvdHRsZShzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQsIDMwMCk7XG4gKlxuICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKGxlYWRpbmcpXG4gKiB0aHJvdHRsZWQoKTtcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKG5lYXIgMzAwIG1pbGxpc2Vjb25kcylcbiAqIHRocm90dGxlZCgpO1xuICogdGhyb3R0bGVkKCk7XG4gKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChuZWFyIDYwMCBtaWxsaXNlY29uZHMpXG4gKiAvLyAuLi5cbiAqIC8vIGludm9rZSAodHJhaWxpbmcpXG4gKlxuICogLy8gaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4gdGhlbiBpbnZva2UgcmVzZXQoKVxuICogdGhyb3R0bGVkLnJlc2V0KCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBpbnRlcnZhbCkge1xuICAgIHZhciBiYXNlLFxuICAgICAgICBfdGltZXN0YW1wID0gdHVpLnV0aWwudGltZXN0YW1wLFxuICAgICAgICBkZWJvdW5jZWQsXG4gICAgICAgIGlzTGVhZGluZyA9IHRydWUsXG4gICAgICAgIHN0YW1wLFxuICAgICAgICBhcmdzLFxuICAgICAgICB0aWNrID0gZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIF9hcmdzKTtcbiAgICAgICAgICAgIGJhc2UgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDA7XG5cbiAgICBkZWJvdW5jZWQgPSB0dWkudXRpbC5kZWJvdW5jZSh0aWNrLCBpbnRlcnZhbCk7XG5cbiAgICBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgICAgIGFyZ3MgPSBhcHMuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmIChpc0xlYWRpbmcpIHtcbiAgICAgICAgICAgIHRpY2soYXJncyk7XG4gICAgICAgICAgICBpc0xlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YW1wID0gX3RpbWVzdGFtcCgpO1xuXG4gICAgICAgIGJhc2UgPSBiYXNlIHx8IHN0YW1wO1xuXG4gICAgICAgIGRlYm91bmNlZChhcmdzKTtcblxuICAgICAgICBpZiAoKHN0YW1wIC0gYmFzZSkgPj0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRpY2soYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgaXNMZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgYmFzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhyb3R0bGVkLnJlc2V0ID0gcmVzZXQ7XG4gICAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxudHVpLnV0aWwuZGVib3VuY2UgPSBkZWJvdW5jZTtcbnR1aS51dGlsLnRocm90dGxlID0gdGhyb3R0bGU7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hhcnQgY29uc3RcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbi8qKlxuICogQ2hhcnQgY29uc3RcbiAqIEByZWFkb25seVxuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIGNoYXJ0Q29uc3QgPSB7XG4gICAgLyoqIHR1aSBjbGFzcyBuYW1lc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgQ0xBU1NfTkFNRV9MRUdFTkQ6ICd0dWktY2hhcnQtbGVnZW5kJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDTEFTU19OQU1FX1NFUklFU19MQUJFTDogJ3R1aS1jaGFydC1zZXJpZXMtbGFiZWwnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENMQVNTX05BTUVfU0VSSUVTX0xFR0VORDogJ3R1aS1jaGFydC1zZXJpZXMtbGVnZW5kJyxcbiAgICAvKiogY2hhcnQgdHlwZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIENIQVJUX1RZUEVfQkFSOiAnYmFyJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0NPTFVNTjogJ2NvbHVtbicsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9MSU5FOiAnbGluZScsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9BUkVBOiAnYXJlYScsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0hBUlRfVFlQRV9DT01CTzogJ2NvbWJvJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX1BJRTogJ3BpZScsXG4gICAgLyoqIGNoYXJ0IHBhZGRpbmcgKi9cbiAgICBDSEFSVF9QQURESU5HOiAxMCxcbiAgICAvKiogY2hhcnQgZGVmYXVsdCB3aWR0aCAqL1xuICAgIENIQVJUX0RFRkFVTFRfV0lEVEg6IDUwMCxcbiAgICAvKiogY2hhcnQgZGVmYXVsdCBoZWlnaHQgKi9cbiAgICBDSEFSVF9ERUZBVUxUX0hFSUdIVDogNDAwLFxuICAgIC8qKiBoaWRkZW4gd2lkdGggKi9cbiAgICBISURERU5fV0lEVEg6IDEsXG4gICAgLyoqIHJlbmRlcmVkIHRleHQgcGFkZGluZyAqL1xuICAgIFRFWFRfUEFERElORzogMixcbiAgICAvKiogc2VyaWVzIGV4cGFuZCBzaXplICovXG4gICAgU0VSSUVTX0VYUEFORF9TSVpFOiAxMCxcbiAgICAvKiogc2VyaWVzIGxhYmVsIHBhZGRpbmcgKi9cbiAgICBTRVJJRVNfTEFCRUxfUEFERElORzogNSxcbiAgICAvKiogZGVmYXVsdCBmb250IHNpemUgb2YgdGl0bGUgKi9cbiAgICBERUZBVUxUX1RJVExFX0ZPTlRfU0laRTogMTQsXG4gICAgLyoqIGRlZmF1bHQgZm9udCBzaXplIG9mIGF4aXMgdGl0bGUgKi9cbiAgICBERUZBVUxUX0FYSVNfVElUTEVfRk9OVF9TSVpFOiAxMCxcbiAgICAvKiogZGVmYXVsdCBmb250IHNpemUgb2YgbGFiZWwgKi9cbiAgICBERUZBVUxUX0xBQkVMX0ZPTlRfU0laRTogMTIsXG4gICAgLyoqIGRlZmF1bHQgZm9udCBzaXplIG9mIHNlcmllcyBsYWJlbCAqL1xuICAgIERFRkFVTFRfU0VSSUVTX0xBQkVMX0ZPTlRfU0laRTogMTEsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgLyoqIGRlZmF1bHQgZ3JhcGggcGx1Z2luXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBERUZBVUxUX1BMVUdJTjogJ3JhcGhhZWwnLFxuICAgIC8qKiBkZWZhdWx0IHRpY2sgY29sb3JcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIERFRkFVTFRfVElDS19DT0xPUjogJ2JsYWNrJyxcbiAgICAvKiogZGVmYXVsdCB0aGVtZSBuYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBERUZBVUxUX1RIRU1FX05BTUU6ICdkZWZhdWx0JyxcbiAgICAvKiogc3RhY2tlZCBvcHRpb24gdHlwZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIFNUQUNLRURfTk9STUFMX1RZUEU6ICdub3JtYWwnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFNUQUNLRURfUEVSQ0VOVF9UWVBFOiAncGVyY2VudCcsXG4gICAgLyoqIGVtcHR5IGF4aXMgbGFiZWwgKi9cbiAgICBFTVBUWV9BWElTX0xBQkVMOiAnJyxcbiAgICAvKiogYW5nZWwgKi9cbiAgICBBTkdMRV84NTogODUsXG4gICAgQU5HTEVfOTA6IDkwLFxuICAgIEFOR0xFXzM2MDogMzYwLFxuICAgIC8qKiByYWRpYW4gKi9cbiAgICBSQUQ6IE1hdGguUEkgLyAxODAsXG4gICAgLyoqIHNlcmllcyBsZWdlbmQgdHlwZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIExFR0VORF9BTElHTl9PVVRFUjogJ291dGVyJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBMRUdFTkRfVFlQRV9DRU5URVI6ICdjZW50ZXInLFxuICAgIC8qKiBzZXJpZXMgb3V0ZXIgbGFiZWwgcGFkZGluZyAqL1xuICAgIFNFUklFU19PVVRFUl9MQUJFTF9QQURESU5HOiAyMCxcbiAgICAvKiogZGVmYXVsdCByYXRlIG9mIHBpZSBncmFwaCAqL1xuICAgIFBJRV9HUkFQSF9ERUZBVUxUX1JBVEU6IDAuOCxcbiAgICAvKiogc21hbGwgcmF0ZSBvZiBwaWUgZ3JhcGggKi9cbiAgICBQSUVfR1JBUEhfU01BTExfUkFURTogMC42NSxcbiAgICAvKiogZG90IHJhZGl1cyAqL1xuICAgIERPVF9SQURJVVM6IDQsXG4gICAgLyoqIHlBeGlzIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSB7YXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgWUFYSVNfUFJPUFM6IFsndGlja0NvbG9yJywgJ3RpdGxlJywgJ2xhYmVsJ10sIC8vIHlheGlzIHRoZW1l7J2YIOyGjeyEsSAtIGNoYXJ0IHR5cGUgZmlsdGVyaW5n7ZWgIOuVjCDsgqzsmqnrkKhcbiAgICAvKiogc2VyaWVzIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSB7YXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgU0VSSUVTX1BST1BTOiBbJ2xhYmVsJywgJ2NvbG9ycycsICdib3JkZXJDb2xvcicsICdzaW5nbGVDb2xvcnMnLCAnc2VsZWN0aW9uQ29sb3InXSwgLy8gc2VyaWVzIHRoZW1l7J2YIOyGjeyEsSAtIGNoYXJ0IHR5cGUgZmlsdGVyaW5n7ZWgIOuVjCDsgqzsmqnrkKhcbiAgICAvKiogdGl0bGUgYXJlYSB3aWR0aCBwYWRkaW5nICovXG4gICAgVElUTEVfQVJFQV9XSURUSF9QQURESU5HOiAyMCxcbiAgICAvKiogdG9wIG1hcmdpbiBvZiB4IGF4aXMgbGFiZWwgKi9cbiAgICBYQVhJU19MQUJFTF9UT1BfTUFSR0lOOiAxMCxcbiAgICAvKiogcmlnaHQgcGFkZGluZyBvZiB2ZXJ0aWNhbCBsYWJlbCAqL1xuICAgIFZfTEFCRUxfUklHSFRfUEFERElORzogMTAsXG4gICAgLyoqIHRvb2x0aXAgcHJlZml4XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBUT09MVElQX1BSRUZJWDogJ3R1aS1jaGFydC10b29sdGlwJyxcbiAgICAvKiogbWluaW11bSBwaXhlbCB0eXBlIHN0ZXAgc2l6ZSAqL1xuICAgIE1JTl9QSVhFTF9UWVBFX1NURVBfU0laRTogNDAsXG4gICAgLyoqIG1heGltdW0gcGl4ZWwgdHlwZSBzdGVwIHNpemUgKi9cbiAgICBNQVhfUElYRUxfVFlQRV9TVEVQX1NJWkU6IDYwLFxuICAgIC8qKiB0aWNrIGluZm8gb2YgcGVyY2VudCBzdGFja2VkIG9wdGlvblxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgUEVSQ0VOVF9TVEFDS0VEX1RJQ0tfSU5GTzoge1xuICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAxMDBcbiAgICAgICAgfSxcbiAgICAgICAgc3RlcDogMjUsXG4gICAgICAgIHRpY2tDb3VudDogNSxcbiAgICAgICAgbGFiZWxzOiBbMCwgMjUsIDUwLCA3NSwgMTAwXVxuICAgIH0sXG4gICAgLyoqIHRpdGxlIGFkZCBwYWRkaW5nICovXG4gICAgVElUTEVfUEFERElORzogMjAsXG4gICAgLyoqIGxlZ2VuZCBhcmVhIHBhZGRpbmcgKi9cbiAgICBMRUdFTkRfQVJFQV9QQURESU5HOiAxMCxcbiAgICAvKiogbGVnZW5kIHJlY3Qgd2lkdGggKi9cbiAgICBMRUdFTkRfUkVDVF9XSURUSDogMTIsXG4gICAgLyoqIGxnZW5kIGxhYmVsIGxlZnQgcGFkZGluZyAqL1xuICAgIExFR0VORF9MQUJFTF9MRUZUX1BBRERJTkc6IDUsXG4gICAgLyoqIEFYSVMgTEFCRUwgUEFERElORyAqL1xuICAgIEFYSVNfTEFCRUxfUEFERElORzogNyxcbiAgICAvKiogcm90YXRpb25zIGRlZ3JlZSBjYW5kaWRhdGVzICovXG4gICAgREVHUkVFX0NBTkRJREFURVM6IFsyNSwgNDUsIDY1LCA4NV0sXG4gICAgLyoqIHhBeGlzIGxhYmVsIGNvbXBhcmUgbWFyZ2luICovXG4gICAgWEFYSVNfTEFCRUxfQ09NUEFSRV9NQVJHSU46IDIwLFxuICAgIC8qKiB4QXhpcyBsYWJlbCBndXR0ZXIgKi9cbiAgICBYQVhJU19MQUJFTF9HVVRURVI6IDIsXG4gICAgLyoqIHN0YW5kIG11bHRpcGxlIG51bXMgb2YgYXhpcyAqL1xuICAgIEFYSVNfU1RBTkRBUkRfTVVMVElQTEVfTlVNUzogWzEsIDIsIDUsIDEwXSxcbiAgICAvKiogbGFiZWwgcGFkZGluZyB0b3AgKi9cbiAgICBMQUJFTF9QQURESU5HX1RPUDogMixcbiAgICAvKiogbGluZSBtYXJnaW4gdG9wICovXG4gICAgTElORV9NQVJHSU5fVE9QOiA1LFxuICAgIC8qKiB0b29sdGlwIGdhcCAqL1xuICAgIFRPT0xUSVBfR0FQOiA1LFxuICAgIC8qKiB0b29sdGlwIGRpcmVjdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRDogJ2ZvcndvcmQnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRPT0xUSVBfRElSRUNUSU9OX0NFTlRFUjogJ2NlbnRlcicsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQ6ICdiYWNrd29yZCcsXG4gICAgLyoqIHRvb2x0aXAgYWxpZ24gb3B0aW9uc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVE9PTFRJUF9ERUZBVUxUX0FMSUdOX09QVElPTjogJ2NlbnRlciB0b3AnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRPT0xUSVBfREVGQVVMVF9IT1JJWk9OVEFMX0FMSUdOX09QVElPTjogJ3JpZ2h0IG1pZGRsZScsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVE9PTFRJUF9ERUZBVUxUX0dST1VQX0FMSUdOX09QVElPTjogJ3JpZ2h0IG1pZGRsZScsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVE9PTFRJUF9ERUZBVUxUX0dST1VQX0hPUklaT05UQUxfQUxJR05fT1BUSU9OOiAnY2VudGVyIGJvdHRvbScsXG4gICAgLyoqIGhpZGUgZGVsYXkgKi9cbiAgICBISURFX0RFTEFZOiAyMDBcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGNoYXJ0Q29uc3Q7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQXJlYVR5cGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGxpbmUgdHlwZSBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1c3RvbUV2ZW50QmFzZSA9IHJlcXVpcmUoJy4vY3VzdG9tRXZlbnRCYXNlJyksXG4gICAgQXJlYVR5cGVEYXRhTW9kZWwgPSByZXF1aXJlKCcuL2FyZWFUeXBlRGF0YU1vZGVsJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBBcmVhVHlwZUN1c3RvbUV2ZW50ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ3VzdG9tRXZlbnRCYXNlLCAvKiogQGxlbmRzIEFyZWFUeXBlQ3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBBcmVhVHlwZUN1c3RvbUV2ZW50IGlzIGN1c3RvbSBldmVudCBmb3IgbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqIEBjb25zdHJ1Y3RzIEFyZWFUeXBlQ3VzdG9tRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBDdXN0b21FdmVudEJhc2VcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkYXRhIG9mIGN1c3RvbSBldmVudFxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IHNlcmllc0luZm9zIHNlcmllcyBpbmZvc1xuICAgICAqL1xuICAgIGluaXRDdXN0b21FdmVudERhdGE6IGZ1bmN0aW9uKHNlcmllc0luZm9zKSB7XG4gICAgICAgIHZhciBzZXJpZXNJbmZvID0gc2VyaWVzSW5mb3NbMF07XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsID0gbmV3IEFyZWFUeXBlRGF0YU1vZGVsKHNlcmllc0luZm8pO1xuICAgICAgICBDdXN0b21FdmVudEJhc2UucHJvdG90eXBlLmluaXRDdXN0b21FdmVudERhdGEuY2FsbCh0aGlzLCBzZXJpZXNJbmZvcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlbW92ZS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgbW91c2UgZXZlbnQgb2JqZWN0XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgb25Nb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGVsVGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuICAgICAgICAgICAgYm91bmQgPSBlbFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGxheWVyWCA9IGUuY2xpZW50WCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFIC0gYm91bmQubGVmdCxcbiAgICAgICAgICAgIGxheWVyWSA9IGUuY2xpZW50WSAtIGJvdW5kLnRvcCxcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSB0aGlzLnRpY2tCYXNlRGF0YU1vZGVsLmZpbmRJbmRleChsYXllclgpLFxuICAgICAgICAgICAgZm91bmREYXRhID0gdGhpcy5kYXRhTW9kZWwuZmluZERhdGEoZ3JvdXBJbmRleCwgbGF5ZXJZKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhbmdlZCh0aGlzLnByZXZGb3VuZERhdGEsIGZvdW5kRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXAnLCBmb3VuZERhdGEpO1xuICAgICAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gZm91bmREYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldkZvdW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcsIHRoaXMucHJldkZvdW5kRGF0YSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2Rm91bmREYXRhO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlb3V0LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudCBvYmplY3RcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBvbk1vdXNlb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldkZvdW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcsIHRoaXMucHJldkZvdW5kRGF0YSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2Rm91bmREYXRhO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihBcmVhVHlwZUN1c3RvbUV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhVHlwZUN1c3RvbUV2ZW50O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFyZWFUeXBlRGF0YU1vZGVsIGlzIGRhdGEgbW9kZWwgZm9yIGFyZWEgdHlwZSBjdXN0b20gZXZlbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBcmVhVHlwZURhdGFNb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQXJlYVR5cGVEYXRhTW9kZWwucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBBcmVhVHlwZURhdGFNb2RlbCBpcyBkYXRhIG1vZGUgZm9yIGFyZWEgdHlwZSBjdXN0b20gZXZlbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQXJlYVR5cGVEYXRhTW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzSW5mbyBzZXJpZXMgaW5mb1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHNlcmllc0luZm8pIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5fbWFrZURhdGEoc2VyaWVzSW5mby5kYXRhLmdyb3VwUG9zaXRpb25zLCBzZXJpZXNJbmZvLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYXJlYSB0eXBlIGRhdGEgZm9yIGN1c3RvbSBldmVudC5cbiAgICAgKiBAcGFyYW0ge2FycmF5LjxhcnJheS48Z3JvdXA+Pn0gZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjYWhydCB0eXBlXG4gICAgICogQHJldHVybnMge2FycmF5fSBhcmVhIHR5cGUgZGF0YSBmb3IgY3VzdG9tIGV2ZW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGF0YTogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMsIGNoYXJ0VHlwZSkge1xuICAgICAgICBncm91cFBvc2l0aW9ucyA9IHR1aS51dGlsLnBpdm90KGdyb3VwUG9zaXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmQ6IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBEYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxheWVyWSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGluZGV4XG4gICAgICovXG4gICAgZmluZERhdGE6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGxheWVyWSkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgbWluID0gMTAwMDA7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2godGhpcy5kYXRhW2dyb3VwSW5kZXhdLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGxheWVyWSAtIGRhdGEuYm91bmQudG9wKTtcbiAgICAgICAgICAgIGlmIChtaW4gPiBkaWZmKSB7XG4gICAgICAgICAgICAgICAgbWluID0gZGlmZjtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhVHlwZURhdGFNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDdXN0b21FdmVudEJhc2UgaXMgYmFzZSBjbGFzcyBmb3IgZXZlbnQgaGFuZGxlIGxheWVycy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2V2ZW50TGlzdGVuZXInKSxcbiAgICBUaWNrQmFzZURhdGFNb2RlbCA9IHJlcXVpcmUoJy4vdGlja0Jhc2VEYXRhTW9kZWwnKSxcbiAgICBQb2ludFR5cGVEYXRhTW9kZWwgPSByZXF1aXJlKCcuL3BvaW50VHlwZURhdGFNb2RlbCcpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIEN1c3RvbUV2ZW50QmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQ3VzdG9tRXZlbnRCYXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ3VzdG9tRXZlbnRCYXNlIGlzIGJhc2UgY2xhc3MgZm9yIGN1c3RvbSBldmVudCBjb21wb25lbnRzLlxuICAgICAqIEBjb25zdHJ1Y3RzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7XG4gICAgICogICAgICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiAgICAgIH19IHBhcmFtcy5ib3VuZCBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9IHBhcmFtcy5pc1ZlcnRpY2FsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZW5kZXIgZXZlbnQgaGFuZGxlIGxheWVyIGFyZWFcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbENvb3JkaW5hdGVBcmVhIGNvb3JkaW5hdGUgYXJlYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgYm91bmQgb2YgZXZlbnQgaGFuZGxlciBsYXllclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ3VzdG9tRXZlbnRBcmVhOiBmdW5jdGlvbihlbENvb3JkaW5hdGVBcmVhLCBib3VuZCwgZGF0YSkge1xuICAgICAgICB2YXIgZXhwYW5kZWRCb3VuZDtcbiAgICAgICAgdGhpcy5ib3VuZCA9IGJvdW5kO1xuICAgICAgICB0aGlzLnRpY2tCYXNlRGF0YU1vZGVsID0gbmV3IFRpY2tCYXNlRGF0YU1vZGVsKGJvdW5kLmRpbWVuc2lvbiwgZGF0YS50aWNrQ291bnQsIHRoaXMuY2hhcnRUeXBlLCB0aGlzLmlzVmVydGljYWwpO1xuICAgICAgICBleHBhbmRlZEJvdW5kID0gcmVuZGVyVXRpbC5leHBhbmRCb3VuZChib3VuZCk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGVsQ29vcmRpbmF0ZUFyZWEsIGV4cGFuZGVkQm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihlbENvb3JkaW5hdGVBcmVhLCBleHBhbmRlZEJvdW5kLnBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVuZGVyIGV2ZW50IGhhbmRsZSBsYXllciBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgYm91bmQgb2YgZXZlbnQgaGFuZGxlciBsYXllclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IGNvb3JkaW5hdGUgYXJlYVxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oYm91bmQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1zZXJpZXMtY3VzdG9tLWV2ZW50LWFyZWEnKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJDdXN0b21FdmVudEFyZWEoZWwsIGJvdW5kLCBkYXRhKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFdmVudChlbCk7XG4gICAgICAgIHRoaXMuZWxDb29yZGluYXRlQXJlYSA9IGVsO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZGF0YSBvZiBjdXN0b20gZXZlbnRcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxvYmplY3Q+fSBzZXJpZXNJbmZvcyBzZXJpZXMgaW5mb3NcbiAgICAgKi9cbiAgICBpbml0Q3VzdG9tRXZlbnREYXRhOiBmdW5jdGlvbihzZXJpZXNJbmZvcykge1xuICAgICAgICB0aGlzLnBvaW50VHlwZURhdGFNb2RlbCA9IG5ldyBQb2ludFR5cGVEYXRhTW9kZWwoc2VyaWVzSW5mb3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZXNpemUgZXZlbnQgaGFuZGxlIGxheWVyIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fSBib3VuZCBib3VuZCBmb3IgcmVzaXphYmxlXG4gICAgICogQHBhcmFtIHt7dGlja0NvdW50OiBudW1iZXJ9fSBkYXRhIGRhdGFcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKGJvdW5kLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckN1c3RvbUV2ZW50QXJlYSh0aGlzLmVsQ29vcmRpbmF0ZUFyZWEsIGJvdW5kLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGFuZ2VkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJldiBwcmV2aW91cyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGN1ciBjdXJyZW50IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBjaGFuZ2VkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZDogZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiAhcHJldiB8fCAhY3VyIHx8IHByZXYuY2hhcnRUeXBlICE9PSBjdXIuY2hhcnRUeXBlIHx8XG4gICAgICAgICAgICBwcmV2LmluZGV4ZXMuZ3JvdXBJbmRleCAhPT0gY3VyLmluZGV4ZXMuZ3JvdXBJbmRleCB8fCBwcmV2LmluZGV4ZXMuaW5kZXggIT09IGN1ci5pbmRleGVzLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHBvaW50IHR5cGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRhcmdldCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRYIG1vdXNlIHBvc2l0aW9uIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WSBtb3VzZSBwb3NpdGlvbiB5XG4gICAgICogQHJldHVybnMge29iamVjdH0gZm91bmQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRQb2ludFR5cGVEYXRhOiBmdW5jdGlvbihlbFRhcmdldCwgY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICB2YXIgYm91bmQgPSBlbFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGxheWVyWCA9IGNsaWVudFggLSBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgbGF5ZXJZID0gY2xpZW50WSAtIGJvdW5kLnRvcCxcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSB0aGlzLnRpY2tCYXNlRGF0YU1vZGVsLmZpbmRJbmRleCh0aGlzLmlzVmVydGljYWwgPyBsYXllclggOiBsYXllclkpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludFR5cGVEYXRhTW9kZWwuZmluZERhdGEoZ3JvdXBJbmRleCwgbGF5ZXJYICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsIGxheWVyWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuc2VsZWN0IHNlbGVjdGVkIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5zZWxlY3RTZWxlY3RlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy5maXJlKHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgndW5zZWxlY3QnLCB0aGlzLnNlbGVjdGVkRGF0YS5jaGFydFR5cGUsICdzZXJpZXMnKSwgdGhpcy5zZWxlY3RlZERhdGEpO1xuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB0aGlzLnNlbGVjdGVkRGF0YSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGVkRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2tcbiAgICAgKiBAcGFyYW0ge21vdXNlZXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBvbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlbFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICAgIGNsaWVudFggPSBlLmNsaWVudFggLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgIGZvdW5kRGF0YSA9IHRoaXMuX2ZpbmRQb2ludFR5cGVEYXRhKGVsVGFyZ2V0LCBjbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhbmdlZCh0aGlzLnNlbGVjdGVkRGF0YSwgZm91bmREYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zZWxlY3RTZWxlY3RlZERhdGEoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZERhdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0U2VsZWN0ZWREYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmUocmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzZWxlY3QnLCBmb3VuZERhdGEuY2hhcnRUeXBlLCAnc2VyaWVzJyksIGZvdW5kRGF0YSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YSA9IGZvdW5kRGF0YTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZSBtb3ZlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgb25Nb3VzZW1vdmU6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZSBvdXRcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBvbk1vdXNlb3V0OiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGV2ZW50XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKi9cbiAgICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lci5iaW5kRXZlbnQoJ2NsaWNrJywgZWwsIHR1aS51dGlsLmJpbmQodGhpcy5vbkNsaWNrLCB0aGlzKSk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZW1vdmUnLCBlbCwgdHVpLnV0aWwuYmluZCh0aGlzLm9uTW91c2Vtb3ZlLCB0aGlzKSk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZW91dCcsIGVsLCB0dWkudXRpbC5iaW5kKHRoaXMub25Nb3VzZW91dCwgdGhpcykpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oQ3VzdG9tRXZlbnRCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXN0b21FdmVudEJhc2U7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgR3JvdXBUeXBlQ3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBncm91cGVkIHRvb2xpcCBvcHRpb24uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgR3JvdXBUeXBlQ3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgR3JvdXBUeXBlQ3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBHcm91cFR5cGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGdyb3VwZWQgdG9vbGlwIG9wdGlvbi5cbiAgICAgKiBAY29uc3RydWN0cyBHcm91cFR5cGVDdXN0b21FdmVudFxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBDdXN0b21FdmVudEJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxheWVyIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge251bWJlcn0gbGF5ZXIgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExheWVyUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24oZSwgYm91bmQsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdmFyIGxheWVyUG9zaXRpb247XG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBsYXllclBvc2l0aW9uID0gZS5jbGllbnRYIC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUgLSBib3VuZC5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGF5ZXJQb3NpdGlvbiA9IGUuY2xpZW50WSAtIGJvdW5kLnRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5ZXJQb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Vtb3ZlLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudCBvYmplY3RcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBvbk1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZWxUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICBib3VuZCA9IGVsVGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgbGF5ZXJQb3NpdGlvblZhbHVlID0gdGhpcy5fZ2V0TGF5ZXJQb3NpdGlvblZhbHVlKGUsIGJvdW5kLCB0aGlzLmlzVmVydGljYWwpLFxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnRpY2tCYXNlRGF0YU1vZGVsLmZpbmRJbmRleChsYXllclBvc2l0aW9uVmFsdWUpLFxuICAgICAgICAgICAgcHJldkluZGV4ID0gdGhpcy5wcmV2SW5kZXgsXG4gICAgICAgICAgICBzaXplVHlwZSA9IHRoaXMuaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW91c2VvdXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZJbmRleCA9IGluZGV4O1xuXG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd0dyb3VwVG9vbHRpcCcsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiB0aGlzLnRpY2tCYXNlRGF0YU1vZGVsLm1ha2VSYW5nZShpbmRleCwgdGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5ib3VuZC5kaW1lbnNpb25bc2l6ZVR5cGVdLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZW91dC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgbW91c2UgZXZlbnQgb2JqZWN0XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgb25Nb3VzZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQodGhpcy5wcmV2SW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVHcm91cFRvb2x0aXAnLCB0aGlzLnByZXZJbmRleCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKEdyb3VwVHlwZUN1c3RvbUV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFR5cGVDdXN0b21FdmVudDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBQb2ludFR5cGVDdXN0b21FdmVuIGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgbGluZSB0eXBlIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgQ3VzdG9tRXZlbnRCYXNlID0gcmVxdWlyZSgnLi9jdXN0b21FdmVudEJhc2UnKTtcblxudmFyIFBvaW50VHlwZUN1c3RvbUV2ZW4gPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgUG9pbnRUeXBlQ3VzdG9tRXZlbi5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFBvaW50VHlwZUN1c3RvbUV2ZW4gaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgUG9pbnRUeXBlQ3VzdG9tRXZlblxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBDdXN0b21FdmVudEJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Vtb3ZlLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudCBvYmplY3RcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBvbk1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZWxUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICBjbGllbnRYID0gZS5jbGllbnRYIC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBmb3VuZERhdGEgPSB0aGlzLl9maW5kUG9pbnRUeXBlRGF0YShlbFRhcmdldCwgY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhbmdlZCh0aGlzLnByZXZGb3VuZERhdGEsIGZvdW5kRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnLCB0aGlzLnByZXZGb3VuZERhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJldkZvdW5kRGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXAnLCBmb3VuZERhdGEpO1xuICAgICAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gZm91bmREYXRhO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlb3V0LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudCBvYmplY3RcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBvbk1vdXNlb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldkZvdW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcsIHRoaXMucHJldkZvdW5kRGF0YSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2Rm91bmREYXRhO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihQb2ludFR5cGVDdXN0b21FdmVuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFR5cGVDdXN0b21FdmVuO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBvaW50VHlwZURhdGFNb2RlbCBpcyBkYXRhIG1vZGUgZm9yIHBvaW50IHR5cGUgY3VzdG9tIGV2ZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcblxudmFyIFBvaW50VHlwZURhdGFNb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgUG9pbnRUeXBlRGF0YU1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUG9pbnRUeXBlRGF0YU1vZGVsIGlzIGRhdGEgbW9kZSBmb3IgcG9pbnQgdHlwZSBjdXN0b20gZXZlbnQuXG4gICAgICogQGNvbnN0cnVjdHMgUG9pbnRUeXBlRGF0YU1vZGVsXG4gICAgICogQHBhcmFtIHthcnJheS48b2JqZWN0Pn0gc2VyaWVzSW5mb3Mgc2VyaWVzIGluZm9zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc2VyaWVzSW5mb3MpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5fbWFrZURhdGEoc2VyaWVzSW5mb3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGNvb3JkaW5hdGUgZGF0YSBhYm91dCBiYXIgdHlwZSBncmFwaFxuICAgICAqIEBwYXJhbSB7YXJyYXkuPGFycmF5LjxvYmplY3Q+Pn0gZ3JvdXBCb3VuZHMgZ3JvdXAgYm91bmRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2FycmF5fSBjb29yZGluYXRlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmVjdFR5cGVDb29yZGluYXRlRGF0YTogZnVuY3Rpb24oZ3JvdXBCb3VuZHMsIGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwQm91bmRzLCBmdW5jdGlvbihib3VuZHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYm91bmRzLCBmdW5jdGlvbihfYm91bmQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kO1xuICAgICAgICAgICAgICAgIGlmICghX2JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvdW5kID0gX2JvdW5kLmVuZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmREYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93TmVnYXRpdmVUb29sdGlwOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQ6IGJvdW5kXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBib3VuZC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogYm91bmQubGVmdCArIGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBib3VuZC50b3AgKyBib3VuZC5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgY29vcmRpbmF0ZSBkYXRhIGFib3V0IGRvdCB0eXBlIGdyYXBoXG4gICAgICogQHBhcmFtIHthcnJheS48YXJyYXkuPG9iamVjdD4+fSBncm91cFBvc2l0aW9ucyBncm91cCBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IGNvb3JkaW5hdGUgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEb3RUeXBlQ29vcmRpbmF0ZURhdGE6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zLCBjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0dWkudXRpbC5waXZvdChncm91cFBvc2l0aW9ucyksIGZ1bmN0aW9uKHBvc2l0aW9ucywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmREYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3VuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuRE9UX1JBRElVUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gY2hhcnRDb25zdC5ET1RfUkFESVVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHBvc2l0aW9uLmxlZnQgKyBjaGFydENvbnN0LkRPVF9SQURJVVMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHBvc2l0aW9uLnRvcCArIGNoYXJ0Q29uc3QuRE9UX1JBRElVU1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gam9pbiBkYXRhLlxuICAgICAqIEBwYXJhbSB7YXJyYXkuPGFycmF5LjxhcnJheS48b2JqZWN0Pj4+fSBncm91cERhdGEgZ3JvdXAgZGF0YVxuICAgICAqIEByZXR1cm5zIHthcnJheS48YXJyYXkuPG9iamVjdD4+fSBqb2luZWQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2pvaW5EYXRhOiBmdW5jdGlvbihncm91cERhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwRGF0YSwgZnVuY3Rpb24oY29vcmREYXRhKSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY29vcmREYXRhLCBmdW5jdGlvbihkYXRhLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHRzW2luZGV4XS5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgY29vcmRpbmF0ZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IHNlcmllc0luZm9zIHNlcmllcyBpbmZvc1xuICAgICAqIEByZXR1cm5zIHthcnJheS48YXJyYXkuPG9iamVjdD4+fSBjb29yZGluYXRlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGF0YTogZnVuY3Rpb24oc2VyaWVzSW5mb3MpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVEYXRhO1xuICAgICAgICBzZXJpZXNJbmZvcy5yZXZlcnNlKCk7XG4gICAgICAgIGNvb3JkaW5hdGVEYXRhID0gdHVpLnV0aWwubWFwKHNlcmllc0luZm9zLCBmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0xpbmVUeXBlQ2hhcnQoaW5mby5jaGFydFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWFrZURvdFR5cGVDb29yZGluYXRlRGF0YShpbmZvLmRhdGEuZ3JvdXBQb3NpdGlvbnMsIGluZm8uY2hhcnRUeXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWFrZVJlY3RUeXBlQ29vcmRpbmF0ZURhdGEoaW5mby5kYXRhLmdyb3VwQm91bmRzLCBpbmZvLmNoYXJ0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5EYXRhKGNvb3JkaW5hdGVEYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0b29sdGlwIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJYIG1vdXNlIHBvc2l0aW9uIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJZIG1vdXNlIHBvc2l0aW9uIHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0b29sdGlwIGRhdGFcbiAgICAgKi9cbiAgICBmaW5kRGF0YTogZnVuY3Rpb24oZ3JvdXBJbmRleCwgbGF5ZXJYLCBsYXllclkpIHtcbiAgICAgICAgdmFyIG1pbiA9IDEwMDAwLFxuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbCxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM7XG5cbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGF5ZXJYLCBsYXllclnrpbwg7Y+s7ZWo7ZWY64qUIGRhdGEg7LaU7LacXG4gICAgICAgIGNhbmRpZGF0ZXMgPSB0dWkudXRpbC5maWx0ZXIodGhpcy5kYXRhW2dyb3VwSW5kZXhdLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYm91bmQgPSBkYXRhICYmIGRhdGEuYm91bmQ7XG4gICAgICAgICAgICByZXR1cm4gYm91bmQgJiYgYm91bmQubGVmdCA8PSBsYXllclggJiYgYm91bmQucmlnaHQgPj0gbGF5ZXJYICYmIGJvdW5kLnRvcCA8PSBsYXllclkgJiYgYm91bmQuYm90dG9tID49IGxheWVyWTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8g7LaU7Lac65CcIGRhdGEg7KSRIHRvcOydtCBsYXllclnsmYAg6rCA7J6lIOqwgOq5jOyatCBkYXRhIOywvuyVhOuCtOq4sFxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY2FuZGlkYXRlcywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhsYXllclkgLSBkYXRhLnNlbmREYXRhLmJvdW5kLnRvcCk7XG4gICAgICAgICAgICBpZiAobWluID4gZGlmZikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGRpZmY7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGF0YS5zZW5kRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFR5cGVEYXRhTW9kZWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGlja0Jhc2VEYXRhTW9kZWwgaXMgdGljayBiYXNlIGRhdGEgbW9kZWwuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpO1xuXG52YXIgVGlja0Jhc2VEYXRhTW9kZWwgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFRpY2tCYXNlRGF0YU1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogVGlja0Jhc2VEYXRhTW9kZWwgaXMgdGljayBiYXNlIGRhdGEgbW9kZWwuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtib29sYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAY29uc3RydWN0cyBUaWNrQmFzZURhdGFNb2RlbFxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgdGlja0NvdW50LCBjaGFydFR5cGUsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5fbWFrZURhdGEoZGltZW5zaW9uLCB0aWNrQ291bnQsIGNoYXJ0VHlwZSwgaXNWZXJ0aWNhbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgdGljayBiYXNlIGRhdGEgYWJvdXQgbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHthcnJheX0gdGljayBiYXNlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGluZVR5cGVEYXRhOiBmdW5jdGlvbih3aWR0aCwgdGlja0NvdW50KSB7XG4gICAgICAgIHZhciB0aWNrSW50ZXJ2YWwgPSB3aWR0aCAvICh0aWNrQ291bnQgLSAxKSxcbiAgICAgICAgICAgIGhhbGZJbnRlcnZhbCA9IHRpY2tJbnRlcnZhbCAvIDI7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodHVpLnV0aWwucmFuZ2UoMCwgdGlja0NvdW50KSwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBpbmRleCAqIHRpY2tJbnRlcnZhbCAtIGhhbGZJbnRlcnZhbCxcbiAgICAgICAgICAgICAgICBtYXg6IGluZGV4ICogdGlja0ludGVydmFsICsgaGFsZkludGVydmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSB0aWNrIGJhc2UgZGF0YSBhYm91dCBub24gbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHthcnJheX0gdGljayBiYXNlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTm9ybWFsRGF0YTogZnVuY3Rpb24oc2l6ZSwgdGlja0NvdW50KSB7XG4gICAgICAgIHZhciBsZW4gPSB0aWNrQ291bnQgLSAxLFxuICAgICAgICAgICAgdGlja0ludGVydmFsID0gc2l6ZSAvIGxlbixcbiAgICAgICAgICAgIHByZXYgPSAwO1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHR1aS51dGlsLnJhbmdlKDAsIGxlbiksIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gdHVpLnV0aWwubWluKFtzaXplLCAoaW5kZXggKyAxKSAqIHRpY2tJbnRlcnZhbF0pLFxuICAgICAgICAgICAgICAgIHNjYWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBtaW46IHByZXYsXG4gICAgICAgICAgICAgICAgICAgIG1heDogbWF4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXYgPSBtYXg7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHRpY2sgYmFzZSBkYXRhIGZvciBjdXN0b20gZXZlbnQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtib29sYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPG9iamVjdD59IHRpY2sgYmFzZSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURhdGE6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgdGlja0NvdW50LCBjaGFydFR5cGUsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdmFyIHNpemVUeXBlID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGRhdGE7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KGNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9tYWtlTGluZVR5cGVEYXRhKGRpbWVuc2lvbltzaXplVHlwZV0sIHRpY2tDb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fbWFrZU5vcm1hbERhdGEoZGltZW5zaW9uW3NpemVUeXBlXSwgdGlja0NvdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludFZhbHVlIG1vdXNlIHBvc2l0aW9uIHBvaW50IHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gZ3JvdXAgaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uKHBvaW50VmFsdWUpIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZGF0YSwgZnVuY3Rpb24oc2NhbGUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoc2NhbGUubWluIDwgcG9pbnRWYWx1ZSAmJiBzY2FsZS5tYXggPj0gcG9pbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb3VuZEluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGljayBiYXNlIGRhdGEgbGVuZ3RoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqL1xuICAgIGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHJhbmdlIG9mIHRvb2x0aXAgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHR5cGUgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1ha2VSYW5nZTogZnVuY3Rpb24oaW5kZXgsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmRhdGFbaW5kZXhdLFxuICAgICAgICAgICAgcmFuZ2UsIGNlbnRlcjtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0xpbmVUeXBlQ2hhcnQoY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgY2VudGVyID0gcGFyc2VJbnQoc2NhbGUubWF4IC0gKHNjYWxlLm1heCAtIHNjYWxlLm1pbikgLyAyLCAxMCk7XG4gICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogY2VudGVyLFxuICAgICAgICAgICAgICAgIGVuZDogY2VudGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHNjYWxlLm1pbixcbiAgICAgICAgICAgICAgICBlbmQ6IHNjYWxlLm1heFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaWNrQmFzZURhdGFNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgQ2hhcnQgZmFjdG9yeSBwbGF5IHJvbGUgcmVnaXN0ZXIgY2hhcnQuXG4gKiAgICAgICAgICAgICAgICBBbHNvLCB5b3UgY2FuIGdldCBjaGFydCBmcm9tIHRoaXMgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0cyA9IHt9LFxuICAgIGZhY3RvcnkgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY2hhcnQgaW5zdGFuY2UuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gY2hhcnQgaW5zdGFuY2U7XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgZGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBDaGFydCA9IGNoYXJ0c1tjaGFydFR5cGVdLFxuICAgICAgICAgICAgICAgIGNoYXJ0O1xuXG4gICAgICAgICAgICBpZiAoIUNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZXhpc3QgJyArIGNoYXJ0VHlwZSArICcgY2hhcnQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYXJ0ID0gbmV3IENoYXJ0KGRhdGEsIHRoZW1lLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBjaGFydC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFyIHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtjbGFzc30gQ2hhcnRDbGFzcyBjaGFydCBjbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgQ2hhcnRDbGFzcykge1xuICAgICAgICAgICAgY2hhcnRzW2NoYXJ0VHlwZV0gPSBDaGFydENsYXNzO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBQbHVnaW4gZmFjdG9yeSBwbGF5IHJvbGUgcmVnaXN0ZXIgcmVuZGVyaW5nIHBsdWdpbi5cbiAqICAgICAgICAgICAgICAgIEFsc28sIHlvdSBjYW4gZ2V0IHBsdWdpbiBmcm9tIHRoaXMgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBsdWdpbnMgPSB7fSxcbiAgICBmYWN0b3J5ID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGdyYXBoIHJlbmRlcmVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGliVHlwZSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJlbmRlcmVyIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGxpYlR5cGUsIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbbGliVHlwZV0sXG4gICAgICAgICAgICAgICAgUmVuZGVyZXIsIHJlbmRlcmVyO1xuXG4gICAgICAgICAgICBpZiAoIXBsdWdpbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGV4aXN0ICcgKyBsaWJUeXBlICsgJyBwbHVnaW4uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlbmRlcmVyID0gcGx1Z2luW2NoYXJ0VHlwZV07XG4gICAgICAgICAgICBpZiAoIVJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZXhpc3QgJyArIGNoYXJ0VHlwZSArICcgY2hhcnQgcmVuZGVyZXIuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsdWdpbiByZWdpc3Rlci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxpYlR5cGUgdHlwZSBvZiBncmFwaCBsaWJyYXJ5XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwbHVnaW4gcGx1Z2luIHRvIGNvbnRyb2wgbGlicmFyeVxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGxpYlR5cGUsIHBsdWdpbikge1xuICAgICAgICAgICAgcGx1Z2luc1tsaWJUeXBlXSA9IHBsdWdpbjtcbiAgICAgICAgfVxuICAgIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgVGhlbWUgZmFjdG9yeSBwbGF5IHJvbGUgcmVnaXN0ZXIgdGhlbWUuXG4gKiAgICAgICAgICAgICAgICBBbHNvLCB5b3UgY2FuIGdldCB0aGVtZSBmcm9tIHRoaXMgZmFjdG9yeS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRlZmF1bHRUaGVtZSA9IHJlcXVpcmUoJy4uL3RoZW1lcy9kZWZhdWx0VGhlbWUnKTtcblxudmFyIHRoZW1lcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lTmFtZSB0aGVtZSBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlbWUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbih0aGVtZU5hbWUpIHtcbiAgICAgICAgdmFyIHRoZW1lID0gdGhlbWVzW3RoZW1lTmFtZV07XG5cbiAgICAgICAgaWYgKCF0aGVtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZXhpc3QgJyArIHRoZW1lTmFtZSArICcgdGhlbWUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhlbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZW1lIHJlZ2lzdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZU5hbWUgdGhlbWUgbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0aGVtZU5hbWUsIHRoZW1lKSB7XG4gICAgICAgIHZhciB0YXJnZXRJdGVtcztcbiAgICAgICAgdGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoZW1lKSk7XG5cbiAgICAgICAgaWYgKHRoZW1lTmFtZSAhPT0gY2hhcnRDb25zdC5ERUZBVUxUX1RIRU1FX05BTUUpIHtcbiAgICAgICAgICAgIHRoZW1lID0gdGhpcy5faW5pdFRoZW1lKHRoZW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldEl0ZW1zID0gdGhpcy5fZ2V0SW5oZXJpdFRhcmdldFRoZW1lSXRlbXModGhlbWUpO1xuXG4gICAgICAgIHRoaXMuX2luaGVyaXRUaGVtZUZvbnQodGhlbWUsIHRhcmdldEl0ZW1zKTtcbiAgICAgICAgdGhpcy5fY29weUNvbG9ySW5mbyh0aGVtZSk7XG4gICAgICAgIHRoZW1lc1t0aGVtZU5hbWVdID0gdGhlbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBfaW5pdFRoZW1lOiBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICB2YXIgY2xvbmVUaGVtZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmYXVsdFRoZW1lKSksXG4gICAgICAgICAgICBuZXdUaGVtZTtcblxuICAgICAgICB0aGlzLl9jb25jYXREZWZhdWx0Q29sb3JzKHRoZW1lLCBjbG9uZVRoZW1lLnNlcmllcy5jb2xvcnMpXG4gICAgICAgIG5ld1RoZW1lID0gdGhpcy5fb3ZlcndyaXRlVGhlbWUodGhlbWUsIGNsb25lVGhlbWUpO1xuXG4gICAgICAgIG5ld1RoZW1lID0gdGhpcy5fY29weVByb3BlcnR5KHtcbiAgICAgICAgICAgIHByb3BOYW1lOiAneUF4aXMnLFxuICAgICAgICAgICAgZnJvbVRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIHRvVGhlbWU6IG5ld1RoZW1lLFxuICAgICAgICAgICAgcmVqZWN0aW9uUHJvcHM6IGNoYXJ0Q29uc3QuWUFYSVNfUFJPUFNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3VGhlbWUgPSB0aGlzLl9jb3B5UHJvcGVydHkoe1xuICAgICAgICAgICAgcHJvcE5hbWU6ICdzZXJpZXMnLFxuICAgICAgICAgICAgZnJvbVRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIHRvVGhlbWU6IG5ld1RoZW1lLFxuICAgICAgICAgICAgcmVqZWN0aW9uUHJvcHM6IGNoYXJ0Q29uc3QuU0VSSUVTX1BST1BTXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXdUaGVtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGNoYXJ0IHR5cGVzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgdGFyZ2V0IGNoYXJ0c1xuICAgICAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IHJlamVjdGlvblByb3BzIHJlamVjdCBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGZpbHRlcmVkIGNoYXJ0cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maWx0ZXJDaGFydFR5cGVzOiBmdW5jdGlvbih0YXJnZXQsIHJlamVjdGlvblByb3BzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0dWkudXRpbC5maWx0ZXIodGFyZ2V0LCBmdW5jdGlvbihpdGVtLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwuaW5BcnJheShuYW1lLCByZWplY3Rpb25Qcm9wcykgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uY2F0IGNvbG9ycy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxzdHJpbmc+fSBzZXJpZXNDb2xvcnMgc2VyaWVzIGNvbG9yc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NvbmNhdENvbG9yczogZnVuY3Rpb24odGhlbWUsIHNlcmllc0NvbG9ycykge1xuICAgICAgICBpZiAodGhlbWUuY29sb3JzKSB7XG4gICAgICAgICAgICB0aGVtZS5jb2xvcnMgPSB0aGVtZS5jb2xvcnMuY29uY2F0KHNlcmllc0NvbG9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhlbWUuc2luZ2xlQ29sb3JzKSB7XG4gICAgICAgICAgICB0aGVtZS5zaW5nbGVDb2xvcnMgPSB0aGVtZS5zaW5nbGVDb2xvcnMuY29uY2F0KHNlcmllc0NvbG9ycyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uY2F0IGRlZmF1bHQgY29sb3JzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IHNlcmllc0NvbG9ycyBzZXJpZXMgY29sb3JzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29uY2F0RGVmYXVsdENvbG9yczogZnVuY3Rpb24odGhlbWUsIHNlcmllc0NvbG9ycykge1xuICAgICAgICB2YXIgY2hhcnRUeXBlcztcblxuICAgICAgICBpZiAoIXRoZW1lLnNlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnRUeXBlcyA9IHRoaXMuX2ZpbHRlckNoYXJ0VHlwZXModGhlbWUuc2VyaWVzLCBjaGFydENvbnN0LlNFUklFU19QUk9QUyk7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5rZXlzKGNoYXJ0VHlwZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fY29uY2F0Q29sb3JzKHRoZW1lLnNlcmllcywgc2VyaWVzQ29sb3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goY2hhcnRUeXBlcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbmNhdENvbG9ycyhpdGVtLCBzZXJpZXNDb2xvcnMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlIHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZyb20gZnJvbSB0aGVtZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0byB0byB0aGVtZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJlc3VsdCBwcm9wZXJ0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX292ZXJ3cml0ZVRoZW1lOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHRvLCBmdW5jdGlvbihpdGVtLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBmcm9tSXRlbSA9IGZyb21ba2V5XTtcbiAgICAgICAgICAgIGlmICghZnJvbUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KGZyb21JdGVtKSkge1xuICAgICAgICAgICAgICAgIHRvW2tleV0gPSBmcm9tSXRlbS5zbGljZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0dWkudXRpbC5pc09iamVjdChmcm9tSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdmVyd3JpdGVUaGVtZShmcm9tSXRlbSwgaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvW2tleV0gPSBmcm9tSXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcm9wTmFtZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmZyb21UaGVtZSBmcm9tIHByb3BlcnR5XG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRvVGhlbWUgdHAgcHJvcGVydHlcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IHBhcmFtcy5yZWplY3Rpb25Qcm9wcyByZWplY3QgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGNvcGllZCBwcm9wZXJ0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NvcHlQcm9wZXJ0eTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBjaGFydFR5cGVzO1xuXG4gICAgICAgIGlmICghcGFyYW1zLnRvVGhlbWVbcGFyYW1zLnByb3BOYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy50b1RoZW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnRUeXBlcyA9IHRoaXMuX2ZpbHRlckNoYXJ0VHlwZXMocGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdLCBwYXJhbXMucmVqZWN0aW9uUHJvcHMpO1xuICAgICAgICBpZiAodHVpLnV0aWwua2V5cyhjaGFydFR5cGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goY2hhcnRUeXBlcywgZnVuY3Rpb24oaXRlbSwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lVGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZmF1bHRUaGVtZVtwYXJhbXMucHJvcE5hbWVdKSk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdW2tleV0gPSB0aGlzLl9vdmVyd3JpdGVUaGVtZShpdGVtLCBjbG9uZVRoZW1lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBwYXJhbXMudG9UaGVtZVtwYXJhbXMucHJvcE5hbWVdID0gcGFyYW1zLmZyb21UaGVtZVtwYXJhbXMucHJvcE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcy50b1RoZW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGNvbG9yIGluZm8gdG8gbGVnZW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc1RoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsZWdlbmRUaGVtZSBsZWdlbmQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxzdHJpbmc+fSBjb2xvcnMgY29sb3JzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29weUNvbG9ySW5mb1RvT3RoZXI6IGZ1bmN0aW9uKHNlcmllc1RoZW1lLCBsZWdlbmRUaGVtZSwgY29sb3JzKSB7XG4gICAgICAgIGxlZ2VuZFRoZW1lLmNvbG9ycyA9IGNvbG9ycyB8fCBzZXJpZXNUaGVtZS5jb2xvcnM7XG4gICAgICAgIGlmIChzZXJpZXNUaGVtZS5zaW5nbGVDb2xvcnMpIHtcbiAgICAgICAgICAgIGxlZ2VuZFRoZW1lLnNpbmdsZUNvbG9ycyA9IHNlcmllc1RoZW1lLnNpbmdsZUNvbG9ycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VyaWVzVGhlbWUuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGxlZ2VuZFRoZW1lLmJvcmRlckNvbG9yID0gc2VyaWVzVGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmllc1RoZW1lLnNlbGVjdGlvbkNvbG9yKSB7XG4gICAgICAgICAgICBsZWdlbmRUaGVtZS5zZWxlY3Rpb25Db2xvciA9IHNlcmllc1RoZW1lLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0YXJnZXQgaXRlbXMgYWJvdXQgZm9udCBpbmhlcml0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEByZXR1cm5zIHthcnJheS48b2JqZWN0Pn0gdGFyZ2V0IGl0ZW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0SW5oZXJpdFRhcmdldFRoZW1lSXRlbXM6IGZ1bmN0aW9uKHRoZW1lKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtcbiAgICAgICAgICAgICAgICB0aGVtZS50aXRsZSxcbiAgICAgICAgICAgICAgICB0aGVtZS54QXhpcy50aXRsZSxcbiAgICAgICAgICAgICAgICB0aGVtZS54QXhpcy5sYWJlbCxcbiAgICAgICAgICAgICAgICB0aGVtZS5sZWdlbmQubGFiZWxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB5QXhpc0NoYXJ0VHlwZVRoZW1zID0gdGhpcy5fZmlsdGVyQ2hhcnRUeXBlcyh0aGVtZS55QXhpcywgY2hhcnRDb25zdC5ZQVhJU19QUk9QUyksXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVUaGVtZXMgPSB0aGlzLl9maWx0ZXJDaGFydFR5cGVzKHRoZW1lLnNlcmllcywgY2hhcnRDb25zdC5TRVJJRVNfUFJPUFMpO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwua2V5cyh5QXhpc0NoYXJ0VHlwZVRoZW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2godGhlbWUueUF4aXMudGl0bGUpO1xuICAgICAgICAgICAgaXRlbXMucHVzaCh0aGVtZS55QXhpcy5sYWJlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHlBeGlzQ2hhcnRUeXBlVGhlbXMsIGZ1bmN0aW9uKGNoYXRUeXBlVGhlbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoYXRUeXBlVGhlbWUudGl0bGUpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hhdFR5cGVUaGVtZS5sYWJlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHVpLnV0aWwua2V5cyhzZXJpZXNDaGFydFR5cGVUaGVtZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh0aGVtZS5zZXJpZXMubGFiZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNDaGFydFR5cGVUaGVtZXMsIGZ1bmN0aW9uKGNoYXRUeXBlVGhlbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoYXRUeXBlVGhlbWUubGFiZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmhlcml0IHRoZW1lIGZvbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHBhcmFtIHthcnJheS48b2JqZWN0Pn0gdGFyZ2V0SXRlbXMgdGFyZ2V0IHRoZW1lIGl0ZW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5oZXJpdFRoZW1lRm9udDogZnVuY3Rpb24odGhlbWUsIHRhcmdldEl0ZW1zKSB7XG4gICAgICAgIHZhciBiYXNlRm9udCA9IHRoZW1lLmNoYXJ0LmZvbnRGYW1pbHk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRhcmdldEl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uZm9udEZhbWlseSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZm9udEZhbWlseSA9IGJhc2VGb250O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weSBjb2xvciBpbmZvLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIF9jb3B5Q29sb3JJbmZvOiBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICB2YXIgc2VyaWVzQ2hhcnRUeXBlcyA9IHRoaXMuX2ZpbHRlckNoYXJ0VHlwZXModGhlbWUuc2VyaWVzLCBjaGFydENvbnN0LlNFUklFU19QUk9QUyk7XG4gICAgICAgIGlmICghdHVpLnV0aWwua2V5cyhzZXJpZXNDaGFydFR5cGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcHlDb2xvckluZm9Ub090aGVyKHRoZW1lLnNlcmllcywgdGhlbWUubGVnZW5kKTtcbiAgICAgICAgICAgIHRoaXMuX2NvcHlDb2xvckluZm9Ub090aGVyKHRoZW1lLnNlcmllcywgdGhlbWUudG9vbHRpcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc0NoYXJ0VHlwZXMsIGZ1bmN0aW9uKGl0ZW0sIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgICAgIHRoZW1lLmxlZ2VuZFtjaGFydFR5cGVdID0ge307XG4gICAgICAgICAgICAgICAgdGhlbWUudG9vbHRpcFtjaGFydFR5cGVdID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5fY29weUNvbG9ySW5mb1RvT3RoZXIoaXRlbSwgdGhlbWUubGVnZW5kW2NoYXJ0VHlwZV0sIGl0ZW0uY29sb3JzIHx8IHRoZW1lLmxlZ2VuZC5jb2xvcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvcHlDb2xvckluZm9Ub090aGVyKGl0ZW0sIHRoZW1lLnRvb2x0aXBbY2hhcnRUeXBlXSwgaXRlbS5jb2xvcnMgfHwgdGhlbWUudG9vbHRpcC5jb2xvcnMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGVtZS5sZWdlbmQuY29sb3JzO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGVtZS50b29sdGlwLmNvbG9ycztcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBBeGlzIERhdGEgTWFrZXJcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4vcHJlZGljYXRlJyksXG4gICAgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4vY2FsY3VsYXRvcicpO1xuXG52YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLyoqXG4gKiBBeGlzIGRhdGEgbWFrZXIuXG4gKiBAbW9kdWxlIGF4aXNEYXRhTWFrZXJcbiAqL1xudmFyIGF4aXNEYXRhTWFrZXIgPSB7XG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBsYWJlbHMuXG4gICAgICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEludGVydmFsIGxhYmVsIGludGVydmFsXG4gICAgICogQHJldHVybnMge2FycmF5LjxzdHJpbmc+fSBsYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzOiBmdW5jdGlvbihsYWJlbHMsIGxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIGxhc3RJbmRleDtcbiAgICAgICAgaWYgKCFsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAobGFiZWxzLCBmdW5jdGlvbihsYWJlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgaW5kZXggPCBsYXN0SW5kZXggJiYgKGluZGV4ICUgbGFiZWxJbnRlcnZhbCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBjaGFydENvbnN0LkVNUFRZX0FYSVNfTEFCRUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGRhdGEgYWJvdXQgbGFiZWwgYXhpcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGxhYmVscyBjaGFydCBsYWJlbHNcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBsYWJlbHM6IGFycmF5LjxzdHJpbmc+LFxuICAgICAqICAgICAgdGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICB2YWxpZFRpY2tDb3VudDogbnVtYmVyLFxuICAgICAqICAgICAgaXNMYWJlbEF4aXM6IGJvb2xlYW4sXG4gICAgICogICAgICBpc1ZlcnRpY2FsOiBib29sZWFuXG4gICAgICogfX0gYXhpcyBkYXRhXG4gICAgICovXG4gICAgbWFrZUxhYmVsQXhpc0RhdGE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgdGlja0NvdW50ID0gcGFyYW1zLmxhYmVscy5sZW5ndGgsXG4gICAgICAgICAgICBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghcGFyYW1zLmFsaWduZWQpIHtcbiAgICAgICAgICAgIHRpY2tDb3VudCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsczogdGhpcy5fbWFrZUxhYmVscyhwYXJhbXMubGFiZWxzLCBvcHRpb25zLmxhYmVsSW50ZXJ2YWwpLFxuICAgICAgICAgICAgdGlja0NvdW50OiB0aWNrQ291bnQsXG4gICAgICAgICAgICB2YWxpZFRpY2tDb3VudDogMCxcbiAgICAgICAgICAgIGlzTGFiZWxBeGlzOiB0cnVlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogISFwYXJhbXMuaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIGFsaWduZWQ6ICEhcGFyYW1zLmFsaWduZWRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBkYXRhIGFib3V0IHZhbHVlIGF4aXMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxhcnJheS48bnVtYmVyPj59IHBhcmFtcy52YWx1ZXMgY2hhcnQgdmFsdWVzXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDpudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBwYXJhbXMuc2VyaWVzRGltZW5zaW9uIHNlcmllcyBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPGZ1bmN0aW9uPn0gcGFyYW1zLmZvcm1hdEZ1bmN0aW9ucyBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnN0YWNrZWQgc3RhY2tlZCBvcHRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMub3B0aW9ucyBheGlzIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgbGFiZWxzOiBhcnJheS48c3RyaW5nPixcbiAgICAgKiAgICAgIHRpY2tDb3VudDogbnVtYmVyLFxuICAgICAqICAgICAgdmFsaWRUaWNrQ291bnQ6IG51bWJlcixcbiAgICAgKiAgICAgIGlzTGFiZWxBeGlzOiBib29sZWFuLFxuICAgICAqICAgICAgc2NhbGU6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LFxuICAgICAqICAgICAgaXNWZXJ0aWNhbDogYm9vbGVhblxuICAgICAqIH19IGF4aXMgZGF0YVxuICAgICAqL1xuICAgIG1ha2VWYWx1ZUF4aXNEYXRhOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgIGlzVmVydGljYWwgPSAhIXBhcmFtcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgaXNQb3NpdGlvblJpZ2h0ID0gISFwYXJhbXMuaXNQb3NpdGlvblJpZ2h0LFxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gcGFyYW1zLmZvcm1hdEZ1bmN0aW9ucyxcbiAgICAgICAgICAgIHRpY2tJbmZvO1xuICAgICAgICBpZiAocGFyYW1zLnN0YWNrZWQgPT09ICdwZXJjZW50Jykge1xuICAgICAgICAgICAgdGlja0luZm8gPSBjaGFydENvbnN0LlBFUkNFTlRfU1RBQ0tFRF9USUNLX0lORk87XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tJbmZvID0gdGhpcy5fZ2V0VGlja0luZm8oe1xuICAgICAgICAgICAgICAgIHZhbHVlczogdGhpcy5fbWFrZUJhc2VWYWx1ZXMocGFyYW1zLnZhbHVlcywgcGFyYW1zLnN0YWNrZWQpLFxuICAgICAgICAgICAgICAgIHNlcmllc0RpbWVuc2lvbjogcGFyYW1zLnNlcmllc0RpbWVuc2lvbixcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiBpc1ZlcnRpY2FsLFxuICAgICAgICAgICAgICAgIGlzUG9zaXRpb25SaWdodDogaXNQb3NpdGlvblJpZ2h0LFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZVxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmZvcm1hdExhYmVscyh0aWNrSW5mby5sYWJlbHMsIGZvcm1hdEZ1bmN0aW9ucyksXG4gICAgICAgICAgICB0aWNrQ291bnQ6IHRpY2tJbmZvLnRpY2tDb3VudCxcbiAgICAgICAgICAgIHZhbGlkVGlja0NvdW50OiB0aWNrSW5mby50aWNrQ291bnQsXG4gICAgICAgICAgICBzY2FsZTogdGlja0luZm8uc2NhbGUsXG4gICAgICAgICAgICBzdGVwOiB0aWNrSW5mby5zdGVwLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIGlzUG9zaXRpb25SaWdodDogaXNQb3NpdGlvblJpZ2h0LFxuICAgICAgICAgICAgYWxpZ25lZDogISFwYXJhbXMuYWxpZ25lZFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGJhc2UgdmFsdWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG51bWJlcj59IGdyb3VwVmFsdWVzIGdyb3VwIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja2VkIHN0YWNrZWQgb3B0aW9uLlxuICAgICAqIEByZXR1cm5zIHthcnJheS48bnVtYmVyPn0gYmFzZSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQmFzZVZhbHVlczogZnVuY3Rpb24oZ3JvdXBWYWx1ZXMsIHN0YWNrZWQpIHtcbiAgICAgICAgdmFyIGJhc2VWYWx1ZXMgPSBjb25jYXQuYXBwbHkoW10sIGdyb3VwVmFsdWVzKTsgLy8gZmxhdHRlbiBhcnJheVxuICAgICAgICBpZiAoc3RhY2tlZCA9PT0gY2hhcnRDb25zdC5TVEFDS0VEX05PUk1BTF9UWVBFKSB7XG4gICAgICAgICAgICBiYXNlVmFsdWVzID0gYmFzZVZhbHVlcy5jb25jYXQodHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGx1c1ZhbHVlcyA9IHR1aS51dGlsLmZpbHRlcih2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLnN1bShwbHVzVmFsdWVzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVZhbHVlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJhc2Ugc2l6ZSBmb3IgZ2V0IGNhbmRpZGF0ZSB0aWNrIGNvdW50cy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBjaGF0IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGJhc2Ugc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJhc2VTaXplOiBmdW5jdGlvbihkaW1lbnNpb24sIGlzVmVydGljYWwpIHtcbiAgICAgICAgdmFyIGJhc2VTaXplO1xuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgYmFzZVNpemUgPSBkaW1lbnNpb24uaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVNpemUgPSBkaW1lbnNpb24ud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FuZGlkYXRlIHRpY2sgY291bnRzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gY2hhcnREaW1lbnNpb24gY2hhdCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPG51bWJlcj59IHRpY2sgY291bnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FuZGlkYXRlVGlja0NvdW50czogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGlzVmVydGljYWwpIHtcbiAgICAgICAgdmFyIGJhc2VTaXplID0gdGhpcy5fZ2V0QmFzZVNpemUoY2hhcnREaW1lbnNpb24sIGlzVmVydGljYWwpLFxuICAgICAgICAgICAgc3RhcnQgPSB0dWkudXRpbC5tYXgoWzMsIHBhcnNlSW50KGJhc2VTaXplIC8gY2hhcnRDb25zdC5NQVhfUElYRUxfVFlQRV9TVEVQX1NJWkUsIDEwKV0pLFxuICAgICAgICAgICAgZW5kID0gdHVpLnV0aWwubWF4KFtzdGFydCwgcGFyc2VJbnQoYmFzZVNpemUgLyBjaGFydENvbnN0Lk1JTl9QSVhFTF9UWVBFX1NURVBfU0laRSwgMTApXSkgKyAxLFxuICAgICAgICAgICAgdGlja0NvdW50cyA9IHR1aS51dGlsLnJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gdGlja0NvdW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbXBhcmluZyB2YWx1ZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBtYXhpbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7e3NjYWxlOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgc3RlcDogbnVtYmVyfX0gdGlja0luZm8gdGljayBpbmZvXG4gICAgICogQHJldHVybnMge251bWJlcn0gY29tcGFyaW5nIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29tcGFyaW5nVmFsdWU6IGZ1bmN0aW9uKG1pbiwgbWF4LCB0aWNrSW5mbykge1xuICAgICAgICB2YXIgZGlmZk1heCA9IGFicyh0aWNrSW5mby5zY2FsZS5tYXggLSBtYXgpLFxuICAgICAgICAgICAgZGlmZk1pbiA9IGFicyhtaW4gLSB0aWNrSW5mby5zY2FsZS5taW4pLFxuICAgICAgICAgICAgd2VpZ2h0ID0gTWF0aC5wb3coMTAsIHR1aS51dGlsLmxlbmd0aEFmdGVyUG9pbnQodGlja0luZm8uc3RlcCkpO1xuICAgICAgICByZXR1cm4gKGRpZmZNYXggKyBkaWZmTWluKSAqIHdlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRpY2sgaW5mby5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBtYXhpbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IGNhbmRpZGF0ZXMgdGljayBpbmZvIGNhbmRpZGF0ZXNcbiAgICAgKiBAcmV0dXJucyB7e3NjYWxlOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgdGlja0NvdW50OiBudW1iZXIsIHN0ZXA6IG51bWJlciwgbGFiZWxzOiBhcnJheS48bnVtYmVyPn19IHNlbGVjdGVkIHRpY2sgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdFRpY2tJbmZvOiBmdW5jdGlvbihtaW4sIG1heCwgY2FuZGlkYXRlcykge1xuICAgICAgICB2YXIgZ2V0Q29tcGFyaW5nVmFsdWUgPSB0dWkudXRpbC5iaW5kKHRoaXMuX2dldENvbXBhcmluZ1ZhbHVlLCB0aGlzLCBtaW4sIG1heCksXG4gICAgICAgICAgICB0aWNrSW5mbyA9IHR1aS51dGlsLm1pbihjYW5kaWRhdGVzLCBnZXRDb21wYXJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aWNrSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRpY2sgY291bnQgYW5kIHNjYWxlLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWx1ZXMgYmFzZSB2YWx1ZXNcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLnNlcmllc0RpbWVuc2lvbiBjaGF0IGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFydFR5cGUgY2hhdCB0eXBlXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDpudW1iZXJ9fSBvcHRpb25zIGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7dGlja0NvdW50OiBudW1iZXIsIHNjYWxlOiBvYmplY3R9fSB0aWNrIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRUaWNrSW5mbzogZnVuY3Rpb24ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtaW4gPSB0dWkudXRpbC5taW4ocGFyYW1zLnZhbHVlcyksXG4gICAgICAgICAgICBtYXggPSB0dWkudXRpbC5tYXgocGFyYW1zLnZhbHVlcyksXG4gICAgICAgICAgICBpbnRUeXBlSW5mbywgdGlja0NvdW50cywgY2FuZGlkYXRlcywgdGlja0luZm87XG4gICAgICAgIC8vIDAxLiBtaW4sIG1heCwgb3B0aW9ucyDsoJXrs7Trpbwg7KCV7IiY7ZiV7Jy866GcIOuzgOqyvVxuICAgICAgICBpbnRUeXBlSW5mbyA9IHRoaXMuX21ha2VJbnRlZ2VyVHlwZUluZm8obWluLCBtYXgsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIDAyLiB0aWNrIGNvdW50IO2bhOuztOq1sCDslrvquLBcbiAgICAgICAgdGlja0NvdW50cyA9IHBhcmFtcy50aWNrQ291bnQgPyBbcGFyYW1zLnRpY2tDb3VudF0gOiB0aGlzLl9nZXRDYW5kaWRhdGVUaWNrQ291bnRzKHBhcmFtcy5zZXJpZXNEaW1lbnNpb24sIHBhcmFtcy5pc1ZlcnRpY2FsKTtcblxuICAgICAgICAvLyAwMy4gdGljayBpbmZvIO2bhOuztOq1sCDqs4TsgrBcbiAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX2dldENhbmRpZGF0ZVRpY2tJbmZvcyh7XG4gICAgICAgICAgICBtaW46IGludFR5cGVJbmZvLm1pbixcbiAgICAgICAgICAgIG1heDogaW50VHlwZUluZm8ubWF4LFxuICAgICAgICAgICAgdGlja0NvdW50czogdGlja0NvdW50cyxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZVxuICAgICAgICB9LCBpbnRUeXBlSW5mby5vcHRpb25zKTtcblxuICAgICAgICAvLyAwNC4gdGljayBpbmZvIO2bhOuztOq1sCDspJEg7ZWY64KYIOyEoO2DnVxuICAgICAgICB0aWNrSW5mbyA9IHRoaXMuX3NlbGVjdFRpY2tJbmZvKGludFR5cGVJbmZvLm1pbiwgaW50VHlwZUluZm8ubWF4LCBjYW5kaWRhdGVzKTtcblxuICAgICAgICAvLyAwNS4g7KCV7IiY7ZiV7Jy866GcIOuzgOqyve2WiOuNmCB0aWNrIGluZm/rpbwg7JuQ656YIO2Yle2DnOuhnCDrs4Dqsr1cbiAgICAgICAgdGlja0luZm8gPSB0aGlzLl9yZXZlcnRPcmlnaW5hbFR5cGVUaWNrSW5mbyh0aWNrSW5mbywgaW50VHlwZUluZm8uZGl2aWRlTnVtKTtcbiAgICAgICAgcmV0dXJuIHRpY2tJbmZvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGludGVnZXIgdHlwZSBpbmZvXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW5pbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBvcHRpb25zIGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBvcHRpb25zOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgZGl2aWRlTnVtOiBudW1iZXJ9fSBpbnRlZ2VyIHR5cGUgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VJbnRlZ2VyVHlwZUluZm86IGZ1bmN0aW9uKG1pbiwgbWF4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtdWx0aXBsZU51bSwgY2hhbmdlZE9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGFicyhtaW4pID49IDEgfHwgYWJzKG1heCkgPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIGRpdmlkZU51bTogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG11bHRpcGxlTnVtID0gdHVpLnV0aWwuZmluZE11bHRpcGxlTnVtKG1pbiwgbWF4KTtcbiAgICAgICAgY2hhbmdlZE9wdGlvbnMgPSB7fTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWluKSkge1xuICAgICAgICAgICAgY2hhbmdlZE9wdGlvbnMubWluID0gb3B0aW9ucy5taW4gKiBtdWx0aXBsZU51bTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9ucy5tYXgpKSB7XG4gICAgICAgICAgICBjaGFuZ2VkT3B0aW9ucy5tYXggPSBvcHRpb25zLm1heCAqIG11bHRpcGxlTnVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogbWluICogbXVsdGlwbGVOdW0sXG4gICAgICAgICAgICBtYXg6IG1heCAqIG11bHRpcGxlTnVtLFxuICAgICAgICAgICAgb3B0aW9uczogY2hhbmdlZE9wdGlvbnMsXG4gICAgICAgICAgICBkaXZpZGVOdW06IG11bHRpcGxlTnVtXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldmVydCB0aWNrIGluZm8gdG8gb3JpZ2luYWwgdHlwZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge3tzdGVwOiBudW1iZXIsIHNjYWxlOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgbGFiZWxzOiBhcnJheS48bnVtYmVyPn19IHRpY2tJbmZvIHRpY2sgaW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVOdW0gZGl2aWRlIG51bVxuICAgICAqIEByZXR1cm5zIHt7c3RlcDogbnVtYmVyLCBzY2FsZToge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIGxhYmVsczogYXJyYXkuPG51bWJlcj59fSBkaXZpZGVkIHRpY2sgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JldmVydE9yaWdpbmFsVHlwZVRpY2tJbmZvOiBmdW5jdGlvbih0aWNrSW5mbywgZGl2aWRlTnVtKSB7XG4gICAgICAgIGlmIChkaXZpZGVOdW0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWNrSW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIHRpY2tJbmZvLnN0ZXAgPSB0dWkudXRpbC5kaXZpc2lvbih0aWNrSW5mby5zdGVwLCBkaXZpZGVOdW0pO1xuICAgICAgICB0aWNrSW5mby5zY2FsZS5taW4gPSB0dWkudXRpbC5kaXZpc2lvbih0aWNrSW5mby5zY2FsZS5taW4sIGRpdmlkZU51bSk7XG4gICAgICAgIHRpY2tJbmZvLnNjYWxlLm1heCA9IHR1aS51dGlsLmRpdmlzaW9uKHRpY2tJbmZvLnNjYWxlLm1heCwgZGl2aWRlTnVtKTtcbiAgICAgICAgdGlja0luZm8ubGFiZWxzID0gdHVpLnV0aWwubWFwKHRpY2tJbmZvLmxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5kaXZpc2lvbihsYWJlbCwgZGl2aWRlTnVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRpY2tJbmZvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgc3RlcC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBvcmlnaW5hbCBzdGVwXG4gICAgICogQHJldHVybnMge251bWJlcn0gbm9ybWFsaXplZCBzdGVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbm9ybWFsaXplU3RlcDogZnVuY3Rpb24oc3RlcCkge1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRvci5ub3JtYWxpemVBeGlzTnVtYmVyKHN0ZXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtaW5pbWl6ZSB0aWNrIHNjYWxlLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy51c2VyTWluIHVzZXIgbWluXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnVzZXJNYXggdXNlciBtYXhcbiAgICAgKiAgICAgIEBwYXJhbSB7e3RpY2tDb3VudDogbnVtYmVyLCBzY2FsZTogb2JqZWN0fX0gcGFyYW1zLnRpY2tJbmZvIHRpY2sgaW5mb1xuICAgICAqICAgICAgQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDpudW1iZXJ9fSBwYXJhbXMub3B0aW9ucyBheGlzIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e3RpY2tDb3VudDogbnVtYmVyLCBzY2FsZTogb2JqZWN0LCBsYWJlbHM6IGFycmF5fX0gY29ycmVjdGVkIHRpY2sgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21pbmltaXplVGlja1NjYWxlOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHRpY2tJbmZvID0gcGFyYW1zLnRpY2tJbmZvLFxuICAgICAgICAgICAgdGlja3MgPSB0dWkudXRpbC5yYW5nZSgxLCB0aWNrSW5mby50aWNrQ291bnQpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zLFxuICAgICAgICAgICAgc3RlcCA9IHRpY2tJbmZvLnN0ZXAsXG4gICAgICAgICAgICBzY2FsZSA9IHRpY2tJbmZvLnNjYWxlLFxuICAgICAgICAgICAgdGlja01heCA9IHNjYWxlLm1heCxcbiAgICAgICAgICAgIHRpY2tNaW4gPSBzY2FsZS5taW4sXG4gICAgICAgICAgICBpc1VuZGVmaW5lZE1pbiA9IHR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWluKSxcbiAgICAgICAgICAgIGlzVW5kZWZpbmVkTWF4ID0gdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9ucy5tYXgpLFxuICAgICAgICAgICAgbGFiZWxzO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGlja3MsIGZ1bmN0aW9uKHRpY2tJbmRleCkge1xuICAgICAgICAgICAgdmFyIGN1clN0ZXAgPSAoc3RlcCAqIHRpY2tJbmRleCksXG4gICAgICAgICAgICAgICAgY3VyTWluID0gdGlja01pbiArIGN1clN0ZXAsXG4gICAgICAgICAgICAgICAgY3VyTWF4ID0gdGlja01heCAtIGN1clN0ZXA7XG5cbiAgICAgICAgICAgIC8vIOuNlOydtOyDgSDrs4Dqsr3snbQg7ZWE7JqUIOyXhuydhCDqsr3smrBcbiAgICAgICAgICAgIGlmIChwYXJhbXMudXNlck1pbiA8PSBjdXJNaW4gJiYgcGFyYW1zLnVzZXJNYXggPj0gY3VyTWF4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtaW4g6rCS7JeQIOuzgOqyvSDsl6zsnKDqsIAg7J6I7J2EIOqyveyasFxuICAgICAgICAgICAgaWYgKChpc1VuZGVmaW5lZE1pbiAmJiBwYXJhbXMudXNlck1pbiA+IGN1ck1pbikgfHxcbiAgICAgICAgICAgICAgICAoIWlzVW5kZWZpbmVkTWluICYmIG9wdGlvbnMubWluID49IGN1ck1pbikpIHtcbiAgICAgICAgICAgICAgICBzY2FsZS5taW4gPSBjdXJNaW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1heCDqsJLsl5Ag67OA6rK9IOyXrOycoOqwgCDsnojsnYQg6rK97JqwXG4gICAgICAgICAgICBpZiAoKGlzVW5kZWZpbmVkTWluICYmIHBhcmFtcy51c2VyTWF4IDwgY3VyTWF4KSB8fFxuICAgICAgICAgICAgICAgICghaXNVbmRlZmluZWRNYXggJiYgb3B0aW9ucy5tYXggPD0gY3VyTWF4KSkge1xuICAgICAgICAgICAgICAgIHNjYWxlLm1heCA9IGN1ck1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGFiZWxzID0gY2FsY3VsYXRvci5tYWtlTGFiZWxzRnJvbVNjYWxlKHNjYWxlLCBzdGVwKTtcbiAgICAgICAgdGlja0luZm8ubGFiZWxzID0gbGFiZWxzO1xuICAgICAgICB0aWNrSW5mby5zdGVwID0gc3RlcDtcbiAgICAgICAgdGlja0luZm8udGlja0NvdW50ID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRpY2tJbmZvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBkaXZpZGUgdGljayBzdGVwLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7e3NjYWxlOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgdGlja0NvdW50OiBudW1iZXIsIHN0ZXA6IG51bWJlciwgbGFiZWxzOiBhcnJheS48bnVtYmVyPn19IHRpY2tJbmZvIHRpY2sgaW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcmdUaWNrQ291bnQgb3JpZ2luYWwgdGlja0NvdW50XG4gICAgICogQHJldHVybnMge3tzY2FsZToge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHRpY2tDb3VudDogbnVtYmVyLCBzdGVwOiBudW1iZXIsIGxhYmVsczogYXJyYXkuPG51bWJlcj59fSB0aWNrIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXZpZGVUaWNrU3RlcDogZnVuY3Rpb24odGlja0luZm8sIG9yZ1RpY2tDb3VudCkge1xuICAgICAgICB2YXIgc3RlcCA9IHRpY2tJbmZvLnN0ZXAsXG4gICAgICAgICAgICBzY2FsZSA9IHRpY2tJbmZvLnNjYWxlLFxuICAgICAgICAgICAgdGlja0NvdW50ID0gdGlja0luZm8udGlja0NvdW50O1xuICAgICAgICAvLyBzdGVwIDLsnZgg67Cw7IiYIOydtOuptOyEnCDrs4Dqsr3rkJwgdGlja0NvdW507J2YIOuRkOuwsOyImC0x7J20IHRpY2tDb3VudOuztOuLpCBvcmdUaWNrQ291bnTsmYAg7LCo7J206rCAIOuNnOuCmOqxsOuCmCDqsJnsnLzrqbQgc3RlcOydhCDrsJjsnLzroZwg67OA6rK97ZWc64ukLlxuICAgICAgICBpZiAoKHN0ZXAgJSAyID09PSAwKSAmJlxuICAgICAgICAgICAgYWJzKG9yZ1RpY2tDb3VudCAtICgodGlja0NvdW50ICogMikgLSAxKSkgPD0gYWJzKG9yZ1RpY2tDb3VudCAtIHRpY2tDb3VudCkpIHtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwIC8gMjtcbiAgICAgICAgICAgIHRpY2tJbmZvLmxhYmVscyA9IGNhbGN1bGF0b3IubWFrZUxhYmVsc0Zyb21TY2FsZShzY2FsZSwgc3RlcCk7XG4gICAgICAgICAgICB0aWNrSW5mby50aWNrQ291bnQgPSB0aWNrSW5mby5sYWJlbHMubGVuZ3RoO1xuICAgICAgICAgICAgdGlja0luZm8uc3RlcCA9IHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tJbmZvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHRpY2sgaW5mb1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5taW4gc2NhbGUgbWluXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heCBzY2FsZSBtYXhcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudXNlck1pbiBtaW5pbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy51c2VyTWF4IG1heGltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc01pbnVzIHdoZXRoZXIgc2NhbGUgaXMgbWludXMgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBwYXJhbXMub3B0aW9ucyBheGlzIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc2NhbGU6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LFxuICAgICAqICAgICAgdGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICBzdGVwOiBudW1iZXIsXG4gICAgICogICAgICBsYWJlbHM6IGFycmF5LjxudW1iZXI+XG4gICAgICogfX0gdGljayBpbmZvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRpY2tJbmZvOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gcGFyYW1zLnNjYWxlLFxuICAgICAgICAgICAgc3RlcCwgdGlja0luZm87XG5cbiAgICAgICAgLy8gMDEuIOq4sOuzuCBzY2FsZSDsoJXrs7TroZwgc3RlcCDslrvquLBcbiAgICAgICAgc3RlcCA9IGNhbGN1bGF0b3IuZ2V0U2NhbGVTdGVwKHNjYWxlLCBwYXJhbXMudGlja0NvdW50KTtcblxuICAgICAgICAvLyAwMi4gc3RlcCDsoJXqt5ztmZQg7Iuc7YKk6riwIChleDogMC4zIC0tPiAwLjUsIDcgLS0+IDEwKVxuICAgICAgICBzdGVwID0gdGhpcy5fbm9ybWFsaXplU3RlcChzdGVwKTtcblxuICAgICAgICAvLyAwMy4gc2NhbGUg7KCV6rec7ZmUIOyLnO2CpOq4sFxuICAgICAgICBzY2FsZSA9IHRoaXMuX25vcm1hbGl6ZVNjYWxlKHNjYWxlLCBzdGVwLCBwYXJhbXMudGlja0NvdW50KTtcblxuICAgICAgICAvLyAwNC4gbGluZeywqO2KuOydmCDqsr3smrAg7IKs7Jqp7J6Q7J2YIG1pbuqwkuydtCBzY2FsZeydmCBtaW7qsJLqs7wg6rCZ7J2EIOqyveyasCwgbWlu6rCS7J2EIDEgc3RlcCDqsJDshowg7Iuc7YK0XG4gICAgICAgIHNjYWxlLm1pbiA9IHRoaXMuX2FkZE1pblBhZGRpbmcoe1xuICAgICAgICAgICAgbWluOiBzY2FsZS5taW4sXG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgdXNlck1pbjogcGFyYW1zLnVzZXJNaW4sXG4gICAgICAgICAgICBtaW5PcHRpb246IHBhcmFtcy5vcHRpb25zLm1pbixcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyAwNC4g7IKs7Jqp7J6Q7J2YIG1heOqwkuydtCBzY2FlbCBtYXjsmYAg6rCZ7J2EIOqyveyasCwgbWF46rCS7J2EIDEgc3RlcCDspp3qsIAg7Iuc7YK0XG4gICAgICAgIHNjYWxlLm1heCA9IHRoaXMuX2FkZE1heFBhZGRpbmcoe1xuICAgICAgICAgICAgbWF4OiBzY2FsZS5tYXgsXG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgdXNlck1heDogcGFyYW1zLnVzZXJNYXgsXG4gICAgICAgICAgICBtYXhPcHRpb246IHBhcmFtcy5vcHRpb25zLm1heCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyAwNS4gYXhpcyBzY2FsZeydtCDsgqzsmqnsnpAgbWluLCBtYXjsmYAg6rGw66as6rCAIOupgCDqsr3smrAg7KGw7KCIXG4gICAgICAgIHRpY2tJbmZvID0gdGhpcy5fbWluaW1pemVUaWNrU2NhbGUoe1xuICAgICAgICAgICAgdXNlck1pbjogcGFyYW1zLnVzZXJNaW4sXG4gICAgICAgICAgICB1c2VyTWF4OiBwYXJhbXMudXNlck1heCxcbiAgICAgICAgICAgIHRpY2tJbmZvOiB7c2NhbGU6IHNjYWxlLCBzdGVwOiBzdGVwLCB0aWNrQ291bnQ6IHBhcmFtcy50aWNrQ291bnR9LFxuICAgICAgICAgICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGlja0luZm8gPSB0aGlzLl9kaXZpZGVUaWNrU3RlcCh0aWNrSW5mbywgcGFyYW1zLnRpY2tDb3VudCk7XG4gICAgICAgIHJldHVybiB0aWNrSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHNjYWxlIG1pbiBwYWRkaW5nLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHByYW1zIHtudW1iZXJ9IHBhcmFtcy5taW4gc2NhbGUgbWluXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnVzZXJNaW4gbWluaW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWluT3B0aW9uIG1pbiBvcHRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RlcCB0aWNrIHN0ZXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzY2FsZSBtaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRNaW5QYWRkaW5nOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIG1pbiA9IHBhcmFtcy5taW47XG5cbiAgICAgICAgaWYgKCghcHJlZGljYXRlLmlzTGluZUNoYXJ0KHBhcmFtcy5jaGFydFR5cGUpICYmIHBhcmFtcy51c2VyTWluID49IDApIHx8ICF0dWkudXRpbC5pc1VuZGVmaW5lZChwYXJhbXMubWluT3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3JtYWxpemXrkJwgc2NhbGUgbWlu6rCS7J20IHVzZXIgbWlu6rCS6rO8IOqwmeydhCDqsr3smrAgc3RlcCDqsJDshoxcbiAgICAgICAgaWYgKHBhcmFtcy5taW4gPT09IHBhcmFtcy51c2VyTWluKSB7XG4gICAgICAgICAgICBtaW4gLT0gcGFyYW1zLnN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHNjYWxlIG1heCBwYWRkaW5nLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHByYW1zIHtudW1iZXJ9IHBhcmFtcy5tYXggc2NhbGUgbWF4XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnVzZXJNYXggbWF4aW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4T3B0aW9uIG1heCBvcHRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RlcCB0aWNrIHN0ZXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzY2FsZSBtYXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRNYXhQYWRkaW5nOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIG1heCA9IHBhcmFtcy5tYXg7XG5cbiAgICAgICAgaWYgKCghcHJlZGljYXRlLmlzTGluZUNoYXJ0KHBhcmFtcy5jaGFydFR5cGUpICYmIHBhcmFtcy51c2VyTWF4IDw9IDApIHx8ICF0dWkudXRpbC5pc1VuZGVmaW5lZChwYXJhbXMubWF4T3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZeuQnCBzY2FsZSBtYXjqsJLsnbQgdXNlciBtYXjqsJLqs7wg6rCZ7J2EIOqyveyasCBzdGVwIOymneqwgFxuICAgICAgICBpZiAodHVpLnV0aWwuaXNVbmRlZmluZWQocGFyYW1zLm1heE9wdGlvbikgJiYgKHBhcmFtcy5tYXggPT09IHBhcmFtcy51c2VyTWF4KSkge1xuICAgICAgICAgICAgbWF4ICs9IHBhcmFtcy5zdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG5vcm1hbGl6ZSBtaW4uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBvcmlnaW5hbCBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCB0aWNrIHN0ZXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBub3JtYWxpemVkIG1pblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZU1pbjogZnVuY3Rpb24obWluLCBzdGVwKSB7XG4gICAgICAgIHZhciBtb2QgPSB0dWkudXRpbC5tb2QobWluLCBzdGVwKSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ7XG5cbiAgICAgICAgaWYgKG1vZCA9PT0gMCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZCA9IG1pbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0dWkudXRpbC5zdWJ0cmFjdGlvbihtaW4sIChtaW4gPj0gMCA/IG1vZCA6IHN0ZXAgKyBtb2QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBub3JtYWxpemVkIG1heC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBzY2FsZSBzY2FsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHRpY2sgc3RlcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5vcm1hbGl6ZWQgbWF4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbGl6ZWRNYXg6IGZ1bmN0aW9uKHNjYWxlLCBzdGVwLCB0aWNrQ291bnQpIHtcbiAgICAgICAgdmFyIG1pbk1heERpZmYgPSB0dWkudXRpbC5tdWx0aXBsaWNhdGlvbihzdGVwLCB0aWNrQ291bnQgLSAxKSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXggPSB0dWkudXRpbC5hZGRpdGlvbihzY2FsZS5taW4sIG1pbk1heERpZmYpLFxuICAgICAgICAgICAgbWF4RGlmZiA9IHNjYWxlLm1heCAtIG5vcm1hbGl6ZWRNYXgsXG4gICAgICAgICAgICBtb2REaWZmLCBkaXZpZGVEaWZmO1xuICAgICAgICAvLyBub3JtYWxpemXrkJwgbWF46rCS7J20IOybkOuemOydmCBtYXjqsJIg67O064ukIOyekeydhCDqsr3smrAgc3RlcOydhCDspp3qsIDsi5zsvJwg7YGwIOqwkuycvOuhnCDrp4zrk6TquLBcbiAgICAgICAgaWYgKG1heERpZmYgPiAwKSB7XG4gICAgICAgICAgICBtb2REaWZmID0gbWF4RGlmZiAlIHN0ZXA7XG4gICAgICAgICAgICBkaXZpZGVEaWZmID0gTWF0aC5mbG9vcihtYXhEaWZmIC8gc3RlcCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWF4ICs9IHN0ZXAgKiAobW9kRGlmZiA+IDAgPyBkaXZpZGVEaWZmICsgMSA6IGRpdmlkZURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkTWF4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBub3JtYWxpemUgc2NhbGUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gc2NhbGUgYmFzZSBzY2FsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHRpY2sgc3RlcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbm9ybWFsaXplZCBzY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZVNjYWxlOiBmdW5jdGlvbihzY2FsZSwgc3RlcCwgdGlja0NvdW50KSB7XG4gICAgICAgIHNjYWxlLm1pbiA9IHRoaXMuX25vcm1hbGl6ZU1pbihzY2FsZS5taW4sIHN0ZXApO1xuICAgICAgICBzY2FsZS5tYXggPSB0aGlzLl9tYWtlTm9ybWFsaXplZE1heChzY2FsZSwgc3RlcCwgdGlja0NvdW50KTtcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FuZGlkYXRlcyBhYm91dCB0aWNrIGluZm8uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1pbiBtaW5pbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXggbWF4aW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPG51bWJlcj59IHBhcmFtcy50aWNrQ291bnRzIHRpY2sgY291bnRzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDpudW1iZXJ9fSBvcHRpb25zIGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHthcnJheX0gY2FuZGlkYXRlcyBhYm91dCB0aWNrIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDYW5kaWRhdGVUaWNrSW5mb3M6IGZ1bmN0aW9uKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXNlck1pbiA9IHBhcmFtcy5taW4sXG4gICAgICAgICAgICB1c2VyTWF4ID0gcGFyYW1zLm1heCxcbiAgICAgICAgICAgIG1pbiA9IHBhcmFtcy5taW4sXG4gICAgICAgICAgICBtYXggPSBwYXJhbXMubWF4LFxuICAgICAgICAgICAgc2NhbGUsIGNhbmRpZGF0ZXM7XG5cbiAgICAgICAgLy8gbWluLCBtYXjrp4zsnLzroZwg6riw67O4IHNjYWxlIOyWu+q4sFxuICAgICAgICBzY2FsZSA9IHRoaXMuX21ha2VCYXNlU2NhbGUobWluLCBtYXgsIG9wdGlvbnMpO1xuXG4gICAgICAgIGNhbmRpZGF0ZXMgPSB0dWkudXRpbC5tYXAocGFyYW1zLnRpY2tDb3VudHMsIGZ1bmN0aW9uKHRpY2tDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VUaWNrSW5mbyh7XG4gICAgICAgICAgICAgICAgdGlja0NvdW50OiB0aWNrQ291bnQsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHR1aS51dGlsLmV4dGVuZCh7fSwgc2NhbGUpLFxuICAgICAgICAgICAgICAgIHVzZXJNaW46IHVzZXJNaW4sXG4gICAgICAgICAgICAgICAgdXNlck1heDogdXNlck1heCxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IHBhcmFtcy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBiYXNlIHNjYWxlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW5pbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBvcHRpb25zIGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gYmFzZSBzY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNlU2NhbGU6IGZ1bmN0aW9uKG1pbiwgbWF4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBpc01pbnVzID0gZmFsc2UsXG4gICAgICAgICAgICB0bXBNaW4sIHNjYWxlO1xuXG4gICAgICAgIGlmIChtaW4gPCAwICYmIG1heCA8PSAwKSB7XG4gICAgICAgICAgICBpc01pbnVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRtcE1pbiA9IG1pbjtcbiAgICAgICAgICAgIG1pbiA9IC1tYXg7XG4gICAgICAgICAgICBtYXggPSAtdG1wTWluO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NhbGUgPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZVNjYWxlKG1pbiwgbWF4KTtcblxuICAgICAgICBpZiAoaXNNaW51cykge1xuICAgICAgICAgICAgdG1wTWluID0gc2NhbGUubWluO1xuICAgICAgICAgICAgc2NhbGUubWluID0gLXNjYWxlLm1heDtcbiAgICAgICAgICAgIHNjYWxlLm1heCA9IC10bXBNaW47XG4gICAgICAgIH1cblxuICAgICAgICBzY2FsZS5taW4gPSAhdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9ucy5taW4pID8gb3B0aW9ucy5taW4gOiBzY2FsZS5taW47XG4gICAgICAgIHNjYWxlLm1heCA9ICF0dWkudXRpbC5pc1VuZGVmaW5lZChvcHRpb25zLm1heCkgPyBvcHRpb25zLm1heCA6IHNjYWxlLm1heDtcblxuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBsYWJlbHMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGFiZWxzIHRhcmdldCBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uW119IGZvcm1hdEZ1bmN0aW9ucyBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBmb3JtYXR0ZWQgbGFiZWxzXG4gICAgICovXG4gICAgZm9ybWF0TGFiZWxzOiBmdW5jdGlvbihsYWJlbHMsIGZvcm1hdEZ1bmN0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoIWZvcm1hdEZ1bmN0aW9ucyB8fCAhZm9ybWF0RnVuY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0dWkudXRpbC5tYXAobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGZucyA9IGNvbmNhdC5hcHBseShbbGFiZWxdLCBmb3JtYXRGdW5jdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLnJlZHVjZShmbnMsIGZ1bmN0aW9uKHN0b3JlZCwgZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oc3RvcmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aXNEYXRhTWFrZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQm91bmRzIG1ha2VyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4vY2FsY3VsYXRvcicpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4vcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmVuZGVyVXRpbCcpO1xuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLyoqXG4gKiBCb3VuZHMgbWFrZXIuXG4gKiBAbW9kdWxlIGJvdW5kc01ha2VyXG4gKi9cbnZhciBib3VuZHNNYWtlciA9IHtcbiAgICAvKipcbiAgICAgKiBHZXQgbWF4IGxhYmVsIG9mIHZhbHVlIGF4aXMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpib3VuZHNNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb252ZXJ0ZWREYXRhIGNvbnZlcnQgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8c3RyaW5nfSBtYXggbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRWYWx1ZUF4aXNNYXhMYWJlbDogZnVuY3Rpb24oY29udmVydGVkRGF0YSwgY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBjaGFydFR5cGUgJiYgY29udmVydGVkRGF0YS52YWx1ZXNbY2hhcnRUeXBlXSB8fCBjb252ZXJ0ZWREYXRhLmpvaW5WYWx1ZXMsXG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSBjb252ZXJ0ZWREYXRhLmZvcm1hdEZ1bmN0aW9ucyxcbiAgICAgICAgICAgIGZsYXR0ZW5WYWx1ZXMgPSBjb25jYXQuYXBwbHkoW10sIHZhbHVlcyksXG4gICAgICAgICAgICBtaW4gPSB0dWkudXRpbC5taW4oZmxhdHRlblZhbHVlcyksXG4gICAgICAgICAgICBtYXggPSB0dWkudXRpbC5tYXgoZmxhdHRlblZhbHVlcyksXG4gICAgICAgICAgICBzY2FsZSA9IGNhbGN1bGF0b3IuY2FsY3VsYXRlU2NhbGUobWluLCBtYXgpLFxuICAgICAgICAgICAgbWluTGFiZWwgPSBjYWxjdWxhdG9yLm5vcm1hbGl6ZUF4aXNOdW1iZXIoc2NhbGUubWluKSxcbiAgICAgICAgICAgIG1heExhYmVsID0gY2FsY3VsYXRvci5ub3JtYWxpemVBeGlzTnVtYmVyKHNjYWxlLm1heCksXG4gICAgICAgICAgICBmbnMgPSBmb3JtYXRGdW5jdGlvbnMgJiYgZm9ybWF0RnVuY3Rpb25zLnNsaWNlKCkgfHwgW107XG4gICAgICAgIG1heExhYmVsID0gKG1pbkxhYmVsICsgJycpLmxlbmd0aCA+IChtYXhMYWJlbCArICcnKS5sZW5ndGggPyBtaW5MYWJlbCA6IG1heExhYmVsO1xuICAgICAgICBmbnMudW5zaGlmdChtYXhMYWJlbCk7XG4gICAgICAgIG1heExhYmVsID0gdHVpLnV0aWwucmVkdWNlKGZucywgZnVuY3Rpb24oc3RvcmVkLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHN0b3JlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF4TGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBoZWlnaHQgb2YgeCBheGlzIGFyZWEuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpib3VuZHNNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHggYXhpcyBvcHRpb25zLFxuICAgICAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGxhYmVscyBheGlzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBheGlzIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0WEF4aXNIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMsIGxhYmVscywgdGhlbWUpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gb3B0aW9ucyAmJiBvcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgdGl0bGVBcmVhSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KHRpdGxlLCB0aGVtZS50aXRsZSkgKyBjaGFydENvbnN0LlRJVExFX1BBRERJTkcsXG4gICAgICAgICAgICBoZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4SGVpZ2h0KGxhYmVscywgdGhlbWUubGFiZWwpICsgdGl0bGVBcmVhSGVpZ2h0O1xuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2lkdGggYWJvdXQgeSBheGlzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHkgYXhpcyBvcHRpb25zXG4gICAgICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB5QXhpcyB0aGVtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBvcHRpb25zIGluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn0geSBheGlzIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0WUF4aXNXaWR0aDogZnVuY3Rpb24ob3B0aW9ucywgbGFiZWxzLCB0aGVtZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gJycsXG4gICAgICAgICAgICB0aXRsZUFyZWFXaWR0aCwgd2lkdGg7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXS5jb25jYXQob3B0aW9ucyk7XG4gICAgICAgICAgICB0aXRsZSA9IG9wdGlvbnNbaW5kZXggfHwgMF0udGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aXRsZUFyZWFXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodCh0aXRsZSwgdGhlbWUudGl0bGUpICsgY2hhcnRDb25zdC5USVRMRV9QQURESU5HO1xuICAgICAgICB3aWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhXaWR0aChsYWJlbHMsIHRoZW1lLmxhYmVsKSArIHRpdGxlQXJlYVdpZHRoICsgY2hhcnRDb25zdC5BWElTX0xBQkVMX1BBRERJTkc7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2lkdGggYWJvdXQgeSByaWdodCBheGlzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Ym91bmRzTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IHBhcmFtcy5jaGFydFR5cGVzIHkgYXhpcyBjaGFydCB0eXBlc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSB5IGF4aXMgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyB5IGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHkgcmlnaHQgYXhpcyB3aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFlSQXhpc1dpZHRoOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGNoYXJ0VHlwZXMgPSBwYXJhbXMuY2hhcnRUeXBlcyB8fCBbXSxcbiAgICAgICAgICAgIGxlbiA9IGNoYXJ0VHlwZXMubGVuZ3RoLFxuICAgICAgICAgICAgd2lkdGggPSAwLFxuICAgICAgICAgICAgaW5kZXgsIGNoYXJ0VHlwZSwgdGhlbWUsIGxhYmVsO1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgaW5kZXggPSBsZW4gLSAxO1xuICAgICAgICAgICAgY2hhcnRUeXBlID0gY2hhcnRUeXBlc1tpbmRleF07XG4gICAgICAgICAgICB0aGVtZSA9IHBhcmFtcy50aGVtZVtjaGFydFR5cGVdIHx8IHBhcmFtcy50aGVtZTtcbiAgICAgICAgICAgIGxhYmVsID0gdGhpcy5fZ2V0VmFsdWVBeGlzTWF4TGFiZWwocGFyYW1zLmNvbnZlcnRlZERhdGEsIGNoYXJ0VHlwZSk7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX2dldFlBeGlzV2lkdGgocGFyYW1zLm9wdGlvbnMsIFtsYWJlbF0sIHRoZW1lLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGF4ZXMgZGltZW5zaW9uLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Ym91bmRzTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuY29udmVydGVkRGF0YSBjb252ZXJ0ZWQgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBjaGFydCB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiAgICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmF4ZXNMYWJlbEluZm8gYXhlcyBsYWJlbCBpbmZvXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHlBeGlzOiB7d2lkdGg6IG51bWJlcn0sXG4gICAgICogICAgICB5ckF4aXM6IHt3aWR0aDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHhBeGlzOiB7aGVpZ2h0OiBudW1iZXJ9XG4gICAgICogfX0gYXhlcyBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0RpbWVuc2lvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB5QXhpc1dpZHRoID0gMCxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0ID0gMCxcbiAgICAgICAgICAgIHlyQXhpc1dpZHRoID0gMCxcbiAgICAgICAgICAgIGF4ZXNMYWJlbEluZm8sIGNoYXJ0VHlwZTtcblxuICAgICAgICAvLyBheGlzIOyYgeyXreydtCDtlYTsmpQg7J6I64qUIOqyveyasOyXkOunjCDsspjrpqxcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNBeGVzKSB7XG4gICAgICAgICAgICBheGVzTGFiZWxJbmZvID0gcGFyYW1zLmF4ZXNMYWJlbEluZm87XG4gICAgICAgICAgICBjaGFydFR5cGUgPSBwYXJhbXMub3B0aW9uQ2hhcnRUeXBlcyAmJiBwYXJhbXMub3B0aW9uQ2hhcnRUeXBlc1swXSB8fCAnJztcbiAgICAgICAgICAgIHlBeGlzV2lkdGggPSB0aGlzLl9nZXRZQXhpc1dpZHRoKHBhcmFtcy5vcHRpb25zLnlBeGlzLCBheGVzTGFiZWxJbmZvLnlBeGlzLCBwYXJhbXMudGhlbWUueUF4aXNbY2hhcnRUeXBlXSB8fCBwYXJhbXMudGhlbWUueUF4aXMpO1xuICAgICAgICAgICAgeEF4aXNIZWlnaHQgPSB0aGlzLl9nZXRYQXhpc0hlaWdodChwYXJhbXMub3B0aW9ucy54QXhpcywgYXhlc0xhYmVsSW5mby54QXhpcywgcGFyYW1zLnRoZW1lLnhBeGlzKTtcbiAgICAgICAgICAgIHlyQXhpc1dpZHRoID0gdGhpcy5fZ2V0WVJBeGlzV2lkdGgoe1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZERhdGE6IHBhcmFtcy5jb252ZXJ0ZWREYXRhLFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZXM6IHBhcmFtcy5vcHRpb25DaGFydFR5cGVzLFxuICAgICAgICAgICAgICAgIHRoZW1lOiBwYXJhbXMudGhlbWUueUF4aXMsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnMueUF4aXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHlBeGlzOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHlBeGlzV2lkdGhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5ckF4aXM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogeXJBeGlzV2lkdGhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4QXhpczoge1xuICAgICAgICAgICAgICAgIGhlaWdodDogeEF4aXNIZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBza2lwcGVkIGxlZ2VuZCBzaXppbmcgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gb3B0aW9ucyBsZWdlbmQgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzU2tpcHBlZExlZ2VuZFNpemluZzogZnVuY3Rpb24oY2hhcnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAocHJlZGljYXRlLmlzUGllQ2hhcnQoY2hhcnRUeXBlKSAmJiBwcmVkaWNhdGUuaXNQaWVMZWdlbmRBbGlnbihvcHRpb25zLmFsaWduKSkgfHwgb3B0aW9ucy5oaWRkZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgbGVnZW5kIGRpbWVuc2lvbi5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gam9pbkxlZ2VuZExhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxhYmVsVGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGVnZW5kT3B0aW9ucyBzZXJpZXMgb3B0aW9uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyfX0gbGVnZW5kIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMZWdlbmREaW1lbnNpb246IGZ1bmN0aW9uKGpvaW5MZWdlbmRMYWJlbHMsIGxhYmVsVGhlbWUsIGNoYXJ0VHlwZSwgbGVnZW5kT3B0aW9ucykge1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSAwLFxuICAgICAgICAgICAgbGVnZW5kTGFiZWxzLCBtYXhMYWJlbFdpZHRoO1xuXG4gICAgICAgIGxlZ2VuZE9wdGlvbnMgPSBsZWdlbmRPcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmICghdGhpcy5faXNTa2lwcGVkTGVnZW5kU2l6aW5nKGNoYXJ0VHlwZSwgbGVnZW5kT3B0aW9ucykpIHtcbiAgICAgICAgICAgIGxlZ2VuZExhYmVscyA9IHR1aS51dGlsLm1hcChqb2luTGVnZW5kTGFiZWxzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1heExhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4V2lkdGgobGVnZW5kTGFiZWxzLCBsYWJlbFRoZW1lKTtcbiAgICAgICAgICAgIGxlZ2VuZFdpZHRoID0gbWF4TGFiZWxXaWR0aCArIGNoYXJ0Q29uc3QuTEVHRU5EX1JFQ1RfV0lEVEggK1xuICAgICAgICAgICAgICAgIGNoYXJ0Q29uc3QuTEVHRU5EX0xBQkVMX0xFRlRfUEFERElORyArIChjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkcgKiAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogbGVnZW5kV2lkdGhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBzZXJpZXMgZGltZW5zaW9uLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Ym91bmRzTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmNoYXJ0RGltZW5zaW9uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHt7XG4gICAgICogICAgICAgICAgeUF4aXM6IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfSxcbiAgICAgKiAgICAgICAgICB4QXhpczoge3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9LFxuICAgICAqICAgICAgICAgIHlyQXhpczoge3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9XG4gICAgICogICAgICB9fSBwYXJhbXMuYXhlc0RpbWVuc2lvbiBheGVzIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sZWdlbmRXaWR0aCBsZWdlbmQgd2lkdGhcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudGl0bGVIZWlnaHQgdGl0bGUgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHNlcmllcyBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGltZW5zaW9uOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGF4ZXNEaW1lbnNpb24gPSBwYXJhbXMuYXhlc0RpbWVuc2lvbixcbiAgICAgICAgICAgIHJpZ2h0QXJlYVdpZHRoID0gcGFyYW1zLmxlZ2VuZFdpZHRoICsgYXhlc0RpbWVuc2lvbi55ckF4aXMud2lkdGgsXG4gICAgICAgICAgICB3aWR0aCA9IHBhcmFtcy5jaGFydERpbWVuc2lvbi53aWR0aCAtIChjaGFydENvbnN0LkNIQVJUX1BBRERJTkcgKiAyKSAtIGF4ZXNEaW1lbnNpb24ueUF4aXMud2lkdGggLSByaWdodEFyZWFXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHBhcmFtcy5jaGFydERpbWVuc2lvbi5oZWlnaHQgLSAoY2hhcnRDb25zdC5DSEFSVF9QQURESU5HICogMikgLSBwYXJhbXMudGl0bGVIZWlnaHQgLSBheGVzRGltZW5zaW9uLnhBeGlzLmhlaWdodDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBjaGFydCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBjaGFydE9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IChudW1iZXIpLCBoZWlnaHQ6IChudW1iZXIpfX0gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNoYXJ0RGltZW5zaW9uOiBmdW5jdGlvbihjaGFydE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBjaGFydE9wdGlvbnMud2lkdGggfHwgY2hhcnRDb25zdC5DSEFSVF9ERUZBVUxUX1dJRFRILFxuICAgICAgICAgICAgaGVpZ2h0OiBjaGFydE9wdGlvbnMuaGVpZ2h0IHx8IGNoYXJ0Q29uc3QuQ0hBUlRfREVGQVVMVF9IRUlHSFRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSB0aXRsZSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3t0aXRsZTogc3RyaW5nfX0gb3B0aW9uIHRpdGxlIG9wdGlvblxuICAgICAqIEBwYXJhbSB7e2ZvbnRGYW1pbHk6IHN0cmluZywgZm9udFNpemU6IG51bWJlcn19IHRoZW1lIHRpdGxlIHRoZW1lXG4gICAgICogQHJldHVybnMge3toZWlnaHQ6IG51bWJlcn19IHRpdGxlIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUaXRsZURpbWVuc2lvbjogZnVuY3Rpb24ob3B0aW9uLCB0aGVtZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQob3B0aW9uLCB0aGVtZSkgKyBjaGFydENvbnN0LlRJVExFX1BBRERJTkdcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBwbG90IGRpbWVudGlvblxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gc2VyaWVzRGltZW5zaW9uIHNlcmllcyBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGxvdCBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGxvdERpbWVuc2lvbjogZnVuY3Rpb24oc2VyaWVzRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogc2VyaWVzRGltZW5zaW9uLndpZHRoICsgY2hhcnRDb25zdC5ISURERU5fV0lEVEgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNlcmllc0RpbWVuc2lvbi5oZWlnaHQgKyBjaGFydENvbnN0LkhJRERFTl9XSURUSFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29tcG9uZW50cyBkaW1lbnNpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmNvbnZlcnRlZERhdGEgY29udmVydGVkIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmF4ZXNMYWJlbEluZm8gYXhlcyBsYWJlbCBpbmZvXG4gICAgICogQHJldHVybnMge09iamVjdH0gY29tcG9uZW50cyBkaW1lbnNpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29tcG9uZW50c0RpbWVuc2lvbnM6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgY2hhcnRPcHRpb25zID0gcGFyYW1zLm9wdGlvbnMuY2hhcnQgfHwge30sXG4gICAgICAgICAgICBjaGFydERpbWVuc2lvbiA9IHRoaXMuX21ha2VDaGFydERpbWVuc2lvbihjaGFydE9wdGlvbnMpLFxuICAgICAgICAgICAgdGl0bGVEaW1lbnNpb24gPSB0aGlzLl9tYWtlVGl0bGVEaW1lbnNpb24oY2hhcnRPcHRpb25zLnRpdGxlLCBwYXJhbXMudGhlbWUudGl0bGUpLFxuICAgICAgICAgICAgYXhlc0RpbWVuc2lvbiA9IHRoaXMuX21ha2VBeGVzRGltZW5zaW9uKHBhcmFtcyksXG4gICAgICAgICAgICBsZWdlbmREaW1lbnNpb24gPSB0aGlzLl9tYWtlTGVnZW5kRGltZW5zaW9uKHBhcmFtcy5jb252ZXJ0ZWREYXRhLmpvaW5MZWdlbmRMYWJlbHMsIHBhcmFtcy50aGVtZS5sZWdlbmQubGFiZWwsIHBhcmFtcy5vcHRpb25zLmNoYXJ0VHlwZSwgcGFyYW1zLm9wdGlvbnMubGVnZW5kKSxcbiAgICAgICAgICAgIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuX21ha2VTZXJpZXNEaW1lbnNpb24oe1xuICAgICAgICAgICAgICAgIGNoYXJ0RGltZW5zaW9uOiBjaGFydERpbWVuc2lvbixcbiAgICAgICAgICAgICAgICBheGVzRGltZW5zaW9uOiBheGVzRGltZW5zaW9uLFxuICAgICAgICAgICAgICAgIGxlZ2VuZFdpZHRoOiBsZWdlbmREaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICAgICAgdGl0bGVIZWlnaHQ6IHRpdGxlRGltZW5zaW9uLmhlaWdodFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBjaGFydDogY2hhcnREaW1lbnNpb24sXG4gICAgICAgICAgICB0aXRsZTogdGl0bGVEaW1lbnNpb24sXG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllc0RpbWVuc2lvbixcbiAgICAgICAgICAgIHBsb3Q6IHRoaXMuX21ha2VQbG90RGltZW5zaW9uKHNlcmllc0RpbWVuc2lvbiksXG4gICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZERpbWVuc2lvblxuICAgICAgICB9LCBheGVzRGltZW5zaW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBiYXNpYyBib3VuZC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgbGVmdFxuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fX0gc2VyaWVzIGJvdW5kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNpY0JvdW5kOiBmdW5jdGlvbihkaW1lbnNpb24sIHRvcCwgbGVmdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiBkaW1lbnNpb24sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSB5QXhpcyBib3VuZC5cbiAgICAgKiBAcGFyYW0ge3t5QXhpczoge3dpZHRoOiBudW1iZXJ9LCBwbG90OiB7aGVpZ2h0OiBudW1iZXJ9fX0gZGltZW5zaW9ucyBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCB0b3BcbiAgICAgKiBAcmV0dXJucyB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogKG51bWJlcil9LCBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fX0geUF4aXMgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlWUF4aXNCb3VuZDogZnVuY3Rpb24oZGltZW5zaW9ucywgdG9wKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogZGltZW5zaW9ucy55QXhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGRpbWVuc2lvbnMucGxvdC5oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuY2hhcnRMZWZ0UGFkZGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHhBeGlzIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7e3hBeGlzOiB7aGVpZ2h0OiBudW1iZXJ9LCBwbG90OiB7d2lkdGg6IG51bWJlcn19fSBkaW1lbnNpb25zIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wIHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGxlZnRcbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlcn19IHJvdGF0aW9uSW5mbyByb3RhdGlvbiBpbmZvXG4gICAgICogQHJldHVybnMge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IChudW1iZXIpfSwgcG9zaXRpb246IHt0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX19IHhBeGlzIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVhBeGlzQm91bmQ6IGZ1bmN0aW9uKGRpbWVuc2lvbnMsIHRvcCwgbGVmdCwgcm90YXRpb25JbmZvKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBkaW1lbnNpb25zLnBsb3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkaW1lbnNpb25zLnhBeGlzLmhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgdG9wOiB0b3AgKyBkaW1lbnNpb25zLnNlcmllcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCAtIGNoYXJ0Q29uc3QuSElEREVOX1dJRFRIXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uSW5mbykge1xuICAgICAgICAgICAgYm91bmQuZGVncmVlID0gcm90YXRpb25JbmZvLmRlZ3JlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSB5ckF4aXMgYm91bmQuXG4gICAgICogQHBhcmFtIHt7eXJBeGlzOiB7d2lkdGg6IG51bWJlcn0sIHBsb3Q6IHtoZWlnaHQ6IG51bWJlcn0sIGxlZ2VuZDoge3dpZHRoOiBudW1iZXJ9fX0gZGltZW5zaW9ucyBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCB0b3BcbiAgICAgKiBAcmV0dXJucyB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogKG51bWJlcil9LCBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fX0geXJBeGlzIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVlSQXhpc0JvdW5kOiBmdW5jdGlvbihkaW1lbnNpb25zLCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBkaW1lbnNpb25zLnlyQXhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGRpbWVuc2lvbnMucGxvdC5oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBkaW1lbnNpb25zLmxlZ2VuZC53aWR0aCArIGNoYXJ0Q29uc3QuSElEREVOX1dJRFRIICsgY2hhcnRDb25zdC5DSEFSVF9QQURESU5HXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYXhlcyBib3VuZHMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpib3VuZHNNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaGFzQXhlcyB3aGV0aGVyIGhhcyBheGVkIG9yIG5vdFxuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48c3RyaW5nPn0gcGFyYW1zLm9wdGlvbkNoYXJ0VHlwZXMgeSBheGlzIGNoYXJ0IHR5cGVzXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnRvcCB0b3AgcG9zaXRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucmlnaHQgcmlnaHQgcG9zaXRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7e2RlZ3JlZTogbnVtYmVyfX0gcGFyYW1zLnJvdGF0aW9uSW5mbyByb3RhdGlvbiBpbmZvXG4gICAgICogQHJldHVybnMge29iamVjdH0gYXhlcyBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0JvdW5kczogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBib3VuZHM7XG5cbiAgICAgICAgLy8gcGll7LCo7Yq47JmAIOqwmeydtCBheGlzIOyYgeyXreydtCDtlYTsmpQg7JeG64qUIOqyveyasOyXkOuKlCDruYgg6rCS7J2EIOuwmO2ZmCDtlahcbiAgICAgICAgaWYgKCFwYXJhbXMuaGFzQXhlcykge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRzID0ge1xuICAgICAgICAgICAgcGxvdDogdGhpcy5fbWFrZUJhc2ljQm91bmQocGFyYW1zLmRpbWVuc2lvbnMucGxvdCwgcGFyYW1zLnRvcCwgcGFyYW1zLmxlZnQgLSBjaGFydENvbnN0LkhJRERFTl9XSURUSCksXG4gICAgICAgICAgICB5QXhpczogdGhpcy5fbWFrZVlBeGlzQm91bmQocGFyYW1zLmRpbWVuc2lvbnMsIHBhcmFtcy50b3ApLFxuICAgICAgICAgICAgeEF4aXM6IHRoaXMuX21ha2VYQXhpc0JvdW5kKHBhcmFtcy5kaW1lbnNpb25zLCBwYXJhbXMudG9wLCBwYXJhbXMubGVmdCwgcGFyYW1zLnJvdGF0aW9uSW5mbylcbiAgICAgICAgfTtcblxuICAgICAgICAvLyDsmrDsuKEgeSBheGlzIOyYgeyXrSBib3VuZHMg7KCV67O0IOy2lOqwgFxuICAgICAgICBpZiAocGFyYW1zLm9wdGlvbkNoYXJ0VHlwZXMgJiYgcGFyYW1zLm9wdGlvbkNoYXJ0VHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBib3VuZHMueXJBeGlzID0gdGhpcy5fbWFrZVlSQXhpc0JvdW5kKHBhcmFtcy5kaW1lbnNpb25zLCBwYXJhbXMudG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgY2hhcnQgYm91bmQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uLlxuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fX0gY2hhcnQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ2hhcnRCb3VuZDogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IGRpbWVuc2lvblxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGxlZ2VuZCBib3VuZC5cbiAgICAgKiBAcGFyYW0ge3t0aXRsZToge2hlaWdodDogbnVtYmVyfSwgc2VyaWVzOiB7d2lkdGg6IG51bWJlcn0sIHlyQXhpczoge3dpZHRoOiBudW1iZXJ9fX0gZGltZW5zaW9ucyBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlBeGlzV2lkdGggeUF4aXMgd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7e3Bvc2l0aW9uOiB7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19fSBsZWdlbmQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGVnZW5kQm91bmQ6IGZ1bmN0aW9uKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgdG9wOiBkaW1lbnNpb25zLnRpdGxlLmhlaWdodCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBkaW1lbnNpb25zLnlBeGlzLndpZHRoICsgZGltZW5zaW9ucy5zZXJpZXMud2lkdGggKyBkaW1lbnNpb25zLnlyQXhpcy53aWR0aCArIHRoaXMuY2hhcnRMZWZ0UGFkZGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGF4ZXMgbGFiZWwgaW5mby5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmhhc0F4ZXMgd2hldGhlciBoYXMgYXhlcyBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXl9IHBhcmFtcy5vcHRpb25DaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gY29udmVydGVkRGF0YSBjb252ZXJ0ZWQgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge3t4QXhpczogYXJyYXksIHlBeGlzOiBhcnJheX19IGxhYmVsIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0xhYmVsSW5mbzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBjaGFydFR5cGUsIG1heFZhbHVlTGFiZWwsIHlMYWJlbHMsIHhMYWJlbHM7XG5cbiAgICAgICAgaWYgKCFwYXJhbXMuaGFzQXhlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydFR5cGUgPSBwYXJhbXMub3B0aW9uQ2hhcnRUeXBlcyAmJiBwYXJhbXMub3B0aW9uQ2hhcnRUeXBlc1swXSB8fCAnJztcblxuICAgICAgICAvLyB2YWx1ZSDspJEg6rCA7J6lIO2BsCDqsJLsnYQg7LaU7Lac7ZWY7JesIHZhbHVlIGxhYmVs66GcIOyngOyglSAobGFibGUg64SI67mEIOyytO2BrCDsi5wg7IKs7JqpKVxuICAgICAgICBtYXhWYWx1ZUxhYmVsID0gdGhpcy5fZ2V0VmFsdWVBeGlzTWF4TGFiZWwocGFyYW1zLmNvbnZlcnRlZERhdGEsIGNoYXJ0VHlwZSk7XG5cbiAgICAgICAgLy8g7IS466Gc7Ji17IWY7JeQIOuUsOudvOyEnCB47LaV6rO8IHnstpXsl5Ag7KCB7Jqp7ZWgIOugiOydtOu4lCDsoJXrs7Qg7KeA7KCVXG4gICAgICAgIGlmIChwYXJhbXMuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgeUxhYmVscyA9IFttYXhWYWx1ZUxhYmVsXTtcbiAgICAgICAgICAgIHhMYWJlbHMgPSBwYXJhbXMuY29udmVydGVkRGF0YS5sYWJlbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5TGFiZWxzID0gcGFyYW1zLmNvbnZlcnRlZERhdGEubGFiZWxzO1xuICAgICAgICAgICAgeExhYmVscyA9IFttYXhWYWx1ZUxhYmVsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4QXhpczogeExhYmVscyxcbiAgICAgICAgICAgIHlBeGlzOiB5TGFiZWxzXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgcm90YXRpb24gZGVncmVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFdpZHRoIGxpbWl0IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsV2lkdGggbGFiZWwgd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGNhbmRpZGF0ZXMgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByb3RhdGlvbiBkZWdyZWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kUm90YXRpb25EZWdyZWU6IGZ1bmN0aW9uKGxpbWl0V2lkdGgsIGxhYmVsV2lkdGgsIGxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIHZhciBmb3VuZERlZ3JlZSxcbiAgICAgICAgICAgIGhhbGZXaWR0aCA9IGxhYmVsV2lkdGggLyAyLFxuICAgICAgICAgICAgaGFsZkhlaWdodCA9IGxhYmVsSGVpZ2h0IC8gMjtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY2hhcnRDb25zdC5ERUdSRUVfQ0FORElEQVRFUywgZnVuY3Rpb24oZGVncmVlKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZVdpZHRoID0gKGNhbGN1bGF0b3IuY2FsY3VsYXRlQWRqYWNlbnQoZGVncmVlLCBoYWxmV2lkdGgpICsgY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChjaGFydENvbnN0LkFOR0xFXzkwIC0gZGVncmVlLCBoYWxmSGVpZ2h0KSkgKiAyO1xuICAgICAgICAgICAgZm91bmREZWdyZWUgPSBkZWdyZWU7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVdpZHRoIDw9IGxpbWl0V2lkdGggKyBjaGFydENvbnN0LlhBWElTX0xBQkVMX0NPTVBBUkVfTUFSR0lOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm91bmREZWdyZWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugcm90YXRpb24gaW5mbyBhYm91dCBob3Jpem9udGFsIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNXaWR0aCBzZXJpZXMgYXJlYSB3aWR0aFxuICAgICAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGxhYmVscyBheGlzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBheGlzIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMgez9vYmplY3R9IHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbExhYmVsUm90YXRpb25JbmZvOiBmdW5jdGlvbihzZXJpZXNXaWR0aCwgbGFiZWxzLCB0aGVtZSkge1xuICAgICAgICB2YXIgbWF4TGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhXaWR0aChsYWJlbHMsIHRoZW1lKSxcbiAgICAgICAgICAgIGxpbWl0V2lkdGggPSBzZXJpZXNXaWR0aCAvIGxhYmVscy5sZW5ndGggLSBjaGFydENvbnN0LlhBWElTX0xBQkVMX0dVVFRFUixcbiAgICAgICAgICAgIGRlZ3JlZSwgbGFiZWxIZWlnaHQ7XG5cbiAgICAgICAgaWYgKG1heExhYmVsV2lkdGggPD0gbGltaXRXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhIZWlnaHQobGFiZWxzLCB0aGVtZSk7XG4gICAgICAgIGRlZ3JlZSA9IHRoaXMuX2ZpbmRSb3RhdGlvbkRlZ3JlZShsaW1pdFdpZHRoLCBtYXhMYWJlbFdpZHRoLCBsYWJlbEhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1heExhYmVsV2lkdGg6IG1heExhYmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbEhlaWdodDogbGFiZWxIZWlnaHQsXG4gICAgICAgICAgICBkZWdyZWU6IGRlZ3JlZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxjdWxhdGUgb3ZlcmZsb3cgcG9zaXRpb24gbGVmdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geUF4aXNXaWR0aCB5QXhpcyB3aWR0aFxuICAgICAqIEBwYXJhbSB7e2RlZ3JlZTogbnVtYmVyLCBsYWJlbEhlaWdodDogbnVtYmVyfX0gcm90YXRpb25JbmZvIHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlyc3RMYWJlbCBmaXJzdExhYmVsXG4gICAgICogQHBhcmFtIHtvYmVqY3R9IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gb3ZlcmZsb3cgcG9zaXRpb24gbGVmdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZU92ZXJmbG93TGVmdDogZnVuY3Rpb24oeUF4aXNXaWR0aCwgcm90YXRpb25JbmZvLCBmaXJzdExhYmVsLCB0aGVtZSkge1xuICAgICAgICB2YXIgZGVncmVlID0gcm90YXRpb25JbmZvLmRlZ3JlZSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcm90YXRpb25JbmZvLmxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgZmlyc3RMYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgoZmlyc3RMYWJlbCwgdGhlbWUpLFxuICAgICAgICAgICAgbmV3TGFiZWxXaWR0aCA9IChjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGRlZ3JlZSwgZmlyc3RMYWJlbFdpZHRoIC8gMikgKyBjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGNoYXJ0Q29uc3QuQU5HTEVfOTAgLSBkZWdyZWUsIGxhYmVsSGVpZ2h0IC8gMikpICogMixcbiAgICAgICAgICAgIGRpZmZMZWZ0ID0gbmV3TGFiZWxXaWR0aCAtIHlBeGlzV2lkdGg7XG4gICAgICAgIHJldHVybiBkaWZmTGVmdDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxjdWxhdGUgaGVpZ2h0IG9mIHhBeGlzLlxuICAgICAqIEBwYXJhbSB7e2RlZ3JlZTogbnVtYmVyLCBtYXhMYWJlbFdpZHRoOiBudW1iZXIsIGxhYmVsSGVpZ2h0OiBudW1iZXJ9fSByb3RhdGlvbkluZm8gcm90YXRpb24gaW5mb1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHhBeGlzIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVhBeGlzSGVpZ2h0OiBmdW5jdGlvbihyb3RhdGlvbkluZm8pIHtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IHJvdGF0aW9uSW5mby5kZWdyZWUsXG4gICAgICAgICAgICBtYXhMYWJlbFdpZHRoID0gcm90YXRpb25JbmZvLm1heExhYmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJvdGF0aW9uSW5mby5sYWJlbEhlaWdodCxcbiAgICAgICAgICAgIGF4aXNIZWlnaHQgPSAoY2FsY3VsYXRvci5jYWxjdWxhdGVPcHBvc2l0ZShkZWdyZWUsIG1heExhYmVsV2lkdGggLyAyKSArIGNhbGN1bGF0b3IuY2FsY3VsYXRlT3Bwb3NpdGUoY2hhcnRDb25zdC5BTkdMRV85MCAtIGRlZ3JlZSwgbGFiZWxIZWlnaHQgLyAyKSkgKiAyO1xuICAgICAgICByZXR1cm4gYXhpc0hlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsY3VsYXRlIGhlaWdodCBkaWZmZXJlbmNlIGJldHdlZW4gb3JpZ2luIGxhYmVsIGFuZCByb3RhdGlvbiBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlciwgbWF4TGFiZWxXaWR0aDogbnVtYmVyLCBsYWJlbEhlaWdodDogbnVtYmVyfX0gcm90YXRpb25JbmZvIHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHQgZGlmZmVyZW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUhlaWdodERpZmZlcmVuY2U6IGZ1bmN0aW9uKHJvdGF0aW9uSW5mbykge1xuICAgICAgICB2YXIgeEF4aXNIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVYQXhpc0hlaWdodChyb3RhdGlvbkluZm8pO1xuICAgICAgICByZXR1cm4geEF4aXNIZWlnaHQgLSByb3RhdGlvbkluZm8ubGFiZWxIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkZWdyZWUgb2Ygcm90YXRpb25JbmZvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNXaWR0aCBzZXJpZXMgd2lkdGhcbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlciwgbWF4TGFiZWxXaWR0aDogbnVtYmVyLCBsYWJlbEhlaWdodDogbnVtYmVyfX0gcm90YXRpb25JbmZvIHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxMZW5ndGggbGFiZWxMZW5ndGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ZlcmZsb3dMZWZ0IG92ZXJmbG93IGxlZnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEZWdyZWU6IGZ1bmN0aW9uKHNlcmllc1dpZHRoLCByb3RhdGlvbkluZm8sIGxhYmVsTGVuZ3RoLCBvdmVyZmxvd0xlZnQpIHtcbiAgICAgICAgdmFyIGxpbWl0V2lkdGgsIG5ld0RlZ3JlZTtcbiAgICAgICAgaWYgKG92ZXJmbG93TGVmdCA+IDApIHtcbiAgICAgICAgICAgIGxpbWl0V2lkdGggPSBzZXJpZXNXaWR0aCAvIGxhYmVsTGVuZ3RoICsgY2hhcnRDb25zdC5YQVhJU19MQUJFTF9HVVRURVI7XG4gICAgICAgICAgICBuZXdEZWdyZWUgPSB0aGlzLl9maW5kUm90YXRpb25EZWdyZWUobGltaXRXaWR0aCwgcm90YXRpb25JbmZvLm1heExhYmVsV2lkdGgsIHJvdGF0aW9uSW5mby5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgICByb3RhdGlvbkluZm8uZGVncmVlID0gbmV3RGVncmVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB3aWR0aCBvZiBkaW1lbnRpb3MuXG4gICAgICogQHBhcmFtIHt7cGxvdDoge3dpZHRoOiBudW1iZXJ9LCBzZXJpZXM6IHt3aWR0aDogbnVtYmVyfSwgeEF4aXM6IHt3aWR0aDogbnVtYmVyfX19IGRpbWVuc2lvbnMgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdmVyZmxvd0xlZnQgb3ZlcmZsb3cgbGVmdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZURpbWVuc2lvbnNXaWR0aDogZnVuY3Rpb24oZGltZW5zaW9ucywgb3ZlcmZsb3dMZWZ0KSB7XG4gICAgICAgIGlmIChvdmVyZmxvd0xlZnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJ0TGVmdFBhZGRpbmcgKz0gb3ZlcmZsb3dMZWZ0O1xuICAgICAgICAgICAgZGltZW5zaW9ucy5wbG90LndpZHRoIC09IG92ZXJmbG93TGVmdDtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuc2VyaWVzLndpZHRoIC09IG92ZXJmbG93TGVmdDtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMueEF4aXMud2lkdGggLT0gb3ZlcmZsb3dMZWZ0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBoZWlnaHQgb2YgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge3twbG90OiB7aGVpZ2h0OiBudW1iZXJ9LCBzZXJpZXM6IHtoZWlnaHQ6IG51bWJlcn0sIHhBeGlzOiB7aGVpZ2h0OiBudW1iZXJ9fX0gZGltZW5zaW9ucyBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZmZIZWlnaHQgZGlmZiBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zSGVpZ2h0OiBmdW5jdGlvbihkaW1lbnNpb25zLCBkaWZmSGVpZ2h0KSB7XG4gICAgICAgIGRpbWVuc2lvbnMucGxvdC5oZWlnaHQgLT0gZGlmZkhlaWdodDtcbiAgICAgICAgZGltZW5zaW9ucy5zZXJpZXMuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIGRpbWVuc2lvbnMueEF4aXMuaGVpZ2h0ICs9IGRpZmZIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkaW1lbnNpb25zIGFuZCBkZWdyZWUuXG4gICAgICogQHBhcmFtIHt7cGxvdDoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgc2VyaWVzOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCB4QXhpczoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX19IGRpbWVuc2lvbnMgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7e2RlZ3JlZTogbnVtYmVyLCBtYXhMYWJlbFdpZHRoOiBudW1iZXIsIGxhYmVsSGVpZ2h0OiBudW1iZXJ9fSByb3RhdGlvbkluZm8gcm90YXRpb24gaW5mb1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IGxhYmVscyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zQW5kRGVncmVlOiBmdW5jdGlvbihkaW1lbnNpb25zLCByb3RhdGlvbkluZm8sIGxhYmVscywgdGhlbWUpIHtcbiAgICAgICAgdmFyIG92ZXJmbG93TGVmdCwgZGlmZkhlaWdodDtcbiAgICAgICAgaWYgKCFyb3RhdGlvbkluZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdmVyZmxvd0xlZnQgPSB0aGlzLl9jYWxjdWxhdGVPdmVyZmxvd0xlZnQoZGltZW5zaW9ucy55QXhpcy53aWR0aCwgcm90YXRpb25JbmZvLCBsYWJlbHNbMF0sIHRoZW1lKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uc1dpZHRoKGRpbWVuc2lvbnMsIG92ZXJmbG93TGVmdCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURlZ3JlZShkaW1lbnNpb25zLnNlcmllcy53aWR0aCwgcm90YXRpb25JbmZvLCBsYWJlbHMubGVuZ3RoLCBvdmVyZmxvd0xlZnQpO1xuICAgICAgICBkaWZmSGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlSGVpZ2h0RGlmZmVyZW5jZShyb3RhdGlvbkluZm8pO1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zSGVpZ2h0KGRpbWVuc2lvbnMsIGRpZmZIZWlnaHQpO1xuICAgIH0sXG5cbiAgICBfbWFrZUN1c3RvbUV2ZW50Qm91bmQ6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBib3VuZC5kaW1lbnNpb24sXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGJvdW5kLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGRpbWVuc2lvbi53aWR0aCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFICogMixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGRpbWVuc2lvbi5oZWlnaHQgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBib3VuZHMgYWJvdXQgY2hhcnQgY29tcG9uZW50cy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmNvbnZlcnRlZERhdGEgY29udmVydGVkIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5oYXNBeGVzIHdoZXRoZXIgaGFzIGF4ZXMgYXJlYSBvciBub3RcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXl9IHBhcmFtcy5vcHRpb25DaGFydFR5cGVzIHkgYXhpcyBvcHRpb24gY2hhcnQgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgcGxvdDoge1xuICAgICAqICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgIHBvc2l0aW9uOiB7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9XG4gICAgICogICB9LFxuICAgICAqICAgeUF4aXM6IHtcbiAgICAgKiAgICAgZGltZW5zaW9uOiB7d2lkdGg6IChudW1iZXIpLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgIHBvc2l0aW9uOiB7dG9wOiBudW1iZXJ9XG4gICAgICogICB9LFxuICAgICAqICAgeEF4aXM6IHtcbiAgICAgKiAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiAobnVtYmVyKX0sXG4gICAgICogICAgIHBvc2l0aW9uOiB7cmlnaHQ6IG51bWJlcn1cbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyfVxuICAgICAqICAgfSxcbiAgICAgKiAgIGxlZ2VuZDoge1xuICAgICAqICAgICBwb3NpdGlvbjoge3RvcDogbnVtYmVyfVxuICAgICAqICAgfSxcbiAgICAgKiAgIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9XG4gICAgICogICB9XG4gICAgICogfX0gYm91bmRzXG4gICAgICovXG4gICAgbWFrZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBheGVzTGFiZWxJbmZvID0gdGhpcy5fbWFrZUF4ZXNMYWJlbEluZm8ocGFyYW1zKSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB0aGlzLl9nZXRDb21wb25lbnRzRGltZW5zaW9ucyh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGF4ZXNMYWJlbEluZm86IGF4ZXNMYWJlbEluZm9cbiAgICAgICAgICAgIH0sIHBhcmFtcykpLFxuICAgICAgICAgICAgcm90YXRpb25JbmZvLCB0b3AsIGxlZnQsIHNlcmllc0JvdW5kLCBheGVzQm91bmRzLCBib3VuZHM7XG5cbiAgICAgICAgdGhpcy5jaGFydExlZnRQYWRkaW5nID0gY2hhcnRDb25zdC5DSEFSVF9QQURESU5HO1xuICAgICAgICBpZiAocGFyYW1zLmhhc0F4ZXMpIHtcbiAgICAgICAgICAgIHJvdGF0aW9uSW5mbyA9IHRoaXMuX21ha2VIb3Jpem9udGFsTGFiZWxSb3RhdGlvbkluZm8oZGltZW5zaW9ucy5zZXJpZXMud2lkdGgsIGF4ZXNMYWJlbEluZm8ueEF4aXMsIHBhcmFtcy50aGVtZS5sYWJlbCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zQW5kRGVncmVlKGRpbWVuc2lvbnMsIHJvdGF0aW9uSW5mbywgYXhlc0xhYmVsSW5mby54QXhpcywgcGFyYW1zLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcCA9IGRpbWVuc2lvbnMudGl0bGUuaGVpZ2h0ICsgY2hhcnRDb25zdC5DSEFSVF9QQURESU5HO1xuICAgICAgICBsZWZ0ID0gZGltZW5zaW9ucy55QXhpcy53aWR0aCArIHRoaXMuY2hhcnRMZWZ0UGFkZGluZztcbiAgICAgICAgc2VyaWVzQm91bmQgPSB0aGlzLl9tYWtlQmFzaWNCb3VuZChkaW1lbnNpb25zLnNlcmllcywgdG9wLCBsZWZ0KTtcblxuICAgICAgICBheGVzQm91bmRzID0gdGhpcy5fbWFrZUF4ZXNCb3VuZHMoe1xuICAgICAgICAgICAgaGFzQXhlczogcGFyYW1zLmhhc0F4ZXMsXG4gICAgICAgICAgICByb3RhdGlvbkluZm86IHJvdGF0aW9uSW5mbyxcbiAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXM6IHBhcmFtcy5vcHRpb25DaGFydFR5cGVzLFxuICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICB9KTtcblxuICAgICAgICBib3VuZHMgPSB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgY2hhcnQ6IHRoaXMuX21ha2VDaGFydEJvdW5kKGRpbWVuc2lvbnMuY2hhcnQpLFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNCb3VuZCxcbiAgICAgICAgICAgIGxlZ2VuZDogdGhpcy5fbWFrZUxlZ2VuZEJvdW5kKGRpbWVuc2lvbnMpLFxuICAgICAgICAgICAgdG9vbHRpcDogdGhpcy5fbWFrZUJhc2ljQm91bmQoZGltZW5zaW9ucy5zZXJpZXMsIHRvcCwgbGVmdCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFKSxcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50OiBzZXJpZXNCb3VuZFxuICAgICAgICB9LCBheGVzQm91bmRzKTtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJvdW5kc01ha2VyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGNhbGN1bGF0b3IuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuLyoqXG4gKiBDYWxjdWxhdG9yLlxuICogQG1vZHVsZSBjYWxjdWxhdG9yXG4gKi9cbnZhciBjYWxjdWxhdG9yID0ge1xuICAgIC8qKlxuICAgICAqIFRvIGNhbGN1bGF0ZSBzY2FsZSBmcm9tIGNoYXJ0IG1pbiwgbWF4IGRhdGEuXG4gICAgICogIC0gaHR0cDovL3BlbHRpZXJ0ZWNoLmNvbS9ob3ctZXhjZWwtY2FsY3VsYXRlcy1hdXRvbWF0aWMtY2hhcnQtYXhpcy1saW1pdHMvXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjYWxjdWxhdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW4gbWluaW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IG1heCBtYXhpbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gc2NhbGUgYXhpcyBzY2FsZVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVNjYWxlOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgICB2YXIgc2F2ZU1pbiA9IDAsXG4gICAgICAgICAgICBzY2FsZSA9IHt9LFxuICAgICAgICAgICAgaW9kVmFsdWU7IC8vIGluY3JlYXNlIG9yIGRlY3JlYXNlIHZhbHVlO1xuXG4gICAgICAgIGlmIChtaW4gPCAwKSB7XG4gICAgICAgICAgICBzYXZlTWluID0gbWluO1xuICAgICAgICAgICAgbWF4IC09IG1pbjtcbiAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpb2RWYWx1ZSA9IChtYXggLSBtaW4pIC8gMjA7XG4gICAgICAgIHNjYWxlLm1heCA9IG1heCArIGlvZFZhbHVlICsgc2F2ZU1pbjtcblxuICAgICAgICBpZiAobWF4IC8gNiA+IG1pbikge1xuICAgICAgICAgICAgc2NhbGUubWluID0gMCArIHNhdmVNaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZS5taW4gPSBtaW4gLSBpb2RWYWx1ZSArIHNhdmVNaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBub3JtYWxpemUgbnVtYmVyLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Y2FsY3VsYXRvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBub3JtYWxpemVkIG51bWJlclxuICAgICAqL1xuICAgIG5vcm1hbGl6ZUF4aXNOdW1iZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzdGFuZGFyZCA9IDAsXG4gICAgICAgICAgICBmbGFnID0gMSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQsIG1vZDtcblxuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIGZsYWcgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICo9IGZsYWc7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0Q29uc3QuQVhJU19TVEFOREFSRF9NVUxUSVBMRV9OVU1TLCBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IG51bSkge1xuICAgICAgICAgICAgICAgIGlmIChudW0gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkID0gbnVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZCA9IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhbmRhcmQgPCAxKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVBeGlzTnVtYmVyKHZhbHVlICogMTApICogMC4xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kID0gdHVpLnV0aWwubW9kKHZhbHVlLCBzdGFuZGFyZCk7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdHVpLnV0aWwuYWRkaXRpb24odmFsdWUsIChtb2QgPiAwID8gc3RhbmRhcmQgLSBtb2QgOiAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZCAqPSBmbGFnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHRpY2sgcG9zaXRpb25zIG9mIHBpeGVsIHR5cGUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjYWxjdWxhdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgYXJlYSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHthcnJheS48bnVtYmVyPn0gcG9zaXRpb25zXG4gICAgICovXG4gICAgbWFrZVRpY2tQaXhlbFBvc2l0aW9uczogZnVuY3Rpb24oc2l6ZSwgY291bnQpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdLFxuICAgICAgICAgICAgcHhTY2FsZSwgcHhTdGVwO1xuXG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgIHB4U2NhbGUgPSB7bWluOiAwLCBtYXg6IHNpemUgLSAxfTtcbiAgICAgICAgICAgIHB4U3RlcCA9IHRoaXMuZ2V0U2NhbGVTdGVwKHB4U2NhbGUsIGNvdW50KTtcbiAgICAgICAgICAgIHBvc2l0aW9ucyA9IHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgwLCBzaXplLCBweFN0ZXApLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSA9IHNpemUgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgbGFiZWxzIGZyb20gc2NhbGUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjYWxjdWxhdG9yXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gc2NhbGUgYXhpcyBzY2FsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHN0ZXAgYmV0d2VlbiBtYXggYW5kIG1pblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gbGFiZWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYWtlTGFiZWxzRnJvbVNjYWxlOiBmdW5jdGlvbihzY2FsZSwgc3RlcCkge1xuICAgICAgICB2YXIgbXVsdGlwbGVOdW0gPSB0dWkudXRpbC5maW5kTXVsdGlwbGVOdW0oc3RlcCksXG4gICAgICAgICAgICBtaW4gPSBzY2FsZS5taW4gKiBtdWx0aXBsZU51bSxcbiAgICAgICAgICAgIG1heCA9IHNjYWxlLm1heCAqIG11bHRpcGxlTnVtLFxuICAgICAgICAgICAgbGFiZWxzID0gdHVpLnV0aWwucmFuZ2UobWluLCBtYXggKyAxLCBzdGVwICogbXVsdGlwbGVOdW0pO1xuICAgICAgICBsYWJlbHMgPSB0dWkudXRpbC5tYXAobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsIC8gbXVsdGlwbGVOdW07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2NhbGUgc3RlcC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBzY2FsZSBheGlzIHNjYWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IHZhbHVlIGNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn0gc2NhbGUgc3RlcFxuICAgICAqL1xuICAgIGdldFNjYWxlU3RlcDogZnVuY3Rpb24oc2NhbGUsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiAoc2NhbGUubWF4IC0gc2NhbGUubWluKSAvIChjb3VudCAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxjdWxhdGUgYWRqYWNlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZSBkZWdyZWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaHlwb3RlbnVzZSBoeXBvdGVudXNlXG4gICAgICogQHJldHVybnMge251bWJlcn0gYWRqYWNlbnRcbiAgICAgKlxuICAgICAqICAgSCA6IEh5cG90ZW51c2VcbiAgICAgKiAgIEEgOiBBZGphY2VudFxuICAgICAqICAgTyA6IE9wcG9zaXRlXG4gICAgICogICBEIDogRGVncmVlXG4gICAgICpcbiAgICAgKiAgICAgICAgL3xcbiAgICAgKiAgICAgICAvIHxcbiAgICAgKiAgICBIIC8gIHwgT1xuICAgICAqICAgICAvICAgfFxuICAgICAqICAgIC9cXCBEIHxcbiAgICAgKiAgICAtLS0tLVxuICAgICAqICAgICAgIEFcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVBZGphY2VudDogZnVuY3Rpb24oZGVncmVlLCBoeXBvdGVudXNlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNvcyhkZWdyZWUgKiBjaGFydENvbnN0LlJBRCkgKiBoeXBvdGVudXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxjdWxhdGUgb3Bwb3NpdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZSBkZWdyZWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaHlwb3RlbnVzZSBoeXBvdGVudXNlXG4gICAgICogQHJldHVybnMge251bWJlcn0gb3Bwb3NpdGVcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVPcHBvc2l0ZTogZnVuY3Rpb24oZGVncmVlLCBoeXBvdGVudXNlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbihkZWdyZWUgKiBjaGFydENvbnN0LlJBRCkgKiBoeXBvdGVudXNlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2FsY3VsYXRvcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBEYXRhIGNvbnZlcnRlci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG5cbi8qKlxuICogRGF0YSBjb252ZXJ0ZXIuXG4gKiBAbW9kdWxlIGRhdGFDb252ZXJ0ZXJcbiAqL1xudmFyIGRhdGFDb252ZXJ0ZXIgPSB7XG4gICAgLyoqXG4gICAgICogQ29udmVydCB1c2VyIGRhdGEuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkYXRhQ29udmVydGVyXG4gICAgICogQHBhcmFtIHthcnJheS48YXJyYXk+fSB1c2VyRGF0YSB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRPcHRpb25zIGNoYXJ0IG9wdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IHNlcmllc0NoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgbGFiZWxzOiBhcnJheS48c3RyaW5nPixcbiAgICAgKiAgICAgIHZhbHVlczogYXJyYXkuPG51bWJlcj4sXG4gICAgICogICAgICBsZWdlbmRMYWJlbHM6IGFycmF5LjxzdHJpbmc+LFxuICAgICAqICAgICAgZm9ybWF0RnVuY3Rpb25zOiBhcnJheS48ZnVuY3Rpb24+LFxuICAgICAqICAgICAgZm9ybWF0dGVkVmFsdWVzOiBhcnJheS48c3RyaW5nPlxuICAgICAqIH19IGNvbnZlcnRlZCBkYXRhXG4gICAgICovXG4gICAgY29udmVydDogZnVuY3Rpb24odXNlckRhdGEsIGNoYXJ0T3B0aW9ucywgY2hhcnRUeXBlLCBzZXJpZXNDaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciBsYWJlbHMgPSB1c2VyRGF0YS5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgc2VyaWVzRGF0YSA9IHVzZXJEYXRhLnNlcmllcyxcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX3BpY2tWYWx1ZXMoc2VyaWVzRGF0YSksXG4gICAgICAgICAgICBqb2luVmFsdWVzID0gdGhpcy5fam9pblZhbHVlcyh2YWx1ZXMsIHNlcmllc0NoYXJ0VHlwZXMpLFxuICAgICAgICAgICAgbGVnZW5kTGFiZWxzID0gdGhpcy5fcGlja0xlZ2VuZExhYmVscyhzZXJpZXNEYXRhKSxcbiAgICAgICAgICAgIGpvaW5MZWdlbmRMYWJlbHMgPSB0aGlzLl9qb2luTGVnZW5kTGFiZWxzKGxlZ2VuZExhYmVscywgY2hhcnRUeXBlLCBzZXJpZXNDaGFydFR5cGVzKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNoYXJ0T3B0aW9ucyAmJiBjaGFydE9wdGlvbnMuZm9ybWF0IHx8ICcnLFxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gdGhpcy5fZmluZEZvcm1hdEZ1bmN0aW9ucyhmb3JtYXQpLFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVzID0gZm9ybWF0ID8gdGhpcy5fZm9ybWF0VmFsdWVzKHZhbHVlcywgZm9ybWF0RnVuY3Rpb25zKSA6IHZhbHVlcyxcbiAgICAgICAgICAgIGpvaW5Gb3JtYXR0ZWRWYWx1ZXMgPSB0aGlzLl9qb2luVmFsdWVzKGZvcm1hdHRlZFZhbHVlcywgc2VyaWVzQ2hhcnRUeXBlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgICAgam9pblZhbHVlczogam9pblZhbHVlcyxcbiAgICAgICAgICAgIGxlZ2VuZExhYmVsczogbGVnZW5kTGFiZWxzLFxuICAgICAgICAgICAgam9pbkxlZ2VuZExhYmVsczogam9pbkxlZ2VuZExhYmVscyxcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uczogZm9ybWF0RnVuY3Rpb25zLFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVzOiBmb3JtYXR0ZWRWYWx1ZXMsXG4gICAgICAgICAgICBqb2luRm9ybWF0dGVkVmFsdWVzOiBqb2luRm9ybWF0dGVkVmFsdWVzXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlcGFyYXRlIGxhYmVsLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YUNvbnZlcnRlclxuICAgICAqIEBwYXJhbSB7YXJyYXkuPGFycmF5LjxhcnJheT4+fSB1c2VyRGF0YSB1c2VyIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7e2xhYmVsczogKGFycmF5LjxzdHJpbmc+KSwgc291cmNlRGF0YTogYXJyYXkuPGFycmF5LjxhcnJheT4+fX0gcmVzdWx0IGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXBhcmF0ZUxhYmVsOiBmdW5jdGlvbih1c2VyRGF0YSkge1xuICAgICAgICB2YXIgbGFiZWxzID0gdXNlckRhdGFbMF0ucG9wKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgICAgIHNvdXJjZURhdGE6IHVzZXJEYXRhXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgdmFsdWUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkYXRhQ29udmVydGVyXG4gICAgICogQHBhcmFtIHt7bmFtZTogc3RyaW5nLCBkYXRhOiAoYXJyYXkuPG51bWJlcj4gfCBudW1iZXIpfX0gaXRlbXMgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IHBpY2tlZCB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BpY2tWYWx1ZTogZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChbXS5jb25jYXQoaXRlbXMuZGF0YSksIHBhcnNlRmxvYXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIHZhbHVlcyBmcm9tIGF4aXMgZGF0YS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRhdGFDb252ZXJ0ZXJcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxhcnJheT59IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IHZhbHVlc1xuICAgICAqL1xuICAgIF9waWNrVmFsdWVzOiBmdW5jdGlvbihzZXJpZXNEYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZXMsIHJlc3VsdDtcbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkoc2VyaWVzRGF0YSkpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHR1aS51dGlsLm1hcChzZXJpZXNEYXRhLCB0aGlzLl9waWNrVmFsdWUsIHRoaXMpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdHVpLnV0aWwucGl2b3QodmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNEYXRhLCBmdW5jdGlvbihncm91cFZhbHVlcywgdHlwZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHR1aS51dGlsLm1hcChncm91cFZhbHVlcywgdGhpcy5fcGlja1ZhbHVlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbdHlwZV0gPSB0dWkudXRpbC5waXZvdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSm9pbiB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkYXRhQ29udmVydGVyXG4gICAgICogQHBhcmFtIHthcnJheS48YXJyYXk+fSBncm91cFZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxzdHJpbmc+fSBzZXJpZXNDaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHJldHVybnMge2FycmF5LjxudW1iZXI+fSBqb2luIHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2pvaW5WYWx1ZXM6IGZ1bmN0aW9uKGdyb3VwVmFsdWVzLCBzZXJpZXNDaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciBqb2luVmFsdWVzO1xuXG4gICAgICAgIGlmICghc2VyaWVzQ2hhcnRUeXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwVmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgam9pblZhbHVlcyA9IHR1aS51dGlsLm1hcChncm91cFZhbHVlcywgZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBqb2luVmFsdWVzID0gW107XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNDaGFydFR5cGVzLCBmdW5jdGlvbihfY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGdyb3VwVmFsdWVzW19jaGFydFR5cGVdLCBmdW5jdGlvbih2YWx1ZXMsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luVmFsdWVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBqb2luVmFsdWVzW2luZGV4XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqb2luVmFsdWVzW2luZGV4XSA9IGpvaW5WYWx1ZXNbaW5kZXhdLmNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBqb2luVmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGxlZ2VuZCBsYWJlbC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRhdGFDb252ZXJ0ZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBpdGVtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9waWNrTGVnZW5kTGFiZWw6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBsZWdlbmQgbGFiZWxzIGZyb20gYXhpcyBkYXRhLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YUNvbnZlcnRlclxuICAgICAqIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gbGFiZWxzXG4gICAgICovXG4gICAgX3BpY2tMZWdlbmRMYWJlbHM6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkoc2VyaWVzRGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHR1aS51dGlsLm1hcChzZXJpZXNEYXRhLCB0aGlzLl9waWNrTGVnZW5kTGFiZWwsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc0RhdGEsIGZ1bmN0aW9uKGdyb3VwVmFsdWVzLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCB0aGlzLl9waWNrTGVnZW5kTGFiZWwsIHRoaXMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSm9pbiBsZWdlbmQgbGFiZWxzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YUNvbnZlcnRlclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGxlZ2VuZExhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gc2VyaWVzQ2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHthcnJheX0gbGFiZWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfam9pbkxlZ2VuZExhYmVsczogZnVuY3Rpb24obGVnZW5kTGFiZWxzLCBjaGFydFR5cGUsIHNlcmllc0NoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIGpvaW5MYWJlbHM7XG4gICAgICAgIGlmICghc2VyaWVzQ2hhcnRUeXBlcyB8fCAhc2VyaWVzQ2hhcnRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGpvaW5MYWJlbHMgPSB0dWkudXRpbC5tYXAobGVnZW5kTGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqb2luTGFiZWxzID0gW107XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoc2VyaWVzQ2hhcnRUeXBlcywgZnVuY3Rpb24oX2NoYXJ0VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbHMgPSB0dWkudXRpbC5tYXAobGVnZW5kTGFiZWxzW19jaGFydFR5cGVdLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBfY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgam9pbkxhYmVscyA9IGpvaW5MYWJlbHMuY29uY2F0KGxhYmVscyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gam9pbkxhYmVscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gZm9ybWF0IGdyb3VwIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRhdGFDb252ZXJ0ZXJcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxhcnJheT59IGdyb3VwVmFsdWVzIGdyb3VwIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gZm9ybWF0RnVuY3Rpb25zIGZvcm1hdCBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGZvcm1hdHRlZCB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXRHcm91cFZhbHVlczogZnVuY3Rpb24oZ3JvdXBWYWx1ZXMsIGZvcm1hdEZ1bmN0aW9ucykge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBmbnMgPSBbdmFsdWVdLmNvbmNhdChmb3JtYXRGdW5jdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5yZWR1Y2UoZm5zLCBmdW5jdGlvbihzdG9yZWQsIGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihzdG9yZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBmb3JtYXQgY29udmVydGVkIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRhdGFDb252ZXJ0ZXJcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxhcnJheT59IGNoYXJ0VmFsdWVzIGNoYXJ0IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gZm9ybWF0RnVuY3Rpb25zIGZvcm1hdCBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGZvcm1hdHRlZCB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXRWYWx1ZXM6IGZ1bmN0aW9uKGNoYXJ0VmFsdWVzLCBmb3JtYXRGdW5jdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkoY2hhcnRWYWx1ZXMpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9mb3JtYXRHcm91cFZhbHVlcyhjaGFydFZhbHVlcywgZm9ybWF0RnVuY3Rpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChjaGFydFZhbHVlcywgZnVuY3Rpb24oZ3JvdXBWYWx1ZXMsIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjaGFydFR5cGVdID0gdGhpcy5fZm9ybWF0R3JvdXBWYWx1ZXMoZ3JvdXBWYWx1ZXMsIGZvcm1hdEZ1bmN0aW9ucyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIG1heCBsZW5ndGggdW5kZXIgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkYXRhQ29udmVydGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdmFsdWVzIGNoYXJ0IHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG1heCBsZW5ndGggdW5kZXIgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9waWNrTWF4TGVuVW5kZXJQb2ludDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciBtYXggPSAwO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdHVpLnV0aWwubGVuZ3RoQWZ0ZXJQb2ludCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobGVuID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHplcm8gZmlsbCBmb3JtYXQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YUNvbnZlcnRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgZm9ybWF0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNaZXJvRmlsbDogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQubGVuZ3RoID4gMiAmJiBmb3JtYXQuY2hhckF0KDApID09PSAnMCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZGVjaW1hbCBmb3JtYXQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YUNvbnZlcnRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgZm9ybWF0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNEZWNpbWFsOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGluZGV4T2YgPSBmb3JtYXQuaW5kZXhPZignLicpO1xuICAgICAgICByZXR1cm4gaW5kZXhPZiA+IC0xICYmIGluZGV4T2YgPCBmb3JtYXQubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjb21tYSBmb3JtYXQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YUNvbnZlcnRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgZm9ybWF0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNDb21tYTogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQuaW5kZXhPZignLCcpID09PSBmb3JtYXQuc3BsaXQoJy4nKVswXS5sZW5ndGggLSA0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgemVybyBmaWxsLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGF0YUNvbnZlcnRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gbGVuZ3RoIG9mIHJlc3VsdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXRaZXJvRmlsbDogZnVuY3Rpb24obGVuLCB2YWx1ZSkge1xuICAgICAgICB2YXIgemVybyA9ICcwJyxcbiAgICAgICAgICAgIGlzTWludXMgPSB2YWx1ZSA8IDA7XG5cbiAgICAgICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSkgKyAnJztcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IGxlbikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgdmFsdWUgPSB6ZXJvICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGlzTWludXMgPyAnLScgOiAnJykgKyB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IERlY2ltYWwuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkYXRhQ29udmVydGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbiBsZW5ndGggb2YgdW5kZXIgZGVjaW1hbCBwb2ludFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXREZWNpbWFsOiBmdW5jdGlvbihsZW4sIHZhbHVlKSB7XG4gICAgICAgIHZhciBwb3c7XG5cbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvdyA9IE1hdGgucG93KDEwLCBsZW4pO1xuICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiBwb3cpIC8gcG93O1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpLnRvRml4ZWQobGVuKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgQ29tbWEuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkYXRhQ29udmVydGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRhcmdldCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Zvcm1hdENvbW1hOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgY29tbWEgPSAnLCcsXG4gICAgICAgICAgICB1bmRlclBvaW50VmFsdWUgPSAnJyxcbiAgICAgICAgICAgIHZhbHVlcywgbGFzdEluZGV4O1xuXG4gICAgICAgIHZhbHVlICs9ICcnO1xuXG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgdW5kZXJQb2ludFZhbHVlID0gJy4nICsgdmFsdWVzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIHVuZGVyUG9pbnRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlcyA9ICh2YWx1ZSkuc3BsaXQoJycpLnJldmVyc2UoKTtcbiAgICAgICAgbGFzdEluZGV4ID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhbHVlcyA9IHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKGNoYXIsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW2NoYXJdO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGFzdEluZGV4ICYmIChpbmRleCArIDEpICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIHZhbHVlcykucmV2ZXJzZSgpLmpvaW4oJycpICsgdW5kZXJQb2ludFZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGZvcm1hdCBmdW5jdGlvbnMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkYXRhQ29udmVydGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCBmb3JtYXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB2YWx1ZXMgY2hhcnQgdmFsdWVzXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uW119IGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIF9maW5kRm9ybWF0RnVuY3Rpb25zOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGZ1bmNzID0gW10sXG4gICAgICAgICAgICBsZW47XG5cbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc0RlY2ltYWwoZm9ybWF0KSkge1xuICAgICAgICAgICAgbGVuID0gdGhpcy5fcGlja01heExlblVuZGVyUG9pbnQoW2Zvcm1hdF0pO1xuICAgICAgICAgICAgZnVuY3MgPSBbdHVpLnV0aWwuYmluZCh0aGlzLl9mb3JtYXREZWNpbWFsLCB0aGlzLCBsZW4pXTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1plcm9GaWxsKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGxlbiA9IGZvcm1hdC5sZW5ndGg7XG4gICAgICAgICAgICBmdW5jcyA9IFt0dWkudXRpbC5iaW5kKHRoaXMuX2Zvcm1hdFplcm9GaWxsLCB0aGlzLCBsZW4pXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc0NvbW1hKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZ1bmNzLnB1c2godGhpcy5fZm9ybWF0Q29tbWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmNzO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGF0YUNvbnZlcnRlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBET00gSGFuZGxlci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBET00gSGFuZGxlci5cbiAqIEBtb2R1bGUgZG9tSGFuZGxlclxuICovXG52YXIgZG9tSGFuZGxlciA9IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZWxlbWVudC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRvbUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIGh0bWwgdGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0NsYXNzIGNsYXNzIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNyZWF0ZWQgZWxlbWVudFxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24odGFnLCBuZXdDbGFzcykge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgICAgICAgaWYgKG5ld0NsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZENsYXNzKGVsLCBuZXdDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjbGFzcyBuYW1lcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRvbUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHthcnJheX0gbmFtZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDbGFzc05hbWVzOiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZSAmJiB0dWkudXRpbC5pc1N0cmluZyhjbGFzc05hbWUpID8gY2xhc3NOYW1lLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjc3MgY2xhc3MgdG8gdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkb21IYW5kbGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2xhc3MgYWRkIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oZWwsIG5ld0NsYXNzKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5fZ2V0Q2xhc3NOYW1lcyhlbCksXG4gICAgICAgICAgICBpbmRleCA9IHR1aS51dGlsLmluQXJyYXkobmV3Q2xhc3MsIGNsYXNzTmFtZXMpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnB1c2gobmV3Q2xhc3MpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNzcyBjbGFzcyBmcm9tIHRhcmdldCBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJtQ2xhc3MgcmVtb3ZlIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIHJtQ2xhc3MpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLl9nZXRDbGFzc05hbWVzKGVsKSxcbiAgICAgICAgICAgIGluZGV4ID0gdHVpLnV0aWwuaW5BcnJheShybUNsYXNzLCBjbGFzc05hbWVzKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNsYXNzIGV4aXN0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRvbUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaW5kQ2xhc3MgdGFyZ2V0IGNzcyBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBoYXMgY2xhc3NcbiAgICAgKi9cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oZWwsIGZpbmRDbGFzcykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IHRoaXMuX2dldENsYXNzTmFtZXMoZWwpLFxuICAgICAgICAgICAgaW5kZXggPSB0dWkudXRpbC5pbkFycmF5KGZpbmRDbGFzcywgY2xhc3NOYW1lcyk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHBhcmVudCBieSBjbGFzcyBuYW1lLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0YXJnZXQgY3NzIGNsYXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhc3RDbGFzcyBsYXN0IGNzcyBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gcmVzdWx0IGVsZW1lbnRcbiAgICAgKi9cbiAgICBmaW5kUGFyZW50QnlDbGFzczogZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSwgbGFzdENsYXNzKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNDbGFzcyhwYXJlbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWScgfHwgdGhpcy5oYXNDbGFzcyhwYXJlbnQsIGxhc3RDbGFzcykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZFBhcmVudEJ5Q2xhc3MocGFyZW50LCBjbGFzc05hbWUsIGxhc3RDbGFzcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGNoaWxkIGVsZW1lbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkb21IYW5kbGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGRyZW4gY2hpbGQgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZDogZnVuY3Rpb24oY29udGFpbmVyLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IHR1aS51dGlsLmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUhhbmRsZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXZlbnQgbGlzdGVuZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXZlbnQgbGlzdGVuZXIuXG4gKiBAbW9kdWxlIGV2ZW50TGlzdGVuZXJcbiAqL1xudmFyIGV2ZW50TGlzdGVuZXIgPSB7XG4gICAgLyoqXG4gICAgICogRXZlbnQgbGlzdGVuZXIgZm9yIElFLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hFdmVudDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gXCJvYmplY3RcIiAmJiBjYWxsYmFjay5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suaGFuZGxlRXZlbnQuY2FsbChjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGxpc3RlbmVyIGZvciBvdGhlciBicm93c2Vycy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwib2JqZWN0XCIgJiYgY2FsbGJhY2suaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmhhbmRsZUV2ZW50LmNhbGwoY2FsbGJhY2ssIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQmluZCBldmVudCBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYmluZEV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGJpbmRFdmVudDtcbiAgICAgICAgaWYgKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIGVsKSB7XG4gICAgICAgICAgICBiaW5kRXZlbnQgPSB0aGlzLl9hZGRFdmVudExpc3RlbmVyO1xuICAgICAgICB9IGVsc2UgaWYgKFwiYXR0YWNoRXZlbnRcIiBpbiBlbCkge1xuICAgICAgICAgICAgYmluZEV2ZW50ID0gdGhpcy5fYXR0YWNoRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kRXZlbnQgPSBiaW5kRXZlbnQ7XG4gICAgICAgIGJpbmRFdmVudChldmVudE5hbWUsIGVsLCBjYWxsYmFjayk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBldmVudExpc3RlbmVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFByZWRpY2F0ZS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG4vKipcbiAqIHByZWRpY2F0ZS5cbiAqIEBtb2R1bGUgcHJlZGljYXRlXG4gKi9cbnZhciBwcmVkaWNhdGUgPSB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBiYXIgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNCYXJDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9CQVI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgbGluZSBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0xpbmVDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9MSU5FO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGxpbmUgdHlwZSBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0xpbmVUeXBlQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xpbmVDaGFydChjaGFydFR5cGUpIHx8IGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0FSRUE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcGllIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzUGllQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2hhcnRUeXBlID09PSBjaGFydENvbnN0LkNIQVJUX1RZUEVfUElFO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG91dGVyIGxlZ2VuZCBhbGlnbiBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gbGVnZW5kIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc091dGVyTGVnZW5kQWxpZ246IGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgICAgIHJldHVybiBhbGlnbiA9PT0gY2hhcnRDb25zdC5MRUdFTkRfQUxJR05fT1VURVI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2VudGVyIGxlZ2VuZCBhbGlnbiBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gbGVnZW5kIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0NlbnRlckxlZ2VuZEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICByZXR1cm4gYWxpZ24gPT09IGNoYXJ0Q29uc3QuTEVHRU5EX1RZUEVfQ0VOVEVSO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGxlZ2VuZCBhbGlnbiBvZiBwaWUgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbiBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNQaWVMZWdlbmRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaXNPdXRlckxlZ2VuZEFsaWduKGFsaWduKSB8fCB0aGlzLmlzQ2VudGVyTGVnZW5kQWxpZ24oYWxpZ24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcmVkaWNhdGU7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbCBmb3IgcmVuZGVyaW5nLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tID0gcmVxdWlyZSgnLi9kb21IYW5kbGVyJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4vLi4vY29uc3QnKTtcblxudmFyIGJyb3dzZXIgPSB0dWkudXRpbC5icm93c2VyLFxuICAgIGlzT2xkQnJvd3NlciA9IGJyb3dzZXIubXNpZSAmJiBicm93c2VyLnZlcnNpb24gPD0gODtcblxuLyoqXG4gKiBVdGlsIGZvciByZW5kZXJpbmcuXG4gKiBAbW9kdWxlIHJlbmRlclV0aWxcbiAqL1xudmFyIHJlbmRlclV0aWwgPSB7XG4gICAgLyoqXG4gICAgICogQ29uY2F0IHN0cmluZy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW1zIHsuLi5zdHJpbmd9IHRhcmdldCBzdHJpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29uY2F0IHN0cmluZ1xuICAgICAqL1xuICAgIGNvbmNhdFN0cjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmNvbmNhdC5hcHBseSgnJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBjc3NUZXh0IGZvciBmb250LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGZvbnQgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0XG4gICAgICovXG4gICAgbWFrZUZvbnRDc3NUZXh0OiBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICB2YXIgY3NzVGV4dHMgPSBbXTtcblxuICAgICAgICBpZiAoIXRoZW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhlbWUuZm9udFNpemUpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2godGhpcy5jb25jYXRTdHIoJ2ZvbnQtc2l6ZTonLCB0aGVtZS5mb250U2l6ZSwgJ3B4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoZW1lLmZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2godGhpcy5jb25jYXRTdHIoJ2ZvbnQtZmFtaWx5OicsIHRoZW1lLmZvbnRGYW1pbHkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGVtZS5jb2xvcikge1xuICAgICAgICAgICAgY3NzVGV4dHMucHVzaCh0aGlzLmNvbmNhdFN0cignY29sb3I6JywgdGhlbWUuY29sb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjc3NUZXh0cy5qb2luKCc7Jyk7XG4gICAgfSxcblxuICAgIGNoZWNrRWw6IG51bGwsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVsZW1lbnQgZm9yIHNpemUgY2hlY2suXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlU2l6ZUNoZWNrRWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxEaXYsIGVsU3BhbjtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tFbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsRGl2ID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1zaXplLWNoZWNrLWVsZW1lbnQnKTtcbiAgICAgICAgZWxTcGFuID0gZG9tLmNyZWF0ZSgnU1BBTicpO1xuXG4gICAgICAgIGVsRGl2LmFwcGVuZENoaWxkKGVsU3Bhbik7XG4gICAgICAgIHRoaXMuY2hlY2tFbCA9IGVsRGl2O1xuICAgICAgICByZXR1cm4gZWxEaXY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZW5kZXJlZCBsYWJlbCBzaXplICh3aWR0aCBvciBoZWlnaHQpLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvZmZzZXRUeXBlIG9mZnNldCB0eXBlIChvZmZzZXRXaWR0aCBvciBvZmZzZXRIZWlnaHQpXG4gICAgICogQHJldHVybnMge251bWJlcn0gc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJlbmRlcmVkTGFiZWxTaXplOiBmdW5jdGlvbihsYWJlbCwgdGhlbWUsIG9mZnNldFR5cGUpIHtcbiAgICAgICAgdmFyIGVsRGl2LCBlbFNwYW4sIGxhYmVsU2l6ZTtcblxuICAgICAgICBpZiAodHVpLnV0aWwuaXNVbmRlZmluZWQobGFiZWwpIHx8IGxhYmVsID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBlbERpdiA9IHRoaXMuX2NyZWF0ZVNpemVDaGVja0VsKCk7XG4gICAgICAgIGVsU3BhbiA9IGVsRGl2LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgdGhlbWUgPSB0aGVtZSB8fCB7fTtcbiAgICAgICAgZWxTcGFuLmlubmVySFRNTCA9IGxhYmVsO1xuICAgICAgICBlbFNwYW4uc3R5bGUuZm9udFNpemUgPSAodGhlbWUuZm9udFNpemUgfHwgY2hhcnRDb25zdC5ERUZBVUxUX0xBQkVMX0ZPTlRfU0laRSkgKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGVtZS5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICBlbFNwYW4uc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICAgICAgICBlbFNwYW4uc3R5bGUuZm9udEZhbWlseSA9IHRoZW1lLmZvbnRGYW1pbHk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsRGl2KTtcbiAgICAgICAgbGFiZWxTaXplID0gZWxTcGFuW29mZnNldFR5cGVdO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsRGl2KTtcbiAgICAgICAgcmV0dXJuIGxhYmVsU2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlbmRlcmVkIGxhYmVsIHdpZHRoLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gd2lkdGhcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsLCB0aGVtZSkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHRoaXMuX2dldFJlbmRlcmVkTGFiZWxTaXplKGxhYmVsLCB0aGVtZSwgJ29mZnNldFdpZHRoJyk7XG4gICAgICAgIHJldHVybiBsYWJlbFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVuZGVyZWQgbGFiZWwgaGVpZ2h0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBsYWJlbFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRMYWJlbEhlaWdodDogZnVuY3Rpb24obGFiZWwsIHRoZW1lKSB7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodCA9IHRoaXMuX2dldFJlbmRlcmVkTGFiZWxTaXplKGxhYmVsLCB0aGVtZSwgJ29mZnNldEhlaWdodCcpO1xuICAgICAgICByZXR1cm4gbGFiZWxIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBSZW5kZXJlZCBMYWJlbHMgTWF4IFNpemUod2lkdGggb3IgaGVpZ2h0KS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJlbmRlcmVkTGFiZWxzTWF4U2l6ZTogZnVuY3Rpb24obGFiZWxzLCB0aGVtZSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHNpemVzID0gdHVpLnV0aWwubWFwKGxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUobGFiZWwsIHRoZW1lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgbWF4U2l6ZSA9IHR1aS51dGlsLm1heChzaXplcyk7XG4gICAgICAgIHJldHVybiBtYXhTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVuZGVyZWQgbGFiZWxzIG1heCB3aWR0aC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWF4IHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZExhYmVsc01heFdpZHRoOiBmdW5jdGlvbihsYWJlbHMsIHRoZW1lKSB7XG4gICAgICAgIHZhciBpdGVyYXRlZSA9IHR1aS51dGlsLmJpbmQodGhpcy5nZXRSZW5kZXJlZExhYmVsV2lkdGgsIHRoaXMpLFxuICAgICAgICAgICAgbWF4V2lkdGggPSB0aGlzLl9nZXRSZW5kZXJlZExhYmVsc01heFNpemUobGFiZWxzLCB0aGVtZSwgaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gbWF4V2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZW5kZXJlZCBsYWJlbHMgbWF4IGhlaWdodC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmJvdW5kc01ha2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY29sb3I6IHN0cmluZ319IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWF4IGhlaWdodFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkTGFiZWxzTWF4SGVpZ2h0OiBmdW5jdGlvbihsYWJlbHMsIHRoZW1lKSB7XG4gICAgICAgIHZhciBpdGVyYXRlZSA9IHR1aS51dGlsLmJpbmQodGhpcy5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0LCB0aGlzKSxcbiAgICAgICAgICAgIG1heEhlaWdodCA9IHRoaXMuX2dldFJlbmRlcmVkTGFiZWxzTWF4U2l6ZShsYWJlbHMsIHRoZW1lLCBpdGVyYXRlZSk7XG4gICAgICAgIHJldHVybiBtYXhIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBkaW1lbnNpb24uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKi9cbiAgICByZW5kZXJEaW1lbnNpb246IGZ1bmN0aW9uKGVsLCBkaW1lbnNpb24pIHtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IFtcbiAgICAgICAgICAgIHRoaXMuY29uY2F0U3RyKCd3aWR0aDonLCBkaW1lbnNpb24ud2lkdGgsICdweCcpLFxuICAgICAgICAgICAgdGhpcy5jb25jYXRTdHIoJ2hlaWdodDonLCBkaW1lbnNpb24uaGVpZ2h0LCAncHgnKVxuICAgICAgICBdLmpvaW4oJzsnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHBvc2l0aW9uKHRvcCwgcmlnaHQpLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICovXG4gICAgcmVuZGVyUG9zaXRpb246IGZ1bmN0aW9uKGVsLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAodHVpLnV0aWwuaXNVbmRlZmluZWQocG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24udG9wKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS50b3AgPSBwb3NpdGlvbi50b3AgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uLmxlZnQpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmxlZnQgPSBwb3NpdGlvbi5sZWZ0ICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbi5yaWdodCkge1xuICAgICAgICAgICAgZWwuc3R5bGUucmlnaHQgPSBwb3NpdGlvbi5yaWdodCArICdweCc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGJhY2tncm91bmQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZCBiYWNrZ3JvdW5kIG9wdGlvblxuICAgICAqL1xuICAgIHJlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGVsLCBiYWNrZ3JvdW5kKSB7XG4gICAgICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuc3R5bGUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBmb250IGZhbWlseS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250RmFtaWx5IGZvbnQgZmFtaWx5IG9wdGlvblxuICAgICAqL1xuICAgIHJlbmRlckZvbnRGYW1pbHk6IGZ1bmN0aW9uKGVsLCBmb250RmFtaWx5KSB7XG4gICAgICAgIGlmICghZm9udEZhbWlseSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuc3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aXRsZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgdGl0bGVcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBjb2xvcjogc3RyaW5nLCBiYWNrZ3JvdW5kOiBzdHJpbmd9fSB0aGVtZSB0aXRsZSB0aGVtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgY3NzIGNsYXNzIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRpdGxlIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXJUaXRsZTogZnVuY3Rpb24odGl0bGUsIHRoZW1lLCBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGVsVGl0bGUsIGNzc1RleHQ7XG5cbiAgICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBlbFRpdGxlID0gZG9tLmNyZWF0ZSgnRElWJywgY2xhc3NOYW1lKTtcbiAgICAgICAgZWxUaXRsZS5pbm5lckhUTUwgPSB0aXRsZTtcblxuICAgICAgICBjc3NUZXh0ID0gcmVuZGVyVXRpbC5tYWtlRm9udENzc1RleHQodGhlbWUpO1xuXG4gICAgICAgIGlmICh0aGVtZS5iYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBjc3NUZXh0ICs9ICc7JyArIHRoaXMuY29uY2F0U3RyKCdiYWNrZ3JvdW5kOicsIHRoZW1lLmJhY2tncm91bmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxUaXRsZS5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcblxuICAgICAgICByZXR1cm4gZWxUaXRsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gZXhwYW5kIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGV4cGVuZGVkIGRpbWVuc2lvblxuICAgICAqL1xuICAgIGV4cGFuZEJvdW5kOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gYm91bmQuZGltZW5zaW9uLFxuICAgICAgICAgICAgcG9zaXRpb24gPSBib3VuZC5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBkaW1lbnNpb24ud2lkdGggKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAqIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkaW1lbnNpb24uaGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBtYWtlQ3VzdG9tRXZlbnROYW1lOiBmdW5jdGlvbihwcmVmaXgsIHN0ciwgc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyB0dWkudXRpbC5wcm9wZXJDYXNlKHN0cikgKyB0dWkudXRpbC5wcm9wZXJDYXNlKHN1ZmZpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgSUU4IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc09sZEJyb3dzZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNPbGRCcm93c2VyO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyVXRpbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlIG1ha2VyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRlbXBsYXRlIG1ha2VyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIGh0bWxcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRlbXBsYXRlIGZ1bmN0aW9uXG4gICAgICogQGVheG1wbGVcbiAgICAgKlxuICAgICAqICAgdmFyIHRlbXBsYXRlID0gdGVtcGxhdGVNYWtlci50ZW1wbGF0ZSgnPHNwYW4+e3sgbmFtZSB9fTwvc3Bhbj4nKSxcbiAgICAgKiAgICAgICByZXN1bHQgPSB0ZW1wbGF0ZSh7bmFtZTogJ0pvaG4nKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7IC8vIDxzcGFuPkpvaG48L3NwYW4+XG4gICAgICpcbiAgICAgKi9cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaHRtbDtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goZGF0YSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgne3tcXFxccyonICsga2V5ICsgJ1xcXFxzKn19JywgJ2cnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZWdFeHAsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVzZXJFdmVudExpc3RlbmVyIGlzIGxpc3RlbmVyIG9mIHVzZXIgZXZlbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVc2VyRXZlbnRMaXN0ZW5lciA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgVXNlckV2ZW50TGlzdGVuZXIucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciB1c2VyIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgZXZlbnQgY2FsbGJhY2tcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24oZXZlbnROYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMub24oZXZlbnROYW1lLCBmdW5jKTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFVzZXJFdmVudExpc3RlbmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVc2VyRXZlbnRMaXN0ZW5lcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgTGVnZW5kIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIGV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2V2ZW50TGlzdGVuZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgZGVmYXVsdFRoZW1lID0gcmVxdWlyZSgnLi4vdGhlbWVzL2RlZmF1bHRUaGVtZScpLFxuICAgIGxlZ2VuZFRlbXBsYXRlID0gcmVxdWlyZSgnLi8uLi9sZWdlbmRzL2xlZ2VuZFRlbXBsYXRlJyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG52YXIgTGVnZW5kID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBMZWdlbmQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMZWdlbmQgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIExlZ2VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sZWdlbmRMYWJlbHMgbGVnZW5kIGxhYmVsc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5ib3VuZCBheGlzIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWdlbmQgdmlldyBjbGFzc05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC1sZWdlbmQtYXJlYSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlbmRlciBsZWdlbmQgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbExlZ25lZEFyZWEgbGVnZW5kIGFyZWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGJvdW5kIGxlbmdlbmQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJMZWdlbmRBcmVhOiBmdW5jdGlvbihlbExlZ25lZEFyZWEsIGJvdW5kKSB7XG4gICAgICAgIHZhciBsZWdlbmREYXRhO1xuICAgICAgICB0aGlzLmJvdW5kID0gYm91bmQ7XG4gICAgICAgIHRoaXMubGVnZW5kRGF0YSA9IGxlZ2VuZERhdGEgPSB0aGlzLl9tYWtlTGVnZW5kRGF0YSgpO1xuICAgICAgICBlbExlZ25lZEFyZWEuaW5uZXJIVE1MID0gdGhpcy5fbWFrZUxlZ2VuZEh0bWwobGVnZW5kRGF0YSk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oZWxMZWduZWRBcmVhLCBib3VuZC5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3JlbmRlckxhYmVsVGhlbWUoZWxMZWduZWRBcmVhLCB0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVuZGVyIGxlZ2VuZCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgbGVuZ2VuZCBib3VuZFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGVnZW5kIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYShlbCwgYm91bmQpO1xuICAgICAgICB0aGlzLl9hdHRhY2hFdmVudChlbCk7XG4gICAgICAgIHRoaXMuZWxMZWdlbmRBcmVhID0gZWw7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVzaXplIGxlZ2VuZCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgbGVuZ2VuZCBib3VuZFxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oYm91bmQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYSh0aGlzLmVsTGVnZW5kQXJlYSwgYm91bmQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlbWUgZm9yIGxlZ2VuZCBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxvYmplY3Q+fSBsYWJlbHMgbGFiZWxzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxlZ2VuZCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHthcnJheS48b2JqZWN0Pn0gbGFiZWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0VGhlbWVGb3JMYWJlbHM6IGZ1bmN0aW9uKGxhYmVscywgdGhlbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gdHVpLnV0aWwubWFwKGxhYmVscywgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtVGhlbWUgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHRoZW1lLmNvbG9yc1tpbmRleF1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGVtZS5zaW5nbGVDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICBpdGVtVGhlbWUuc2luZ2xlQ29sb3IgPSB0aGVtZS5zaW5nbGVDb2xvcnNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoZW1lLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRoZW1lLmJvcmRlckNvbG9yID0gdGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnRoZW1lID0gaXRlbVRoZW1lO1xuICAgICAgICAgICAgaXRlbS5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgbGVnZW5kIGxhYmVscy5cbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPG9iamVjdD59IGxlZ2VuZCBsYWJlbHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgam9pbkxlZ2VuZExhYmVscyA9IHRoaXMuam9pbkxlZ2VuZExhYmVscyxcbiAgICAgICAgICAgIHRoZW1lID0gdGhpcy50aGVtZSxcbiAgICAgICAgICAgIGRlZmF1bHRMZWdlbmRUaGVtZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcnM6IGRlZmF1bHRUaGVtZS5zZXJpZXMuY29sb3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhcnRJbmRleCwgcmVzdWx0O1xuXG4gICAgICAgIGlmICghdGhpcy5zZXJpZXNDaGFydFR5cGVzKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9zZXRUaGVtZUZvckxhYmVscyhqb2luTGVnZW5kTGFiZWxzLCB0aGVtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbmNhdC5hcHBseShbXSwgdHVpLnV0aWwubWFwKHRoaXMuc2VyaWVzQ2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJ0VGhlbWUgPSB0aGVtZVtjaGFydFR5cGVdIHx8IGRlZmF1bHRMZWdlbmRUaGVtZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgdGhpcy5sZWdlbmRMYWJlbHNbY2hhcnRUeXBlXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9zZXRUaGVtZUZvckxhYmVscyhqb2luTGVnZW5kTGFiZWxzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSwgY2hhcnRUaGVtZSk7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgbGVnZW5kIGh0bWwuXG4gICAgICogQHBhcmFtIHthcnJheX0gbGVnZW5kRGF0YSBsZWdlbmQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGxlZ2VuZCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZEh0bWw6IGZ1bmN0aW9uKGxlZ2VuZERhdGEpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gbGVnZW5kVGVtcGxhdGUudHBsTGVnZW5kLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQobGVnZW5kRGF0YVswXS5sYWJlbCwgbGVnZW5kRGF0YVswXS50aGVtZSksXG4gICAgICAgICAgICBoZWlnaHQgPSBsYWJlbEhlaWdodCArIChjaGFydENvbnN0LkxBQkVMX1BBRERJTkdfVE9QICogMiksXG4gICAgICAgICAgICBiYXNlTWFyZ2luVG9wID0gcGFyc2VJbnQoKGhlaWdodCAtIGNoYXJ0Q29uc3QuTEVHRU5EX1JFQ1RfV0lEVEgpIC8gMiwgMTApIC0gMSxcbiAgICAgICAgICAgIGh0bWwgPSB0dWkudXRpbC5tYXAobGVnZW5kRGF0YSwgZnVuY3Rpb24obGVnZW5kSW5mbywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQ3NzVGV4dCA9IGxlZ2VuZEluZm8uYm9yZGVyQ29sb3IgPyByZW5kZXJVdGlsLmNvbmNhdFN0cignO2JvcmRlcjoxcHggc29saWQgJywgbGVnZW5kSW5mby5ib3JkZXJDb2xvcikgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcmVjdE1hcmdpbiwgbWFyZ2luVG9wLCBkYXRhO1xuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRJbmZvLmNoYXJ0VHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IGJhc2VNYXJnaW5Ub3AgKyBjaGFydENvbnN0LkxJTkVfTUFSR0lOX1RPUDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBiYXNlTWFyZ2luVG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0TWFyZ2luID0gcmVuZGVyVXRpbC5jb25jYXRTdHIoJzttYXJnaW4tdG9wOicsIG1hcmdpblRvcCwgJ3B4Jyk7XG5cbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBjc3NUZXh0OiByZW5kZXJVdGlsLmNvbmNhdFN0cignYmFja2dyb3VuZC1jb2xvcjonLCBsZWdlbmRJbmZvLnRoZW1lLnNpbmdsZUNvbG9yIHx8IGxlZ2VuZEluZm8udGhlbWUuY29sb3IsIGJvcmRlckNzc1RleHQsIHJlY3RNYXJnaW4pLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQ6IGxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGxlZ2VuZEluZm8uY2hhcnRUeXBlIHx8ICdyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxlZ2VuZEluZm8ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEpO1xuICAgICAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgY3NzIHN0eWxlIG9mIGxhYmVsIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6bnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckxhYmVsVGhlbWU6IGZ1bmN0aW9uKGVsLCB0aGVtZSkge1xuICAgICAgICB2YXIgY3NzVGV4dCA9IHJlbmRlclV0aWwubWFrZUZvbnRDc3NUZXh0KHRoZW1lKTtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBjc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGxlZ2VuZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVGFyZ2V0IHRhcmdldCBlbGVtZW50XG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBsZWdlbmQgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRMZWdlbmRFbGVtZW50OiBmdW5jdGlvbihlbFRhcmdldCkge1xuICAgICAgICB2YXIgZWxMZWdlbmQ7XG5cbiAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5DTEFTU19OQU1FX0xFR0VORCkpIHtcbiAgICAgICAgICAgIGVsTGVnZW5kID0gZWxUYXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbExlZ2VuZCA9IGRvbS5maW5kUGFyZW50QnlDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5DTEFTU19OQU1FX0xFR0VORCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxMZWdlbmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0TGVnZW5kOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMubGVnZW5kRGF0YVtpbmRleF07XG4gICAgICAgIHRoaXMudXNlckV2ZW50LmZpcmUoJ3NlbGVjdExlZ2VuZCcsIHtcbiAgICAgICAgICAgIGxlZ2VuZDogZGF0YS5sYWJlbCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogZGF0YS5jaGFydFR5cGUsXG4gICAgICAgICAgICBpbmRleDogZGF0YS5pbmRleFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2sgZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlbFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICAgIGVsTGVnZW5kID0gdGhpcy5fZmluZExlZ2VuZEVsZW1lbnQoZWxUYXJnZXQpLFxuICAgICAgICAgICAgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFlbExlZ2VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBwYXJzZUludChlbExlZ2VuZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApO1xuICAgICAgICB0aGlzLl9zZWxlY3RMZWdlbmQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYnJvd3NlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEV2ZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICBldmVudExpc3RlbmVyLmJpbmRFdmVudCgnY2xpY2snLCBlbCwgdHVpLnV0aWwuYmluZCh0aGlzLl9vbkNsaWNrLCB0aGlzKSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGVnZW5kO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgdGVtcGxhdGVzIG9mIGxlZ2VuZCB2aWV3LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxudmFyIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKTtcblxudmFyIHRhZ3MgPSB7XG4gICAgSFRNTF9MRUdFTkQ6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWxlZ2VuZFwiIHN0eWxlPVwiaGVpZ2h0Ont7IGhlaWdodCB9fXB4XCIgZGF0YS1pbmRleD1cInt7IGluZGV4IH19XCI+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWxlZ2VuZC1yZWN0IHt7IGNoYXJ0VHlwZSB9fVwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiPjwvZGl2PicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1sZWdlbmQtbGFiZWxcIiBzdHlsZT1cImhlaWdodDp7eyBsYWJlbEhlaWdodCB9fXB4XCI+e3sgbGFiZWwgfX08L2Rpdj48L2Rpdj4nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0cGxMZWdlbmQ6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUodGFncy5IVE1MX0xFR0VORClcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGxvdCBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9jYWxjdWxhdG9yJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIHBsb3RUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vcGxvdFRlbXBsYXRlJyk7XG5cbnZhciBQbG90ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBQbG90LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUGxvdCBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgUGxvdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52VGlja0NvdW50IHZlcnRpY2FsIHRpY2sgY291bnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuaFRpY2tDb3VudCBob3Jpem9udGFsIHRpY2sgY291bnRcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYm91bmQgYXhpcyBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHR1aS51dGlsLmV4dGVuZCh0aGlzLCBwYXJhbXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxvdCB2aWV3IGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNoYXJ0LXBsb3QtYXJlYSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlbmRlciBwbG90IGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxQbG90QXJlYSBwbG90IGFyZWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGJvdW5kIHBsb3QgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclBsb3RBcmVhOiBmdW5jdGlvbihlbFBsb3RBcmVhLCBib3VuZCwgZGF0YSkge1xuICAgICAgICB0aGlzLmJvdW5kID0gYm91bmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oZWxQbG90QXJlYSwgYm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihlbFBsb3RBcmVhLCBib3VuZC5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3JlbmRlckxpbmVzKGVsUGxvdEFyZWEsIGJvdW5kLmRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlbmRlciBwbG90IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fSBib3VuZCBwbG90IGJvdW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHBsb3QgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oYm91bmQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB0aGlzLl9yZW5kZXJQbG90QXJlYShlbCwgYm91bmQsIGRhdGEpO1xuICAgICAgICB0aGlzLmVsUGxvdEFyZWEgPSBlbDtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZXNpemUgcGxvdCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgcGxvdCBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihib3VuZCwgZGF0YSkge1xuICAgICAgICB0aGlzLmVsUGxvdEFyZWEuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMuX3JlbmRlclBsb3RBcmVhKHRoaXMuZWxQbG90QXJlYSwgYm91bmQsIGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcGxvdCBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gcGxvdCBhcmVhIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckxpbmVzOiBmdW5jdGlvbihlbCwgZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBoUG9zaXRpb25zID0gdGhpcy5fbWFrZUhvcml6b250YWxQaXhlbFBvc2l0aW9ucyhkaW1lbnNpb24ud2lkdGgpLFxuICAgICAgICAgICAgdlBvc2l0aW9ucyA9IHRoaXMuX21ha2VWZXJ0aWNhbFBpeGVsUG9zaXRpb25zKGRpbWVuc2lvbi5oZWlnaHQpLFxuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgbGluZUh0bWwgPSAnJztcblxuICAgICAgICBsaW5lSHRtbCArPSB0aGlzLl9tYWtlTGluZUh0bWwoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiBoUG9zaXRpb25zLFxuICAgICAgICAgICAgc2l6ZTogZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ2xlZnQnLFxuICAgICAgICAgICAgc2l6ZVR5cGU6ICdoZWlnaHQnLFxuICAgICAgICAgICAgbGluZUNvbG9yOiB0aGVtZS5saW5lQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmVIdG1sICs9IHRoaXMuX21ha2VMaW5lSHRtbCh7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHZQb3NpdGlvbnMsXG4gICAgICAgICAgICBzaXplOiBkaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ2JvdHRvbScsXG4gICAgICAgICAgICBzaXplVHlwZTogJ3dpZHRoJyxcbiAgICAgICAgICAgIGxpbmVDb2xvcjogdGhlbWUubGluZUNvbG9yXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsLmlubmVySFRNTCA9IGxpbmVIdG1sO1xuXG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyQmFja2dyb3VuZChlbCwgdGhlbWUuYmFja2dyb3VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgaHRtbCBvZiBwbG90IGxpbmUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxvYmplY3Q+fSBwYXJhbXMucG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jbGFzc05hbWUgbGluZSBjbGFzc05hbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucG9zaXRpb25UeXBlIHBvc2l0aW9uIHR5cGUgKGxlZnQgb3IgYm90dG9tKVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5zaXplVHlwZSBzaXplIHR5cGUgKHNpemUgb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5saW5lQ29sb3IgbGluZSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGluZUh0bWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBwbG90VGVtcGxhdGUudHBsUGxvdExpbmUsXG4gICAgICAgICAgICBsaW5lSHRtbCA9IHR1aS51dGlsLm1hcChwYXJhbXMucG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjc3NUZXh0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKHBhcmFtcy5wb3NpdGlvblR5cGUsICc6JywgcG9zaXRpb24sICdweCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVXRpbC5jb25jYXRTdHIocGFyYW1zLnNpemVUeXBlLCAnOicsIHBhcmFtcy5zaXplLCAncHgnKVxuICAgICAgICAgICAgICAgICAgICBdLCBkYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5saW5lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cignYmFja2dyb3VuZC1jb2xvcjonLCBwYXJhbXMubGluZUNvbG9yKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtjbGFzc05hbWU6IHBhcmFtcy5jbGFzc05hbWUsIGNzc1RleHQ6IGNzc1RleHRzLmpvaW4oJzsnKX07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEpO1xuICAgICAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG4gICAgICAgIHJldHVybiBsaW5lSHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBwaXhlbCB2YWx1ZSBvZiB2ZXJ0aWNhbCBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHBsb3QgaGVpZ2h0XG4gICAgICogQHJldHVybnMge2FycmF5LjxudW1iZXI+fSBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxQaXhlbFBvc2l0aW9uczogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBjYWxjdWxhdG9yLm1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMoaGVpZ2h0LCB0aGlzLmRhdGEudlRpY2tDb3VudCk7XG4gICAgICAgIHBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHBpeGVsIHZhbHVlIG9mIGhvcml6b250YWwgcG9zaXRpb25zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBwbG90IHdpZHRoXG4gICAgICogQHJldHVybnMge2FycmF5LjxudW1iZXI+fSBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbFBpeGVsUG9zaXRpb25zOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gY2FsY3VsYXRvci5tYWtlVGlja1BpeGVsUG9zaXRpb25zKHdpZHRoLCB0aGlzLmRhdGEuaFRpY2tDb3VudCk7XG4gICAgICAgIHBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsb3Q7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBpcyB0ZW1wbGF0ZXMgb2YgcGxvdCB2aWV3IC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbnZhciB0ZW1wbGF0ZU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy90ZW1wbGF0ZU1ha2VyJyk7XG5cbnZhciB0YWdzID0ge1xuICAgIEhUTUxfUExPVF9MSU5FOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1wbG90LWxpbmUge3sgY2xhc3NOYW1lIH19XCIgc3R5bGU9XCJ7eyBjc3NUZXh0IH19XCI+PC9kaXY+J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdHBsUGxvdExpbmU6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUodGFncy5IVE1MX1BMT1RfTElORSlcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbCByZW5kZXIgcGx1Z2luLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFyQ2hhcnQgPSByZXF1aXJlKCcuL3JhcGhhZWxCYXJDaGFydCcpLFxuICAgIExpbmVDaGFydCA9IHJlcXVpcmUoJy4vcmFwaGFlbExpbmVDaGFydCcpLFxuICAgIEFyZWFDaGFydCA9IHJlcXVpcmUoJy4vcmFwaGFlbEFyZWFDaGFydCcpLFxuICAgIFBpZUNoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsUGllQ2hhcnQnKTtcblxudmFyIHBsdWdpbk5hbWUgPSAncmFwaGFlbCcsXG4gICAgcGx1Z2luUmFwaGFlbDtcblxucGx1Z2luUmFwaGFlbCA9IHtcbiAgICBiYXI6IEJhckNoYXJ0LFxuICAgIGNvbHVtbjogQmFyQ2hhcnQsXG4gICAgbGluZTogTGluZUNoYXJ0LFxuICAgIGFyZWE6IEFyZWFDaGFydCxcbiAgICBwaWU6IFBpZUNoYXJ0XG59O1xuXG50dWkuY2hhcnQucmVnaXN0ZXJQbHVnaW4ocGx1Z2luTmFtZSwgcGx1Z2luUmFwaGFlbCk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbCBhcmVhIGNoYXJ0IHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmFwaGFlbExpbmVCYXNlID0gcmVxdWlyZSgnLi9yYXBoYWVsTGluZVR5cGVCYXNlJyksXG4gICAgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciBSYXBoYWVsID0gd2luZG93LlJhcGhhZWwsXG4gICAgQU5JTUFUSU9OX1RJTUUgPSA3MDA7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbEFyZWFDaGFydCBpcyBncmFwaCByZW5kZXJlciBmb3IgYXJlYSBjaGFydC5cbiAqIEBjbGFzcyBSYXBoYWVsQXJlYUNoYXJ0XG4gKiBAZXh0ZW5kcyBSYXBoYWVsTGluZVR5cGVCYXNlXG4gKi9cbnZhciBSYXBoYWVsQXJlYUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoUmFwaGFlbExpbmVCYXNlLCAvKiogQGxlbmRzIFJhcGhhZWxBcmVhQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgYXJlYSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHt7Z3JvdXBQb3NpdGlvbnM6IGFycmF5LjxhcnJheT4sIGRpbWVuc2lvbjogb2JqZWN0LCB0aGVtZTogb2JqZWN0LCBvcHRpb25zOiBvYmplY3R9fSBkYXRhIHJlbmRlciBkYXRhXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSBkYXRhLmdyb3VwUG9zaXRpb25zLFxuICAgICAgICAgICAgdGhlbWUgPSBkYXRhLnRoZW1lLFxuICAgICAgICAgICAgY29sb3JzID0gdGhlbWUuY29sb3JzLFxuICAgICAgICAgICAgb3BhY2l0eSA9IGRhdGEub3B0aW9ucy5oYXNEb3QgPyAxIDogMCxcbiAgICAgICAgICAgIGdyb3VwUGF0aHMgPSB0aGlzLl9nZXRBcmVhc1BhdGgoZ3JvdXBQb3NpdGlvbnMsIGRhdGEuemVyb1RvcCksXG4gICAgICAgICAgICBib3JkZXJTdHlsZSA9IHRoaXMubWFrZUJvcmRlclN0eWxlKHRoZW1lLmJvcmRlckNvbG9yLCBvcGFjaXR5KSxcbiAgICAgICAgICAgIG91dERvdFN0eWxlID0gdGhpcy5tYWtlT3V0RG90U3R5bGUob3BhY2l0eSwgYm9yZGVyU3R5bGUpLFxuICAgICAgICAgICAgcGFwZXIsIGdyb3VwQXJlYXMsIHRvb2x0aXBMaW5lLCBzZWxlY3Rpb25Eb3QsIGdyb3VwRG90cztcblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSBSYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICBncm91cEFyZWFzID0gdGhpcy5fcmVuZGVyQXJlYXMocGFwZXIsIGdyb3VwUGF0aHMsIGNvbG9ycyk7XG4gICAgICAgIHRvb2x0aXBMaW5lID0gdGhpcy5fcmVuZGVyVG9vbHRpcExpbmUocGFwZXIsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICBzZWxlY3Rpb25Eb3QgPSB0aGlzLl9tYWtlU2VsZWN0aW9uRG90KHBhcGVyKTtcbiAgICAgICAgZ3JvdXBEb3RzID0gdGhpcy5fcmVuZGVyRG90cyhwYXBlciwgZ3JvdXBQb3NpdGlvbnMsIGNvbG9ycywgYm9yZGVyU3R5bGUpO1xuXG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkRvdCA9IHNlbGVjdGlvbkRvdDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ29sb3IgPSB0aGVtZS5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3V0RG90U3R5bGUgPSBvdXREb3RTdHlsZTtcbiAgICAgICAgdGhpcy5ncm91cFBvc2l0aW9ucyA9IGdyb3VwUG9zaXRpb25zO1xuICAgICAgICB0aGlzLmdyb3VwUGF0aHMgPSBncm91cFBhdGhzO1xuICAgICAgICB0aGlzLmdyb3VwQXJlYXMgPSBncm91cEFyZWFzO1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lID0gdG9vbHRpcExpbmU7XG4gICAgICAgIHRoaXMuZ3JvdXBEb3RzID0gZ3JvdXBEb3RzO1xuICAgICAgICB0aGlzLmRvdE9wYWNpdHkgPSBvcGFjaXR5O1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGFyZWEgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHBhcGVyXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IHN0cmluZywgYWRkU3RhcnQ6IHN0cmluZ319IHBhdGggcGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBjb2xvclxuICAgICAqIEByZXR1cm5zIHthcnJheS48b2JqZWN0Pn0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJBcmVhOiBmdW5jdGlvbihwYXBlciwgcGF0aCwgY29sb3IpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgYXJlYSA9IHBhcGVyLnBhdGgoW3BhdGguc3RhcnRdKSxcbiAgICAgICAgICAgIGZpbGxTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkQXJlYTtcblxuICAgICAgICBhcmVhLmF0dHIoZmlsbFN0eWxlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYXJlYSk7XG5cbiAgICAgICAgaWYgKHBhdGguYWRkU3RhcnQpIHtcbiAgICAgICAgICAgIGFkZEFyZWEgPSBwYXBlci5wYXRoKFtwYXRoLmFkZFN0YXJ0XSk7XG4gICAgICAgICAgICBhZGRBcmVhLmF0dHIoZmlsbFN0eWxlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEFyZWEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhcmVhIGdyYXBocy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcGFwZXJcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxvYmplY3Q+fSBncm91cFBhdGhzIGdyb3VwIHBhdGhzXG4gICAgICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gY29sb3JzIGNvbG9yc1xuICAgICAqIEByZXR1cm5zIHthcnJheX0gcmFwaGFlbCBvYmplY3RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQXJlYXM6IGZ1bmN0aW9uKHBhcGVyLCBncm91cFBhdGhzLCBjb2xvcnMpIHtcbiAgICAgICAgdmFyIGdyb3VwQXJlYXMgPSB0dWkudXRpbC5tYXAoZ3JvdXBQYXRocywgZnVuY3Rpb24ocGF0aHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yc1tncm91cEluZGV4XSB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZWE6IHRoaXMuX3JlbmRlckFyZWEocGFwZXIsIHBhdGguYXJlYSwgY29sb3IpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJMaW5lKHBhcGVyLCBwYXRoLmxpbmUuc3RhcnQsIGNvbG9yKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gZ3JvdXBBcmVhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBtaW51cyBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNNaW51czogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBwbHVzIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1BsdXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wIHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6ZXJvVG9wIHplcm8gcG9zaXRpb24gdG9wXG4gICAgICogQHJldHVybnMge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhlaWdodDogZnVuY3Rpb24odG9wLCB6ZXJvVG9wKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0b3AgLSB6ZXJvVG9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBtaWRkbGUgbGVmdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBmcm9tUG9zIGZyb20gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gdG9Qb3MgdG8gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gemVyb1RvcCB6ZXJvIHBvc2l0aW9uIHRvcFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG1pZGRsZSBsZWZ0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE1pZGRsZUxlZnQ6IGZ1bmN0aW9uKGZyb21Qb3MsIHRvUG9zLCB6ZXJvVG9wKSB7XG4gICAgICAgIHZhciB0b3BzID0gW3plcm9Ub3AgLSBmcm9tUG9zLnRvcCwgemVyb1RvcCAtIHRvUG9zLnRvcF0sXG4gICAgICAgICAgICBtaWRkbGVMZWZ0LCB3aWR0aCwgZnJvbUhlaWdodCwgdG9IZWlnaHQ7XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmFsbCh0b3BzLCB0aGlzLl9pc01pbnVzKSB8fCB0dWkudXRpbC5hbGwodG9wcywgdGhpcy5faXNQbHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJvbUhlaWdodCA9IHRoaXMuX21ha2VIZWlnaHQoZnJvbVBvcy50b3AsIHplcm9Ub3ApO1xuICAgICAgICB0b0hlaWdodCA9IHRoaXMuX21ha2VIZWlnaHQodG9Qb3MudG9wLCB6ZXJvVG9wKTtcbiAgICAgICAgd2lkdGggPSB0b1Bvcy5sZWZ0IC0gZnJvbVBvcy5sZWZ0O1xuXG4gICAgICAgIG1pZGRsZUxlZnQgPSBmcm9tUG9zLmxlZnQgKyAod2lkdGggKiAoZnJvbUhlaWdodCAvIChmcm9tSGVpZ2h0ICsgdG9IZWlnaHQpKSk7XG4gICAgICAgIHJldHVybiBtaWRkbGVMZWZ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGFyZWEgcGF0aC5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gZnJvbVBvcyBmcm9tIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHRvUG9zIHRvIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHplcm9Ub3AgemVybyBwb3NpdGlvbiB0b3BcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBhcmVhIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXJlYVBhdGg6IGZ1bmN0aW9uKGZyb21Qb3MsIHRvUG9zLCB6ZXJvVG9wKSB7XG4gICAgICAgIHZhciBmcm9tU3RhcnRQb2ludCA9IFsnTScsIGZyb21Qb3MubGVmdCwgJyAnLCB6ZXJvVG9wXSxcbiAgICAgICAgICAgIGZyb21FbmRQb2ludCA9IHplcm9Ub3AgPT09IGZyb21Qb3MudG9wID8gW10gOiBbJ0wnLCBmcm9tUG9zLmxlZnQsICcgJywgZnJvbVBvcy50b3BdLFxuICAgICAgICAgICAgdG9TdGFydFBvaW50ID0gWydMJywgdG9Qb3MubGVmdCwgJyAnLCB0b1Bvcy50b3BdLFxuICAgICAgICAgICAgdG9FbmRQb2ludCA9IHplcm9Ub3AgPT09IHRvUG9zLnRvcCA/IFtdIDogWydMJywgdG9Qb3MubGVmdCwgJyAnLCB6ZXJvVG9wXTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdC5jYWxsKFtdLCBmcm9tU3RhcnRQb2ludCwgZnJvbUVuZFBvaW50LCB0b1N0YXJ0UG9pbnQsIHRvRW5kUG9pbnQpLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGFyZWEgcGF0aHMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGZyb21Qb3MgZnJvbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSB0b1BvcyB0byBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6ZXJvVG9wIHplcm8gcG9zaXRpb24gdG9wXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHN0YXJ0OiBzdHJpbmcsXG4gICAgICogICAgICBlbmQ6IHN0cmluZyxcbiAgICAgKiAgICAgIGFkZFN0YXJ0OiBzdHJpbmcsXG4gICAgICogICAgICBhZGRFbmQ6IHN0cmluZ1xuICAgICAqIH19IGFyZWEgcGF0aHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXJlYVBhdGhzOiBmdW5jdGlvbihmcm9tUG9zLCB0b1BvcywgemVyb1RvcCkge1xuICAgICAgICB2YXIgbWlkZGxlTGVmdCA9IHRoaXMuX2ZpbmRNaWRkbGVMZWZ0KGZyb21Qb3MsIHRvUG9zLCB6ZXJvVG9wKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5fbWFrZUFyZWFQYXRoKGZyb21Qb3MsIGZyb21Qb3MsIHplcm9Ub3ApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWlkZGxlUG9zO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1BsdXMobWlkZGxlTGVmdCkpIHtcbiAgICAgICAgICAgIG1pZGRsZVBvcyA9IHtsZWZ0OiBtaWRkbGVMZWZ0LCB0b3A6IHplcm9Ub3B9O1xuICAgICAgICAgICAgcmVzdWx0LmVuZCA9IHRoaXMuX21ha2VBcmVhUGF0aChmcm9tUG9zLCBtaWRkbGVQb3MsIHplcm9Ub3ApO1xuICAgICAgICAgICAgcmVzdWx0LmFkZFN0YXJ0ID0gdGhpcy5fbWFrZUFyZWFQYXRoKG1pZGRsZVBvcywgbWlkZGxlUG9zLCB6ZXJvVG9wKTtcbiAgICAgICAgICAgIHJlc3VsdC5hZGRFbmQgPSB0aGlzLl9tYWtlQXJlYVBhdGgobWlkZGxlUG9zLCB0b1BvcywgemVyb1RvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kID0gdGhpcy5fbWFrZUFyZWFQYXRoKGZyb21Qb3MsIHRvUG9zLCB6ZXJvVG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhcmVhIHBhdGguXG4gICAgICogQHBhcmFtIHthcnJheS48YXJyYXkuPG9iamVjdD4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gemVyb1RvcCB6ZXJvIHRvcFxuICAgICAqIEByZXR1cm5zIHthcnJheS48YXJyYXkuPHN0cmluZz4+fSBwYXRoc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEFyZWFzUGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMsIHplcm9Ub3ApIHtcbiAgICAgICAgdmFyIGdyb3VwUGF0aHMgPSB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgdmFyIGZyb21Qb3MgPSBwb3NpdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgcmVzdCA9IHBvc2l0aW9ucy5zbGljZSgxKTtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAocmVzdCwgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBhcmVhOiB0aGlzLl9tYWtlQXJlYVBhdGhzKGZyb21Qb3MsIHBvc2l0aW9uLCB6ZXJvVG9wKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5tYWtlTGluZVBhdGgoZnJvbVBvcywgcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmcm9tUG9zID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwUGF0aHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgYXJlYSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJlYSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmVhUGF0aCBwYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgcGxheSB0aW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VGltZSBzdGFydCB0aW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUFyZWE6IGZ1bmN0aW9uKGFyZWEsIGFyZWFQYXRoLCB0aW1lLCBzdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGFyZWFBZGRFbmRQYXRoID0gYXJlYVBhdGguYWRkRW5kLFxuICAgICAgICAgICAgYXJlYUVuZFBhdGggPSBhcmVhUGF0aC5lbmQ7XG4gICAgICAgIGlmIChhcmVhQWRkRW5kUGF0aCkge1xuICAgICAgICAgICAgdGltZSA9IHRpbWUgLyAyO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhcmVhWzFdLmFuaW1hdGUoe3BhdGg6IGFyZWFBZGRFbmRQYXRoLCAnc3Ryb2tlLW9wYWNpdHknOiAwLjI1fSwgdGltZSk7XG4gICAgICAgICAgICB9LCBzdGFydFRpbWUgKyB0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXJlYVswXS5hbmltYXRlKHtwYXRoOiBhcmVhRW5kUGF0aCwgJ3N0cm9rZS1vcGFjaXR5JzogMC4yNX0sIHRpbWUpO1xuICAgICAgICB9LCBzdGFydFRpbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRpbWUgPSBBTklNQVRJT05fVElNRSAvIHRoaXMuZ3JvdXBBcmVhc1swXS5sZW5ndGgsXG4gICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IDA7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJJdGVtcyhmdW5jdGlvbihkb3QsIGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYXJlYSwgYXJlYVBhdGg7XG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBhcmVhID0gdGhhdC5ncm91cEFyZWFzW2dyb3VwSW5kZXhdW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgYXJlYVBhdGggPSB0aGF0Lmdyb3VwUGF0aHNbZ3JvdXBJbmRleF1baW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICB0aGF0LmFuaW1hdGVMaW5lKGFyZWEubGluZSwgYXJlYVBhdGgubGluZS5lbmQsIHRpbWUsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgdGhhdC5fYW5pbWF0ZUFyZWEoYXJlYS5hcmVhLCBhcmVhUGF0aC5hcmVhLCB0aW1lLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSArPSB0aW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhhdC5kb3RPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZG90LmF0dHIoeydmaWxsLW9wYWNpdHknOiB0aGF0LmRvdE9wYWNpdHl9KTtcbiAgICAgICAgICAgICAgICB9LCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIHN0YXJ0VGltZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gdXBkYXRlIGFyZWEgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZWEgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJlYVBhdGggYXJlYSBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQXJlYUF0dHI6IGZ1bmN0aW9uKGFyZWEsIGFyZWFQYXRoKSB7XG4gICAgICAgIHZhciBhcmVhQWRkRW5kUGF0aCA9IGFyZWFQYXRoLmFkZEVuZDtcbiAgICAgICAgYXJlYVswXS5hdHRyKHtwYXRoOiBhcmVhUGF0aC5lbmR9KTtcbiAgICAgICAgaWYgKGFyZWFBZGRFbmRQYXRoKSB7XG4gICAgICAgICAgICBhcmVhWzFdLmF0dHIoe3BhdGg6IGFyZWFBZGRFbmRQYXRofSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVzaXplIGdyYXBoIG9mIGFyZWEgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Ljx7bGVmdDpudW1iZXIsIHRvcDpudW1iZXJ9Pj59IHBhcmFtcy5ncm91cFBvc2l0aW9ucyBncm91cCBwb3NpdGlvbnNcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gcGFyYW1zLmRpbWVuc2lvbixcbiAgICAgICAgICAgIGdyb3VwUG9zaXRpb25zID0gcGFyYW1zLmdyb3VwUG9zaXRpb25zLFxuICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5ncm91cFBvc2l0aW9ucyA9IGdyb3VwUG9zaXRpb25zO1xuICAgICAgICB0aGlzLmdyb3VwUGF0aHMgPSB0aGlzLl9nZXRBcmVhc1BhdGgoZ3JvdXBQb3NpdGlvbnMsIHBhcmFtcy56ZXJvVG9wKTtcbiAgICAgICAgdGhpcy5wYXBlci5zZXRTaXplKGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHRoaXMudG9vbHRpcExpbmUuYXR0cih7dG9wOiBkaW1lbnNpb24uaGVpZ2h0fSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJJdGVtcyhmdW5jdGlvbihkb3QsIGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBncm91cFBvc2l0aW9uc1tncm91cEluZGV4XVtpbmRleF0sXG4gICAgICAgICAgICAgICAgZG90QXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBwb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBjeTogcG9zaXRpb24udG9wXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmVhLCBhcmVhUGF0aDtcbiAgICAgICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGFyZWEgPSB0aGF0Lmdyb3VwQXJlYXNbZ3JvdXBJbmRleF1baW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBhcmVhUGF0aCA9IHRoYXQuZ3JvdXBQYXRoc1tncm91cEluZGV4XVtpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIGFyZWEubGluZS5hdHRyKHtwYXRoOiBhcmVhUGF0aC5saW5lLmVuZH0pO1xuICAgICAgICAgICAgICAgIHRoYXQuX3VwZGF0ZUFyZWFBdHRyKGFyZWEuYXJlYSwgYXJlYVBhdGguYXJlYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGF0LmRvdE9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICBkb3RBdHRycyA9IHR1aS51dGlsLmV4dGVuZCh7J2ZpbGwtb3BhY2l0eSc6IHRoYXQuZG90T3BhY2l0eX0sIGRvdEF0dHJzLCB0aGF0LmJvcmRlclN0eWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG90LmF0dHIoZG90QXR0cnMpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsQXJlYUNoYXJ0O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWwgYmFyIGNoYXJ0IHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yYXBoYWVsUmVuZGVyVXRpbCcpO1xuXG52YXIgUmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG52YXIgQU5JTUFUSU9OX1RJTUUgPSA3MDA7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsQmFyQ2hhcnQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGJhciwgY29sdW1uIGNoYXJ0LlxuICogQGNsYXNzIFJhcGhhZWxCYXJDaGFydFxuICovXG52YXIgUmFwaGFlbEJhckNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsQmFyQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgYmFyIGNoYXJ0XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7c2l6ZTogb2JqZWN0LCBtb2RlbDogb2JqZWN0LCBvcHRpb25zOiBvYmplY3QsIHRvb2x0aXBQb3NpdGlvbjogc3RyaW5nfX0gZGF0YSBjaGFydCBkYXRhXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGdyb3VwQm91bmRzID0gZGF0YS5ncm91cEJvdW5kcyxcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgcGFwZXIsIGJhc2VQYXJhbXM7XG5cbiAgICAgICAgaWYgKCFncm91cEJvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSBSYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICBiYXNlUGFyYW1zID0ge1xuICAgICAgICAgICAgcGFwZXI6IHBhcGVyLFxuICAgICAgICAgICAgdGhlbWU6IGRhdGEudGhlbWUsXG4gICAgICAgICAgICBncm91cEJvdW5kczogZ3JvdXBCb3VuZHMsXG4gICAgICAgICAgICBncm91cFZhbHVlczogZGF0YS5ncm91cFZhbHVlcyxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogZGF0YS5jaGFydFR5cGVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJCYXJzKGJhc2VQYXJhbXMpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckJhckJvcmRlcnMoYmFzZVBhcmFtcyk7XG5cbiAgICAgICAgdGhpcy50aGVtZSA9IGRhdGEudGhlbWU7XG4gICAgICAgIHRoaXMuZ3JvdXBCb3VuZHMgPSBncm91cEJvdW5kcztcbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBkYXRhLmNoYXJ0VHlwZTtcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY29sb3Igc2VyaWVzIGNvbG9yXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmJvcmRlckNvbG9yIHNlcmllcyBib3JkZXJDb2xvclxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuYm91bmQgYm91bmRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgcmVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckJhcjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgIHJlY3Q7XG4gICAgICAgIGlmIChib3VuZC53aWR0aCA8IDAgfHwgYm91bmQuaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZWN0ID0gcGFyYW1zLnBhcGVyLnJlY3QoYm91bmQubGVmdCwgYm91bmQudG9wLCBib3VuZC53aWR0aCwgYm91bmQuaGVpZ2h0KTtcbiAgICAgICAgcmVjdC5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IHBhcmFtcy5jb2xvcixcbiAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYmFycy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMucGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqICAgICAgQHBhcmFtIHt7Y29sb3JzOiBzdHJpbmdbXSwgc2luZ2xlQ29sb3JzOiBzdHJpbmdbXSwgYm9yZGVyQ29sb3I6IHN0cmluZ319IHBhcmFtcy50aGVtZSBiYXIgY2hhcnQgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0+Pn0gcGFyYW1zLmdyb3VwQm91bmRzIGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckJhcnM6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc2luZ2xlQ29sb3JzID0gKHBhcmFtcy5ncm91cEJvdW5kc1swXS5sZW5ndGggPT09IDEpICYmIHBhcmFtcy50aGVtZS5zaW5nbGVDb2xvcnMgfHwgW10sXG4gICAgICAgICAgICBjb2xvcnMgPSBwYXJhbXMudGhlbWUuY29sb3JzO1xuICAgICAgICB0aGlzLmdyb3VwQmFycyA9IHR1aS51dGlsLm1hcChwYXJhbXMuZ3JvdXBCb3VuZHMsIGZ1bmN0aW9uKGJvdW5kcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIHNpbmdsZUNvbG9yID0gc2luZ2xlQ29sb3JzW2dyb3VwSW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChib3VuZHMsIGZ1bmN0aW9uKGJvdW5kLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciwgcmVjdCwgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbG9yID0gc2luZ2xlQ29sb3IgfHwgY29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtcy5ncm91cFZhbHVlc1tncm91cEluZGV4XVtpbmRleF07XG5cbiAgICAgICAgICAgICAgICByZWN0ID0gdGhpcy5fcmVuZGVyQmFyKHtcbiAgICAgICAgICAgICAgICAgICAgcGFwZXI6IHBhcmFtcy5wYXBlcixcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBwYXJhbXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBwYXJhbXMudGhlbWUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZC5lbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSByZWN0IHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgcmVjdCBib3VuZFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBsZWZ0VG9wOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0sXG4gICAgICogICAgICByaWdodFRvcDoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9LFxuICAgICAqICAgICAgcmlnaHRCb3R0b206IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGxlZnRCb3R0b206IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IHJlY3QgcG9pbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJlY3RQb2ludHM6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0VG9wOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGJvdW5kLmxlZnQpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGJvdW5kLnRvcClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodFRvcDoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGguY2VpbChib3VuZC5sZWZ0ICsgYm91bmQud2lkdGgpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGJvdW5kLnRvcClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodEJvdHRvbToge1xuICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGguY2VpbChib3VuZC5sZWZ0ICsgYm91bmQud2lkdGgpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGJvdW5kLnRvcCArIGJvdW5kLmhlaWdodClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWZ0Qm90dG9tOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGJvdW5kLmxlZnQpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGJvdW5kLnRvcCArIGJvdW5kLmhlaWdodClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSB0b3AgbGluZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJyZXIsIHRvcDogbnVtYmVyfX0gbGVmdFRvcCBsZWZ0IHRvcFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJyZXIsIHRvcDogbnVtYmVyfX0gcmlnaHRUb3AgcmlnaHQgdG9wXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9wIGxpbmUgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb3BMaW5lUGF0aDogZnVuY3Rpb24obGVmdFRvcCwgcmlnaHRUb3AsIGNoYXJ0VHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNsb25lTGVmdFRvcCA9IHR1aS51dGlsLmV4dGVuZCh7fSwgbGVmdFRvcCk7XG4gICAgICAgIGNsb25lTGVmdFRvcC5sZWZ0IC09IGNoYXJ0VHlwZSA9PT0gJ2NvbHVtbicgfHwgdmFsdWUgPCAwID8gMSA6IDA7XG4gICAgICAgIHJldHVybiByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgoY2xvbmVMZWZ0VG9wLCByaWdodFRvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYm9yZGVyIGxpbmVzIHBhdGhzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCByZWN0IGJvdW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHJldHVybnMge3t0b3A6IHN0cmluZywgcmlnaHQ6IHN0cmluZywgYm90dG9tOiBzdHJpbmcsIGxlZnQ6IHN0cmluZ319IHBhdGhzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvcmRlckxpbmVzUGF0aHM6IGZ1bmN0aW9uKGJvdW5kLCBjaGFydFR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9tYWtlUmVjdFBvaW50cyhib3VuZCksXG4gICAgICAgICAgICBwYXRocyA9IHt9O1xuXG4gICAgICAgIGlmIChjaGFydFR5cGUgPT09ICdiYXInIHx8IHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIHBhdGhzLnRvcCA9IHRoaXMuX21ha2VUb3BMaW5lUGF0aChwb2ludHMubGVmdFRvcCwgcG9pbnRzLnJpZ2h0VG9wLCBjaGFydFR5cGUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFydFR5cGUgPT09ICdjb2x1bW4nIHx8IHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIHBhdGhzLnJpZ2h0ID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvaW50cy5yaWdodFRvcCwgcG9pbnRzLnJpZ2h0Qm90dG9tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFydFR5cGUgPT09ICdiYXInIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgcGF0aHMuYm90dG9tID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvaW50cy5sZWZ0Qm90dG9tLCBwb2ludHMucmlnaHRCb3R0b20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gJ2NvbHVtbicgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBwYXRocy5sZWZ0ID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvaW50cy5sZWZ0VG9wLCBwb2ludHMubGVmdEJvdHRvbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBib3JkZXIgbGluZXM7XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnBhcGVyIHBhcGVyXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmJvdW5kIGJhciBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5ib3JkZXJDb2xvciBib3JkZXIgY29sb3JcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmFsdWUgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckJvcmRlckxpbmVzOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGJvcmRlckxpbmVQYXRocyA9IHRoaXMuX21ha2VCb3JkZXJMaW5lc1BhdGhzKHBhcmFtcy5ib3VuZCwgcGFyYW1zLmNoYXJ0VHlwZSwgcGFyYW1zLnZhbHVlKSxcbiAgICAgICAgICAgIGxpbmVzID0ge307XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goYm9yZGVyTGluZVBhdGhzLCBmdW5jdGlvbihwYXRoLCBuYW1lKSB7XG4gICAgICAgICAgICBsaW5lc1tuYW1lXSA9IHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckxpbmUocGFyYW1zLnBhcGVyLCBwYXRoLCBwYXJhbXMuYm9yZGVyQ29sb3IsIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYmFyIGJvcmRlcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7e2NvbG9yczogc3RyaW5nW10sIHNpbmdsZUNvbG9yczogc3RyaW5nW10sIGJvcmRlckNvbG9yOiBzdHJpbmd9fSBwYXJhbXMudGhlbWUgYmFyIGNoYXJ0IHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxhcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9Pj59IHBhcmFtcy5ncm91cEJvdW5kcyBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJCYXJCb3JkZXJzOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGJvcmRlckNvbG9yID0gcGFyYW1zLnRoZW1lLmJvcmRlckNvbG9yO1xuICAgICAgICBpZiAoIWJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncm91cEJvcmRlcnMgPSB0dWkudXRpbC5tYXAocGFyYW1zLmdyb3VwQm91bmRzLCBmdW5jdGlvbihib3VuZHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYm91bmRzLCBmdW5jdGlvbihib3VuZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW1zLmdyb3VwVmFsdWVzW2dyb3VwSW5kZXhdW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJCb3JkZXJMaW5lcyh7XG4gICAgICAgICAgICAgICAgICAgIHBhcGVyOiBwYXJhbXMucGFwZXIsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IHBhcmFtcy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIHJlY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlY3QgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgcmVjdCBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVSZWN0OiBmdW5jdGlvbihyZWN0LCBib3VuZCkge1xuICAgICAgICByZWN0LmFuaW1hdGUoe1xuICAgICAgICAgICAgeDogYm91bmQubGVmdCxcbiAgICAgICAgICAgIHk6IGJvdW5kLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYm91bmQuaGVpZ2h0XG4gICAgICAgIH0sIEFOSU1BVElPTl9USU1FKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSBib3JkZXJzLlxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IGxpbmVzIHJhcGhhZWwgb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCByZWN0IGJvdW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUJvcmRlcnM6IGZ1bmN0aW9uKGxpbmVzLCBib3VuZCwgY2hhcnRUeXBlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLl9tYWtlQm9yZGVyTGluZXNQYXRocyhib3VuZCwgY2hhcnRUeXBlLCB2YWx1ZSk7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2gobGluZXMsIGZ1bmN0aW9uKGxpbmUsIG5hbWUpIHtcbiAgICAgICAgICAgIGxpbmUuYW5pbWF0ZSh7cGF0aDogcGF0aHNbbmFtZV19LCBBTklNQVRJT05fVElNRSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuZ3JvdXBCYXJzLCBmdW5jdGlvbihiYXJzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYm9yZGVycyA9IHRoaXMuZ3JvdXBCb3JkZXJzICYmIHRoaXMuZ3JvdXBCb3JkZXJzW2dyb3VwSW5kZXhdO1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGJhcnMsIGZ1bmN0aW9uKGJhciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBib3JkZXJzICYmIGJvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVSZWN0KGJhci5yZWN0LCBiYXIuYm91bmQpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlQm9yZGVycyhsaW5lcywgYmFyLmJvdW5kLCB0aGlzLmNoYXJ0VHlwZSwgYmFyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBBTklNQVRJT05fVElNRSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gdXBkYXRlIHJlY3QgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlY3QgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUmVjdEF0dHI6IGZ1bmN0aW9uKHJlY3QsIGJvdW5kKSB7XG4gICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICB4OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgeTogYm91bmQudG9wLFxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZC5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHVwZGF0ZSBib3JkZXJzIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IGxpbmVzIHJhcGhhZWwgb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVCb3JkZXJzQXR0cjogZnVuY3Rpb24obGluZXMsIGJvdW5kLCBjaGFydFR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMuX21ha2VCb3JkZXJMaW5lc1BhdGhzKGJvdW5kLCBjaGFydFR5cGUsIHZhbHVlKTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChsaW5lcywgZnVuY3Rpb24obGluZSwgbmFtZSkge1xuICAgICAgICAgICAgbGluZS5hdHRyKHtwYXRoOiBwYXRoc1tuYW1lXX0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVzaXplIGdyYXBoIG9mIGJhciB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxhcnJheS48e2xlZnQ6bnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0+Pn0gcGFyYW1zLmdyb3VwQm91bmRzIGdyb3VwIGJvdW5kc1xuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBwYXJhbXMuZGltZW5zaW9uLFxuICAgICAgICAgICAgZ3JvdXBCb3VuZHMgPSBwYXJhbXMuZ3JvdXBCb3VuZHM7XG5cbiAgICAgICAgdGhpcy5ncm91cEJvdW5kcyA9IGdyb3VwQm91bmRzO1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cEJhcnMsIGZ1bmN0aW9uKGJhcnMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBib3JkZXJzID0gdGhpcy5ncm91cEJvcmRlcnMgJiYgdGhpcy5ncm91cEJvcmRlcnNbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoYmFycywgZnVuY3Rpb24oYmFyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGJvcmRlcnMgJiYgYm9yZGVyc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kID0gZ3JvdXBCb3VuZHNbZ3JvdXBJbmRleF1baW5kZXhdLmVuZDtcbiAgICAgICAgICAgICAgICBiYXIuYm91bmQgPSBib3VuZDtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVSZWN0QXR0cihiYXIucmVjdCwgYm91bmQpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVCb3JkZXJzQXR0cihsaW5lcywgYm91bmQsIHRoaXMuY2hhcnRUeXBlLCBiYXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGJvcmRlcnMgY29sb3IuXG4gICAgICogQHBhcmFtIHthcnJheS48b2JqZWN0Pn0gbGluZXMgcmFwaGFlbCBvYmplY3RzXG4gICAgICogQHBhcmFtIHtib3JkZXJDb2xvcn0gYm9yZGVyQ29sb3IgYm9yZGVyIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hhbmdlQm9yZGVyc0NvbG9yOiBmdW5jdGlvbihsaW5lcywgYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChsaW5lcywgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgbGluZS5hdHRyKHtzdHJva2U6IGJvcmRlckNvbG9yfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjaGFuZ2UgYmFyIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBib3JkZXJDb2xvciBzdHJva2UgY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGFuZ2VCYXJDb2xvcjogZnVuY3Rpb24oaW5kZXhlcywgY29sb3IsIGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tpbmRleGVzLmdyb3VwSW5kZXhdW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgbGluZXM7XG5cbiAgICAgICAgYmFyLnJlY3QuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGxpbmVzID0gdGhpcy5ncm91cEJvcmRlcnNbaW5kZXhlcy5ncm91cEluZGV4XVtpbmRleGVzLmluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUJvcmRlcnNDb2xvcihsaW5lcywgYm9yZGVyQ29sb3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tpbmRleGVzLmdyb3VwSW5kZXhdW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgb2JqQ29sb3IgPSBSYXBoYWVsLmNvbG9yKGJhci5jb2xvciksXG4gICAgICAgICAgICBjb2xvciA9IHRoaXMudGhlbWUuc2VsZWN0aW9uQ29sb3IgfHwgcmFwaGFlbFJlbmRlclV0aWwubWFrZUNoYW5nZWRMdW1pbmFuY2VDb2xvcihvYmpDb2xvci5oZXgsIDAuMiksXG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHRoaXMudGhlbWUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBvYmpCb3JkZXJDb2xvcjtcblxuICAgICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIG9iakJvcmRlckNvbG9yID0gUmFwaGFlbC5jb2xvcihib3JkZXJDb2xvcik7XG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VDaGFuZ2VkTHVtaW5hbmNlQ29sb3Iob2JqQm9yZGVyQ29sb3IuaGV4LCAwLjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlQmFyQ29sb3IoaW5kZXhlcywgY29sb3IsIGJvcmRlckNvbG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5zZWxlY3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqL1xuICAgIHVuc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tpbmRleGVzLmdyb3VwSW5kZXhdW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLnRoZW1lLmJvcmRlckNvbG9yO1xuICAgICAgICB0aGlzLl9jaGFuZ2VCYXJDb2xvcihpbmRleGVzLCBiYXIuY29sb3IsIGJvcmRlckNvbG9yKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsQmFyQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbCBsaW5lIGNoYXJ0IHJlbmRlcmVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmFwaGFlbExpbmVCYXNlID0gcmVxdWlyZSgnLi9yYXBoYWVsTGluZVR5cGVCYXNlJyksXG4gICAgcmFwaGFlbFJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JhcGhhZWxSZW5kZXJVdGlsJyk7XG5cbnZhciBSYXBoYWVsID0gd2luZG93LlJhcGhhZWwsXG4gICAgQU5JTUFUSU9OX1RJTUUgPSA3MDA7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsTGluZUNoYXJ0cyBpcyBncmFwaCByZW5kZXJlciBmb3IgbGluZSBjaGFydC5cbiAqIEBjbGFzcyBSYXBoYWVsTGluZUNoYXJ0XG4gKiBAZXh0ZW5kcyBSYXBoYWVsTGluZVR5cGVCYXNlXG4gKi9cbnZhciBSYXBoYWVsTGluZUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoUmFwaGFlbExpbmVCYXNlLCAvKiogQGxlbmRzIFJhcGhhZWxMaW5lQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgbGluZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHt7Z3JvdXBQb3NpdGlvbnM6IGFycmF5LjxhcnJheT4sIGRpbWVuc2lvbjogb2JqZWN0LCB0aGVtZTogb2JqZWN0LCBvcHRpb25zOiBvYmplY3R9fSBkYXRhIHJlbmRlciBkYXRhXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSBkYXRhLmdyb3VwUG9zaXRpb25zLFxuICAgICAgICAgICAgdGhlbWUgPSBkYXRhLnRoZW1lLFxuICAgICAgICAgICAgY29sb3JzID0gdGhlbWUuY29sb3JzLFxuICAgICAgICAgICAgb3BhY2l0eSA9IGRhdGEub3B0aW9ucy5oYXNEb3QgPyAxIDogMCxcbiAgICAgICAgICAgIGdyb3VwUGF0aHMgPSB0aGlzLl9nZXRMaW5lc1BhdGgoZ3JvdXBQb3NpdGlvbnMpLFxuICAgICAgICAgICAgYm9yZGVyU3R5bGUgPSB0aGlzLm1ha2VCb3JkZXJTdHlsZSh0aGVtZS5ib3JkZXJDb2xvciwgb3BhY2l0eSksXG4gICAgICAgICAgICBvdXREb3RTdHlsZSA9IHRoaXMubWFrZU91dERvdFN0eWxlKG9wYWNpdHksIGJvcmRlclN0eWxlKSxcbiAgICAgICAgICAgIHBhcGVyLCBncm91cExpbmVzLCB0b29sdGlwTGluZSwgc2VsZWN0aW9uRG90LCBncm91cERvdHM7XG5cbiAgICAgICAgdGhpcy5wYXBlciA9IHBhcGVyID0gUmFwaGFlbChjb250YWluZXIsIGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG5cbiAgICAgICAgZ3JvdXBMaW5lcyA9IHRoaXMuX3JlbmRlckxpbmVzKHBhcGVyLCBncm91cFBhdGhzLCBjb2xvcnMpO1xuICAgICAgICB0b29sdGlwTGluZSA9IHRoaXMuX3JlbmRlclRvb2x0aXBMaW5lKHBhcGVyLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgc2VsZWN0aW9uRG90ID0gdGhpcy5fbWFrZVNlbGVjdGlvbkRvdChwYXBlcik7XG4gICAgICAgIGdyb3VwRG90cyA9IHRoaXMuX3JlbmRlckRvdHMocGFwZXIsIGdyb3VwUG9zaXRpb25zLCBjb2xvcnMsIGJvcmRlclN0eWxlKTtcblxuICAgICAgICBpZiAoZGF0YS5vcHRpb25zLmhhc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Eb3QgPSBzZWxlY3Rpb25Eb3Q7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbG9yID0gdGhlbWUuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvcmRlclN0eWxlID0gYm9yZGVyU3R5bGU7XG4gICAgICAgIHRoaXMub3V0RG90U3R5bGUgPSBvdXREb3RTdHlsZTtcbiAgICAgICAgdGhpcy5ncm91cFBvc2l0aW9ucyA9IGdyb3VwUG9zaXRpb25zO1xuICAgICAgICB0aGlzLmdyb3VwUGF0aHMgPSBncm91cFBhdGhzO1xuICAgICAgICB0aGlzLmdyb3VwTGluZXMgPSBncm91cExpbmVzO1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lID0gdG9vbHRpcExpbmU7XG4gICAgICAgIHRoaXMuZ3JvdXBEb3RzID0gZ3JvdXBEb3RzO1xuICAgICAgICB0aGlzLmRvdE9wYWNpdHkgPSBvcGFjaXR5O1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxpbmVzIHBhdGguXG4gICAgICogQHBhcmFtIHthcnJheS48YXJyYXkuPG9iamVjdD4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPGFycmF5LjxzdHJpbmc+Pn0gcGF0aHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMaW5lc1BhdGg6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBncm91cFBhdGhzID0gdHVpLnV0aWwubWFwKGdyb3VwUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBmcm9tUG9zID0gcG9zaXRpb25zWzBdLFxuICAgICAgICAgICAgICAgIHJlc3QgPSBwb3NpdGlvbnMuc2xpY2UoMSk7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHJlc3QsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubWFrZUxpbmVQYXRoKGZyb21Qb3MsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBmcm9tUG9zID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwUGF0aHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7YXJyYXkuPGFycmF5LjxzdHJpbmc+Pn0gZ3JvdXBQYXRocyBwYXRoc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNvbG9ycyBsaW5lIGNvbG9yc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VXaWR0aCBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPGFycmF5LjxvYmplY3Q+Pn0gbGluZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJMaW5lczogZnVuY3Rpb24ocGFwZXIsIGdyb3VwUGF0aHMsIGNvbG9ycywgc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgdmFyIGdyb3VwTGluZXMgPSB0dWkudXRpbC5tYXAoZ3JvdXBQYXRocywgZnVuY3Rpb24ocGF0aHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yc1tncm91cEluZGV4XSB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJMaW5lKHBhcGVyLCBwYXRoLnN0YXJ0LCBjb2xvciwgc3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBncm91cExpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRpbWUgPSBBTklNQVRJT05fVElNRSAvIHRoaXMuZ3JvdXBMaW5lc1swXS5sZW5ndGgsXG4gICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMucmVuZGVySXRlbXMoZnVuY3Rpb24oZG90LCBncm91cEluZGV4LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxpbmUsIHBhdGg7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSB0aGF0Lmdyb3VwTGluZXNbZ3JvdXBJbmRleF1baW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBwYXRoID0gdGhhdC5ncm91cFBhdGhzW2dyb3VwSW5kZXhdW2luZGV4IC0gMV0uZW5kO1xuICAgICAgICAgICAgICAgIHRoYXQuYW5pbWF0ZUxpbmUobGluZSwgcGF0aCwgdGltZSwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgKz0gdGltZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoYXQuZG90T3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvdC5hdHRyKHR1aS51dGlsLmV4dGVuZCh7J2ZpbGwtb3BhY2l0eSc6IHRoYXQuZG90T3BhY2l0eX0sIHRoYXQuYm9yZGVyU3R5bGUpKTtcbiAgICAgICAgICAgICAgICB9LCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIHN0YXJ0VGltZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVzaXplIGdyYXBoIG9mIGxpbmUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Ljx7bGVmdDpudW1iZXIsIHRvcDpudW1iZXJ9Pj59IHBhcmFtcy5ncm91cFBvc2l0aW9ucyBncm91cCBwb3NpdGlvbnNcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gcGFyYW1zLmRpbWVuc2lvbixcbiAgICAgICAgICAgIGdyb3VwUG9zaXRpb25zID0gcGFyYW1zLmdyb3VwUG9zaXRpb25zLFxuICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5ncm91cFBvc2l0aW9ucyA9IGdyb3VwUG9zaXRpb25zO1xuICAgICAgICB0aGlzLmdyb3VwUGF0aHMgPSB0aGlzLl9nZXRMaW5lc1BhdGgoZ3JvdXBQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50b29sdGlwTGluZS5hdHRyKHt0b3A6IGRpbWVuc2lvbi5oZWlnaHR9KTtcblxuICAgICAgICB0aGlzLnJlbmRlckl0ZW1zKGZ1bmN0aW9uKGRvdCwgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdyb3VwUG9zaXRpb25zW2dyb3VwSW5kZXhdW2luZGV4XSxcbiAgICAgICAgICAgICAgICBkb3RBdHRycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3g6IHBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBwb3NpdGlvbi50b3BcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxpbmUsIHBhdGg7XG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gdGhhdC5ncm91cExpbmVzW2dyb3VwSW5kZXhdW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgcGF0aCA9IHRoYXQuZ3JvdXBQYXRoc1tncm91cEluZGV4XVtpbmRleCAtIDFdLmVuZDtcbiAgICAgICAgICAgICAgICBsaW5lLmF0dHIoe3BhdGg6IHBhdGh9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoYXQuZG90T3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIGRvdEF0dHJzID0gdHVpLnV0aWwuZXh0ZW5kKHsnZmlsbC1vcGFjaXR5JzogdGhhdC5kb3RPcGFjaXR5fSwgZG90QXR0cnMsIHRoYXQuYm9yZGVyU3R5bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb3QuYXR0cihkb3RBdHRycyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWxMaW5lQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbExpbmVUeXBlQmFzZSBpcyBiYXNlIGNsYXNzIGZvciBsaW5lIHR5cGUgcmVuZGVyZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIERFRkFVTFRfRE9UX1JBRElVUyA9IDMsXG4gICAgSE9WRVJfRE9UX1JBRElVUyA9IDQsXG4gICAgU0VMRUNUSU9OX0RPVF9SQURJT1VTID0gNztcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFJhcGhhZWxMaW5lVHlwZUJhc2UgaXMgYmFzZSBmb3IgbGluZSB0eXBlIHJlbmRlcmVyLlxuICogQGNsYXNzIFJhcGhhZWxMaW5lVHlwZUJhc2VcbiAqL1xudmFyIFJhcGhhZWxMaW5lVHlwZUJhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFJhcGhhZWxMaW5lVHlwZUJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGxpbmUgcGF0aHMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGZyb21Qb3MgZnJvbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSB0b1BvcyB0byBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHt7c3RhcnQ6IHN0cmluZywgZW5kOiBzdHJpbmd9fSBsaW5lIHBhdGhzLlxuICAgICAqL1xuICAgIG1ha2VMaW5lUGF0aDogZnVuY3Rpb24oZnJvbVBvcywgdG9Qb3MpIHtcbiAgICAgICAgdmFyIHN0YXJ0TGluZVBhdGggPSByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgoZnJvbVBvcywgZnJvbVBvcyksXG4gICAgICAgICAgICBlbmRMaW5lUGF0aCA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aChmcm9tUG9zLCB0b1Bvcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRMaW5lUGF0aCxcbiAgICAgICAgICAgIGVuZDogZW5kTGluZVBhdGhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRvb2x0aXAgbGluZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0XG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUb29sdGlwTGluZTogZnVuY3Rpb24ocGFwZXIsIGhlaWdodCkge1xuICAgICAgICB2YXIgbGluZVBhdGggPSByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IDEwLFxuICAgICAgICAgICAgICAgIHRvcDogaGVpZ2h0XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGVmdDogMTAsXG4gICAgICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckxpbmUocGFwZXIsIGxpbmVQYXRoLCAndHJhbnNwYXJlbnQnLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBib3JkZXIgc3R5bGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvcmRlckNvbG9yIGJvcmRlciBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7e3N0cm9rZTogc3RyaW5nLCBzdHJva2Utd2lkdGg6IG51bWJlciwgc3RyaWtlLW9wYWNpdHk6IG51bWJlcn19IGJvcmRlciBzdHlsZVxuICAgICAqL1xuICAgIG1ha2VCb3JkZXJTdHlsZTogZnVuY3Rpb24oYm9yZGVyQ29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIGJvcmRlclN0eWxlO1xuICAgICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGJvcmRlclN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDEsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogb3BhY2l0eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9yZGVyU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgZG90IHN0eWxlIGZvciBtb3VzZW91dCBldmVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBvcGFjaXR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvcmRlclN0eWxlIGJvcmRlciBzdHlsZVxuICAgICAqIEByZXR1cm5zIHt7ZmlsbC1vcGFjaXR5OiBudW1iZXIsIHN0cm9rZS1vcGFjaXR5OiBudW1iZXIsIHI6IG51bWJlcn19IHN0eWxlXG4gICAgICovXG4gICAgbWFrZU91dERvdFN0eWxlOiBmdW5jdGlvbihvcGFjaXR5LCBib3JkZXJTdHlsZSkge1xuICAgICAgICB2YXIgb3V0RG90U3R5bGUgPSB7XG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogb3BhY2l0eSxcbiAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICByOiBERUZBVUxUX0RPVF9SQURJVVNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmV4dGVuZChvdXREb3RTdHlsZSwgYm9yZGVyU3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dERvdFN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZG90LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGFlclxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBkb3QgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgZG90IGNvbG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvcmRlclN0eWxlIGJvcmRlciBzdHlsZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJhcGhhZWwgZG90XG4gICAgICovXG4gICAgcmVuZGVyRG90OiBmdW5jdGlvbihwYXBlciwgcG9zaXRpb24sIGNvbG9yKSB7XG4gICAgICAgIHZhciBkb3QgPSBwYXBlci5jaXJjbGUocG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wLCBERUZBVUxUX0RPVF9SQURJVVMpLFxuICAgICAgICAgICAgZG90U3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBkb3QuYXR0cihkb3RTdHlsZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvdDogZG90LFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBkb3RzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICogQHBhcmFtIHthcnJheS48YXJyYXkuPG9iamVjdD4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb2xvcnMgY29sb3JzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvcmRlclN0eWxlIGJvcmRlciBzdHlsZVxuICAgICAqIEByZXR1cm5zIHthcnJheS48b2JqZWN0Pn0gZG90c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckRvdHM6IGZ1bmN0aW9uKHBhcGVyLCBncm91cFBvc2l0aW9ucywgY29sb3JzKSB7XG4gICAgICAgIHZhciBkb3RzID0gdHVpLnV0aWwubWFwKGdyb3VwUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbnMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBkb3QgPSB0aGlzLnJlbmRlckRvdChwYXBlciwgcG9zaXRpb24sIGNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG90O1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBkb3RzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2VudGVyIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGZyb21Qb3MgZnJvbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSB0b1BvcyB0byBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2VudGVyOiBmdW5jdGlvbihmcm9tUG9zLCB0b1Bvcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogKGZyb21Qb3MubGVmdCArIHRvUG9zLmxlZnQpIC8gMixcbiAgICAgICAgICAgIHRvcDogKGZyb21Qb3MudG9wICsgdG9Qb3MudG9wKSAvIDJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBkb3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRvdCByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dEb3Q6IGZ1bmN0aW9uKGRvdCkge1xuICAgICAgICBkb3QuYXR0cih7XG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDAuMyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAgICAgcjogSE9WRVJfRE9UX1JBRElVU1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDpudW1iZXJ9fSBkYXRhIHNob3cgaW5mb1xuICAgICAqL1xuICAgIHNob3dBbmltYXRpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZGF0YS5ncm91cEluZGV4LCAvLyBMaW5lIGNoYXJ0IGhhcyBwaXZvdCB2YWx1ZXMuXG4gICAgICAgICAgICBncm91cEluZGV4ID0gZGF0YS5pbmRleCxcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmdyb3VwRG90c1tncm91cEluZGV4XVtpbmRleF07XG4gICAgICAgIHRoaXMuX3Nob3dEb3QoaXRlbS5kb3QpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGl2b3QgZ3JvdXAgZG90cy5cbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPGFycmF5Pn0gZG90c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBpdm90R3JvdXBEb3RzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBpdm90R3JvdXBEb3RzKSB7XG4gICAgICAgICAgICB0aGlzLnBpdm90R3JvdXBEb3RzID0gdHVpLnV0aWwucGl2b3QodGhpcy5ncm91cERvdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGl2b3RHcm91cERvdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgZ3JvdXAgZG90cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93R3JvdXBEb3RzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgZ3JvdXBEb3RzID0gdGhpcy5fZ2V0UGl2b3RHcm91cERvdHMoKTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwRG90c1tpbmRleF0sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dEb3QoaXRlbS5kb3QpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBsaW5lIGZvciBncm91cCB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGJvdW5kIGJvdW5kXG4gICAgICovXG4gICAgc2hvd0dyb3VwVG9vbHRpcExpbmU6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHZhciBsaW5lUGF0aCA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aCh7XG4gICAgICAgICAgICBsZWZ0OiBib3VuZC5wb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBib3VuZC5kaW1lbnNpb24uaGVpZ2h0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kLnBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICB0b3A6IGJvdW5kLnBvc2l0aW9uLnRvcFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sdGlwTGluZS5hdHRyKHtcbiAgICAgICAgICAgIHBhdGg6IGxpbmVQYXRoLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzk5OScsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGdyb3VwIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBzaG93R3JvdXBBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3Nob3dHcm91cERvdHMoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGRvdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZG90IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZURvdDogZnVuY3Rpb24oZG90KSB7XG4gICAgICAgIGRvdC5hdHRyKHRoaXMub3V0RG90U3R5bGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4Om51bWJlcn19IGRhdGEgaGlkZSBpbmZvXG4gICAgICovXG4gICAgaGlkZUFuaW1hdGlvbjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgaW5kZXggPSBkYXRhLmdyb3VwSW5kZXgsIC8vIExpbmUgY2hhcnQgaGFzIHBpdm90IHZhbHVlcy5cbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSBkYXRhLmluZGV4LFxuICAgICAgICAgICAgaXRlbSA9IHRoaXMuZ3JvdXBEb3RzW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVEb3QoaXRlbS5kb3QpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgZ3JvdXAgZG90cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlR3JvdXBEb3RzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgZG90cyA9IHRoaXMuX2dldFBpdm90R3JvdXBEb3RzKCk7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShkb3RzW2luZGV4XSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZURvdChpdGVtLmRvdCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGxpbmUgZm9yIGdyb3VwIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBoaWRlR3JvdXBUb29sdGlwTGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcExpbmUuYXR0cih7XG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGdyb3VwIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBoaWRlR3JvdXBBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2hpZGVHcm91cERvdHMoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGxpbmUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxpbmUgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZVBhdGggbGluZSBwYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgcGxheSB0aW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0VGltZSBzdGFydCB0aW1lXG4gICAgICovXG4gICAgYW5pbWF0ZUxpbmU6IGZ1bmN0aW9uKGxpbmUsIGxpbmVQYXRoLCB0aW1lLCBzdGFydFRpbWUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxpbmUuYW5pbWF0ZSh7cGF0aDogbGluZVBhdGh9LCB0aW1lKTtcbiAgICAgICAgfSwgc3RhcnRUaW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVuZGVyIGl0ZW1zIG9mIGxpbmUgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmVuZGVySXRlbSBmdW5jdGlvblxuICAgICAqL1xuICAgIHJlbmRlckl0ZW1zOiBmdW5jdGlvbihmdW5jUmVuZGVySXRlbSkge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cERvdHMsIGZ1bmN0aW9uKGRvdHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShkb3RzLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGZ1bmNSZW5kZXJJdGVtKGl0ZW0uZG90LCBncm91cEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugc2VsZWN0aW9uIGRvdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHNlbGVjdGlvbiBkb3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VsZWN0aW9uRG90OiBmdW5jdGlvbihwYXBlcikge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRG90ID0gcGFwZXIuY2lyY2xlKDAsIDAsIFNFTEVDVElPTl9ET1RfUkFESU9VUyk7XG4gICAgICAgIHNlbGVjdGlvbkRvdC5hdHRyKHtcbiAgICAgICAgICAgICdmaWxsJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25Eb3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5ncm91cERvdHNbaW5kZXhlcy5pbmRleF1baW5kZXhlcy5ncm91cEluZGV4XSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5ncm91cFBvc2l0aW9uc1tpbmRleGVzLmluZGV4XVtpbmRleGVzLmdyb3VwSW5kZXhdO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRG90LmF0dHIoe1xuICAgICAgICAgICAgY3g6IHBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICBjeTogcG9zaXRpb24udG9wLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuNSxcbiAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICAgICAgICAgICBzdHJva2U6IHRoaXMuc2VsZWN0aW9uQ29sb3IgfHwgaXRlbS5jb2xvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5zZWxlY3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqL1xuICAgIHVuc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5ncm91cERvdHNbaW5kZXhlcy5pbmRleF1baW5kZXhlcy5ncm91cEluZGV4XTtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEl0ZW0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRG90LmF0dHIoe1xuICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbExpbmVUeXBlQmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsUGllQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBwaWUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIFJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbCxcbiAgICBBTkdMRV8xODAgPSAxODAsXG4gICAgUkFEID0gTWF0aC5QSSAvIEFOR0xFXzE4MCxcbiAgICBBTklNQVRJT05fVElNRSA9IDUwMCxcbiAgICBMT0FESU5HX0FOSU1BVElPTl9USU1FID0gNzAwO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbFBpZUNoYXJ0cyBpcyBncmFwaCByZW5kZXJlciBmb3IgcGllIGNoYXJ0LlxuICogQGNsYXNzIFJhcGhhZWxQaWVDaGFydFxuICovXG52YXIgUmFwaGFlbFBpZUNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsUGllQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgcGllIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3tzZWN0b3JzSW5mbzogYXJyYXkuPG9iamVjdD4sIGNpcmNsZUJvdW5kOiB7Y3g6IG51bWJlciwgY3k6IG51bWJlciwgcjogbnVtYmVyfSwgZGltZW5zaW9uOiBvYmplY3QsIHRoZW1lOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdH19IGRhdGEgcmVuZGVyIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2tzIGNhbGxiYWNrc1xuICAgICAqICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmZ1bmNTaG93VG9vbHRpcCBzaG93IHRvb2x0aXAgZnVuY3Rpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5mdW5jSGlkZVRvb2x0aXAgaGlkZSB0b29sdGlwIGZ1bmN0aW9uXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuZnVuY1NlbGVjdFNlcmllcyBzZWxlY3Qgc2VyaWVzIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIGNhbGxiYWNrcykge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gZGF0YS5kaW1lbnNpb24sXG4gICAgICAgICAgICBwYXBlcjtcblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSBSYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICBpZiAoIXBhcGVyLmN1c3RvbUF0dHJpYnV0ZXMuc2VjdG9yKSB7XG4gICAgICAgICAgICBwYXBlci5jdXN0b21BdHRyaWJ1dGVzLnNlY3RvciA9IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZVNlY3RvclBhdGgsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Db2xvciA9IGRhdGEudGhlbWUuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIHRoaXMuY2lyY2xlQm91bmQgPSBkYXRhLmNpcmNsZUJvdW5kO1xuICAgICAgICB0aGlzLl9yZW5kZXJQaWUocGFwZXIsIGRhdGEsIGNhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuIHBhcGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHNlY3RvciBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeCBjZW50ZXIgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeSBjZW50ZXIgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlIHN0YXJ0IGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlIGVuZCBhbmdlbFxuICAgICAqIEByZXR1cm5zIHt7cGF0aDogYXJyYXl9fSBzZWN0b3IgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZWN0b3JQYXRoOiBmdW5jdGlvbihjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gICAgICAgIHZhciB4MSA9IGN4ICsgciAqIE1hdGguc2luKHN0YXJ0QW5nbGUgKiBSQUQpLCAvLyDsm5Ag7Zi47J2YIOyLnOyekSB4IOyijO2RnFxuICAgICAgICAgICAgeTEgPSBjeSAtIHIgKiBNYXRoLmNvcyhzdGFydEFuZ2xlICogUkFEKSwgLy8g7JuQIO2YuOydmCDsi5zsnpEgeSDsooztkZxcbiAgICAgICAgICAgIHgyID0gY3ggKyByICogTWF0aC5zaW4oZW5kQW5nbGUgKiBSQUQpLC8vIOybkCDtmLjsnZgg7KKF66OMIHgg7KKM7ZGcXG4gICAgICAgICAgICB5MiA9IGN5IC0gciAqIE1hdGguY29zKGVuZEFuZ2xlICogUkFEKSwgLy8g7JuQIO2YuOydmCDsooXro4wgeSDsooztkZxcbiAgICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSA+IEFOR0xFXzE4MCA/IDEgOiAwLFxuICAgICAgICAgICAgcGF0aCA9IFtcIk1cIiwgY3gsIGN5LFxuICAgICAgICAgICAgICAgIFwiTFwiLCB4MSwgeTEsXG4gICAgICAgICAgICAgICAgXCJBXCIsIHIsIHIsIDAsIGxhcmdlQXJjRmxhZywgMSwgeDIsIHkyLFxuICAgICAgICAgICAgICAgIFwiWlwiXG4gICAgICAgICAgICBdO1xuICAgICAgICAvLyBwYXRo7JeQIOuMgO2VnCDsnpDshLjtlZwg7ISk66qF7J2AIOyVhOuemCDrp4Htgazrpbwg7LC46rOgXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzNzY2hvb2xzLmNvbS9zdmcvc3ZnX3BhdGguYXNwXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZFxuICAgICAgICByZXR1cm4ge3BhdGg6IHBhdGh9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VjdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7e2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6bnVtYmVyfX0gcGFyYW1zLmNpcmNsZUJvdW5kIGNpcmNsZSBib3VuZHNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnRBbmdsZSBzdGFydCBhbmdsZVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmRBbmdsZSBlbmQgYW5nbGVcbiAgICAgKiAgICAgIEBwYXJhbSB7e2ZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmcsIHN0cmlrZS13aWR0aDogc3RyaW5nfX0gcGFyYW1zLmF0dHJzIGF0dHJzXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZWN0b3I6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGNpcmNsZUJvdW5kID0gcGFyYW1zLmNpcmNsZUJvdW5kLFxuICAgICAgICAgICAgYW5nbGVzID0gcGFyYW1zLmFuZ2xlcztcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXBlci5wYXRoKCkuYXR0cih7XG4gICAgICAgICAgICBzZWN0b3I6IFtjaXJjbGVCb3VuZC5jeCwgY2lyY2xlQm91bmQuY3ksIGNpcmNsZUJvdW5kLnIsIGFuZ2xlcy5zdGFydEFuZ2xlLCBhbmdsZXMuZW5kQW5nbGVdXG4gICAgICAgIH0pLmF0dHIocGFyYW1zLmF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHBpZSBncmFwaC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7e3NlY3RvcnNJbmZvOiBhcnJheS48b2JqZWN0PiwgY2lyY2xlQm91bmQ6IHtjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9LCBkaW1lbnNpb246IG9iamVjdCwgdGhlbWU6IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gZGF0YSByZW5kZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFja3MgY2FsbGJhY2tzXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuZnVuY1Nob3dUb29sdGlwIHNob3cgdG9vbHRpcCBmdW5jdGlvblxuICAgICAqICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmZ1bmNIaWRlVG9vbHRpcCBoaWRlIHRvb2x0aXAgZnVuY3Rpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5mdW5jU2VsZWN0U2VyaWVzIHNlbGVjdCBzZXJpZXMgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQaWU6IGZ1bmN0aW9uKHBhcGVyLCBkYXRhLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdmFyIGNpcmNsZUJvdW5kID0gZGF0YS5jaXJjbGVCb3VuZCxcbiAgICAgICAgICAgIGNvbG9ycyA9IGRhdGEudGhlbWUuY29sb3JzLFxuICAgICAgICAgICAgY2hhcnRCYWNrZ3JvdW5kID0gZGF0YS5jaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICBzZWN0b3JzID0gW107XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGRhdGEuc2VjdG9yc0luZm8sIGZ1bmN0aW9uKHNlY3RvckluZm8sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcGVyY2VudFZhbHVlID0gc2VjdG9ySW5mby5wZXJjZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcnNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIHNlY3RvciA9IHRoaXMuX3JlbmRlclNlY3Rvcih7XG4gICAgICAgICAgICAgICAgICAgIHBhcGVyOiBwYXBlcixcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlQm91bmQ6IGNpcmNsZUJvdW5kLFxuICAgICAgICAgICAgICAgICAgICBhbmdsZXM6IHNlY3RvckluZm8uYW5nbGVzLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IGNoYXJ0QmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fYmluZEhvdmVyRXZlbnQoc2VjdG9yLCBpbmRleCwgY2FsbGJhY2tzKTtcblxuICAgICAgICAgICAgc2VjdG9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWN0b3I6IHNlY3RvcixcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgYW5nbGVzOiBzZWN0b3JJbmZvLmFuZ2xlcy5lbmQsXG4gICAgICAgICAgICAgICAgcGVyY2VudFZhbHVlOiBwZXJjZW50VmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLnNlY3RvcnMgPSBzZWN0b3JzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGVnZW5kIGxpbmVzLlxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IG91dGVyUG9zaXRpb25zIG91dGVyIHBvc2l0aW9uXG4gICAgICovXG4gICAgcmVuZGVyTGVnZW5kTGluZXM6IGZ1bmN0aW9uKG91dGVyUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHBhdGhzO1xuXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZExpbmVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXRocyA9IHRoaXMuX21ha2VMaW5lUGF0aHMob3V0ZXJQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLmxlZ2VuZExpbmVzID0gdHVpLnV0aWwubWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZSh0aGF0LnBhcGVyLCBwYXRoLCAndHJhbnNwYXJlbnQnLCAxKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgbGluZSBwYXRocy5cbiAgICAgKiBAcGFyYW0ge2FycmF5LjxvYmplY3Q+fSBvdXRlclBvc2l0aW9ucyBvdXRlciBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGxpbmUgcGF0aHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxpbmVQYXRoczogZnVuY3Rpb24ob3V0ZXJQb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gdHVpLnV0aWwubWFwKG91dGVyUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvc2l0aW9ucy5zdGFydCwgcG9zaXRpb25zLm1pZGRsZSksXG4gICAgICAgICAgICAgICAgcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvc2l0aW9ucy5taWRkbGUsIHBvc2l0aW9ucy5lbmQpLFxuICAgICAgICAgICAgICAgICdaJ1xuICAgICAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmluZCBob3ZlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IHJhcGhhZWwgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFja3MgY2FsbGJhY2tzXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuZnVuY1Nob3dUb29sdGlwIHNob3cgdG9vbHRpcCBmdW5jdGlvblxuICAgICAqICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmZ1bmNIaWRlVG9vbHRpcCBoaWRlIHRvb2x0aXAgZnVuY3Rpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5mdW5jU2VsZWN0U2VyaWVzIHNlbGVjdCBzZXJpZXMgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iaW5kSG92ZXJFdmVudDogZnVuY3Rpb24odGFyZ2V0LCBpbmRleCwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3t9LCAwLCBpbmRleF0sXG4gICAgICAgICAgICBpc09uID0gZmFsc2UsXG4gICAgICAgICAgICB0aHJvdHRsZWQgPSB0dWkudXRpbC50aHJvdHRsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzT24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFja3MuZnVuY1Nob3dUb29sdGlwLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgIHRhcmdldC5tb3VzZW92ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYXJncyA9IGFyZ3MuY29uY2F0KHtcbiAgICAgICAgICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgY2xpZW50WTogZS5jbGllbnRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlzT24gPSB0cnVlO1xuICAgICAgICAgICAgY2FsbGJhY2tzLmZ1bmNTaG93VG9vbHRpcC5hcHBseShudWxsLCBfYXJncyk7XG4gICAgICAgIH0pLm1vdXNlbW92ZShmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgX2FyZ3MgPSBhcmdzLmNvbmNhdCh7XG4gICAgICAgICAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSAtIDEwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm90dGxlZC5hcHBseShudWxsLCBfYXJncyk7XG4gICAgICAgIH0pLm1vdXNlb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlzT24gPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mdW5jSGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfSkuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MuZnVuY1NlbGVjdFNlcmllcyhpbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBleHBhbmQgc2VsZWN0b3IgcmFkaXVzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZWN0b3IgcGllIHNlY3RvclxuICAgICAqL1xuICAgIF9leHBhbmRTZWN0b3I6IGZ1bmN0aW9uKHNlY3Rvcikge1xuICAgICAgICB2YXIgY3ggPSB0aGlzLmNpcmNsZUJvdW5kLmN4LFxuICAgICAgICAgICAgY3kgPSB0aGlzLmNpcmNsZUJvdW5kLmN5O1xuICAgICAgICBzZWN0b3IuYW5pbWF0ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwiczEuMSAxLjEgXCIgKyBjeCArIFwiIFwiICsgY3lcbiAgICAgICAgfSwgQU5JTUFUSU9OX1RJTUUsIFwiZWxhc3RpY1wiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVzdG9yZSBzZWxlY3RvciByYWRpdXMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlY3RvciBwaWUgc2VjdG9yXG4gICAgICovXG4gICAgX3Jlc3RvcmVTZWN0b3I6IGZ1bmN0aW9uKHNlY3Rvcikge1xuICAgICAgICBzZWN0b3IuYW5pbWF0ZSh7dHJhbnNmb3JtOiBcIlwifSwgQU5JTUFUSU9OX1RJTUUsIFwiZWxhc3RpY1wiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7aW5kZXg6IG51bWJlcn19IGRhdGEgZGF0YVxuICAgICAqL1xuICAgIHNob3dBbmltYXRpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHNlY3RvciA9IHRoaXMuc2VjdG9yc1tkYXRhLmluZGV4XS5zZWN0b3I7XG4gICAgICAgIHRoaXMuX2V4cGFuZFNlY3RvcihzZWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tpbmRleDogbnVtYmVyfX0gZGF0YSBkYXRhXG4gICAgICovXG4gICAgaGlkZUFuaW1hdGlvbjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5zZWN0b3JzW2RhdGEuaW5kZXhdLnNlY3RvcjtcbiAgICAgICAgdGhpcy5fcmVzdG9yZVNlY3RvcihzZWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRlbGF5VGltZSA9IDAsXG4gICAgICAgICAgICBjaXJjbGVCb3VuZCA9IHRoaXMuY2lyY2xlQm91bmQ7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLnNlY3RvcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBhbmdsZXMgPSBpdGVtLmFuZ2xlcyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25UaW1lID0gTE9BRElOR19BTklNQVRJT05fVElNRSAqIGl0ZW0ucGVyY2VudFZhbHVlLFxuICAgICAgICAgICAgICAgIGFuaW0gPSBSYXBoYWVsLmFuaW1hdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHNlY3RvcjogW2NpcmNsZUJvdW5kLmN4LCBjaXJjbGVCb3VuZC5jeSwgY2lyY2xlQm91bmQuciwgYW5nbGVzLnN0YXJ0QW5nbGUsIGFuZ2xlcy5lbmRBbmdsZV1cbiAgICAgICAgICAgICAgICB9LCBhbmltYXRpb25UaW1lKTtcbiAgICAgICAgICAgIGl0ZW0uc2VjdG9yLmFuaW1hdGUoYW5pbS5kZWxheShkZWxheVRpbWUpKTtcbiAgICAgICAgICAgIGRlbGF5VGltZSArPSBhbmltYXRpb25UaW1lO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5VGltZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSBsZWdlbmQgbGluZXMuXG4gICAgICovXG4gICAgYW5pbWF0ZUxlZ2VuZExpbmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxlZ2VuZExpbmVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMubGVnZW5kTGluZXMsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIGxpbmUuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRvIHJlc2l6ZSBncmFwaCBvZiBwaWUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7e2N4Om51bWJlciwgY3k6bnVtYmVyLCByOiBudW1iZXJ9fSBwYXJhbXMuY2lyY2xlQm91bmQgY2lyY2xlIGJvdW5kXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHBhcmFtcy5kaW1lbnNpb24sXG4gICAgICAgICAgICBjaXJjbGVCb3VuZCA9IHBhcmFtcy5jaXJjbGVCb3VuZDtcblxuICAgICAgICB0aGlzLmNpcmNsZUJvdW5kID0gY2lyY2xlQm91bmQ7XG4gICAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZShkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLnNlY3RvcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBhbmdsZXMgPSBpdGVtLmFuZ2xlcztcbiAgICAgICAgICAgIGl0ZW0uc2VjdG9yLmF0dHIoe1xuICAgICAgICAgICAgICAgIHNlY3RvcjogW2NpcmNsZUJvdW5kLmN4LCBjaXJjbGVCb3VuZC5jeSwgY2lyY2xlQm91bmQuciwgYW5nbGVzLnN0YXJ0QW5nbGUsIGFuZ2xlcy5lbmRBbmdsZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbW92ZSBsZWdlbmQgbGluZXMuXG4gICAgICogQHBhcmFtIHthcnJheS48b2JqZWN0Pn0gb3V0ZXJQb3NpdGlvbnMgb3V0ZXIgcG9zaXRpb25zXG4gICAgICovXG4gICAgbW92ZUxlZ2VuZExpbmVzOiBmdW5jdGlvbihvdXRlclBvc2l0aW9ucykge1xuICAgICAgICB2YXIgcGF0aHM7XG4gICAgICAgIGlmICghdGhpcy5sZWdlbmRMaW5lcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMgPSB0aGlzLl9tYWtlTGluZVBhdGhzKG91dGVyUG9zaXRpb25zKVxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5sZWdlbmRMaW5lcywgZnVuY3Rpb24obGluZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGxpbmUuYXR0cih7cGF0aDogcGF0aHNbaW5kZXhdfSk7XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5zZWN0b3JzW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgb2JqQ29sb3IgPSBSYXBoYWVsLmNvbG9yKGl0ZW0uY29sb3IpLFxuICAgICAgICAgICAgY29sb3IgPSB0aGlzLnNlbGVjdGlvbkNvbG9yIHx8IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VDaGFuZ2VkTHVtaW5hbmNlQ29sb3Iob2JqQ29sb3IuaGV4LCAwLjIpO1xuICAgICAgICBpdGVtLnNlY3Rvci5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGNvbG9yXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmVsZWN0IHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKi9cbiAgICB1bnNlbGVjdFNlcmllczogZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5zZWN0b3JzW2luZGV4ZXMuaW5kZXhdO1xuICAgICAgICBzZWN0b3Iuc2VjdG9yLmF0dHIoe1xuICAgICAgICAgICAgZmlsbDogc2VjdG9yLmNvbG9yXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWxQaWVDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsIGZvciByYXBoYWVsIHJlbmRlcmluZy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVdGlsIGZvciByYXBoYWVsIHJlbmRlcmluZy5cbiAqIEBtb2R1bGUgcmFwaGFlbFJlbmRlclV0aWxcbiAqL1xudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0ge1xuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgbGluZSBwYXRoLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmFwaGFlbFJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gZnJvbVBvcyBmcm9tIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHRvUG9zIHRvIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHdpZHRoXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGF0aFxuICAgICAqL1xuICAgIG1ha2VMaW5lUGF0aDogZnVuY3Rpb24oZnJvbVBvcywgdG9Qb3MsIHdpZHRoKSB7XG4gICAgICAgIHZhciBmcm9tUG9pbnQgPSBbZnJvbVBvcy5sZWZ0LCBmcm9tUG9zLnRvcF0sXG4gICAgICAgICAgICB0b1BvaW50ID0gW3RvUG9zLmxlZnQsIHRvUG9zLnRvcF07XG5cbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCAxO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShmcm9tUG9pbnQsIGZ1bmN0aW9uKGZyb20sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG9Qb2ludFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBmcm9tUG9pbnRbaW5kZXhdID0gdG9Qb2ludFtpbmRleF0gPSBNYXRoLnJvdW5kKGZyb20pIC0gKHdpZHRoICUgMiAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICdNJyArIGZyb21Qb2ludC5qb2luKCcgJykgKyAnTCcgKyB0b1BvaW50LmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxpbmUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyYXBoYWVsUmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbGluZSBwYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIGxpbmUgY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3Ryb2tlV2lkdGggc3Ryb2tlIHdpZHRoXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBsaW5lXG4gICAgICovXG4gICAgcmVuZGVyTGluZTogZnVuY3Rpb24ocGFwZXIsIHBhdGgsIGNvbG9yLCBzdHJva2VXaWR0aCkge1xuICAgICAgICB2YXIgbGluZSA9IHBhcGVyLnBhdGgoW3BhdGhdKSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoIHx8IDJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICBzdHJva2VTdHlsZS5zdHJva2UgPSAnI2ZmZic7XG4gICAgICAgICAgICBzdHJva2VTdHlsZVsnc3Ryb2tlLW9wYWNpdHknXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGluZS5hdHRyKHN0cm9rZVN0eWxlKTtcblxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBjaGFuZ2VkIGx1bWluYW5jZSBjb2xvci5cbiAgICAgKiBodHRwOi8vd3d3LnNpdGVwb2ludC5jb20vamF2YXNjcmlwdC1nZW5lcmF0ZS1saWdodGVyLWRhcmtlci1jb2xvci9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4IGhheCBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsdW0gbHVtaW5hbmNlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY2hhbmdlZCBjb2xvclxuICAgICAqL1xuICAgIG1ha2VDaGFuZ2VkTHVtaW5hbmNlQ29sb3I6IGZ1bmN0aW9uIChoZXgsIGx1bSkge1xuICAgICAgICAvLyB2YWxpZGF0ZSBoZXggc3RyaW5nXG4gICAgICAgIGhleCA9IFN0cmluZyhoZXgpLnJlcGxhY2UoL1teMC05YS1mXS9naSwgJycpO1xuXG4gICAgICAgIGlmIChoZXgubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgaGV4ID0gaGV4WzBdICsgaGV4WzBdICsgaGV4WzFdICsgaGV4WzFdICsgaGV4WzJdICsgaGV4WzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgbHVtID0gbHVtIHx8IDA7XG5cbiAgICAgICAgLy8gY29udmVydCB0byBkZWNpbWFsIGFuZCBjaGFuZ2UgbHVtaW5vc2l0eVxuICAgICAgICByZXR1cm4gJyMnICsgdHVpLnV0aWwubWFwKHR1aS51dGlsLnJhbmdlKDMpLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgdmFyIGMgPSBwYXJzZUludChoZXguc3Vic3RyKGluZGV4ICogMiwgMiksIDE2KTtcbiAgICAgICAgICAgIGMgPSBNYXRoLnJvdW5kKE1hdGgubWluKE1hdGgubWF4KDAsIGMgKyAoYyAqIGx1bSkpLCAyNTUpKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gKFwiMDBcIiArIGMpLnN1YnN0cihjLmxlbmd0aCk7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmFwaGFlbFJlbmRlclV0aWw7XG4iLCJpZiAoIXdpbmRvdy5KU09OKSB7XG4gICAgd2luZG93LkpTT04gPSB7XG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzSlNPTikgeyByZXR1cm4gZXZhbCgnKCcgKyBzSlNPTiArICcpJyk7IH0sXG4gICAgICAgIHN0cmluZ2lmeTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYSkgPT09ICdbb2JqZWN0IEFycmF5XSc7IH07XG4gICAgICAgICAgICB2YXIgZXNjTWFwID0geydcIic6ICdcXFxcXCInLCAnXFxcXCc6ICdcXFxcXFxcXCcsICdcXGInOiAnXFxcXGInLCAnXFxmJzogJ1xcXFxmJywgJ1xcbic6ICdcXFxcbicsICdcXHInOiAnXFxcXHInLCAnXFx0JzogJ1xcXFx0J307XG4gICAgICAgICAgICB2YXIgZXNjRnVuYyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBlc2NNYXBbbV0gfHwgJ1xcXFx1JyArIChtLmNoYXJDb2RlQXQoMCkgKyAweDEwMDAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpOyB9O1xuICAgICAgICAgICAgdmFyIGVzY1JFID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMUZcXHUyMDI4XFx1MjAyOV0vZztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6ICdudWxsJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSAnWyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSAoaSA/ICcsICcgOiAnJykgKyBzdHJpbmdpZnkodmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcyArICddJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKHN0cmluZ2lmeShrKSArICc6ICcgKyBzdHJpbmdpZnkodmFsdWVba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneycgKyB0bXAuam9pbignLCAnKSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJyArIHZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZShlc2NSRSwgZXNjRnVuYykgKyAnXCInO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKVxuICAgIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi9jb25zdCcpLFxuICAgIGNoYXJ0RmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzL2NoYXJ0RmFjdG9yeScpLFxuICAgIEJhckNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvYmFyQ2hhcnQnKSxcbiAgICBDb2x1bW5DaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL2NvbHVtbkNoYXJ0JyksXG4gICAgTGluZUNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvbGluZUNoYXJ0JyksXG4gICAgQXJlYUNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvYXJlYUNoYXJ0JyksXG4gICAgQ29tYm9DaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL2NvbWJvQ2hhcnQnKSxcbiAgICBQaWVDaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL3BpZUNoYXJ0Jyk7XG5cbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfQkFSLCBCYXJDaGFydCk7XG5jaGFydEZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5DSEFSVF9UWVBFX0NPTFVNTiwgQ29sdW1uQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9MSU5FLCBMaW5lQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9BUkVBLCBBcmVhQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT01CTywgQ29tYm9DaGFydCk7XG5jaGFydEZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5DSEFSVF9UWVBFX1BJRSwgUGllQ2hhcnQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4vY29uc3QnKSxcbiAgICB0aGVtZUZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3Rvcmllcy90aGVtZUZhY3RvcnknKSxcbiAgICBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuL3RoZW1lcy9kZWZhdWx0VGhlbWUnKTtcblxudGhlbWVGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuREVGQVVMVF9USEVNRV9OQU1FLCBkZWZhdWx0VGhlbWUpO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFyZWEgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgTGluZVR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9saW5lVHlwZVNlcmllc0Jhc2UnKTtcblxudmFyIEFyZWFDaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBBcmVhQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBBcmVhIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQXJlYUNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQG1peGVzIExpbmVUeXBlU2VyaWVzQmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5tb2RlbCBzZXJpZXMgbW9kZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBzZXJpZXMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBzZXJpZXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugc2VyaWVzIGRhdGEuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgc2VyaWVzIGJvdW5kXG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKi9cbiAgICBtYWtlU2VyaWVzRGF0YTogZnVuY3Rpb24oYm91bmQpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGJvdW5kLmRpbWVuc2lvbixcbiAgICAgICAgICAgIHNjYWxlRGlzdGFuY2UgPSB0aGlzLmdldFNjYWxlRGlzdGFuY2VGcm9tWmVyb1BvaW50KGRpbWVuc2lvbi5oZWlnaHQsIHRoaXMuZGF0YS5zY2FsZSksXG4gICAgICAgICAgICB6ZXJvVG9wID0gc2NhbGVEaXN0YW5jZS50b01heDtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5zY2FsZS5taW4gPj0gMCAmJiAhemVyb1RvcCkge1xuICAgICAgICAgICAgemVyb1RvcCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnM6IHRoaXMubWFrZVBvc2l0aW9ucyhkaW1lbnNpb24pLFxuICAgICAgICAgICAgemVyb1RvcDogemVyb1RvcFxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5MaW5lVHlwZVNlcmllc0Jhc2UubWl4aW4oQXJlYUNoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmFyIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpLFxuICAgIEJhclR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9iYXJUeXBlU2VyaWVzQmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIEJhckNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIEJhckNoYXJ0U2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQmFyIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQmFyQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubW9kZWwgc2VyaWVzIG1vZGVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFNlcmllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGJvdW5kIG9mIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5iYXNlQm91bmQgYmFzZSBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydExlZnQgc3RhcnQgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmRMZWZ0IGVuZCBsZWZ0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZFdpZHRoIGVuZCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBzdGFydDoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGVuZDoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfVxuICAgICAqIH19IGNvbHVtbiBjaGFydCBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXJDaGFydEJvdW5kOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBhcmFtcy5zdGFydExlZnQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH0sIHBhcmFtcy5iYXNlQm91bmQpLFxuICAgICAgICAgICAgZW5kOiB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBhcmFtcy5lbmRMZWZ0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJhbXMuZW5kV2lkdGhcbiAgICAgICAgICAgIH0sIHBhcmFtcy5iYXNlQm91bmQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugbm9ybWFsIGJhciBjaGFydCBib3VuZC5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGdyb3VwVmFsdWVzOiBhcnJheS48YXJyYXkuPG51bWJlcj4+LFxuICAgICAqICAgICAgZ3JvdXBTaXplOiBudW1iZXIsIGJhclNpemU6IG51bWJlciwgc3RlcDogbnVtYmVyLFxuICAgICAqICAgICAgZGlzdGFuY2VUb01pbjogbnVtYmVyLCBpc01pbnVzOiBib29sZWFuXG4gICAgICogfX0gYmFzZUluZm8gYmFzZSBpbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdUb3AgcGFkZGluZyB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc3RhcnQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBlbmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn1cbiAgICAgKiB9fSBjb2x1bW4gY2hhcnQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTm9ybWFsQmFyQ2hhcnRCb3VuZDogZnVuY3Rpb24oYmFzZUluZm8sIHZhbHVlLCBwYWRkaW5nVG9wLCBpbmRleCkge1xuICAgICAgICB2YXIgc3RhcnRMZWZ0LCBlbmRXaWR0aCwgYm91bmQsIGJhc2VCb3VuZDtcblxuICAgICAgICBzdGFydExlZnQgPSBiYXNlSW5mby5kaXN0YW5jZVRvTWluICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgICAgIGVuZFdpZHRoID0gTWF0aC5hYnModmFsdWUgKiBiYXNlSW5mby5kaW1lbnNpb24ud2lkdGgpO1xuICAgICAgICBiYXNlQm91bmQgPSB7XG4gICAgICAgICAgICB0b3A6IHBhZGRpbmdUb3AgKyAoKGJhc2VJbmZvLnN0ZXApICogaW5kZXgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYXNlSW5mby5iYXJTaXplXG4gICAgICAgIH07XG4gICAgICAgIGJvdW5kID0gdGhpcy5fbWFrZUJhckNoYXJ0Qm91bmQoe1xuICAgICAgICAgICAgYmFzZUJvdW5kOiBiYXNlQm91bmQsXG4gICAgICAgICAgICBzdGFydExlZnQ6IHN0YXJ0TGVmdCxcbiAgICAgICAgICAgIGVuZExlZnQ6IHN0YXJ0TGVmdCArICh2YWx1ZSA8IDAgPyAtZW5kV2lkdGggOiAwKSxcbiAgICAgICAgICAgIGVuZFdpZHRoOiBlbmRXaWR0aFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYm91bmRzIG9mIG5vcm1hbCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IGRpbWVuc2lvbiBiYXIgY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge2FycmF5LjxhcnJheS48b2JqZWN0Pj59IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxCYXJDaGFydEJvdW5kczogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBiYXNlSW5mbyA9IHRoaXMubWFrZUJhc2VJbmZvRm9yTm9ybWFsQ2hhcnRCb3VuZHMoZGltZW5zaW9uLCAnd2lkdGgnLCAnaGVpZ2h0JyksXG4gICAgICAgICAgICBib3VuZHM7XG5cbiAgICAgICAgYm91bmRzID0gdHVpLnV0aWwubWFwKGJhc2VJbmZvLmdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nVG9wID0gKGJhc2VJbmZvLmdyb3VwU2l6ZSAqIGdyb3VwSW5kZXgpICsgYmFzZUluZm8uYWRkaXRpb25QYWRkaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZU5vcm1hbEJhckNoYXJ0Qm91bmQoYmFzZUluZm8sIHZhbHVlLCBwYWRkaW5nVG9wLCBpbmRleCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBib3VuZHMgb2Ygc3RhY2tlZCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IGRpbWVuc2lvbiBiYXIgY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge2FycmF5LjxhcnJheS48b2JqZWN0Pj59IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdGFja2VkQmFyQ2hhcnRCb3VuZHM6IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgZ3JvdXBWYWx1ZXMsIGdyb3VwSGVpZ2h0LCBiYXJIZWlnaHQsXG4gICAgICAgICAgICBvcHRpb25IZWlnaHQsIGFkZGl0aW9uUGFkZGluZywgYm91bmRzO1xuICAgICAgICBncm91cFZhbHVlcyA9IHRoaXMucGVyY2VudFZhbHVlcztcbiAgICAgICAgZ3JvdXBIZWlnaHQgPSAoZGltZW5zaW9uLmhlaWdodCAvIGdyb3VwVmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGJhckhlaWdodCA9IGdyb3VwSGVpZ2h0IC8gMjtcbiAgICAgICAgb3B0aW9uSGVpZ2h0ID0gdGhpcy5fbWFrZU9wdGlvblNpemUoYmFySGVpZ2h0LCB0aGlzLm9wdGlvbnMuYmFyV2lkdGgpO1xuICAgICAgICBhZGRpdGlvblBhZGRpbmcgPSB0aGlzLl9tYWtlQWRkaXRpb25QYWRkaW5nKGJhckhlaWdodCwgb3B0aW9uSGVpZ2h0LCAxKTtcbiAgICAgICAgYmFySGVpZ2h0ID0gb3B0aW9uSGVpZ2h0IHx8IGJhckhlaWdodDtcbiAgICAgICAgYm91bmRzID0gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbiAodmFsdWVzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ1RvcCA9IChncm91cEhlaWdodCAqIGdyb3VwSW5kZXgpICsgYWRkaXRpb25QYWRkaW5nLFxuICAgICAgICAgICAgICAgIGVuZExlZnQgPSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRTtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kV2lkdGgsIGJhc2VCb3VuZCwgYm91bmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVuZFdpZHRoID0gdmFsdWUgKiBkaW1lbnNpb24ud2lkdGg7XG4gICAgICAgICAgICAgICAgYmFzZUJvdW5kID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHBhZGRpbmdUb3AsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW9uSGVpZ2h0IHx8IGJhckhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlQmFyQ2hhcnRCb3VuZCh7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VCb3VuZDogYmFzZUJvdW5kLFxuICAgICAgICAgICAgICAgICAgICBzdGFydExlZnQ6IGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICBlbmRMZWZ0OiBlbmRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBlbmRXaWR0aDogZW5kV2lkdGhcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVuZExlZnQgPSBlbmRMZWZ0ICsgZW5kV2lkdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYm91bmRzIG9mIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gZGltZW5zaW9uIGJhciBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPGFycmF5LjxvYmplY3Q+Pn0gYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kczogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlTm9ybWFsQmFyQ2hhcnRCb3VuZHMoZGltZW5zaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlU3RhY2tlZEJhckNoYXJ0Qm91bmRzKGRpbWVuc2lvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBzZXJpZXMgcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtvYmVqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWx1ZSB2YWx1ZVxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6bnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5ib3VuZCBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mb3JtYXR0ZWRWYWx1ZSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICovXG4gICAgbWFrZVNlcmllc1JlbmRlcmluZ1Bvc2l0aW9uOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChwYXJhbXMuZm9ybWF0dGVkVmFsdWUsIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgYm91bmQgPSBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICBsZWZ0ID0gYm91bmQubGVmdCxcbiAgICAgICAgICAgIHRvcCA9IGJvdW5kLnRvcCArIChib3VuZC5oZWlnaHQgLSBwYXJhbXMubGFiZWxIZWlnaHQgKyBjaGFydENvbnN0LlRFWFRfUEFERElORykgLyAyO1xuXG4gICAgICAgIGlmIChwYXJhbXMudmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgbGVmdCArPSBib3VuZC53aWR0aCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0IC09IGxhYmVsV2lkdGggKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHN1bSBsYWJlbCBodG1sLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48bnVtYmVyPn0gcGFyYW1zLnZhbHVlcyB2YWx1ZXNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPGZ1bmN0aW9uPn0gcGFyYW1zLmZvcm1hdEZ1bmN0aW9ucyBmb3JtYXR0aW5nIGZ1bmN0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBhcmFtcy5ib3VuZCBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdW0gbGFiZWwgaHRtbFxuICAgICAqL1xuICAgIG1ha2VTdW1MYWJlbEh0bWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc3VtID0gdGhpcy5tYWtlU3VtVmFsdWVzKHBhcmFtcy52YWx1ZXMsIHBhcmFtcy5mb3JtYXRGdW5jdGlvbnMpLFxuICAgICAgICAgICAgYm91bmQgPSBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChzdW0sIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgdG9wID0gYm91bmQudG9wICsgKChib3VuZC5oZWlnaHQgLSBsYWJlbEhlaWdodCArIGNoYXJ0Q29uc3QuVEVYVF9QQURESU5HKSAvIDIpLFxuICAgICAgICAgICAgbGVmdCA9IGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZVNlcmllc0xhYmVsSHRtbCh7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfSwgc3VtLCAtMSwgLTEpO1xuICAgIH1cbn0pO1xuXG5CYXJUeXBlU2VyaWVzQmFzZS5taXhpbihCYXJDaGFydFNlcmllcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFyQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29sdW1uIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBCYXJUeXBlU2VyaWVzQmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQmFyVHlwZVNlcmllc0Jhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHNlcmllcyBkYXRhLlxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGJvdW5kIHNlcmllcyBib3VuZFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGFkZCBkYXRhXG4gICAgICovXG4gICAgbWFrZVNlcmllc0RhdGE6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHZhciBncm91cEJvdW5kcyA9IHRoaXMuX21ha2VCb3VuZHMoYm91bmQuZGltZW5zaW9uKTtcblxuICAgICAgICB0aGlzLmdyb3VwQm91bmRzID0gZ3JvdXBCb3VuZHM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwQm91bmRzOiBncm91cEJvdW5kcyxcbiAgICAgICAgICAgIGdyb3VwVmFsdWVzOiB0aGlzLnBlcmNlbnRWYWx1ZXNcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBiYXIgZ3V0dGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cFNpemUgYmFyIGdyb3VwIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaXRlbUNvdW50IGdyb3VwIGl0ZW0gY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBiYXIgZ3V0dGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhckd1dHRlcjogZnVuY3Rpb24oZ3JvdXBTaXplLCBpdGVtQ291bnQpIHtcbiAgICAgICAgdmFyIGJhc2VTaXplID0gZ3JvdXBTaXplIC8gKGl0ZW1Db3VudCArIDEpIC8gMixcbiAgICAgICAgICAgIGd1dHRlcjtcbiAgICAgICAgaWYgKGJhc2VTaXplIDw9IDIpIHtcbiAgICAgICAgICAgIGd1dHRlciA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZVNpemUgPD0gNikge1xuICAgICAgICAgICAgZ3V0dGVyID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGd1dHRlciA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGd1dHRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBiYXIgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBTaXplIGJhciBncm91cCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhckd1dHRlciBiYXIgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgZ3JvdXAgaXRlbSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGJhciBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhclNpemU6IGZ1bmN0aW9uKGdyb3VwU2l6ZSwgYmFyR3V0dGVyLCBpdGVtQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIChncm91cFNpemUgLSAoYmFyR3V0dGVyICogKGl0ZW1Db3VudCAtIDEpKSkgLyAoaXRlbUNvdW50ICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugb3B0aW9uIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhclNpemUgYmFyIHNpemVcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG9wdGlvbkJhcldpZHRoIGJhcldpZHRoIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG9wdGlvbiBzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU9wdGlvblNpemU6IGZ1bmN0aW9uKGJhclNpemUsIG9wdGlvbkJhcldpZHRoKSB7XG4gICAgICAgIHZhciBvcHRpb25zU2l6ZSA9IDA7XG4gICAgICAgIGlmIChvcHRpb25CYXJXaWR0aCkge1xuICAgICAgICAgICAgb3B0aW9uc1NpemUgPSB0dWkudXRpbC5taW4oW2JhclNpemUsIG9wdGlvbkJhcldpZHRoXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnNTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGFkZGl0aW9uIHBhZGRpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhclNpemUgYmFyIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9uU2l6ZSBvcHRpb24gc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgaXRlbSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGFkZGl0aW9uIHBhZGRpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQWRkaXRpb25QYWRkaW5nOiBmdW5jdGlvbihiYXJTaXplLCBvcHRpb25TaXplLCBpdGVtQ291bnQpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAwO1xuICAgICAgICBpZiAob3B0aW9uU2l6ZSAmJiBvcHRpb25TaXplIDwgYmFyU2l6ZSkge1xuICAgICAgICAgICAgcGFkZGluZyA9IChiYXJTaXplIC0gb3B0aW9uU2l6ZSkgKiBpdGVtQ291bnQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYmFyU2l6ZSAvIDIpICsgcGFkZGluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBiYXNlIGluZm8gZm9yIG5vcm1hbCBjaGFydCBib3VuZHMuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gc2VyaWVzIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaXplVHlwZSBzaXplIHR5cGUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYW5vdGhlclNpemVUeXBlIGFub3RoZXIgc2l6ZSB0eXBlICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGdyb3VwVmFsdWVzOiBhcnJheS48YXJyYXkuPG51bWJlcj4+LFxuICAgICAqICAgICAgZ3JvdXBTaXplOiBudW1iZXIsIGJhclNpemU6IG51bWJlciwgc3RlcDogbnVtYmVyLFxuICAgICAqICAgICAgZGlzdGFuY2VUb01pbjogbnVtYmVyLCBpc01pbnVzOiBib29sZWFuXG4gICAgICogfX0gYmFzZSBpbmZvXG4gICAgICovXG4gICAgbWFrZUJhc2VJbmZvRm9yTm9ybWFsQ2hhcnRCb3VuZHM6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2l6ZVR5cGUsIGFub3RoZXJTaXplVHlwZSkge1xuICAgICAgICB2YXIgZ3JvdXBWYWx1ZXMgPSB0aGlzLnBlcmNlbnRWYWx1ZXMsXG4gICAgICAgICAgICBncm91cFNpemUgPSBkaW1lbnNpb25bYW5vdGhlclNpemVUeXBlXSAvIGdyb3VwVmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW1Db3VudCA9IGdyb3VwVmFsdWVzWzBdICYmIGdyb3VwVmFsdWVzWzBdLmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgYmFyR3V0dGVyID0gdGhpcy5fbWFrZUJhckd1dHRlcihncm91cFNpemUsIGl0ZW1Db3VudCksXG4gICAgICAgICAgICBiYXJTaXplID0gdGhpcy5fbWFrZUJhclNpemUoZ3JvdXBTaXplLCBiYXJHdXR0ZXIsIGl0ZW1Db3VudCksXG4gICAgICAgICAgICBvcHRpb25TaXplID0gdGhpcy5fbWFrZU9wdGlvblNpemUoYmFyU2l6ZSwgdGhpcy5vcHRpb25zLmJhcldpZHRoKSxcbiAgICAgICAgICAgIGFkZGl0aW9uUGFkZGluZyA9IHRoaXMuX21ha2VBZGRpdGlvblBhZGRpbmcoYmFyU2l6ZSwgb3B0aW9uU2l6ZSwgaXRlbUNvdW50KSxcbiAgICAgICAgICAgIHNjYWxlRGlzdGFuY2UgPSB0aGlzLmdldFNjYWxlRGlzdGFuY2VGcm9tWmVyb1BvaW50KGRpbWVuc2lvbltzaXplVHlwZV0sIHRoaXMuZGF0YS5zY2FsZSk7XG4gICAgICAgIGJhclNpemUgPSBvcHRpb25TaXplIHx8IGJhclNpemU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IGRpbWVuc2lvbixcbiAgICAgICAgICAgIGdyb3VwVmFsdWVzOiBncm91cFZhbHVlcyxcbiAgICAgICAgICAgIGdyb3VwU2l6ZTogZ3JvdXBTaXplLFxuICAgICAgICAgICAgYmFyU2l6ZTogYmFyU2l6ZSxcbiAgICAgICAgICAgIGFkZGl0aW9uUGFkZGluZzogYWRkaXRpb25QYWRkaW5nLFxuICAgICAgICAgICAgc3RlcDogYmFyU2l6ZSArIGJhckd1dHRlcixcbiAgICAgICAgICAgIGRpc3RhbmNlVG9NaW46IHNjYWxlRGlzdGFuY2UudG9NaW4sXG4gICAgICAgICAgICBpc01pbnVzOiB0aGlzLmRhdGEuc2NhbGUubWluIDwgMCAmJiB0aGlzLmRhdGEuc2NhbGUubWF4IDw9IDBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG5vcm1hbCBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJhbXMuY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48YXJyYXk+fSBwYXJhbXMuZ3JvdXBCb3VuZHMgZ3JvdXAgYm91bmRzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxhcnJheT59IHBhcmFtcy5mb3JtYXR0ZWRWYWx1ZXMgZm9ybWF0dGVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsU2VyaWVzTGFiZWxBcmVhIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJOb3JtYWxTZXJpZXNMYWJlbDogZnVuY3Rpb24ocGFyYW1zLCBlbFNlcmllc0xhYmVsQXJlYSkge1xuICAgICAgICB2YXIgZ3JvdXBCb3VuZHMgPSBwYXJhbXMuZ3JvdXBCb3VuZHMsXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXMgPSBwYXJhbXMuZm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoZm9ybWF0dGVkVmFsdWVzWzBdWzBdLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIGh0bWw7XG4gICAgICAgIGh0bWwgPSB0dWkudXRpbC5tYXAocGFyYW1zLnZhbHVlcywgZnVuY3Rpb24odmFsdWVzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kLCBmb3JtYXR0ZWRWYWx1ZSwgcmVuZGVyaW5nUG9zaXRpb247XG4gICAgICAgICAgICAgICAgYm91bmQgPSBncm91cEJvdW5kc1tncm91cEluZGV4XVtpbmRleF0uZW5kO1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWVzW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZW5kZXJpbmdQb3NpdGlvbiA9IHRoaXMubWFrZVNlcmllc1JlbmRlcmluZ1Bvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBib3VuZDogYm91bmQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQ6IGxhYmVsSGVpZ2h0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVNlcmllc0xhYmVsSHRtbChyZW5kZXJpbmdQb3NpdGlvbiwgZm9ybWF0dGVkVmFsdWUsIGdyb3VwSW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIH0sIHRoaXMpLmpvaW4oJycpO1xuICAgICAgICB9LCB0aGlzKS5qb2luKCcnKTtcblxuICAgICAgICBlbFNlcmllc0xhYmVsQXJlYS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHN1bSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHthcnJheS48bnVtYmVyPn0gdmFsdWVzIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7YXJyYXkuPGZ1bmN0aW9uPn0gZm9ybWF0RnVuY3Rpb25zIGZvcm1hdCBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzdW0gcmVzdWx0LlxuICAgICAqL1xuICAgIG1ha2VTdW1WYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcywgZm9ybWF0RnVuY3Rpb25zKSB7XG4gICAgICAgIHZhciBzdW0gPSB0dWkudXRpbC5zdW0odHVpLnV0aWwuZmlsdGVyKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAwO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgZm5zID0gW3N1bV0uY29uY2F0KGZvcm1hdEZ1bmN0aW9ucyB8fCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnJlZHVjZShmbnMsIGZ1bmN0aW9uKHN0b3JlZCwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmbihzdG9yZWQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBzdGFja2VkIGxhYmVscyBodG1sLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5ncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxudW1iZXI+fSBwYXJhbXMudmFsdWVzIHZhbHVlcyxcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPGZ1bmN0aW9uPn0gcGFyYW1zLmZvcm1hdEZ1bmN0aW9ucyBmb3JtYXR0aW5nIGZ1bmN0aW9ucyxcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPG9iamVjdD59IHBhcmFtcy5ib3VuZHMgYm91bmRzLFxuICAgICAqICAgICAgQHBhcmFtIHthcnJheX0gcGFyYW1zLmZvcm1hdHRlZFZhbHVlcyBmb3JtYXR0ZWQgdmFsdWVzLFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsYWJlbHMgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdGFja2VkTGFiZWxzSHRtbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBwYXJhbXMudmFsdWVzLFxuICAgICAgICAgICAgYm91bmQsIGh0bWxzO1xuXG4gICAgICAgIGh0bWxzID0gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxXaWR0aCwgbGVmdCwgdG9wLCBsYWJlbEh0bWwsIGZvcm1hdHRlZFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZCA9IHBhcmFtcy5ib3VuZHNbaW5kZXhdLmVuZDtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gcGFyYW1zLmZvcm1hdHRlZFZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgoZm9ybWF0dGVkVmFsdWUsIHRoaXMudGhlbWUubGFiZWwpO1xuICAgICAgICAgICAgbGVmdCA9IGJvdW5kLmxlZnQgKyAoKGJvdW5kLndpZHRoIC0gbGFiZWxXaWR0aCArIGNoYXJ0Q29uc3QuVEVYVF9QQURESU5HKSAvIDIpO1xuICAgICAgICAgICAgdG9wID0gYm91bmQudG9wICsgKChib3VuZC5oZWlnaHQgLSBwYXJhbXMubGFiZWxIZWlnaHQgKyBjaGFydENvbnN0LlRFWFRfUEFERElORykgLyAyKTtcbiAgICAgICAgICAgIGxhYmVsSHRtbCA9IHRoaXMubWFrZVNlcmllc0xhYmVsSHRtbCh7XG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgfSwgZm9ybWF0dGVkVmFsdWUsIHBhcmFtcy5ncm91cEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxIdG1sO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNrZWQgPT09ICdub3JtYWwnICYmIGJvdW5kKSB7XG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMubWFrZVN1bUxhYmVsSHRtbCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zOiBwYXJhbXMuZm9ybWF0RnVuY3Rpb25zLFxuICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZCxcbiAgICAgICAgICAgICAgICBsYWJlbEhlaWdodDogcGFyYW1zLmxhYmVsSGVpZ2h0XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc3RhY2tlZCBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxhcnJheT59IHBhcmFtcy5ncm91cEJvdW5kcyBncm91cCBib3VuZHNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gcGFyYW1zLmZvcm1hdHRlZFZhbHVlcyBmb3JtYXR0ZWQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxTZXJpZXNMYWJlbEFyZWEgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclN0YWNrZWRTZXJpZXNMYWJlbDogZnVuY3Rpb24ocGFyYW1zLCBlbFNlcmllc0xhYmVsQXJlYSkge1xuICAgICAgICB2YXIgZ3JvdXBCb3VuZHMgPSBwYXJhbXMuZ3JvdXBCb3VuZHMsXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXMgPSBwYXJhbXMuZm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gcGFyYW1zLmZvcm1hdEZ1bmN0aW9ucyB8fCBbXSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGZvcm1hdHRlZFZhbHVlc1swXVswXSwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBodG1sO1xuICAgICAgICBodG1sID0gdHVpLnV0aWwubWFwKHBhcmFtcy52YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlcywgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbHNIdG1sID0gdGhpcy5fbWFrZVN0YWNrZWRMYWJlbHNIdG1sKHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnM6IGZvcm1hdEZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgICBib3VuZHM6IGdyb3VwQm91bmRzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXM6IGZvcm1hdHRlZFZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQ6IGxhYmVsSGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNIdG1sO1xuICAgICAgICB9LCB0aGlzKS5qb2luKCcnKTtcblxuICAgICAgICBlbFNlcmllc0xhYmVsQXJlYS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48YXJyYXk+fSBwYXJhbXMuZ3JvdXBCb3VuZHMgZ3JvdXAgYm91bmRzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxhcnJheT59IHBhcmFtcy5mb3JtYXR0ZWRWYWx1ZXMgZm9ybWF0dGVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsU2VyaWVzTGFiZWxBcmVhIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24ocGFyYW1zLCBlbFNlcmllc0xhYmVsQXJlYSkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhY2tlZFNlcmllc0xhYmVsKHBhcmFtcywgZWxTZXJpZXNMYWJlbEFyZWEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTm9ybWFsU2VyaWVzTGFiZWwocGFyYW1zLCBlbFNlcmllc0xhYmVsQXJlYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRCb3VuZDogZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IC0xIHx8IGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBCb3VuZHNbZ3JvdXBJbmRleF1baW5kZXhdLmVuZDtcbiAgICB9XG59KTtcblxuQmFyVHlwZVNlcmllc0Jhc2UubWl4aW4gPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdHVpLnV0aWwuZXh0ZW5kKGZ1bmMucHJvdG90eXBlLCBCYXJUeXBlU2VyaWVzQmFzZS5wcm90b3R5cGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXJUeXBlU2VyaWVzQmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb2x1bW4gY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgQmFyVHlwZVNlcmllc0Jhc2UgPSByZXF1aXJlKCcuL2JhclR5cGVTZXJpZXNCYXNlJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgQ29sdW1uQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgQ29sdW1uQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDb2x1bW4gY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBDb2x1bW5DaGFydFNlcmllc1xuICAgICAqIEBleHRlbmRzIFNlcmllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5tb2RlbCBzZXJpZXMgbW9kZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBzZXJpZXMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBzZXJpZXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugc3RhcnQgZW5kIHRvcHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFRvcCBlbmQgdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEhlaWdodCBlbmQgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc01pbnVzIHdoZXRoZXIgbWludXMgb3Igbm90XG4gICAgICogQHJldHVybnMge3tzdGFydFRvcDogbnVtYmVyLCBlbmRUb3A6IG51bWJlcn19IHN0YXJ0IGVuZCB0b3BzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVN0YXJ0RW5kVG9wczogZnVuY3Rpb24oZW5kVG9wLCBlbmRIZWlnaHQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdGFydFRvcDtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgc3RhcnRUb3AgPSBlbmRUb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFRvcCA9IGVuZFRvcDtcbiAgICAgICAgICAgIGVuZFRvcCAtPSBlbmRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRUb3A6IHN0YXJ0VG9wLFxuICAgICAgICAgICAgZW5kVG9wOiBlbmRUb3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBib3VuZCBvZiBjb2x1bW4gY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXJ9fSBwYXJhbXMuYmFzZUJvdW5kIGJhc2UgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnRUb3Agc3RhcnQgdG9wXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZFRvcCBlbmQgdG9wXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZEhlaWdodCBlbmQgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHN0YXJ0OiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgZW5kOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9XG4gICAgICogfX0gY29sdW1uIGNoYXJ0IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNvbHVtbkNoYXJ0Qm91bmQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgdG9wOiBwYXJhbXMuc3RhcnRUb3AsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LCBwYXJhbXMuYmFzZUJvdW5kKSxcbiAgICAgICAgICAgIGVuZDogdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICB0b3A6IHBhcmFtcy5lbmRUb3AsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJhbXMuZW5kSGVpZ2h0XG4gICAgICAgICAgICB9LCBwYXJhbXMuYmFzZUJvdW5kKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIG5vcm1hbCBjb2x1bW4gY2hhcnQgYm91bmQuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBncm91cFZhbHVlczogYXJyYXkuPGFycmF5LjxudW1iZXI+PixcbiAgICAgKiAgICAgIGdyb3VwU2l6ZTogbnVtYmVyLCBiYXJTaXplOiBudW1iZXIsIHN0ZXA6IG51bWJlcixcbiAgICAgKiAgICAgIGRpc3RhbmNlVG9NaW46IG51bWJlciwgaXNNaW51czogYm9vbGVhblxuICAgICAqIH19IGJhc2VJbmZvIGJhc2UgaW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nTGVmdCBwYWRkaW5nIGxlZnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc3RhcnQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBlbmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn1cbiAgICAgKiB9fSBjb2x1bW4gY2hhcnQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTm9ybWFsQ29sdW1uQ2hhcnRCb3VuZDogZnVuY3Rpb24oYmFzZUluZm8sIHZhbHVlLCBwYWRkaW5nTGVmdCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGVuZEhlaWdodCwgZW5kVG9wLCBzdGFydEVuZFRvcHMsIGJvdW5kO1xuXG4gICAgICAgIGVuZEhlaWdodCA9IE1hdGguYWJzKHZhbHVlICogYmFzZUluZm8uZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIGVuZFRvcCA9IGJhc2VJbmZvLmlzTWludXMgPyAwIDogYmFzZUluZm8uZGltZW5zaW9uLmhlaWdodCAtIGJhc2VJbmZvLmRpc3RhbmNlVG9NaW47XG4gICAgICAgIHN0YXJ0RW5kVG9wcyA9IHRoaXMuX21ha2VTdGFydEVuZFRvcHMoZW5kVG9wLCBlbmRIZWlnaHQsIHZhbHVlKTtcbiAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlQ29sdW1uQ2hhcnRCb3VuZCh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgYmFzZUJvdW5kOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogcGFkZGluZ0xlZnQgKyAoYmFzZUluZm8uc3RlcCAqIGluZGV4KSArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBiYXNlSW5mby5iYXJTaXplXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kSGVpZ2h0OiBlbmRIZWlnaHRcbiAgICAgICAgfSwgc3RhcnRFbmRUb3BzKSk7XG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBib3VuZHMgb2Ygbm9ybWFsIGNvbHVtbiBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gZGltZW5zaW9uIGNvbHVtbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPGFycmF5LjxvYmplY3Q+Pn0gYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbENvbHVtbkNoYXJ0Qm91bmRzOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIGJhc2VJbmZvID0gdGhpcy5tYWtlQmFzZUluZm9Gb3JOb3JtYWxDaGFydEJvdW5kcyhkaW1lbnNpb24sICdoZWlnaHQnLCAnd2lkdGgnKSxcbiAgICAgICAgICAgIGJvdW5kcztcblxuICAgICAgICBib3VuZHMgPSB0dWkudXRpbC5tYXAoYmFzZUluZm8uZ3JvdXBWYWx1ZXMsIGZ1bmN0aW9uKHZhbHVlcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gKGJhc2VJbmZvLmdyb3VwU2l6ZSAqIGdyb3VwSW5kZXgpICsgYmFzZUluZm8uYWRkaXRpb25QYWRkaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZU5vcm1hbENvbHVtbkNoYXJ0Qm91bmQoYmFzZUluZm8sIHZhbHVlLCBwYWRkaW5nTGVmdCwgaW5kZXgpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYm91bmRzIG9mIHN0YWNrZWQgY29sdW1uIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBkaW1lbnNpb24gY29sdW1uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHthcnJheS48YXJyYXkuPG9iamVjdD4+fSBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3RhY2tlZENvbHVtbkNoYXJ0Qm91bmRzOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIGdyb3VwVmFsdWVzLCBncm91cFdpZHRoLCBiYXJXaWR0aCxcbiAgICAgICAgICAgIG9wdGlvbldpZHRoLCBhZGRpdGlvblBhZGRpbmcsIGJvdW5kcztcblxuICAgICAgICBncm91cFZhbHVlcyA9IHRoaXMucGVyY2VudFZhbHVlcztcbiAgICAgICAgZ3JvdXBXaWR0aCA9IChkaW1lbnNpb24ud2lkdGggLyBncm91cFZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBiYXJXaWR0aCA9IGdyb3VwV2lkdGggLyAyO1xuICAgICAgICBvcHRpb25XaWR0aCA9IHRoaXMuX21ha2VPcHRpb25TaXplKGJhcldpZHRoLCB0aGlzLm9wdGlvbnMuYmFyV2lkdGgpO1xuICAgICAgICBhZGRpdGlvblBhZGRpbmcgPSB0aGlzLl9tYWtlQWRkaXRpb25QYWRkaW5nKGJhcldpZHRoLCBvcHRpb25XaWR0aCwgMSk7XG4gICAgICAgIGJhcldpZHRoID0gb3B0aW9uV2lkdGggfHwgYmFyV2lkdGg7XG4gICAgICAgIGJvdW5kcyA9IHR1aS51dGlsLm1hcChncm91cFZhbHVlcywgZnVuY3Rpb24odmFsdWVzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSAoZ3JvdXBXaWR0aCAqIGdyb3VwSW5kZXgpICsgYWRkaXRpb25QYWRkaW5nICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kSGVpZ2h0LCBiYXNlQm91bmQsIGJvdW5kO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZW5kSGVpZ2h0ID0gdmFsdWUgKiBkaW1lbnNpb24uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJhc2VCb3VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogcGFkZGluZ0xlZnQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlQ29sdW1uQ2hhcnRCb3VuZCh7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VCb3VuZDogYmFzZUJvdW5kLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRvcDogZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZW5kVG9wOiBkaW1lbnNpb24uaGVpZ2h0IC0gZW5kSGVpZ2h0IC0gdG9wLFxuICAgICAgICAgICAgICAgICAgICBlbmRIZWlnaHQ6IGVuZEhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdG9wICs9IGVuZEhlaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYm91bmRzIG9mIGNvbHVtbiBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gZGltZW5zaW9uIGNvbHVtbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPGFycmF5LjxvYmplY3Q+Pn0gYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kczogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlTm9ybWFsQ29sdW1uQ2hhcnRCb3VuZHMoZGltZW5zaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlU3RhY2tlZENvbHVtbkNoYXJ0Qm91bmRzKGRpbWVuc2lvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBzZXJpZXMgcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtvYmVqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWx1ZSB2YWx1ZVxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6bnVtYmVyLCB3aWR0aDpudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmJvdW5kIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZvcm1hdHRlZFZhbHVlIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSByZW5kZXJpbmcgcG9zaXRpb25cbiAgICAgKi9cbiAgICBtYWtlU2VyaWVzUmVuZGVyaW5nUG9zaXRpb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKHBhcmFtcy5mb3JtYXR0ZWRWYWx1ZSwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBib3VuZCA9IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgIHRvcCA9IGJvdW5kLnRvcCxcbiAgICAgICAgICAgIGxlZnQgPSBib3VuZC5sZWZ0ICsgKGJvdW5kLndpZHRoIC0gbGFiZWxXaWR0aCkgLyAyO1xuXG4gICAgICAgIGlmIChwYXJhbXMudmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgdG9wIC09IHBhcmFtcy5sYWJlbEhlaWdodCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgKz0gYm91bmQuaGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBzdW0gbGFiZWwgaHRtbC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPG51bWJlcj59IHBhcmFtcy52YWx1ZXMgdmFsdWVzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxmdW5jdGlvbj59IHBhcmFtcy5mb3JtYXRGdW5jdGlvbnMgZm9ybWF0dGluZyBmdW5jdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwYXJhbXMuYm91bmQgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3N0cmluZ30gc3VtIGxhYmVsIGh0bWxcbiAgICAgKi9cbiAgICBtYWtlU3VtTGFiZWxIdG1sOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHN1bSA9IHRoaXMubWFrZVN1bVZhbHVlcyhwYXJhbXMudmFsdWVzLCBwYXJhbXMuZm9ybWF0RnVuY3Rpb25zKSxcbiAgICAgICAgICAgIGJvdW5kID0gcGFyYW1zLmJvdW5kLFxuICAgICAgICAgICAgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKHN1bSwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBsZWZ0ID0gYm91bmQubGVmdCArICgoYm91bmQud2lkdGggLSBsYWJlbFdpZHRoICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMiksXG4gICAgICAgICAgICB0b3AgPSBib3VuZC50b3AgLSBwYXJhbXMubGFiZWxIZWlnaHQgLSBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VTZXJpZXNMYWJlbEh0bWwoe1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgIH0sIHN1bSwgLTEsIC0xKTtcbiAgICB9XG59KTtcblxuQmFyVHlwZVNlcmllc0Jhc2UubWl4aW4oQ29sdW1uQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkNoYXJ0U2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IExpbmUgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgTGluZVR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9saW5lVHlwZVNlcmllc0Jhc2UnKTtcblxudmFyIExpbmVDaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBMaW5lQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMaW5lIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgTGluZUNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQG1peGVzIExpbmVUeXBlU2VyaWVzQmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5tb2RlbCBzZXJpZXMgbW9kZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBzZXJpZXMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBzZXJpZXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugc2VyaWVzIGRhdGEuXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fX0gYm91bmQgYm91bmRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZXJpZXMgZGF0YVxuICAgICAqL1xuICAgIG1ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnM6IHRoaXMubWFrZVBvc2l0aW9ucyhib3VuZC5kaW1lbnNpb24pXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbkxpbmVUeXBlU2VyaWVzQmFzZS5taXhpbihMaW5lQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVDaGFydFNlcmllcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMaW5lVHlwZVNlcmllc0Jhc2UgaXMgYmFzZSBjbGFzcyBmb3IgbGluZSB0eXBlIHNlcmllcy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcbi8qKlxuICogQGNsYXNzZGVzYyBMaW5lVHlwZVNlcmllc0Jhc2UgaXMgYmFzZSBjbGFzcyBmb3IgbGluZSB0eXBlIHNlcmllcy5cbiAqIEBjbGFzcyBMaW5lVHlwZVNlcmllc0Jhc2VcbiAqIEBtaXhpblxuICovXG52YXIgTGluZVR5cGVTZXJpZXNCYXNlID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBMaW5lVHlwZVNlcmllc0Jhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHBvc2l0aW9ucyBvZiBsaW5lIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW5iZXJ9fSBkaW1lbnNpb24gbGluZSBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPGFycmF5LjxvYmplY3Q+Pn0gcG9zaXRpb25zXG4gICAgICovXG4gICAgbWFrZVBvc2l0aW9uczogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBncm91cFZhbHVlcyA9IHRoaXMucGVyY2VudFZhbHVlcyxcbiAgICAgICAgICAgIHdpZHRoID0gZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGxlbiA9IGdyb3VwVmFsdWVzWzBdLmxlbmd0aCxcbiAgICAgICAgICAgIHN0YXJ0ID0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBzdGVwLCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hbGlnbmVkKSB7XG4gICAgICAgICAgICBzdGVwID0gd2lkdGggLyAobGVuIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGVwID0gd2lkdGggLyBsZW47XG4gICAgICAgICAgICBzdGFydCArPSAoc3RlcCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzdGFydCArIChzdGVwICogaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGhlaWdodCAtICh2YWx1ZSAqIGhlaWdodClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyYW1zLmNvbnRhaW5lciBjb250YWluZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPGFycmF5Pn0gcGFyYW1zLmdyb3VwUG9zaXRpb25zIGdyb3VwIHBvc2l0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48YXJyYXk+fSBwYXJhbXMuZm9ybWF0dGVkVmFsdWVzIGZvcm1hdHRlZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFNlcmllc0xhYmVsQXJlYSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKHBhcmFtcywgZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25zLCBsYWJlbEhlaWdodCwgaHRtbDtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSBwYXJhbXMuZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KHBhcmFtcy5mb3JtYXR0ZWRWYWx1ZXNbMF1bMF0sIHRoaXMudGhlbWUubGFiZWwpO1xuXG4gICAgICAgIGh0bWwgPSB0dWkudXRpbC5tYXAocGFyYW1zLmZvcm1hdHRlZFZhbHVlcywgZnVuY3Rpb24odmFsdWVzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gZ3JvdXBQb3NpdGlvbnNbZ3JvdXBJbmRleF1baW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgodmFsdWUsIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEh0bWwgPSB0aGlzLm1ha2VTZXJpZXNMYWJlbEh0bWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIChsYWJlbFdpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCAtIGxhYmVsSGVpZ2h0IC0gY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElOR1xuICAgICAgICAgICAgICAgICAgICB9LCB2YWx1ZSwgaW5kZXgsIGdyb3VwSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbEh0bWw7XG4gICAgICAgICAgICB9LCB0aGlzKS5qb2luKCcnKTtcbiAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG5cbiAgICAgICAgZWxTZXJpZXNMYWJlbEFyZWEuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRCb3VuZDogZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBQb3NpdGlvbnNbaW5kZXhdW2dyb3VwSW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxheWVyWSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZEluZGV4OiBmdW5jdGlvbihncm91cEluZGV4LCBsYXllclkpIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGRpZmYgPSAxMDAwO1xuXG4gICAgICAgIGlmICghdGhpcy50aWNrSXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0l0ZW1zID0gdHVpLnV0aWwucGl2b3QodGhpcy5ncm91cFBvc2l0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHRoaXMudGlja0l0ZW1zW2dyb3VwSW5kZXhdLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb21wYXJlID0gTWF0aC5hYnMobGF5ZXJZIC0gcG9zaXRpb24udG9wKTtcbiAgICAgICAgICAgIGlmIChkaWZmID4gY29tcGFyZSkge1xuICAgICAgICAgICAgICAgIGRpZmYgPSBjb21wYXJlO1xuICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZEluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNoYW5nZWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgY2hhbmdlZCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NoYW5nZWQ6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIHZhciBwcmV2SW5kZXhlcyA9IHRoaXMucHJldkluZGV4ZXM7XG5cbiAgICAgICAgdGhpcy5wcmV2SW5kZXhlcyA9IHtcbiAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gIXByZXZJbmRleGVzIHx8IChwcmV2SW5kZXhlcy5ncm91cEluZGV4ICE9PSBncm91cEluZGV4KSB8fCAocHJldkluZGV4ZXMuaW5kZXggIT09IGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBzaG93R3JvdXBUb29sdGlwTGluZSBmdW5jdGlvbiBvZiBncmFwaFJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGJvdW5kIGJvdW5kXG4gICAgICovXG4gICAgb25TaG93R3JvdXBUb29sdGlwTGluZTogZnVuY3Rpb24oYm91bmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0dyb3VwVG9vbHRpcExpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0dyb3VwVG9vbHRpcExpbmUoYm91bmQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGhpZGVHcm91cFRvb2x0aXBMaW5lIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICovXG4gICAgb25IaWRlR3JvdXBUb29sdGlwTGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVHcm91cFRvb2x0aXBMaW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVHcm91cFRvb2x0aXBMaW5lKCk7XG4gICAgfVxufSk7XG5cbkxpbmVUeXBlU2VyaWVzQmFzZS5taXhpbiA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB0dWkudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIExpbmVUeXBlU2VyaWVzQmFzZS5wcm90b3R5cGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVHlwZVNlcmllc0Jhc2U7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGllIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIGV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2V2ZW50TGlzdGVuZXInKTtcblxudmFyIFBpZUNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIFBpZUNoYXJ0U2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTGluZSBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIFBpZUNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1vZGVsIHNlcmllcyBtb2RlbFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBTZXJpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBwZXJjZW50IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7e3ZhbHVlczogYXJyYXksIHNjYWxlOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX19IGRhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPGFycmF5LjxudW1iZXI+Pn0gcGVyY2VudCB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGVyY2VudFZhbHVlczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHVpLnV0aWwubWFwKGRhdGEudmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSB0dWkudXRpbC5zdW0odmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAvIHN1bTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBzZWN0b3JzIGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSB7YXJyYXkuPG51bWJlcj59IHBlcmNlbnRWYWx1ZXMgcGVyY2VudCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge3tjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9fSBjaXJjbGVCb3VuZCBjaXJjbGUgYm91bmRcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPG9iamVjdD59IHNlY3RvcnMgaW5mb3JtYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VjdG9yc0luZm86IGZ1bmN0aW9uKHBlcmNlbnRWYWx1ZXMsIGNpcmNsZUJvdW5kKSB7XG4gICAgICAgIHZhciBjeCA9IGNpcmNsZUJvdW5kLmN4LFxuICAgICAgICAgICAgY3kgPSBjaXJjbGVCb3VuZC5jeSxcbiAgICAgICAgICAgIHIgPSBjaXJjbGVCb3VuZC5yLFxuICAgICAgICAgICAgYW5nbGUgPSAwLFxuICAgICAgICAgICAgZGVsdGEgPSAxMCxcbiAgICAgICAgICAgIHBhdGhzO1xuXG4gICAgICAgIHBhdGhzID0gdHVpLnV0aWwubWFwKHBlcmNlbnRWYWx1ZXMsIGZ1bmN0aW9uKHBlcmNlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGFkZEFuZ2xlID0gY2hhcnRDb25zdC5BTkdMRV8zNjAgKiBwZXJjZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBhbmdsZSArIGFkZEFuZ2xlLFxuICAgICAgICAgICAgICAgIHBvcHVwQW5nbGUgPSBhbmdsZSArIChhZGRBbmdsZSAvIDIpLFxuICAgICAgICAgICAgICAgIGFuZ2xlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogYW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25EYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgYW5nbGU6IHBvcHVwQW5nbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudFZhbHVlOiBwZXJjZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgYW5nbGVzOiBhbmdsZXMsXG4gICAgICAgICAgICAgICAgY2VudGVyUG9zaXRpb246IHRoaXMuX2dldEFyY1Bvc2l0aW9uKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIHI6IChyIC8gMikgKyBkZWx0YVxuICAgICAgICAgICAgICAgIH0sIHBvc2l0aW9uRGF0YSkpLFxuICAgICAgICAgICAgICAgIG91dGVyUG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuX2dldEFyY1Bvc2l0aW9uKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByOiByXG4gICAgICAgICAgICAgICAgICAgIH0sIHBvc2l0aW9uRGF0YSkpLFxuICAgICAgICAgICAgICAgICAgICBtaWRkbGU6IHRoaXMuX2dldEFyY1Bvc2l0aW9uKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByOiByICsgZGVsdGFcbiAgICAgICAgICAgICAgICAgICAgfSwgcG9zaXRpb25EYXRhKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugc2VyaWVzIGRhdGEuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgc2VyaWVzIGJvdW5kXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGNoYXJ0QmFja2dyb3VuZDogc3RyaW5nLFxuICAgICAqICAgICAgY2lyY2xlQm91bmQ6ICh7Y3g6IG51bWJlciwgY3k6IG51bWJlciwgcjogbnVtYmVyfSksXG4gICAgICogICAgICBzZWN0b3JzSW5mbzogYXJyYXkuPG9iamVjdD5cbiAgICAgKiB9fSBhZGQgZGF0YSBmb3IgZ3JhcGggcmVuZGVyaW5nXG4gICAgICovXG4gICAgbWFrZVNlcmllc0RhdGE6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHZhciBjaXJjbGVCb3VuZCA9IHRoaXMuX21ha2VDaXJjbGVCb3VuZChib3VuZC5kaW1lbnNpb24sIHtcbiAgICAgICAgICAgICAgICBzaG93TGFiZWw6IHRoaXMub3B0aW9ucy5zaG93TGFiZWwsXG4gICAgICAgICAgICAgICAgbGVnZW5kQWxpZ246IHRoaXMubGVnZW5kQWxpZ25cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2VjdG9yc0luZm8gPSB0aGlzLl9tYWtlU2VjdG9yc0luZm8odGhpcy5wZXJjZW50VmFsdWVzWzBdLCBjaXJjbGVCb3VuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFydEJhY2tncm91bmQ6IHRoaXMuY2hhcnRCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgY2lyY2xlQm91bmQ6IGNpcmNsZUJvdW5kLFxuICAgICAgICAgICAgc2VjdG9yc0luZm86IHNlY3RvcnNJbmZvXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgY2lyY2xlIGJvdW5kXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IGRpbWVuc2lvbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tzaG93TGFiZWw6IGJvb2xlYW4sIGxlZ2VuZEFsaWduOiBzdHJpbmd9fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlcn19IGNpcmNsZSBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ2lyY2xlQm91bmQ6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgd2lkdGggPSBkaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgaXNTbWFsbFBpZSA9IHByZWRpY2F0ZS5pc091dGVyTGVnZW5kQWxpZ24ob3B0aW9ucy5sZWdlbmRBbGlnbikgJiYgb3B0aW9ucy5zaG93TGFiZWwsXG4gICAgICAgICAgICByYWRpdXNSYXRlID0gaXNTbWFsbFBpZSA/IGNoYXJ0Q29uc3QuUElFX0dSQVBIX1NNQUxMX1JBVEUgOiBjaGFydENvbnN0LlBJRV9HUkFQSF9ERUZBVUxUX1JBVEUsXG4gICAgICAgICAgICBkaWFtZXRlciA9IHR1aS51dGlsLm11bHRpcGxpY2F0aW9uKHR1aS51dGlsLm1pbihbd2lkdGgsIGhlaWdodF0pLCByYWRpdXNSYXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiB0dWkudXRpbC5kaXZpc2lvbih3aWR0aCwgMiksXG4gICAgICAgICAgICBjeTogdHVpLnV0aWwuZGl2aXNpb24oaGVpZ2h0LCAyKSxcbiAgICAgICAgICAgIHI6IHR1aS51dGlsLmRpdmlzaW9uKGRpYW1ldGVyLCAyKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXJjIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5jeCBjZW50ZXIgeFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5jeSBjZW50ZXIgeVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5yIHJhZGl1c1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5hbmdsZSBhbmdsZShkZWdyZWUpXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYXJjIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QXJjUG9zaXRpb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcGFyYW1zLmN4ICsgKHBhcmFtcy5yICogTWF0aC5zaW4ocGFyYW1zLmFuZ2xlICogY2hhcnRDb25zdC5SQUQpKSxcbiAgICAgICAgICAgIHRvcDogcGFyYW1zLmN5IC0gKHBhcmFtcy5yICogTWF0aC5jb3MocGFyYW1zLmFuZ2xlICogY2hhcnRDb25zdC5SQUQpKVxuICAgICAgICB9O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYWRkIGRhdGEgZm9yIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICAgICAqICAgICAgbGVnZW5kTGFiZWxzOiBhcnJheS48c3RyaW5nPixcbiAgICAgKiAgICAgIG9wdGlvbnM6IHtsZWdlbmRBbGlnbjogc3RyaW5nLCBzaG93TGFiZWw6IGJvb2xlYW59LFxuICAgICAqICAgICAgY2hhcnRXaWR0aDogbnVtYmVyLFxuICAgICAqICAgICAgZm9ybWF0dGVkVmFsdWVzOiBhcnJheVxuICAgICAqIH19IGFkZCBkYXRhIGZvciBtYWtlIHNlcmllcyBsYWJlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhRm9yU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHM6IHRoaXMuZGF0YS5sZWdlbmRMYWJlbHMsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbGVnZW5kQWxpZ246IHRoaXMubGVnZW5kQWxpZ24sXG4gICAgICAgICAgICAgICAgc2hvd0xhYmVsOiB0aGlzLm9wdGlvbnMuc2hvd0xhYmVsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhcnRXaWR0aDogdGhpcy5kYXRhLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXM6IHRoaXMuZGF0YS5mb3JtYXR0ZWRWYWx1ZXNbMF1cbiAgICAgICAgfSwgc2VyaWVzRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlbmRlciByYXBoYWVsIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhcGg6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgZnVuY1Nob3dUb29sdGlwID0gdHVpLnV0aWwuYmluZCh0aGlzLnNob3dUb29sdGlwLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6ICEhdGhpcy5hbGxvd05lZ2F0aXZlVG9vbHRpcCxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgICAgICBmdW5jU2hvd1Rvb2x0aXA6IGZ1bmNTaG93VG9vbHRpcCxcbiAgICAgICAgICAgICAgICBmdW5jSGlkZVRvb2x0aXA6IHR1aS51dGlsLmJpbmQodGhpcy5oaWRlVG9vbHRpcCwgdGhpcyksXG4gICAgICAgICAgICAgICAgZnVuY1NlbGVjdFNlcmllczogdHVpLnV0aWwuYmluZCh0aGlzLnNlbGVjdFNlcmllcywgdGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJhbXMgPSB0aGlzLl9tYWtlUGFyYW1zRm9yR3JhcGhSZW5kZXJpbmcoZGltZW5zaW9uLCBzZXJpZXNEYXRhKTtcblxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIucmVuZGVyKHRoaXMuZWxTZXJpZXNBcmVhLCBwYXJhbXMsIGNhbGxiYWNrcyk7XG5cbiAgICAgICAgLy8gc2VyaWVzIGxhYmVsIG1vdXNlIGV2ZW50IOuPmeyekSDsi5wg7IKs7JqpXG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAgPSBmdW5jU2hvd1Rvb2x0aXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlbmRlciBzZXJpZXMgY29tcG9uZW50IG9mIHBpZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBib3VuZCBzZXJpZXMgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHNlcmllcyBlbGVtZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsID0gU2VyaWVzLnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFdmVudChlbCk7XG5cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaG93VG9vbHRpcCBpcyBtb3VzZW92ZXIgZXZlbnQgY2FsbGJhY2sgb24gc2VyaWVzIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuYWxsb3dOZWdhdGl2ZVRvb2x0aXAgd2hldGhlciBhbGxvdyBuZWdhdGl2ZSB0b29sdGlwIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7e3RvcDpudW1iZXIsIGxlZnQ6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBib3VuZCBncmFwaCBib3VuZCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHt7Y2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJ9fSBldmVudFBvc2l0aW9uIG1vdXNlIGV2ZW50IHBvc2l0aW9uXG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKHBhcmFtcywgYm91bmQsIGdyb3VwSW5kZXgsIGluZGV4LCBldmVudFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXAnLCB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm91bmQ6IGJvdW5kLFxuICAgICAgICAgICAgZXZlbnRQb3NpdGlvbjogZXZlbnRQb3NpdGlvblxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGlkZVRvb2x0aXAgaXMgbW91c2VvdXQgZXZlbnQgY2FsbGJhY2sgb24gc2VyaWVzIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0b29sdGlwIGlkXG4gICAgICovXG4gICAgaGlkZVRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2hpZGVUb29sdGlwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugc2VyaWVzIGRhdGEgYnkgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEByZXR1cm5zIHt7aW5kZXhlczoge2luZGV4OiBudW1iZXIsIGdyb3VwSW5kZXg6IG51bWJlcn19fSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhQnlTZWxlY3Rpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNlbGVjdFNlcmllcyBpcyBjbGljayBldmVudCBjYWxsYmFjayBvbiBzZXJpZXMgZ3JhcGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHRoaXMuX21ha2VTZXJpZXNEYXRhQnlTZWxlY3Rpb24oaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5vblVuc2VsZWN0U2VyaWVzKHNlcmllc0RhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQodGhpcy5zZWxlY3RlZEluZGV4KSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25VbnNlbGVjdFNlcmllcyh0aGlzLl9tYWtlU2VyaWVzRGF0YUJ5U2VsZWN0aW9uKHRoaXMuc2VsZWN0ZWRJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdFNlcmllcyhzZXJpZXNEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmxlZ2VuZCBsZWdlbmRcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubGFiZWwgbGFiZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2VwYXJhdG9yIHNlcGFyYXRvclxuICAgICAqICAgICAgQHBhcmFtIHt7bGVnZW5kQWxpZ246ID9zdHJpbmcsIHNob3dMYWJlbDogYm9vbGVhbn19IHBhcmFtcy5vcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzZXJpZXMgbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTZXJpZXNMYWJlbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZXJpZXNMYWJlbCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm9wdGlvbnMubGVnZW5kQWxpZ24pIHtcbiAgICAgICAgICAgIHNlcmllc0xhYmVsID0gJzxzcGFuIGNsYXNzPVwidHVpLWNoYXJ0LXNlcmllcy1sZWdlbmRcIj4nICsgcGFyYW1zLmxlZ2VuZCArICc8L3NwYW4+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMub3B0aW9ucy5zaG93TGFiZWwpIHtcbiAgICAgICAgICAgIHNlcmllc0xhYmVsICs9IChzZXJpZXNMYWJlbCA/IHBhcmFtcy5zZXBhcmF0b3IgOiAnJykgKyBwYXJhbXMubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzTGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjZW50ZXIgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48b2JqZWN0Pn0gcGFyYW1zLnBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IHBhcmFtcy5sZWdlbmRzIGxlZ2VuZExhYmVsc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48c3RyaW5nPn0gcGFyYW1zLmZvcm1hdHRlZFZhbHVlcyBmb3JtYXR0ZWQgdmFsdWVzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNlcGFyYXRvciBzZXBhcmF0b3JcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJhbXMuZnVuY01vdmVUb1Bvc2l0aW9uIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxTZXJpZXNMYWJlbEFyZWEgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckxlZ2VuZExhYmVsOiBmdW5jdGlvbihwYXJhbXMsIGVsU2VyaWVzTGFiZWxBcmVhKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBwYXJhbXMucG9zaXRpb25zLFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVzID0gcGFyYW1zLmZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgICAgIGh0bWw7XG4gICAgICAgIGh0bWwgPSB0dWkudXRpbC5tYXAocGFyYW1zLmxlZ2VuZExhYmVscywgZnVuY3Rpb24obGVnZW5kLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fZ2V0U2VyaWVzTGFiZWwoe1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdHRlZFZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjogcGFyYW1zLnNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnNcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBhcmFtcy5mdW5jTW92ZVRvUG9zaXRpb24ocG9zaXRpb25zW2luZGV4XSwgbGFiZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVNlcmllc0xhYmVsSHRtbChwb3NpdGlvbiwgbGFiZWwsIDAsIGluZGV4KTtcbiAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG5cbiAgICAgICAgZWxTZXJpZXNMYWJlbEFyZWEuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byBjZW50ZXIgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIGxhYmVsXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gY2VudGVyIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW92ZVRvQ2VudGVyUG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBsYWJlbCkge1xuICAgICAgICB2YXIgbGVmdCA9IHBvc2l0aW9uLmxlZnQgLSAocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpIC8gMiksXG4gICAgICAgICAgICB0b3AgPSBwb3NpdGlvbi50b3AgLSAocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSAvIDIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjZW50ZXIgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5zZWN0b3JzSW5mbyBzZWN0b3IgaW5mb1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsU2VyaWVzTGFiZWxBcmVhIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDZW50ZXJMZWdlbmQ6IGZ1bmN0aW9uKHBhcmFtcywgZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kTGFiZWwodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogdHVpLnV0aWwucGx1Y2socGFyYW1zLnNlY3RvcnNJbmZvLCAnY2VudGVyUG9zaXRpb24nKSxcbiAgICAgICAgICAgIGZ1bmNNb3ZlVG9Qb3NpdGlvbjogdHVpLnV0aWwuYmluZCh0aGlzLl9tb3ZlVG9DZW50ZXJQb3NpdGlvbiwgdGhpcyksXG4gICAgICAgICAgICBzZXBhcmF0b3I6ICc8YnI+J1xuICAgICAgICB9LCBwYXJhbXMpLCBlbFNlcmllc0xhYmVsQXJlYSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBlbmQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlckxlZnQgY2VudGVyIGxlZnRcbiAgICAgKiBAcGFyYW0ge2FycmF5LjxvYmplY3Q+fSBwb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkRW5kUG9zaXRpb246IGZ1bmN0aW9uKGNlbnRlckxlZnQsIHBvc2l0aW9ucykge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0dWkudXRpbC5leHRlbmQoe30sIHBvc2l0aW9uLm1pZGRsZSk7XG4gICAgICAgICAgICBpZiAoZW5kLmxlZnQgPCBjZW50ZXJMZWZ0KSB7XG4gICAgICAgICAgICAgICAgZW5kLmxlZnQgLT0gY2hhcnRDb25zdC5TRVJJRVNfT1VURVJfTEFCRUxfUEFERElORztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kLmxlZnQgKz0gY2hhcnRDb25zdC5TRVJJRVNfT1VURVJfTEFCRUxfUEFERElORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IGVuZDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gb3V0ZXIgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlckxlZnQgY2VudGVyIGxlZnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWxcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBvdXRlciBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdmVUb091dGVyUG9zaXRpb246IGZ1bmN0aW9uKGNlbnRlckxlZnQsIHBvc2l0aW9uLCBsYWJlbCkge1xuICAgICAgICB2YXIgcG9zaXRpb25FbmQgPSBwb3NpdGlvbi5lbmQsXG4gICAgICAgICAgICBsZWZ0ID0gcG9zaXRpb25FbmQubGVmdCxcbiAgICAgICAgICAgIHRvcCA9IHBvc2l0aW9uRW5kLnRvcCAtIChyZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpIC8gMik7XG5cbiAgICAgICAgaWYgKGxlZnQgPCBjZW50ZXJMZWZ0KSB7XG4gICAgICAgICAgICBsZWZ0IC09IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ICs9IGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBvdXRlciBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnNlY3RvcnNJbmZvIHNlY3RvciBpbmZvXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmNoYXJ0V2lkdGggY2hhcnQgd2lkdGhcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFNlcmllc0xhYmVsQXJlYSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyT3V0ZXJMZWdlbmQ6IGZ1bmN0aW9uKHBhcmFtcywgZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgdmFyIG91dGVyUG9zaXRpb25zID0gdHVpLnV0aWwucGx1Y2socGFyYW1zLnNlY3RvcnNJbmZvLCAnb3V0ZXJQb3NpdGlvbicpLFxuICAgICAgICAgICAgY2VudGVyTGVmdCA9IHBhcmFtcy5jaGFydFdpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5fYWRkRW5kUG9zaXRpb24oY2VudGVyTGVmdCwgb3V0ZXJQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLl9yZW5kZXJMZWdlbmRMYWJlbCh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiBvdXRlclBvc2l0aW9ucyxcbiAgICAgICAgICAgIGZ1bmNNb3ZlVG9Qb3NpdGlvbjogdHVpLnV0aWwuYmluZCh0aGlzLl9tb3ZlVG9PdXRlclBvc2l0aW9uLCB0aGlzLCBjZW50ZXJMZWZ0KSxcbiAgICAgICAgICAgIHNlcGFyYXRvcjogJzombmJzcDsnXG4gICAgICAgIH0sIHBhcmFtcyksIGVsU2VyaWVzTGFiZWxBcmVhKTtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlckxlZ2VuZExpbmVzKG91dGVyUG9zaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFNlcmllc0xhYmVsQXJlYSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKHBhcmFtcywgZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgdmFyIGxlZ2VuZEFsaWduID0gcGFyYW1zLm9wdGlvbnMubGVnZW5kQWxpZ247XG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNPdXRlckxlZ2VuZEFsaWduKGxlZ2VuZEFsaWduKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyT3V0ZXJMZWdlbmQocGFyYW1zLCBlbFNlcmllc0xhYmVsQXJlYSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlLmlzQ2VudGVyTGVnZW5kQWxpZ24obGVnZW5kQWxpZ24pKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDZW50ZXJMZWdlbmQocGFyYW1zLCBlbFNlcmllc0xhYmVsQXJlYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudWxsfSBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgc2hvd2luZyBhYm91dCBzZXJpZXMgbGFiZWwgYXJlYS5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBhbmltYXRlU2hvd2luZ0Fib3V0U2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmFuaW1hdGVMZWdlbmRMaW5lcygpO1xuICAgICAgICBTZXJpZXMucHJvdG90eXBlLmFuaW1hdGVTaG93aW5nQWJvdXRTZXJpZXNMYWJlbEFyZWEuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBzZXJpZXMgbGFiZWwgYXJlYS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHNob3dTZXJpZXNMYWJlbEFyZWE6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIG91dGVyUG9zaXRpb25zID0gdHVpLnV0aWwucGx1Y2soc2VyaWVzRGF0YS5zZWN0b3JzSW5mbywgJ291dGVyUG9zaXRpb24nKSxcbiAgICAgICAgICAgIGNlbnRlckxlZnQgPSB0aGlzLmRhdGEuY2hhcnRXaWR0aCAvIDI7XG4gICAgICAgIHRoaXMuX2FkZEVuZFBvc2l0aW9uKGNlbnRlckxlZnQsIG91dGVyUG9zaXRpb25zKTtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLm1vdmVMZWdlbmRMaW5lcyhvdXRlclBvc2l0aW9ucyk7XG4gICAgICAgIFNlcmllcy5wcm90b3R5cGUuc2hvd1Nlcmllc0xhYmVsQXJlYS5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBoYW5kbGUgbW91c2UgZXZlbnQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVNb3VzZUV2ZW50OiBmdW5jdGlvbihlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICBlbExhYmVsID0gdGhpcy5fZmluZExhYmVsRWxlbWVudChlbFRhcmdldCksXG4gICAgICAgICAgICBncm91cEluZGV4LCBpbmRleDtcblxuICAgICAgICBpZiAoIWVsTGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwSW5kZXggPSBwYXJzZUludChlbExhYmVsLmdldEF0dHJpYnV0ZSgnZGF0YS1ncm91cC1pbmRleCcpLCAxMCk7XG4gICAgICAgIGluZGV4ID0gcGFyc2VJbnQoZWxMYWJlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApO1xuXG4gICAgICAgIGlmIChncm91cEluZGV4ID09PSAtMSB8fCBpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGdyb3VwSW5kZXgsIGluZGV4LCBlbFRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbGVnZW5kIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUYXJnZXQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGxlZ2VuZCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZExlZ2VuZEVsZW1lbnQ6IGZ1bmN0aW9uKGVsVGFyZ2V0KSB7XG4gICAgICAgIHZhciBlbExlZ2VuZDtcbiAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5DTEFTU19OQU1FX1NFUklFU19MRUdFTkQpKSB7XG4gICAgICAgICAgICBlbExlZ2VuZCA9IGVsVGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsTGVnZW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljayBldmVudCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KGUsIGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4LCBlbFRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGVsTGVnZW5kID0gdGhhdC5fZmluZExlZ2VuZEVsZW1lbnQoZWxUYXJnZXQpLFxuICAgICAgICAgICAgICAgIGxlZ2VuZERhdGE7XG5cbiAgICAgICAgICAgIGlmICghZWxMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdFNlcmllcyhpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZ2VuZERhdGEgPSB0aGF0LmRhdGEuam9pbkxlZ2VuZExhYmVsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdGhhdC51c2VyRXZlbnQuZmlyZSgnc2VsZWN0TGVnZW5kJywge1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZERhdGEubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogbGVnZW5kRGF0YS5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZEluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlb3Zlci5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlb3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoZSwgZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZCA9IHRoYXQuX2dldEJvdW5kKGdyb3VwSW5kZXgsIGluZGV4KSB8fCB0aGF0Ll9tYWtlTGFiZWxCb3VuZChlLmNsaWVudFgsIGUuY2xpZW50WSAtIDEwKTtcbiAgICAgICAgICAgIHRoYXQuc2hvd1Rvb2x0aXAoYm91bmQsIGdyb3VwSW5kZXgsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgZXZlbnQgaGFuZGxlciBmb3IgbW91c2VvdXQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZW91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoZSwgZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoYXQuaGlkZVRvb2x0aXAoZ3JvdXBJbmRleCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGV2ZW50XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKi9cbiAgICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lci5iaW5kRXZlbnQoJ2NsaWNrJywgZWwsIHR1aS51dGlsLmJpbmQodGhpcy5vbkNsaWNrLCB0aGlzKSk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZW92ZXInLCBlbCwgdHVpLnV0aWwuYmluZCh0aGlzLm9uTW91c2VvdmVyLCB0aGlzKSk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZW91dCcsIGVsLCB0dWkudXRpbC5iaW5kKHRoaXMub25Nb3VzZW91dCwgdGhpcykpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oUGllQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBpZUNoYXJ0U2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlcmllcyBiYXNlIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNlcmllc1RlbXBsYXRlID0gcmVxdWlyZSgnLi9zZXJpZXNUZW1wbGF0ZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIHBsdWdpbkZhY3RvcnkgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvcGx1Z2luRmFjdG9yeScpO1xuXG52YXIgU2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBTZXJpZXMgYmFzZSBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgU2VyaWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1vZGVsIHNlcmllcyBtb2RlbFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbGliVHlwZTtcblxuICAgICAgICB0dWkudXRpbC5leHRlbmQodGhpcywgcGFyYW1zKTtcbiAgICAgICAgbGliVHlwZSA9IHBhcmFtcy5saWJUeXBlIHx8IGNoYXJ0Q29uc3QuREVGQVVMVF9QTFVHSU47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoIHJlbmRlcmVyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIgPSBwbHVnaW5GYWN0b3J5LmdldChsaWJUeXBlLCBwYXJhbXMuY2hhcnRUeXBlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VyaWVzIHZpZXcgY2xhc3NOYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY2hhcnQtc2VyaWVzLWFyZWEnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHNlcmllcyBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGFkZCBkYXRhXG4gICAgICovXG4gICAgbWFrZVNlcmllc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZXJpZXNEYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKi9cbiAgICBnZXRTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFNldCBiYXNlIGRhdGEuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgc2VyaWVzIGJvdW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0QmFzZURhdGE6IGZ1bmN0aW9uKGJvdW5kLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHR1aS51dGlsLmV4dGVuZCh0aGlzLmRhdGEsIGRhdGEpO1xuICAgICAgICB0aGlzLmJvdW5kID0gYm91bmQ7XG4gICAgICAgIHRoaXMucGVyY2VudFZhbHVlcyA9IHRoaXMuX21ha2VQZXJjZW50VmFsdWVzKHRoaXMuZGF0YSwgdGhpcy5vcHRpb25zLnN0YWNrZWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZW5kZXIgc2VyaWVzIGxhYmVsIGFyZWFcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0gez9IVE1MRWxlbWVudH0gZWxTZXJpZXNMYWJlbEFyZWEgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsQXJlYTogZnVuY3Rpb24oZGltZW5zaW9uLCBzZXJpZXNEYXRhLCBlbFNlcmllc0xhYmVsQXJlYSkge1xuICAgICAgICB2YXIgYWRkRGF0YUZvclNlcmllc0xhYmVsID0gdGhpcy5fbWFrZVNlcmllc0RhdGFGb3JTZXJpZXNMYWJlbChzZXJpZXNEYXRhLCBkaW1lbnNpb24pO1xuICAgICAgICBpZiAoIWVsU2VyaWVzTGFiZWxBcmVhKSB7XG4gICAgICAgICAgICBlbFNlcmllc0xhYmVsQXJlYSA9IGRvbS5jcmVhdGUoJ2RpdicsICd0dWktY2hhcnQtc2VyaWVzLWxhYmVsLWFyZWEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0xhYmVsKGFkZERhdGFGb3JTZXJpZXNMYWJlbCwgZWxTZXJpZXNMYWJlbEFyZWEpO1xuICAgICAgICByZXR1cm4gZWxTZXJpZXNMYWJlbEFyZWE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlbmRlciBzZXJpZXMgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFNlcmllc0FyZWEgc2VyaWVzIGFyZWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGJvdW5kIHNlcmllcyBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNSZW5kZXJHcmFwaCBmdW5jdGlvbiBmb3IgZ3JhcGggcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzQXJlYTogZnVuY3Rpb24oZWxTZXJpZXNBcmVhLCBib3VuZCwgZGF0YSwgZnVuY1JlbmRlckdyYXBoKSB7XG4gICAgICAgIHZhciBleHBhbmRlZEJvdW5kLCBzZXJpZXNEYXRhLCBlbFNlcmllc0xhYmVsQXJlYTtcblxuICAgICAgICB0aGlzLl9zZXRCYXNlRGF0YShib3VuZCwgZGF0YSk7XG5cbiAgICAgICAgZXhwYW5kZWRCb3VuZCA9IHJlbmRlclV0aWwuZXhwYW5kQm91bmQoYm91bmQpO1xuICAgICAgICB0aGlzLnNlcmllc0RhdGEgPSBzZXJpZXNEYXRhID0gdGhpcy5tYWtlU2VyaWVzRGF0YShib3VuZCk7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oZWxTZXJpZXNBcmVhLCBleHBhbmRlZEJvdW5kLmRpbWVuc2lvbik7XG4gICAgICAgIHRoaXMuX3JlbmRlclBvc2l0aW9uKGVsU2VyaWVzQXJlYSwgZXhwYW5kZWRCb3VuZC5wb3NpdGlvbiwgdGhpcy5jaGFydFR5cGUpO1xuICAgICAgICBmdW5jUmVuZGVyR3JhcGgoZXhwYW5kZWRCb3VuZC5kaW1lbnNpb24sIHNlcmllc0RhdGEpO1xuXG4gICAgICAgIGVsU2VyaWVzTGFiZWxBcmVhID0gdGhpcy5fcmVuZGVyU2VyaWVzTGFiZWxBcmVhKGV4cGFuZGVkQm91bmQuZGltZW5zaW9uLCBzZXJpZXNEYXRhLCB0aGlzLmVsU2VyaWVzTGFiZWxBcmVhKTtcblxuICAgICAgICBpZiAoIXRoaXMuZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuZWxTZXJpZXNMYWJlbEFyZWEgPSBlbFNlcmllc0xhYmVsQXJlYTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQoZWxTZXJpZXNBcmVhLCBlbFNlcmllc0xhYmVsQXJlYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBwYXJhbWV0ZXJzIGZvciBncmFwaCByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJhbWV0ZXJzIGZvciBncmFwaCByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGFyYW1zRm9yR3JhcGhSZW5kZXJpbmc6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXG4gICAgICAgIH0sIHNlcmllc0RhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZW5kZXIgcmFwaGFlbCBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckdyYXBoOiBmdW5jdGlvbihkaW1lbnNpb24sIHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX21ha2VQYXJhbXNGb3JHcmFwaFJlbmRlcmluZyhkaW1lbnNpb24sIHNlcmllc0RhdGEpO1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIucmVuZGVyKHRoaXMuZWxTZXJpZXNBcmVhLCBwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZW5kZXIgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBib3VuZCBzZXJpZXMgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHNlcmllcyBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihib3VuZCwgZGF0YSkge1xuICAgICAgICB2YXIgZWwgPSBkb20uY3JlYXRlKCdESVYnLCB0aGlzLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgdGhpcy5lbFNlcmllc0FyZWEgPSBlbDtcblxuICAgICAgICB0aGlzLl9yZW5kZXJTZXJpZXNBcmVhKGVsLCBib3VuZCwgZGF0YSwgdHVpLnV0aWwuYmluZCh0aGlzLl9yZW5kZXJHcmFwaCwgdGhpcykpO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVzaXplIHJhcGhhZWwgZ3JhcGguXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNpemVHcmFwaDogZnVuY3Rpb24oZGltZW5zaW9uLCBzZXJpZXNEYXRhKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZXNpemUodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uXG4gICAgICAgIH0sIHNlcmllc0RhdGEpKTtcbiAgICAgICAgdGhpcy5zaG93U2VyaWVzTGFiZWxBcmVhKHNlcmllc0RhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZXNpemUgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBib3VuZCBzZXJpZXMgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKGJvdW5kLCBkYXRhKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWxTZXJpZXNBcmVhO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0FyZWEoZWwsIGJvdW5kLCBkYXRhLCB0dWkudXRpbC5iaW5kKHRoaXMuX3Jlc2l6ZUdyYXBoLCB0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYWRkIGRhdGEgZm9yIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICAgICAqICAgICAgdmFsdWVzOiBhcnJheS48YXJyYXk+LFxuICAgICAqICAgICAgZm9ybWF0dGVkVmFsdWVzOiBhcnJheS48YXJyYXk+LFxuICAgICAqICAgICAgZm9ybWF0RnVuY3Rpb25zOiBhcnJheS48ZnVuY3Rpb24+LFxuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9XG4gICAgICogfX0gYWRkIGRhdGEgZm9yIHNlcmllcyBsYWJlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhRm9yU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKHNlcmllc0RhdGEsIGRpbWVuc2lvbikge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy5kYXRhLnZhbHVlcyxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlczogdGhpcy5kYXRhLmZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uczogdGhpcy5kYXRhLmZvcm1hdEZ1bmN0aW9ucyxcbiAgICAgICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uXG4gICAgICAgIH0sIHNlcmllc0RhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYm91bmRzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgc2VyaWVzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb24gc2VyaWVzIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyUG9zaXRpb246IGZ1bmN0aW9uKGVsLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgaGlkZGVuV2lkdGggPSByZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpID8gY2hhcnRDb25zdC5ISURERU5fV0lEVEggOiAwO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGVsLCB7XG4gICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCAtIChoaWRkZW5XaWR0aCAqIDIpLFxuICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGhpZGRlbldpZHRoXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHBlcmNlbnQgdmFsdWUuXG4gICAgICogQHBhcmFtIHt7dmFsdWVzOiBhcnJheSwgc2NhbGU6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fX0gZGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja2VkIHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHJldHVybnMge2FycmF5LjxhcnJheS48bnVtYmVyPj59IHBlcmNlbnQgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBlcmNlbnRWYWx1ZXM6IGZ1bmN0aW9uKGRhdGEsIHN0YWNrZWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHN0YWNrZWQgPT09IGNoYXJ0Q29uc3QuU1RBQ0tFRF9OT1JNQUxfVFlQRSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWFrZU5vcm1hbFN0YWNrZWRQZXJjZW50VmFsdWVzKGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YWNrZWQgPT09IGNoYXJ0Q29uc3QuU1RBQ0tFRF9QRVJDRU5UX1RZUEUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21ha2VQZXJjZW50U3RhY2tlZFBlcmNlbnRWYWx1ZXMoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYWtlTm9ybWFsUGVyY2VudFZhbHVlcyhkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgcGVyY2VudCB2YWx1ZXMgYWJvdXQgbm9ybWFsIHN0YWNrZWQgb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7e3ZhbHVlczogYXJyYXksIHNjYWxlOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX19IGRhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IHBlcmNlbnQgdmFsdWVzIGFib3V0IG5vcm1hbCBzdGFja2VkIG9wdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTm9ybWFsU3RhY2tlZFBlcmNlbnRWYWx1ZXM6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIG1pbiA9IGRhdGEuc2NhbGUubWluLFxuICAgICAgICAgICAgbWF4ID0gZGF0YS5zY2FsZS5tYXgsXG4gICAgICAgICAgICBkaXN0YW5jZSA9IG1heCAtIG1pbixcbiAgICAgICAgICAgIHBlcmNlbnRWYWx1ZXMgPSB0dWkudXRpbC5tYXAoZGF0YS52YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciBwbHVzVmFsdWVzID0gdHVpLnV0aWwuZmlsdGVyKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzdW0gPSB0dWkudXRpbC5zdW0ocGx1c1ZhbHVlcyksXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUGVyY2VudCA9IChzdW0gLSBtaW4pIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IDAgOiBncm91cFBlcmNlbnQgKiAodmFsdWUgLyBzdW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwZXJjZW50VmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHBlcmNlbnQgdmFsdWVzIGFib3V0IHBlcmNlbnQgc3RhY2tlZCBvcHRpb24uXG4gICAgICogQHBhcmFtIHt7dmFsdWVzOiBhcnJheSwgc2NhbGU6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fX0gZGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHthcnJheX0gcGVyY2VudCB2YWx1ZXMgYWJvdXQgcGVyY2VudCBzdGFja2VkIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQZXJjZW50U3RhY2tlZFBlcmNlbnRWYWx1ZXM6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHBlcmNlbnRWYWx1ZXMgPSB0dWkudXRpbC5tYXAoZGF0YS52YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICAgICAgdmFyIHBsdXNWYWx1ZXMgPSB0dWkudXRpbC5maWx0ZXIodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAwO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHN1bSA9IHR1aS51dGlsLnN1bShwbHVzVmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSAvIHN1bTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBlcmNlbnRWYWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2Ugbm9ybWFsIHBlcmNlbnQgdmFsdWUuXG4gICAgICogQHBhcmFtIHt7dmFsdWVzOiBhcnJheSwgc2NhbGU6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fX0gZGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHthcnJheS48YXJyYXkuPG51bWJlcj4+fSBwZXJjZW50IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxQZXJjZW50VmFsdWVzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBtaW4gPSBkYXRhLnNjYWxlLm1pbixcbiAgICAgICAgICAgIG1heCA9IGRhdGEuc2NhbGUubWF4LFxuICAgICAgICAgICAgZGlzdGFuY2UgPSBtYXggLSBtaW4sXG4gICAgICAgICAgICBpc0xpbmVUeXBlQ2hhcnQgPSBwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGZsYWcgPSAxLFxuICAgICAgICAgICAgc3ViVmFsdWUgPSAwLFxuICAgICAgICAgICAgcGVyY2VudFZhbHVlcztcblxuICAgICAgICBpZiAoIWlzTGluZVR5cGVDaGFydCAmJiBtaW4gPCAwICYmIG1heCA8PSAwKSB7XG4gICAgICAgICAgICBmbGFnID0gLTE7XG4gICAgICAgICAgICBzdWJWYWx1ZSA9IG1heDtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gbWluIC0gbWF4O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVR5cGVDaGFydCB8fCBtaW4gPj0gMCkge1xuICAgICAgICAgICAgc3ViVmFsdWUgPSBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBwZXJjZW50VmFsdWVzID0gdHVpLnV0aWwubWFwKGRhdGEudmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgLSBzdWJWYWx1ZSkgKiBmbGFnIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBlcmNlbnRWYWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzY2FsZSBkaXN0YW5jZSBmcm9tIHplcm8gcG9pbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgY2hhcnQgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IHNjYWxlIHNjYWxlXG4gICAgICogQHJldHVybnMge3t0b01heDogbnVtYmVyLCB0b01pbjogbnVtYmVyfX0gcGl4ZWwgZGlzdGFuY2VcbiAgICAgKi9cbiAgICBnZXRTY2FsZURpc3RhbmNlRnJvbVplcm9Qb2ludDogZnVuY3Rpb24oc2l6ZSwgc2NhbGUpIHtcbiAgICAgICAgdmFyIG1pbiA9IHNjYWxlLm1pbixcbiAgICAgICAgICAgIG1heCA9IHNjYWxlLm1heCxcbiAgICAgICAgICAgIGRpc3RhbmNlID0gbWF4IC0gbWluLFxuICAgICAgICAgICAgdG9NYXggPSAwLFxuICAgICAgICAgICAgdG9NaW4gPSAwO1xuXG4gICAgICAgIGlmIChtaW4gPCAwICYmIG1heCA+IDApIHtcbiAgICAgICAgICAgIHRvTWF4ID0gKGRpc3RhbmNlICsgbWluKSAvIGRpc3RhbmNlICogc2l6ZTtcbiAgICAgICAgICAgIHRvTWluID0gKGRpc3RhbmNlIC0gbWF4KSAvIGRpc3RhbmNlICogc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b01heDogdG9NYXgsXG4gICAgICAgICAgICB0b01pbjogdG9NaW5cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBsYWJlbCBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WCBjbGllbnRYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFkgY2xpZW50WVxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsQm91bmQ6IGZ1bmN0aW9uKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGNsaWVudFggLSB0aGlzLmJvdW5kLnBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICB0b3A6IGNsaWVudFkgLSB0aGlzLmJvdW5kLnBvc2l0aW9uLnRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGxhYmVsIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUYXJnZXQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGxhYmVsIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTGFiZWxFbGVtZW50OiBmdW5jdGlvbihlbFRhcmdldCkge1xuICAgICAgICB2YXIgZWxMYWJlbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5DTEFTU19OQU1FX1NFUklFU19MQUJFTCkpIHtcbiAgICAgICAgICAgIGVsTGFiZWwgPSBlbFRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsTGFiZWwgPSBkb20uZmluZFBhcmVudEJ5Q2xhc3MoZWxUYXJnZXQsIGNoYXJ0Q29uc3QuQ0xBU1NfTkFNRV9TRVJJRVNfTEFCRUwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsTGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgc2hvd0FuaW1hdGlvbiBmdW5jdGlvbiBvZiBncmFwaFJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGRhdGEgZGF0YVxuICAgICAqL1xuICAgIG9uU2hvd0FuaW1hdGlvbjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGhSZW5kZXJlci5zaG93QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dBbmltYXRpb24oZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgaGlkZUFuaW1hdGlvbiBmdW5jdGlvbiBvZiBncmFwaFJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGRhdGEgZGF0YVxuICAgICAqL1xuICAgIG9uSGlkZUFuaW1hdGlvbjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVBbmltYXRpb24oZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgc2hvd0dyb3VwQW5pbWF0aW9uIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgb25TaG93R3JvdXBBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaFJlbmRlcmVyLnNob3dHcm91cEFuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zaG93R3JvdXBBbmltYXRpb24oaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGhpZGVHcm91cEFuaW1hdGlvbiBmdW5jdGlvbiBvZiBncmFwaFJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqL1xuICAgIG9uSGlkZUdyb3VwQW5pbWF0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlR3JvdXBBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUdyb3VwQW5pbWF0aW9uKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgYW5pbWF0ZUNvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmdyYXBoUmVuZGVyZXIuYW5pbWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmFuaW1hdGUodHVpLnV0aWwuYmluZCh0aGlzLmFuaW1hdGVTaG93aW5nQWJvdXRTZXJpZXNMYWJlbEFyZWEsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGh0bWwgYWJvdXQgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBtYWtlU2VyaWVzTGFiZWxIdG1sOiBmdW5jdGlvbihwb3NpdGlvbiwgdmFsdWUsIGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIHZhciBjc3NPYmogPSB0dWkudXRpbC5leHRlbmQocG9zaXRpb24sIHRoaXMudGhlbWUubGFiZWwpO1xuICAgICAgICByZXR1cm4gc2VyaWVzVGVtcGxhdGUudHBsU2VyaWVzTGFiZWwoe1xuICAgICAgICAgICAgY3NzVGV4dDogc2VyaWVzVGVtcGxhdGUudHBsQ3NzVGV4dChjc3NPYmopLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBzZXJpZXMgbGFiZWwgYXJlYS5cbiAgICAgKi9cbiAgICBzaG93U2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlbmRlclV0aWwuaXNPbGRCcm93c2VyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWxTZXJpZXNMYWJlbEFyZWEuc3R5bGUuZmlsdGVyID0gJ2FscGhhKG9wYWNpdHk9JyArIDEwMCArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxTZXJpZXNMYWJlbEFyZWEuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZWxTZXJpZXNMYWJlbEFyZWEsICdzaG93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgc2hvd2luZyBhYm91dCBzZXJpZXMgbGFiZWwgYXJlYS5cbiAgICAgKi9cbiAgICBhbmltYXRlU2hvd2luZ0Fib3V0U2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCghdGhpcy5vcHRpb25zLnNob3dMYWJlbCAmJiAhdGhpcy5sZWdlbmRBbGlnbikgfHwgIXRoaXMuZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmVsU2VyaWVzTGFiZWxBcmVhLCAnc2hvdycpO1xuXG4gICAgICAgIChuZXcgdHVpLmNvbXBvbmVudC5FZmZlY3RzLkZhZGUoe1xuICAgICAgICAgICAgZWxlbWVudDogdGhpcy5lbFNlcmllc0xhYmVsQXJlYSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDBcbiAgICAgICAgfSkpLmFjdGlvbih7XG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHt9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGV4cG9ydGF0aW9uIGRhdGEgZm9yIHNlcmllcyB0eXBlIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHt7Y2hhcnRUeXBlOiBzdHJpbmcsIGxlZ2VuZDogc3RyaW5nLCBsZWdlbmRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gZXhwb3J0IGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRXhwb3J0YXRpb25TZXJpZXNEYXRhOiBmdW5jdGlvbihzZXJpZXNEYXRhKSB7XG4gICAgICAgIHZhciBsZWdlbmRJbmRleCA9IHNlcmllc0RhdGEuaW5kZXhlcy5pbmRleCxcbiAgICAgICAgICAgIGxlZ2VuZERhdGEgPSB0aGlzLmRhdGEuam9pbkxlZ2VuZExhYmVsc1tsZWdlbmRJbmRleF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IGxlZ2VuZERhdGEuY2hhcnRUeXBlLFxuICAgICAgICAgICAgbGVnZW5kOiBsZWdlbmREYXRhLmxhYmVsLFxuICAgICAgICAgICAgbGVnZW5kSW5kZXg6IGxlZ2VuZEluZGV4LFxuICAgICAgICAgICAgaW5kZXg6IHNlcmllc0RhdGEuaW5kZXhlcy5ncm91cEluZGV4XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgc2VsZWN0U2VyaWVzIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqL1xuICAgIG9uU2VsZWN0U2VyaWVzOiBmdW5jdGlvbihzZXJpZXNEYXRhKSB7XG4gICAgICAgIHRoaXMudXNlckV2ZW50LmZpcmUoJ3NlbGVjdFNlcmllcycsIHRoaXMuX21ha2VFeHBvcnRhdGlvblNlcmllc0RhdGEoc2VyaWVzRGF0YSkpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhhc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnNlbGVjdFNlcmllcyhzZXJpZXNEYXRhLmluZGV4ZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgdW5zZWxlY3RTZXJpZXMgY2FsbGJhY2sgb2YgdXNlckV2ZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhLlxuICAgICAqL1xuICAgIG9uVW5zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgndW5zZWxlY3RTZXJpZXMnLCBzZXJpZXNEYXRhLmluZGV4ZXMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhhc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnVuc2VsZWN0U2VyaWVzKHNlcmllc0RhdGEuaW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBpcyB0ZW1wbGF0ZXMgb2Ygc2VyaWVzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxudmFyIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKTtcblxudmFyIHRhZ3MgPSB7XG4gICAgSFRNTF9TRVJJRVNfTEFCRUw6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LXNlcmllcy1sYWJlbFwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiIGRhdGEtZ3JvdXAtaW5kZXg9XCJ7eyBncm91cEluZGV4IH19XCIgZGF0YS1pbmRleD1cInt7IGluZGV4IH19XCI+e3sgdmFsdWUgfX08L2Rpdj4nLFxuICAgIFRFWFRfQ1NTX1RFWFQ6ICdsZWZ0Ont7IGxlZnQgfX1weDt0b3A6e3sgdG9wIH19cHg7Zm9udC1mYW1pbHk6e3sgZm9udEZhbWlseSB9fTtmb250LXNpemU6e3sgZm9udFNpemUgfX1weCdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbFNlcmllc0xhYmVsOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKHRhZ3MuSFRNTF9TRVJJRVNfTEFCRUwpLFxuICAgIHRwbENzc1RleHQ6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUodGFncy5URVhUX0NTU19URVhUKVxufTtcbiIsInZhciBERUZBVUxUX0NPTE9SID0gJyMwMDAwMDAnLFxuICAgIERFRkFVTFRfQkFDS0dST1VORCA9ICcjZmZmZmZmJyxcbiAgICBFTVBUWSA9ICcnLFxuICAgIERFRkFVTFRfQVhJUyA9IHtcbiAgICAgICAgdGlja0NvbG9yOiBERUZBVUxUX0NPTE9SLFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9XG4gICAgfTtcblxudmFyIGRlZmF1bHRUaGVtZSA9IHtcbiAgICBjaGFydDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBERUZBVUxUX0JBQ0tHUk9VTkQsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdWZXJkYW5hJ1xuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgICAgZm9udFNpemU6IDE4LFxuICAgICAgICBmb250RmFtaWx5OiBFTVBUWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICB9LFxuICAgIHlBeGlzOiBERUZBVUxUX0FYSVMsXG4gICAgeEF4aXM6IERFRkFVTFRfQVhJUyxcbiAgICBwbG90OiB7XG4gICAgICAgIGxpbmVDb2xvcjogJyNkZGRkZGQnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZmZmZidcbiAgICB9LFxuICAgIHNlcmllczoge1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9LFxuICAgICAgICBjb2xvcnM6IFsnI2FjNDE0MicsICcjZDI4NDQ1JywgJyNmNGJmNzUnLCAnIzkwYTk1OScsICcjNzViNWFhJywgJyM2YTlmYjUnLCAnI2FhNzU5ZicsICcjOGY1NTM2J10sXG4gICAgICAgIGJvcmRlckNvbG9yOiBFTVBUWSxcbiAgICAgICAgc2VsZWN0aW9uQ29sb3I6IEVNUFRZXG4gICAgfSxcbiAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IEVNUFRZLFxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdFRoZW1lO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdyb3VwIHRvb2x0aXAgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9vbHRpcEJhc2UgPSByZXF1aXJlKCcuL3Rvb2x0aXBCYXNlJyksXG4gICAgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCA9IHJlcXVpcmUoJy4vZ3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCcpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuLi90aGVtZXMvZGVmYXVsdFRoZW1lJyksXG4gICAgdG9vbHRpcFRlbXBsYXRlID0gcmVxdWlyZSgnLi90b29sdGlwVGVtcGxhdGUnKTtcblxudmFyIEdyb3VwVG9vbHRpcCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFRvb2x0aXBCYXNlLCAvKiogQGxlbmRzIEdyb3VwVG9vbHRpcC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEdyb3VwIHRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIEdyb3VwVG9vbHRpcFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48bnVtYmVyPn0gcGFyYW1zLnZhbHVlcyBjb252ZXJ0ZWQgdmFsdWVzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5fSBwYXJhbXMubGFiZWxzIGxhYmVsc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheX0gcGFyYW1zLmxlZ2VuZExhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmJvdW5kIGF4aXMgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBUb29sdGlwQmFzZS5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IGFsaWduIG9wdGlvbiBvZiB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldERlZmF1bHRUb29sdGlwUG9zaXRpb25PcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9HUk9VUF9BTElHTl9PUFRJT047XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9HUk9VUF9IT1JJWk9OVEFMX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyByZW5kZXIgdG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7cG9zaXRpb246IG9iamVjdH19IGJvdW5kIHRvb2x0aXAgYm91bmRcbiAgICAgKiBAcGFyYW0gez97c2VyaWVzUG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oYm91bmQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGVsID0gVG9vbHRpcEJhc2UucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMsIGJvdW5kLCBkYXRhKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uTW9kZWwgPSBuZXcgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCh0aGlzLmNoYXJ0RGltZW5zaW9uLCBib3VuZCwgdGhpcy5pc1ZlcnRpY2FsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHthcnJheS48b2JqZWN0Pn0gdG9vbHRpcCBkYXRhXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgbWFrZVRvb2x0aXBEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0aGlzLmpvaW5Gb3JtYXR0ZWRWYWx1ZXMsIGZ1bmN0aW9uKHZhbHVlcywgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IHRoaXMubGFiZWxzW2luZGV4XSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgY29sb3JzLlxuICAgICAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz59IGxlZ2VuZExhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRvb2x0aXAgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7YXJyYXkuPHN0cmluZz59IGNvbG9yc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDb2xvcnM6IGZ1bmN0aW9uKGxlZ2VuZExhYmVscywgdGhlbWUpIHtcbiAgICAgICAgdmFyIGNvbG9ySW5kZXggPSAwLFxuICAgICAgICAgICAgZGVmYXVsdENvbG9ycywgY29sb3JzLCBwcmV2Q2hhcnRUeXBlO1xuICAgICAgICBpZiAodGhlbWUuY29sb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhlbWUuY29sb3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdENvbG9ycyA9IGRlZmF1bHRUaGVtZS5zZXJpZXMuY29sb3JzLnNsaWNlKDAsIGxlZ2VuZExhYmVscy5sZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodHVpLnV0aWwucGx1Y2sobGVnZW5kTGFiZWxzLCAnY2hhcnRUeXBlJyksIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGNvbG9yO1xuICAgICAgICAgICAgaWYgKHByZXZDaGFydFR5cGUgIT09IGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IHRoZW1lW2NoYXJ0VHlwZV0gPyB0aGVtZVtjaGFydFR5cGVdLmNvbG9ycyA6IGRlZmF1bHRDb2xvcnM7XG4gICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2Q2hhcnRUeXBlID0gY2hhcnRUeXBlO1xuICAgICAgICAgICAgY29sb3IgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgICAgICBjb2xvckluZGV4ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHRvb2x0aXAgaHRtbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBncm91cCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwSHRtbDogZnVuY3Rpb24oZ3JvdXBJbmRleCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZGF0YVtncm91cEluZGV4XSxcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdG9vbHRpcFRlbXBsYXRlLnRwbEdyb3VwSXRlbSxcbiAgICAgICAgICAgIGNzc1RleHRUZW1wbGF0ZSA9IHRvb2x0aXBUZW1wbGF0ZS50cGxHcm91cENzc1RleHQsXG4gICAgICAgICAgICBjb2xvcnMgPSB0aGlzLl9tYWtlQ29sb3JzKHRoaXMuam9pbkxlZ2VuZExhYmVscywgdGhpcy50aGVtZSksXG4gICAgICAgICAgICBpdGVtc0h0bWw7XG5cbiAgICAgICAgaXRlbXNIdG1sID0gdHVpLnV0aWwubWFwKGl0ZW0udmFsdWVzLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsZWdlbmRMYWJlbCA9IHRoaXMuam9pbkxlZ2VuZExhYmVsc1tpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZExhYmVsLmxhYmVsLFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogbGVnZW5kTGFiZWwuY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgIGNzc1RleHQ6IGNzc1RleHRUZW1wbGF0ZSh7Y29sb3I6IGNvbG9yc1tpbmRleF19KSxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHRoaXMuc3VmZml4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRvb2x0aXBUZW1wbGF0ZS50cGxHcm91cCh7XG4gICAgICAgICAgICBjYXRlZ29yeTogaXRlbS5jYXRlZ29yeSxcbiAgICAgICAgICAgIGl0ZW1zOiBpdGVtc0h0bWxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0b29sdGlwIHNlY3RvciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gc2VjdG9yIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRUb29sdGlwU2VjdG9yRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbFRvb2x0aXBTZWN0b3I7XG4gICAgICAgIGlmICghdGhpcy5lbFRvb2x0aXBTZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZWxUb29sdGlwU2VjdG9yID0gZWxUb29sdGlwU2VjdG9yID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1ncm91cC10b29sdGlwLXNlY3RvcicpO1xuICAgICAgICAgICAgZG9tLmFwcGVuZCh0aGlzLmVsVG9vbHRpcEFyZWEsIGVsVG9vbHRpcFNlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxUb29sdGlwU2VjdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGJvdW5kIGFib3V0IHRvb2x0aXAgc2VjdG9yIG9mIHZlcnRpY2FsIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xpbmUgd2hldGhlciBsaW5lIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxUb29sdGlwU2VjdG9yQm91bmQ6IGZ1bmN0aW9uKGhlaWdodCwgcmFuZ2UsIGlzTGluZSkge1xuICAgICAgICB2YXIgd2lkdGg7XG4gICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIHdpZHRoID0gMTtcbiAgICAgICAgICAgIGhlaWdodCArPSA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggPSByYW5nZS5lbmQgLSByYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiByYW5nZS5zdGFydCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIGJvdW5kIGFib3V0IHRvb2x0aXAgc2VjdG9yIG9mIGhvcml6b250YWwgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGhcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcmV0dXJucyB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUhvcml6b250YWxUb29sdGlwU2VjdG9yQm91bmQ6IGZ1bmN0aW9uKHdpZHRoLCByYW5nZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQgKyBjaGFydENvbnN0LkhJRERFTl9XSURUSFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUgLSBjaGFydENvbnN0LkhJRERFTl9XSURUSCxcbiAgICAgICAgICAgICAgICB0b3A6IHJhbmdlLnN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgYm91bmQgYWJvdXQgdG9vbHRpcCBzZWN0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgd2lkdGggb3IgaGVpZ2h0XG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xpbmUgd2hldGhlciBsaW5lIHR5cGUgb3Igbm90XG4gICAgICogQHJldHVybnMge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fSBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwU2VjdG9yQm91bmQ6IGZ1bmN0aW9uKHNpemUsIHJhbmdlLCBpc1ZlcnRpY2FsLCBpc0xpbmUpIHtcbiAgICAgICAgdmFyIGJvdW5kO1xuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlVmVydGljYWxUb29sdGlwU2VjdG9yQm91bmQoc2l6ZSwgcmFuZ2UsIGlzTGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3VuZCA9IHRoaXMuX21ha2VIb3Jpem9udGFsVG9vbHRpcFNlY3RvckJvdW5kKHNpemUsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcCBzZWN0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgd2lkdGggb3IgaGVpZ2h0XG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1Rvb2x0aXBTZWN0b3I6IGZ1bmN0aW9uKHNpemUsIHJhbmdlLCBpc1ZlcnRpY2FsLCBpbmRleCkge1xuICAgICAgICB2YXIgZWxUb29sdGlwU2VjdG9yID0gdGhpcy5fZ2V0VG9vbHRpcFNlY3RvckVsZW1lbnQoKSxcbiAgICAgICAgICAgIGlzTGluZSA9IChyYW5nZS5zdGFydCA9PT0gcmFuZ2UuZW5kKSxcbiAgICAgICAgICAgIGJvdW5kID0gdGhpcy5fbWFrZVRvb2x0aXBTZWN0b3JCb3VuZChzaXplLCByYW5nZSwgaXNWZXJ0aWNhbCwgaXNMaW5lKTtcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzaG93R3JvdXBUb29sdGlwTGluZScsIGJvdW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGVsVG9vbHRpcFNlY3RvciwgYm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oZWxUb29sdGlwU2VjdG9yLCBib3VuZC5wb3NpdGlvbik7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoZWxUb29sdGlwU2VjdG9yLCAnc2hvdycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdzaG93R3JvdXBBbmltYXRpb24nLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcCBzZWN0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZVRvb2x0aXBTZWN0b3I6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBlbFRvb2x0aXBTZWN0b3IgPSB0aGlzLl9nZXRUb29sdGlwU2VjdG9yRWxlbWVudCgpO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoZWxUb29sdGlwU2VjdG9yLCAnc2hvdycpO1xuICAgICAgICB0aGlzLmZpcmUoJ2hpZGVHcm91cEFuaW1hdGlvbicsIGluZGV4KTtcbiAgICAgICAgdGhpcy5maXJlKCdoaWRlR3JvdXBUb29sdGlwTGluZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2luZGV4OiBudW1iZXIsIHJhbmdlOiB7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9LFxuICAgICAqICAgICAgICAgIHNpemU6IG51bWJlciwgZGlyZWN0aW9uOiBzdHJpbmcsIGlzVmVydGljYWw6IGJvb2xlYW5cbiAgICAgKiAgICAgICAgfX0gcGFyYW1zIGNvb3JkaW5hdGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldiBwb3NpdGlvblxuICAgICAqL1xuICAgIHNob3dUb29sdGlwOiBmdW5jdGlvbihlbFRvb2x0aXAsIHBhcmFtcywgcHJldlBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24sIHBvc2l0aW9uO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQodGhpcy5wcmV2SW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVHcm91cEFuaW1hdGlvbicsIHRoaXMucHJldkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbFRvb2x0aXAuaW5uZXJIVE1MID0gdGhpcy5fbWFrZVRvb2x0aXBIdG1sKHBhcmFtcy5pbmRleCk7XG5cbiAgICAgICAgdGhpcy5fZmlyZUJlZm9yZVNob3dUb29sdGlwKHBhcmFtcy5pbmRleCwgcGFyYW1zLnJhbmdlKTtcblxuICAgICAgICBkb20uYWRkQ2xhc3MoZWxUb29sdGlwLCAnc2hvdycpO1xuXG4gICAgICAgIHRoaXMuX3Nob3dUb29sdGlwU2VjdG9yKHBhcmFtcy5zaXplLCBwYXJhbXMucmFuZ2UsIHBhcmFtcy5pc1ZlcnRpY2FsLCBwYXJhbXMuaW5kZXgpO1xuXG4gICAgICAgIGRpbWVuc2lvbiA9IHRoaXMuZ2V0VG9vbHRpcERpbWVuc2lvbihlbFRvb2x0aXApO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb25Nb2RlbC5jYWxjdWxhdGVQb3NpdGlvbihkaW1lbnNpb24sIHBhcmFtcy5yYW5nZSk7XG4gICAgICAgIHRoaXMubW92ZVRvUG9zaXRpb24oZWxUb29sdGlwLCBwb3NpdGlvbiwgcHJldlBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLl9maXJlQWZ0ZXJTaG93VG9vbHRpcChwYXJhbXMuaW5kZXgsIHBhcmFtcy5yYW5nZSwge1xuICAgICAgICAgICAgZWxlbWVudDogZWxUb29sdGlwLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHJldkluZGV4ID0gcGFyYW1zLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGJlZm9yZVNob3dUb29sdGlwIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUJlZm9yZVNob3dUb29sdGlwOiBmdW5jdGlvbihpbmRleCwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYmVmb3JlU2hvd1Rvb2x0aXAnLCB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgYWZ0ZXJTaG93VG9vbHRpcCBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUFmdGVyU2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGluZGV4LCByYW5nZSwgYWRkaXRpb25QYXJhbXMpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYWZ0ZXJTaG93VG9vbHRpcCcsIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSwgYWRkaXRpb25QYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcDogZnVuY3Rpb24oZWxUb29sdGlwLCBpbmRleCkge1xuICAgICAgICBkZWxldGUgdGhpcy5wcmV2SW5kZXg7XG4gICAgICAgIHRoaXMuX2hpZGVUb29sdGlwU2VjdG9yKGluZGV4KTtcbiAgICAgICAgdGhpcy5oaWRlQW5pbWF0aW9uKGVsVG9vbHRpcCk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihHcm91cFRvb2x0aXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwVG9vbHRpcDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBHcm91cFRvb2x0aXBQb3NpdGlvbk1vZGVsIGlzIHBvc2l0aW9uIG1vZGVsIGZvciBncm91cCB0b29sdGlwLi5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwgaXMgcG9zaXRpb24gbW9kZWwgZm9yIGdyb3VwIHRvb2x0aXAuXG4gICAgICogQGNvbnN0cnVjdHMgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbFxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gY2hhcnREaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYXJlYUJvdW5kIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7e2FsaWduOiA/c3RyaW5nLCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gb3B0aW9ucyB0b29sdGlwIG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBpc1ZlcnRpY2FsLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCBkaW1lbnNpb25cbiAgICAgICAgICogQHR5cGUge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0RGltZW5zaW9uID0gY2hhcnREaW1lbnNpb247XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAgICAgKiBAdHlwZSB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFyZWFCb3VuZCA9IGFyZWFCb3VuZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b29sdGlwIG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgY2FjaGluZ1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbnM7XG5cbiAgICAgICAgdGhpcy5fc2V0RGF0YShjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBpc1ZlcnRpY2FsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGhvcml6b250YWwgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZGlyZWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0SG9yaXpvbnRhbERpcmVjdGlvbjogZnVuY3Rpb24oYWxpZ25PcHRpb24pIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbjtcbiAgICAgICAgYWxpZ25PcHRpb24gPSBhbGlnbk9wdGlvbiB8fCAnJztcbiAgICAgICAgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2xlZnQnKSA+IC0xKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2NlbnRlcicpID4gLTEpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQ0VOVEVSO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9GT1JXQVJEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgdmVydGljYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGNoYXJ0RGltZW5zaW9uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGFyZWFCb3VuZCB0b29sdGlwIGFyZWEgYm91bmRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGFsaWduT3B0aW9uIGFsaWduIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBwb3NpdGlvblR5cGU6IHN0cmluZywgc2l6ZVR5cGU6IHN0cmluZywgZGlyZWN0aW9uOiAoc3RyaW5nKSxcbiAgICAgKiAgICAgIGFyZWFQb3NpdGlvbjogbnVtYmVyLCBhcmVhU2l6ZTogbnVtYmVyLCBjaGFydFNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIGJhc2VQb3NpdGlvbjogKG51bWJlcilcbiAgICAgKiB9fSB2ZXJ0aWNhbCBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsRGF0YTogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgYWxpZ25PcHRpb24pIHtcbiAgICAgICAgdmFyIGhEaXJlY3Rpb24gPSB0aGlzLl9nZXRIb3Jpem9udGFsRGlyZWN0aW9uKGFsaWduT3B0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ2xlZnQnLFxuICAgICAgICAgICAgc2l6ZVR5cGU6ICd3aWR0aCcsXG4gICAgICAgICAgICBkaXJlY3Rpb246IGhEaXJlY3Rpb24sXG4gICAgICAgICAgICBhcmVhUG9zaXRpb246IGFyZWFCb3VuZC5wb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgYXJlYVNpemU6IGFyZWFCb3VuZC5kaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBjaGFydFNpemU6IGNoYXJ0RGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmVydGljYWwgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZGlyZWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VmVydGljYWxEaXJlY3Rpb246IGZ1bmN0aW9uKGFsaWduT3B0aW9uKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb247XG4gICAgICAgIGFsaWduT3B0aW9uID0gYWxpZ25PcHRpb24gfHwgJyc7XG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCd0b3AnKSA+IC0xKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2JvdHRvbScpID4gLTEpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQ0VOVEVSO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgaG9yaXpvbnRhbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gY2hhcnREaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYXJlYUJvdW5kIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHBvc2l0aW9uVHlwZTogc3RyaW5nLCBzaXplVHlwZTogc3RyaW5nLCBkaXJlY3Rpb246IChzdHJpbmcpLFxuICAgICAqICAgICAgYXJlYVBvc2l0aW9uOiBudW1iZXIsIGFyZWFTaXplOiBudW1iZXIsIGNoYXJ0U2l6ZTogbnVtYmVyLFxuICAgICAqICAgICAgYmFzZVBvc2l0aW9uOiAobnVtYmVyKVxuICAgICAqIH19IHZlcnRpY2FsIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbERhdGE6IGZ1bmN0aW9uKGNoYXJ0RGltZW5zaW9uLCBhcmVhQm91bmQsIGFsaWduT3B0aW9uKSB7XG4gICAgICAgIHZhciB2RGlyZWN0aW9uID0gdGhpcy5fZ2V0VmVydGljYWxEaXJlY3Rpb24oYWxpZ25PcHRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb25UeXBlOiAndG9wJyxcbiAgICAgICAgICAgIHNpemVUeXBlOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdkRpcmVjdGlvbixcbiAgICAgICAgICAgIGFyZWFQb3NpdGlvbjogYXJlYUJvdW5kLnBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGFyZWFTaXplOiBhcmVhQm91bmQuZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGNoYXJ0U2l6ZTogY2hhcnREaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkYXRhLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gY2hhcnREaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYXJlYUJvdW5kIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7e2FsaWduOiA/c3RyaW5nLCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gb3B0aW9ucyB0b29sdGlwIG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXREYXRhOiBmdW5jdGlvbihjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBpc1ZlcnRpY2FsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNhbERhdGEgPSB0aGlzLl9tYWtlVmVydGljYWxEYXRhKGNoYXJ0RGltZW5zaW9uLCBhcmVhQm91bmQsIG9wdGlvbnMuYWxpZ24pLFxuICAgICAgICAgICAgaG9yaXpvbnRhbERhdGEgPSB0aGlzLl9tYWtlSG9yaXpvbnRhbERhdGEoY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgb3B0aW9ucy5hbGlnbik7XG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLm1haW5EYXRhID0gdmVydGljYWxEYXRhO1xuICAgICAgICAgICAgdGhpcy5zdWJEYXRhID0gaG9yaXpvbnRhbERhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW5EYXRhID0gaG9yaXpvbnRhbERhdGE7XG4gICAgICAgICAgICB0aGlzLnN1YkRhdGEgPSB2ZXJ0aWNhbERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvc2l0aW9uT3B0aW9uID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfSwgb3B0aW9ucy5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsY3VsYXRlIG1haW4gcG9zaXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBTaXplIHRvb2x0aXAgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gZGF0YS5kaXJlY3Rpb24gZGlyZWN0aW9uXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5iYXNlUG9zaXRpb24gYmFzZVBvc2l0aW9uXG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVNYWluUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odG9vbHRpcFNpemUsIHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIHZhciBpc0xpbmUgPSAocmFuZ2Uuc3RhcnQgPT09IHJhbmdlLmVuZCksXG4gICAgICAgICAgICBwYWRkaW5nID0gaXNMaW5lID8gOSA6IDUsXG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGEuYmFzZVBvc2l0aW9uO1xuICAgICAgICBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gcmFuZ2UuZW5kICsgcGFkZGluZztcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9CQUNLV0FSRCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gcmFuZ2Uuc3RhcnQgLSB0b29sdGlwU2l6ZSAtIHBhZGRpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSByYW5nZS5zdGFydCAtIHRvb2x0aXBTaXplIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHJhbmdlLnN0YXJ0ICsgKChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCAtIHRvb2x0aXBTaXplKSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsY3VsYXRlIHN1YiBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVNpemUgdG9vbHRpcCBhcmVhIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLmRpcmVjdGlvbiBkaXJlY3Rpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmJhc2VQb3NpdGlvbiBiYXNlUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVN1YlBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIHZhciBtaWRkbGUgPSBkYXRhLmFyZWFTaXplIC8gMixcbiAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRCkge1xuICAgICAgICAgICAgdmFsdWUgPSBtaWRkbGUgKyBkYXRhLmJhc2VQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9CQUNLV0FSRCkge1xuICAgICAgICAgICAgdmFsdWUgPSBtaWRkbGUgLSB0b29sdGlwU2l6ZSArIGRhdGEuYmFzZVBvc2l0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBtaWRkbGUgLSAodG9vbHRpcFNpemUgLyAyKSArIGRhdGEuYmFzZVBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBwb3NpdGlvbiB2YWx1ZSBkaWZmLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdG9pbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwU2l6ZSB0b29sdGlwIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5jaGFydFNpemUgY2hhcnQgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVBvc2l0aW9uIHRvb2x0aXAgYXJlYSBwb3NpdGlvbiAobGVmdCBvciB0b3ApXG4gICAgICogQHJldHVybnMge251bWJlcn0gZGlmZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQb3NpdGlvblZhbHVlRGlmZjogZnVuY3Rpb24odmFsdWUsIHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIGRhdGEuYXJlYVBvc2l0aW9uICsgdG9vbHRpcFNpemUgLSBkYXRhLmNoYXJ0U2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IGJhY2t3YXJkIHBvc2l0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYmFzZVBvc2l0aW9uIGJhc2VQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0QmFja3dhcmRQb3NpdGlvblZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgcmFuZ2UsIHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkVmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA8IC1kYXRhLmFyZWFQb3NpdGlvbikge1xuICAgICAgICAgICAgY2hhbmdlZFZhbHVlID0gdGhpcy5fY2FsY3VsYXRlTWFpblBvc2l0aW9uVmFsdWUodG9vbHRpcFNpemUsIHJhbmdlLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQsXG4gICAgICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBkYXRhLmJhc2VQb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFrZVBvc2l0aW9uVmFsdWVEaWZmKGNoYW5nZWRWYWx1ZSwgdG9vbHRpcFNpemUsIGRhdGEpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gLWRhdGEuYXJlYVBvc2l0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYW5nZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBmb3J3YXJkIHBvc2l0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYmFzZVBvc2l0aW9uIGJhc2VQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0Rm9yd2FyZFBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYW5nZSwgdG9vbHRpcFNpemUsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLl9tYWtlUG9zaXRpb25WYWx1ZURpZmYodmFsdWUsIHRvb2x0aXBTaXplLCBkYXRhKSxcbiAgICAgICAgICAgIGNoYW5nZWRWYWx1ZTtcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVNYWluUG9zaXRpb25WYWx1ZSh0b29sdGlwU2l6ZSwgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQsXG4gICAgICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBkYXRhLmJhc2VQb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFZhbHVlIDwgLWRhdGEuYXJlYVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgLT0gZGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFuZ2VkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgbWFpbiBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0TWFpblBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYW5nZSwgdG9vbHRpcFNpemUsIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0JBQ0tXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdEJhY2t3YXJkUG9zaXRpb25WYWx1ZSh2YWx1ZSwgcmFuZ2UsIHRvb2x0aXBTaXplLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9GT1JXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdEZvcndhcmRQb3NpdGlvblZhbHVlKHZhbHVlLCByYW5nZSwgdG9vbHRpcFNpemUsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB0dWkudXRpbC5tYXgoW3ZhbHVlLCAtZGF0YS5hcmVhUG9zaXRpb25dKTtcbiAgICAgICAgICAgIHZhbHVlID0gdHVpLnV0aWwubWluKFt2YWx1ZSwgZGF0YS5jaGFydFNpemUgLSBkYXRhLmFyZWFQb3NpdGlvbiAtIHRvb2x0aXBTaXplXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3Qgc3ViIHBvc2l0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwU2l6ZSB0b29sdGlwIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5jaGFydFNpemUgY2hhcnQgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVBvc2l0aW9uIHRvb2x0aXAgYXJlYSBwb3NpdGlvbiAobGVmdCBvciB0b3ApXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5iYXNlUG9zaXRpb24gYmFzZVBvc2l0aW9uXG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGp1c3RTdWJQb3NpdGlvblZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgdG9vbHRpcFNpemUsIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHVpLnV0aWwubWluKFt2YWx1ZSwgZGF0YS5jaGFydFNpemUgLSBkYXRhLmFyZWFQb3NpdGlvbiAtIHRvb2x0aXBTaXplXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHR1aS51dGlsLm1heChbdmFsdWUsIC1kYXRhLmFyZWFQb3NpdGlvbl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gbWFrZSBjYWNoaW5nIGtleS5cbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHJldHVybnMge3N0cmluZ30ga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNhY2hpbmdLZXk6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydCArICctJyArIHJhbmdlLmVuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHBvc2l0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25UeXBlIHBvc2l0aW9uIHR5cGUgKGxlZnQgb3IgdG9wKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkUG9zaXRpb25PcHRpb25WYWx1ZTogZnVuY3Rpb24ocG9zaXRpb24sIHBvc2l0aW9uVHlwZSkge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gKyB0aGlzLnBvc2l0aW9uT3B0aW9uW3Bvc2l0aW9uVHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGN1bGF0ZSBncm91cCB0b29sdGlwIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gdG9vbHRpcERpbWVuc2lvbiB0b29sdGlwIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgdG9vbHRpcCBzZWN0b3IgcmFuZ2VcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBncm91cCB0b29sdGlwIHBvc2l0aW9uXG4gICAgICovXG4gICAgY2FsY3VsYXRlUG9zaXRpb246IGZ1bmN0aW9uKHRvb2x0aXBEaW1lbnNpb24sIHJhbmdlKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLl9tYWtlQ2FjaGluZ0tleShyYW5nZSksXG4gICAgICAgICAgICBtYWluID0gdGhpcy5tYWluRGF0YSxcbiAgICAgICAgICAgIHN1YiA9IHRoaXMuc3ViRGF0YSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbnNba2V5XSxcbiAgICAgICAgICAgIG1haW5Qb3NpdGlvbiwgc3ViUG9zaXRpb247XG5cbiAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgICAgIG1haW5Qb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZU1haW5Qb3NpdGlvblZhbHVlKHRvb2x0aXBEaW1lbnNpb25bbWFpbi5zaXplVHlwZV0sIHJhbmdlLCBtYWluKTtcbiAgICAgICAgICAgIHN1YlBvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlU3ViUG9zaXRpb25WYWx1ZSh0b29sdGlwRGltZW5zaW9uW3N1Yi5zaXplVHlwZV0sIHN1Yik7XG5cbiAgICAgICAgICAgIG1haW5Qb3NpdGlvbiA9IHRoaXMuX2FkZFBvc2l0aW9uT3B0aW9uVmFsdWUobWFpblBvc2l0aW9uLCBtYWluLnBvc2l0aW9uVHlwZSk7XG4gICAgICAgICAgICBzdWJQb3NpdGlvbiA9IHRoaXMuX2FkZFBvc2l0aW9uT3B0aW9uVmFsdWUoc3ViUG9zaXRpb24sIHN1Yi5wb3NpdGlvblR5cGUpO1xuXG4gICAgICAgICAgICBwb3NpdGlvblttYWluLnBvc2l0aW9uVHlwZV0gPSB0aGlzLl9hZGp1c3RNYWluUG9zaXRpb25WYWx1ZShtYWluUG9zaXRpb24sIHJhbmdlLCB0b29sdGlwRGltZW5zaW9uW21haW4uc2l6ZVR5cGVdLCBtYWluKTtcbiAgICAgICAgICAgIHBvc2l0aW9uW3N1Yi5wb3NpdGlvblR5cGVdID0gdGhpcy5fYWRqdXN0U3ViUG9zaXRpb25WYWx1ZShzdWJQb3NpdGlvbiwgdG9vbHRpcERpbWVuc2lvbltzdWIuc2l6ZVR5cGVdLCBzdWIpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnNba2V5XSA9IHBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdG9vbHRpcCBvcHRpb25zIGZvciBwb3NpdGlvbiBjYWxjdWxhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IG9wdGlvbnMgdG9vbHRpcCBvcHRpb25zXG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9zZXREYXRhKHRoaXMuY2hhcnREaW1lbnNpb24sIHRoaXMuYXJlYUJvdW5kLCB0aGlzLmlzVmVydGljYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdG9vbHRpcCBib3VuZCBmb3IgcG9zaXRpb24gY2FsY3VsYXRpb24uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgdG9vbHRpcCBhcmVhIGJvdW5kXG4gICAgICovXG4gICAgdXBkYXRlQm91bmQ6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHRoaXMuYXJlYUJvdW5kID0gYm91bmQ7XG4gICAgICAgIHRoaXMuX3NldERhdGEodGhpcy5jaGFydERpbWVuc2lvbiwgYm91bmQsIHRoaXMuaXNWZXJ0aWNhbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFRvb2x0aXBQb3NpdGlvbk1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRvb2x0aXAgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9vbHRpcEJhc2UgPSByZXF1aXJlKCcuL3Rvb2x0aXBCYXNlJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICBldmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi4vaGVscGVycy9ldmVudExpc3RlbmVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKSxcbiAgICB0b29sdGlwVGVtcGxhdGUgPSByZXF1aXJlKCcuL3Rvb2x0aXBUZW1wbGF0ZScpO1xuXG52YXIgVG9vbHRpcCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFRvb2x0aXBCYXNlLCAvKiogQGxlbmRzIFRvb2x0aXAucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUb29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBUb29sdGlwXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5LjxudW1iZXI+fSBwYXJhbXMudmFsdWVzIGNvbnZlcnRlZCB2YWx1ZXNcbiAgICAgKiAgICAgIEBwYXJhbSB7YXJyYXl9IHBhcmFtcy5sYWJlbHMgbGFiZWxzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5fSBwYXJhbXMubGVnZW5kTGFiZWxzIGxlZ2VuZCBsYWJlbHNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYm91bmQgYXhpcyBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB2YWx1ZXM7XG4gICAgICAgIFRvb2x0aXBCYXNlLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICAgICAgdGhpcy50cGxUb29sdGlwID0gdGhpcy5fZ2V0VG9vbHRpcFRlbXBsYXRlKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSk7XG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KHRoaXMudmFsdWVzKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNbdGhpcy5jaGFydFR5cGVdID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0b29sdGlwIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25UZW1wbGF0ZSB0ZW1wbGF0ZSBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0ZW1wbGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFRvb2x0aXBUZW1wbGF0ZTogZnVuY3Rpb24ob3B0aW9uVGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvblRlbXBsYXRlID8gdGVtcGxhdGVNYWtlci50ZW1wbGF0ZShvcHRpb25UZW1wbGF0ZSkgOiB0b29sdGlwVGVtcGxhdGUudHBsRGVmYXVsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgYWxpZ24gb3B0aW9uIG9mIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxpZ24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ERUZBVUxUX0FMSUdOX09QVElPTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ERUZBVUxUX0hPUklaT05UQUxfQUxJR05fT1BUSU9OO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlbmRlciB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3twb3NpdGlvbjogb2JqZWN0fX0gYm91bmQgdG9vbHRpcCBib3VuZFxuICAgICAqIEBwYXJhbSB7P3tzZXJpZXNQb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdG9vbHRpcCBlbGVtZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihib3VuZCwgZGF0YSkge1xuICAgICAgICB2YXIgZWwgPSBUb29sdGlwQmFzZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgYm91bmQsIGRhdGEpO1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmllc1Bvc2l0aW9uID0gZGF0YS5zZXJpZXNQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXR0YWNoRXZlbnQoZWwpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlc2l6ZSB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3twb3NpdGlvbjogb2JqZWN0fX0gYm91bmQgdG9vbHRpcCBib3VuZFxuICAgICAqIEBwYXJhbSB7P3tzZXJpZXNQb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oYm91bmQsIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzUG9zaXRpb24gPSBkYXRhLnNlcmllc1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIFRvb2x0aXBCYXNlLnByb3RvdHlwZS5yZXNpemUuY2FsbCh0aGlzLCBib3VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHthcnJheS48b2JqZWN0Pn0gdG9vbHRpcCBkYXRhXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgbWFrZVRvb2x0aXBEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzLFxuICAgICAgICAgICAgdG9vbHRpcERhdGEgPSB7fSxcbiAgICAgICAgICAgIGxlZ2VuZExhYmVscyA9IHt9O1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KHRoaXMuZm9ybWF0dGVkVmFsdWVzKSkge1xuICAgICAgICAgICAgdG9vbHRpcERhdGFbdGhpcy5jaGFydFR5cGVdID0gdGhpcy5mb3JtYXR0ZWRWYWx1ZXM7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHNbdGhpcy5jaGFydFR5cGVdID0gdGhpcy5sZWdlbmRMYWJlbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b29sdGlwRGF0YSA9IHRoaXMuZm9ybWF0dGVkVmFsdWVzO1xuICAgICAgICAgICAgbGVnZW5kTGFiZWxzID0gdGhpcy5sZWdlbmRMYWJlbHM7XG4gICAgICAgIH1cblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHRvb2x0aXBEYXRhLCBmdW5jdGlvbihncm91cFZhbHVlcywgY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB0b29sdGlwRGF0YVtjaGFydFR5cGVdID0gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogbGFiZWxzID8gbGFiZWxzW2dyb3VwSW5kZXhdIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZExhYmVsc1tjaGFydFR5cGVdW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9vbHRpcERhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgY3VzdG9tIGV2ZW50IHNob3dBbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZVNob3dBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4ZXMsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzaG93JywgY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyk7XG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIGluZGV4ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGN1c3RvbSBldmVudCBoaWRlQW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVIaWRlQW5pbWF0aW9uOiBmdW5jdGlvbihpbmRleGVzLCBjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgnaGlkZScsIGNoYXJ0VHlwZSwgJ2FuaW1hdGlvbicpO1xuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCBpbmRleGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRhdGEgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDpudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihlbFRvb2x0aXAsIGluZGV4ZXMpIHtcbiAgICAgICAgZWxUb29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1ncm91cEluZGV4JywgaW5kZXhlcy5ncm91cEluZGV4KTtcbiAgICAgICAgZWxUb29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcsIGluZGV4ZXMuaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YSBpbmRleGVzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEluZGV4ZXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsVG9vbHRpcCkge1xuICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IGVsVG9vbHRpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXBJbmRleCcpLFxuICAgICAgICAgICAgaW5kZXggPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JyksXG4gICAgICAgICAgICBpbmRleGVzID0gbnVsbDtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzTnVsbChncm91cEluZGV4KSAmJiAhdHVpLnV0aWwuaXNOdWxsKGluZGV4KSkge1xuICAgICAgICAgICAgaW5kZXhlcyA9IHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBwYXJzZUludChncm91cEluZGV4LCAxMCksXG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcnNlSW50KGluZGV4LCAxMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBzaG93ZWQgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGF0dXMgd2hldGhlciBzaG93ZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U2hvd2VkQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihlbFRvb2x0aXAsIHN0YXR1cykge1xuICAgICAgICBlbFRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLXNob3dlZCcsIHN0YXR1cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgc2hvd2VkIHRvb2x0aXAgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBzaG93ZWQgdG9vbHRpcCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1Nob3dlZFRvb2x0aXA6IGZ1bmN0aW9uKGVsVG9vbHRpcCkge1xuICAgICAgICB2YXIgaXNTaG93ZWQgPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLXNob3dlZCcpO1xuICAgICAgICByZXR1cm4gaXNTaG93ZWQgPT09ICd0cnVlJyB8fCBpc1Nob3dlZCA9PT0gdHJ1ZTsgLy8gaWU37JeQ7ISc64qUIGJvb2xlYW7tmJXtg5zsnZggdHJ1ZeulvCDrsJjtmZjtlahcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2VvdmVyIGV2ZW50IGhhbmRsZXIgZm9yIHRvb2x0aXAgYXJlYVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VvdmVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlbFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICAgIGluZGV4ZXMsIGNoYXJ0VHlwZTtcblxuICAgICAgICBpZiAoIWRvbS5oYXNDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5UT09MVElQX1BSRUZJWCkpIHtcbiAgICAgICAgICAgIGVsVGFyZ2V0ID0gZG9tLmZpbmRQYXJlbnRCeUNsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LlRPT0xUSVBfUFJFRklYKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ZXMgPSB0aGlzLl9nZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlKGVsVGFyZ2V0KTtcbiAgICAgICAgY2hhcnRUeXBlID0gZWxUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWNoYXJ0LXR5cGUnKTtcblxuICAgICAgICB0aGlzLl9zZXRTaG93ZWRDdXN0b21BdHRyaWJ1dGUoZWxUYXJnZXQsIHRydWUpO1xuICAgICAgICB0aGlzLl9maXJlU2hvd0FuaW1hdGlvbihpbmRleGVzLCBjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZW91dCBldmVudCBoYW5kbGVyIGZvciB0b29sdGlwIGFyZWFcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlb3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlbFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuXG4gICAgICAgIGlmICghZG9tLmhhc0NsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LlRPT0xUSVBfUFJFRklYKSkge1xuICAgICAgICAgICAgZWxUYXJnZXQgPSBkb20uZmluZFBhcmVudEJ5Q2xhc3MoZWxUYXJnZXQsIGNoYXJ0Q29uc3QuVE9PTFRJUF9QUkVGSVgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaWRlVG9vbHRpcChlbFRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGN1bGF0ZSB0b29sdGlwIHBvc2l0aW9uIGFib3VudCBwaWUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcGFyYW1zLmJvdW5kIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge3tjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn19IHBhcmFtcy5ldmVudFBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVUb29sdGlwUG9zaXRpb25BYm91dFBpZUNoYXJ0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLmJvdW5kLmxlZnQgPSBwYXJhbXMuZXZlbnRQb3NpdGlvbi5jbGllbnRYIC0gdGhpcy5zZXJpZXNQb3NpdGlvbi5sZWZ0O1xuICAgICAgICBwYXJhbXMuYm91bmQudG9wID0gcGFyYW1zLmV2ZW50UG9zaXRpb24uY2xpZW50WSAtIHRoaXMuc2VyaWVzUG9zaXRpb24udG9wO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlVG9vbHRpcFBvc2l0aW9uQWJvdXROb3RCYXJDaGFydChwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxjdWxhdGUgdG9vbHRpcCBwb3NpdGlvbiBhYm91dCBub3QgYmFyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7Ym91bmQ6IG9iamVjdH19IHBhcmFtcy5kYXRhIGdyYXBoIGluZm9ybWF0aW9uXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWxpZ25PcHRpb24gcG9zaXRpb24gb3B0aW9uIChleDogJ2xlZnQgdG9wJylcbiAgICAgKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVRvb2x0aXBQb3NpdGlvbkFib3V0Tm90QmFyQ2hhcnQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgYm91bmQgPSBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICBwb3NpdGlvbk9wdGlvbiA9IHBhcmFtcy5wb3NpdGlvbk9wdGlvbixcbiAgICAgICAgICAgIG1pbnVzV2lkdGggPSBwYXJhbXMuZGltZW5zaW9uLndpZHRoIC0gKGJvdW5kLndpZHRoIHx8IDApLFxuICAgICAgICAgICAgbGluZUdhcCA9IGJvdW5kLndpZHRoID8gMCA6IGNoYXJ0Q29uc3QuVE9PTFRJUF9HQVAsXG4gICAgICAgICAgICBhbGlnbk9wdGlvbiA9IHBhcmFtcy5hbGlnbk9wdGlvbiB8fCAnJyxcbiAgICAgICAgICAgIHRvb2x0aXBIZWlnaHQgPSBwYXJhbXMuZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHQubGVmdCA9IGJvdW5kLmxlZnQgKyBwb3NpdGlvbk9wdGlvbi5sZWZ0O1xuICAgICAgICByZXN1bHQudG9wID0gYm91bmQudG9wIC0gdG9vbHRpcEhlaWdodCArIHBvc2l0aW9uT3B0aW9uLnRvcDtcblxuICAgICAgICBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignbGVmdCcpID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sZWZ0IC09IG1pbnVzV2lkdGggKyBsaW5lR2FwO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2NlbnRlcicpID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sZWZ0IC09IG1pbnVzV2lkdGggLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmxlZnQgKz0gbGluZUdhcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdib3R0b20nKSA+IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQudG9wICs9IHRvb2x0aXBIZWlnaHQgKyBsaW5lR2FwO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ21pZGRsZScpID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC50b3AgKz0gdG9vbHRpcEhlaWdodCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQudG9wIC09IGNoYXJ0Q29uc3QuVE9PTFRJUF9HQVA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxjdWxhdGUgdG9vbHRpcCBwb3NpdGlvbiBhYm91dCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tib3VuZDogb2JqZWN0fX0gcGFyYW1zLmRhdGEgZ3JhcGggaW5mb3JtYXRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiB0b29sdGlwIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hbGlnbk9wdGlvbiBwb3NpdGlvbiBvcHRpb24gKGV4OiAnbGVmdCB0b3AnKVxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlVG9vbHRpcFBvc2l0aW9uQWJvdXRCYXJDaGFydDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgIHBvc2l0aW9uT3B0aW9uID0gcGFyYW1zLnBvc2l0aW9uT3B0aW9uLFxuICAgICAgICAgICAgbWludXNIZWlnaHQgPSBwYXJhbXMuZGltZW5zaW9uLmhlaWdodCAtIChib3VuZC5oZWlnaHQgfHwgMCksXG4gICAgICAgICAgICBhbGlnbk9wdGlvbiA9IHBhcmFtcy5hbGlnbk9wdGlvbiB8fCAnJyxcbiAgICAgICAgICAgIHRvb2x0aXBXaWR0aCA9IHBhcmFtcy5kaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICByZXN1bHQubGVmdCA9IGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aCArIHBvc2l0aW9uT3B0aW9uLmxlZnQ7XG4gICAgICAgIHJlc3VsdC50b3AgPSBib3VuZC50b3AgKyBwb3NpdGlvbk9wdGlvbi50b3A7XG5cbiAgICAgICAgLy8gVE9ETyA6IGFsaWduT3B0aW9uc+ydhCDqsJ3ssrTroZwg66eM65Ok7Ja07IScIOqygOyCrO2VmOuPhOuhnSDrs4Dqsr3tlZjquLAgZXgpIGFsaWduT3B0aW9uLmxlZnQgPSB0cnVlXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdsZWZ0JykgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmxlZnQgLT0gdG9vbHRpcFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2NlbnRlcicpID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sZWZ0IC09IHRvb2x0aXBXaWR0aCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQubGVmdCArPSBjaGFydENvbnN0LlRPT0xUSVBfR0FQO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ3RvcCcpID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC50b3AgLT0gbWludXNIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignbWlkZGxlJykgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnRvcCAtPSBtaW51c0hlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBjaGFydERpbWVuc2lvbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYXJlYVBvc2l0aW9uIGFyZWEgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHRvb2x0aXBEaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBhZGp1c3RlZCBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdFBvc2l0aW9uOiBmdW5jdGlvbihjaGFydERpbWVuc2lvbiwgYXJlYVBvc2l0aW9uLCB0b29sdGlwRGltZW5zaW9uLCBwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbi5sZWZ0ID0gdHVpLnV0aWwubWF4KFtwb3NpdGlvbi5sZWZ0LCAtYXJlYVBvc2l0aW9uLmxlZnRdKTtcbiAgICAgICAgcG9zaXRpb24ubGVmdCA9IHR1aS51dGlsLm1pbihbcG9zaXRpb24ubGVmdCwgY2hhcnREaW1lbnNpb24ud2lkdGggLSBhcmVhUG9zaXRpb24ubGVmdCAtIHRvb2x0aXBEaW1lbnNpb24ud2lkdGhdKTtcbiAgICAgICAgcG9zaXRpb24udG9wID0gdHVpLnV0aWwubWF4KFtwb3NpdGlvbi50b3AsIC1hcmVhUG9zaXRpb24udG9wXSk7XG4gICAgICAgIHBvc2l0aW9uLnRvcCA9IHR1aS51dGlsLm1pbihbcG9zaXRpb24udG9wLCBjaGFydERpbWVuc2lvbi5oZWlnaHQgLSBhcmVhUG9zaXRpb24udG9wIC0gdG9vbHRpcERpbWVuc2lvbi5oZWlnaHRdKTtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdG9vbHRpcCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmJvdW5kIGdyYXBoIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5hbGxvd05lZ2F0aXZlVG9vbHRpcCB3aGV0aGVyIGFsbG93IG5lZ2F0aXZlIHRvb2x0aXAgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWxpZ25PcHRpb24gcG9zaXRpb24gb3B0aW9uIChleDogJ2xlZnQgdG9wJylcbiAgICAgKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHt9LFxuICAgICAgICAgICAgc2l6ZVR5cGUsIHBvc2l0aW9uVHlwZSwgYWRkUGFkZGluZztcblxuICAgICAgICBpZiAocGFyYW1zLmV2ZW50UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVUb29sdGlwUG9zaXRpb25BYm91dFBpZUNoYXJ0KHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlZGljYXRlLmlzQmFyQ2hhcnQocGFyYW1zLmNoYXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fY2FsY3VsYXRlVG9vbHRpcFBvc2l0aW9uQWJvdXRCYXJDaGFydChwYXJhbXMpO1xuICAgICAgICAgICAgc2l6ZVR5cGUgPSAnd2lkdGgnO1xuICAgICAgICAgICAgcG9zaXRpb25UeXBlID0gJ2xlZnQnO1xuICAgICAgICAgICAgYWRkUGFkZGluZyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZVRvb2x0aXBQb3NpdGlvbkFib3V0Tm90QmFyQ2hhcnQocGFyYW1zKTtcbiAgICAgICAgICAgIHNpemVUeXBlID0gJ2hlaWdodCc7XG4gICAgICAgICAgICBwb3NpdGlvblR5cGUgPSAndG9wJztcbiAgICAgICAgICAgIGFkZFBhZGRpbmcgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuYWxsb3dOZWdhdGl2ZVRvb2x0aXApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fbW92ZVRvU3ltbWV0cnkocG9zaXRpb24sIHtcbiAgICAgICAgICAgICAgICBib3VuZDogcGFyYW1zLmJvdW5kLFxuICAgICAgICAgICAgICAgIGluZGV4ZXM6IHBhcmFtcy5pbmRleGVzLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogcGFyYW1zLmRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IHBhcmFtcy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgc2l6ZVR5cGU6IHNpemVUeXBlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogcG9zaXRpb25UeXBlLFxuICAgICAgICAgICAgICAgIGFkZFBhZGRpbmc6IGFkZFBhZGRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9hZGp1c3RQb3NpdGlvbih0aGlzLmNoYXJ0RGltZW5zaW9uLCB0aGlzLmJvdW5kLnBvc2l0aW9uLCBwYXJhbXMuZGltZW5zaW9uLCBwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlIGJ5IGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMgeyhzdHJpbmcgfCBudW1iZXIpfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFZhbHVlQnlJbmRleGVzOiBmdW5jdGlvbihpbmRleGVzLCBjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2NoYXJ0VHlwZV1baW5kZXhlcy5ncm91cEluZGV4XVtpbmRleGVzLmluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byBzeW1tZXRyeS5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gdG9vbHRpcCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuYm91bmQgZ3JhcGggYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuaWQgdG9vbHRpcCBpZFxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpemVUeXBlIHNpemUgdHlwZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wb3NpdGlvblR5cGUgcG9zaXRpb24gdHlwZSAobGVmdCBvciB0b3ApXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmFkZFBhZGRpbmcgYWRkIHBhZGRpbmdcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBtb3ZlZCBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdmVUb1N5bW1ldHJ5OiBmdW5jdGlvbihwb3NpdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgIHNpemVUeXBlID0gcGFyYW1zLnNpemVUeXBlLFxuICAgICAgICAgICAgcG9zaXRpb25UeXBlID0gcGFyYW1zLnBvc2l0aW9uVHlwZSxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWVCeUluZGV4ZXMocGFyYW1zLmluZGV4ZXMsIHBhcmFtcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgY2VudGVyO1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBib3VuZFtwb3NpdGlvblR5cGVdICsgKGJvdW5kW3NpemVUeXBlXSAvIDIpICsgKHBhcmFtcy5hZGRQYWRkaW5nIHx8IDApO1xuICAgICAgICAgICAgcG9zaXRpb25bcG9zaXRpb25UeXBlXSA9IHBvc2l0aW9uW3Bvc2l0aW9uVHlwZV0gLSAocG9zaXRpb25bcG9zaXRpb25UeXBlXSAtIGNlbnRlcikgKiAyIC0gcGFyYW1zLmRpbWVuc2lvbltzaXplVHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHRvb2x0aXAgaHRtbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0b29sdGlwIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcEh0bWw6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgaW5kZXhlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YVtjaGFydFR5cGVdW2luZGV4ZXMuZ3JvdXBJbmRleF1baW5kZXhlcy5pbmRleF07XG4gICAgICAgIGRhdGEuc3VmZml4ID0gdGhpcy5zdWZmaXg7XG4gICAgICAgIHJldHVybiB0aGlzLnRwbFRvb2x0aXAoZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBpbmRleGVzIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBwcmV2SW5kZXhlcyBwcmV2IGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBjaGFuZ2VkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZEluZGV4ZXM6IGZ1bmN0aW9uKHByZXZJbmRleGVzLCBpbmRleGVzKSB7XG4gICAgICAgIHJldHVybiAhIXByZXZJbmRleGVzICYmIChwcmV2SW5kZXhlcy5ncm91cEluZGV4ICE9PSBpbmRleGVzLmdyb3VwSW5kZXggfHwgcHJldkluZGV4ZXMuaW5kZXggIT09IGluZGV4ZXMuaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2luZGV4ZXM6IHtncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9LCBib3VuZDogb2JqZWN0fX0gcGFyYW1zIHRvb2x0aXAgZGF0YVxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldiBwb3NpdGlvblxuICAgICAqL1xuICAgIHNob3dUb29sdGlwOiBmdW5jdGlvbihlbFRvb2x0aXAsIHBhcmFtcywgcHJldlBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBpbmRleGVzID0gcGFyYW1zLmluZGV4ZXMsXG4gICAgICAgICAgICBwcmV2SW5kZXhlcyA9IHRoaXMuX2dldEluZGV4ZXNDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwKSxcbiAgICAgICAgICAgIHByZXZDaGFydFR5cGUsIHBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5faXNDaGFuZ2VkSW5kZXhlcyhwcmV2SW5kZXhlcywgaW5kZXhlcykpIHtcbiAgICAgICAgICAgIHByZXZDaGFydFR5cGUgPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLWNoYXJ0LXR5cGUnKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVIaWRlQW5pbWF0aW9uKHByZXZJbmRleGVzLCBwcmV2Q2hhcnRUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsVG9vbHRpcC5pbm5lckhUTUwgPSB0aGlzLl9tYWtlVG9vbHRpcEh0bWwocGFyYW1zLmNoYXJ0VHlwZSwgaW5kZXhlcyk7XG5cbiAgICAgICAgZWxUb29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1jaGFydC10eXBlJywgcGFyYW1zLmNoYXJ0VHlwZSk7XG4gICAgICAgIHRoaXMuX3NldEluZGV4ZXNDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwLCBpbmRleGVzKTtcbiAgICAgICAgdGhpcy5fc2V0U2hvd2VkQ3VzdG9tQXR0cmlidXRlKGVsVG9vbHRpcCwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fZmlyZUJlZm9yZVNob3dUb29sdGlwKGluZGV4ZXMpO1xuXG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbFRvb2x0aXAsICdzaG93Jyk7XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVUb29sdGlwUG9zaXRpb24odHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogdGhpcy5nZXRUb29sdGlwRGltZW5zaW9uKGVsVG9vbHRpcCksXG4gICAgICAgICAgICBwb3NpdGlvbk9wdGlvbjogdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uKSxcbiAgICAgICAgICAgIGFsaWduT3B0aW9uOiB0aGlzLm9wdGlvbnMuYWxpZ24gfHwgJydcbiAgICAgICAgfSwgcGFyYW1zKSk7XG5cbiAgICAgICAgdGhpcy5tb3ZlVG9Qb3NpdGlvbihlbFRvb2x0aXAsIHBvc2l0aW9uLCBwcmV2UG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9maXJlU2hvd0FuaW1hdGlvbihpbmRleGVzLCBwYXJhbXMuY2hhcnRUeXBlKTtcbiAgICAgICAgdGhpcy5fZmlyZUFmdGVyU2hvd1Rvb2x0aXAoaW5kZXhlcywge1xuICAgICAgICAgICAgZWxlbWVudDogZWxUb29sdGlwLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBtYWtlIHBhcmFtZXRlcnMgZm9yIHNob3cgdG9vbHRpcCB1c2VyIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGxlZ2VuZEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBwYXJhbWV0ZXJzIGZvciBzaG93IHRvb2x0aXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2hvd1Rvb2x0aXBQYXJhbXM6IGZ1bmN0aW9uKGluZGV4ZXMsIGFkZGl0aW9uUGFyYW1zKSB7XG4gICAgICAgIHZhciBsZWdlbmRJbmRleCA9IGluZGV4ZXMuaW5kZXgsXG4gICAgICAgICAgICBsZWdlbmREYXRhID0gdGhpcy5qb2luTGVnZW5kTGFiZWxzW2xlZ2VuZEluZGV4XSxcbiAgICAgICAgICAgIHBhcmFtcztcbiAgICAgICAgcGFyYW1zID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogbGVnZW5kRGF0YS5jaGFydFR5cGUsXG4gICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZERhdGEubGFiZWwsXG4gICAgICAgICAgICBsZWdlbmRJbmRleDogbGVnZW5kSW5kZXgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhlcy5ncm91cEluZGV4XG4gICAgICAgIH0sIGFkZGl0aW9uUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBiZWZvcmVTaG93VG9vbHRpcCBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUJlZm9yZVNob3dUb29sdGlwOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLl9tYWtlU2hvd1Rvb2x0aXBQYXJhbXMoaW5kZXhlcyk7XG4gICAgICAgIHRoaXMudXNlckV2ZW50LmZpcmUoJ2JlZm9yZVNob3dUb29sdGlwJywgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBhZnRlclNob3dUb29sdGlwIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWRkaXRpb25QYXJhbXMgYWRkaXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVBZnRlclNob3dUb29sdGlwOiBmdW5jdGlvbihpbmRleGVzLCBhZGRpdGlvblBhcmFtcykge1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5fbWFrZVNob3dUb29sdGlwUGFyYW1zKGluZGV4ZXMsIGFkZGl0aW9uUGFyYW1zKTtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYWZ0ZXJTaG93VG9vbHRpcCcsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcDogZnVuY3Rpb24oZWxUb29sdGlwKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGluZGV4ZXMgPSB0aGlzLl9nZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlKGVsVG9vbHRpcCksXG4gICAgICAgICAgICBjaGFydFR5cGUgPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLWNoYXJ0LXR5cGUnKTtcblxuICAgICAgICB0aGlzLl9zZXRTaG93ZWRDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2ZpcmVIaWRlQW5pbWF0aW9uKGluZGV4ZXMsIGNoYXJ0VHlwZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzQ2hhbmdlZEluZGV4ZXModGhpcy5wcmV2SW5kZXhlcywgaW5kZXhlcykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnByZXZJbmRleGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGF0Ll9pc1Nob3dlZFRvb2x0aXAoZWxUb29sdGlwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQuaGlkZUFuaW1hdGlvbihlbFRvb2x0aXApO1xuXG4gICAgICAgICAgICB0aGF0ID0gbnVsbDtcbiAgICAgICAgICAgIGluZGV4ZXMgPSBudWxsO1xuICAgICAgICB9LCBjaGFydENvbnN0LkhJREVfREVMQVkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggZXZlbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqL1xuICAgIGF0dGFjaEV2ZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICBldmVudExpc3RlbmVyLmJpbmRFdmVudCgnbW91c2VvdmVyJywgZWwsIHR1aS51dGlsLmJpbmQodGhpcy5vbk1vdXNlb3ZlciwgdGhpcykpO1xuICAgICAgICBldmVudExpc3RlbmVyLmJpbmRFdmVudCgnbW91c2VvdXQnLCBlbCwgdHVpLnV0aWwuYmluZCh0aGlzLm9uTW91c2VvdXQsIHRoaXMpKTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFRvb2x0aXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvb2x0aXA7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVG9vbHRpcEJhc2UgaXMgYmFzZSBjbGFzcyBvZiB0b29sdGlwIGNvbXBvbmVudHMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBUb29sdGlwQmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgVG9vbHRpcEJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUb29sdGlwQmFzZSBpcyBiYXNlIGNsYXNzIG9mIHRvb2x0aXAgY29tcG9uZW50cy5cbiAgICAgKiBAY29uc3RydWN0cyBUb29sdGlwQmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheS48bnVtYmVyPn0gcGFyYW1zLnZhbHVlcyBjb252ZXJ0ZWQgdmFsdWVzXG4gICAgICogICAgICBAcGFyYW0ge2FycmF5fSBwYXJhbXMubGFiZWxzIGxhYmVsc1xuICAgICAqICAgICAgQHBhcmFtIHthcnJheX0gcGFyYW1zLmxlZ2VuZExhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmJvdW5kIGF4aXMgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0dWkudXRpbC5leHRlbmQodGhpcywgcGFyYW1zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNoYXJ0LXRvb2x0aXAtYXJlYSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvb2x0aXBCYXNlIGNvbnRhaW5lci5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbExheW91dCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvb2x0aXBCYXNlIGJhc2UgZGF0YS5cbiAgICAgICAgICogQHR5cGUge2FycmF5LjxhcnJheS48b2JqZWN0Pj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLm1ha2VUb29sdGlwRGF0YSgpO1xuXG5cbiAgICAgICAgdGhpcy5zdWZmaXggPSB0aGlzLm9wdGlvbnMuc3VmZml4ID8gJyZuYnNwOycgKyB0aGlzLm9wdGlvbnMuc3VmZml4IDogJyc7XG5cbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbigpO1xuICAgICAgICB0aGlzLl9zYXZlT3JpZ2luYWxQb3NpdGlvbk9wdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgYWxpZ24gb3B0aW9uIG9mIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFRvIHNhdmUgcG9zaXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlT3JpZ2luYWxQb3NpdGlvbk9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9yZ1Bvc2l0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsaWduOiB0aGlzLm9wdGlvbnMuYWxpZ24sXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIG1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIG1ha2VUb29sdGlwRGF0YTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFRvIHJlbmRlciB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3twb3NpdGlvbjogb2JqZWN0fX0gYm91bmQgdG9vbHRpcCBib3VuZFxuICAgICAqIEBwYXJhbSB7P3tzZXJpZXNQb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdG9vbHRpcCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihib3VuZCwgZGF0YSkge1xuICAgICAgICB2YXIgZWwgPSBkb20uY3JlYXRlKCdESVYnLCB0aGlzLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihlbCwgYm91bmQucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuYm91bmQgPSBib3VuZDtcbiAgICAgICAgdGhpcy5jaGFydERpbWVuc2lvbiA9IGRhdGEuY2hhcnREaW1lbnNpb247XG4gICAgICAgIHRoaXMuZWxUb29sdGlwQXJlYSA9IGVsO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gcmVzaXplIHRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7e3Bvc2l0aW9uOiBvYmplY3R9fSBib3VuZCB0b29sdGlwIGJvdW5kXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICB0aGlzLmJvdW5kID0gYm91bmQ7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odGhpcy5lbFRvb2x0aXBBcmVhLCBib3VuZC5wb3NpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVCb3VuZChib3VuZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRvb2x0aXAgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFRvb2x0aXBFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsVG9vbHRpcDtcbiAgICAgICAgaWYgKCF0aGlzLmVsVG9vbHRpcCkge1xuICAgICAgICAgICAgdGhpcy5lbFRvb2x0aXAgPSBlbFRvb2x0aXAgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LXRvb2x0aXAnKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQodGhpcy5lbFRvb2x0aXBBcmVhLCBlbFRvb2x0aXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsVG9vbHRpcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogb25TaG93IGlzIGNhbGxiYWNrIG9mIGN1c3RvbSBldmVudCBzaG93VG9vbHRpcCBmb3IgU2VyaWVzVmlldy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIGNvb3JkaW5hdGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIG9uU2hvdzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBlbFRvb2x0aXAgPSB0aGlzLl9nZXRUb29sdGlwRWxlbWVudCgpLFxuICAgICAgICAgICAgcHJldlBvc2l0aW9uO1xuICAgICAgICBpZiAoZWxUb29sdGlwLm9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgICBwcmV2UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogZWxUb29sdGlwLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBlbFRvb2x0aXAub2Zmc2V0VG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcChlbFRvb2x0aXAsIHBhcmFtcywgcHJldlBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSByZW5kZXJlZCB0b29sdGlwIGRpbWVuc2lvblxuICAgICAqL1xuICAgIGdldFRvb2x0aXBEaW1lbnNpb246IGZ1bmN0aW9uKGVsVG9vbHRpcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IGVsVG9vbHRpcC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZWxUb29sdGlwLm9mZnNldEhlaWdodFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgaGlkZSB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbmNlbEhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlSGlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuYWN0aXZlSGlkZXIudGltZXJJZCk7XG4gICAgICAgIHRoaXMuYWN0aXZlSGlkZXIuc2V0T3BhY2l0eSgxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHNsaWRlIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FuY2VsU2xpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlU2xpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0aGlzLmFjdGl2ZVNsaWRlcnMsIGZ1bmN0aW9uKHNsaWRlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzbGlkZXIudGltZXJJZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlU2xpZGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byBQb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiBwcmV2IHBvc2l0aW9uXG4gICAgICovXG4gICAgbW92ZVRvUG9zaXRpb246IGZ1bmN0aW9uKGVsVG9vbHRpcCwgcG9zaXRpb24sIHByZXZQb3NpdGlvbikge1xuICAgICAgICBpZiAocHJldlBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxIaWRlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxTbGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2xpZGVUb29sdGlwKGVsVG9vbHRpcCwgcHJldlBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGVsVG9vbHRpcCwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzbGlkZXIuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgc2xpZGUgdHlwZSAoaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbClcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBlZmZlY3Qgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2xpZGVyOiBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5zbGlkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2xpZGVyW3R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLnNsaWRlclt0eXBlXSA9IG5ldyB0dWkuY29tcG9uZW50LkVmZmVjdHMuU2xpZGUoe1xuICAgICAgICAgICAgICAgIGZsb3c6IHR5cGUsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zbGlkZXJbdHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHNsaWRlIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29tcGxldGVTbGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFjdGl2ZVNsaWRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNsaWRlIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiBwcmV2IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2xpZGVUb29sdGlwOiBmdW5jdGlvbihlbFRvb2x0aXAsIHByZXZQb3NpdGlvbiwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHZTbGlkZXIgPSB0aGlzLl9nZXRTbGlkZXIoZWxUb29sdGlwLCAndmVydGljYWwnKSxcbiAgICAgICAgICAgIGhTbGlkZXIgPSB0aGlzLl9nZXRTbGlkZXIoZWxUb29sdGlwLCAnaG9yaXpvbnRhbCcpLFxuICAgICAgICAgICAgbW92ZVRvcCA9IHByZXZQb3NpdGlvbi50b3AgLSBwb3NpdGlvbi50b3AsXG4gICAgICAgICAgICBtb3ZlTGVmdCA9IHByZXZQb3NpdGlvbi5sZWZ0IC0gcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIHZEaXJlY3Rpb24gPSBtb3ZlVG9wID4gMCA/ICdmb3J3b3JkJyA6ICdiYWNrd29yZCcsXG4gICAgICAgICAgICBoRGlyZWN0aW9uID0gbW92ZVRvcCA+IDAgPyAnZm9yd29yZCcgOiAnYmFja3dvcmQnLFxuICAgICAgICAgICAgYWN0aXZlU2xpZGVycyA9IFtdLFxuICAgICAgICAgICAgY29tcGxhdGUgPSB0dWkudXRpbC5iaW5kKHRoaXMuX2NvbXBsZXRlU2xpZGUsIHRoaXMpO1xuXG4gICAgICAgIGlmIChtb3ZlVG9wKSB7XG4gICAgICAgICAgICB2U2xpZGVyLnNldERpc3RhbmNlKG1vdmVUb3ApO1xuICAgICAgICAgICAgdlNsaWRlci5hY3Rpb24oe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogdkRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBzdGFydDogcHJldlBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogY29tcGxhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWN0aXZlU2xpZGVycy5wdXNoKHZTbGlkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdmVMZWZ0KSB7XG4gICAgICAgICAgICBoU2xpZGVyLnNldERpc3RhbmNlKG1vdmVMZWZ0KTtcbiAgICAgICAgICAgIGhTbGlkZXIuYWN0aW9uKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGhEaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHByZXZQb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhY3RpdmVTbGlkZXJzLnB1c2godlNsaWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlU2xpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU2xpZGVycyA9IGFjdGl2ZVNsaWRlcnM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogb25IaWRlIGlzIGNhbGxiYWNrIG9mIGN1c3RvbSBldmVudCBoaWRlVG9vbHRpcCBmb3IgU2VyaWVzVmlld1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqL1xuICAgIG9uSGlkZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGVsVG9vbHRpcCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuaGlkZVRvb2x0aXAoZWxUb29sdGlwLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBoaWRlci5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBlZmZlY3Qgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0SGlkZXI6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhpZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVyID0gbmV3IHR1aS5jb21wb25lbnQuRWZmZWN0cy5GYWRlKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxMDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGhpZGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKi9cbiAgICBoaWRlQW5pbWF0aW9uOiBmdW5jdGlvbihlbFRvb2x0aXApIHtcbiAgICAgICAgdGhpcy5hY3RpdmVIaWRlciA9IHRoaXMuX2dldEhpZGVyKGVsVG9vbHRpcCk7XG4gICAgICAgIHRoaXMuYWN0aXZlSGlkZXIuYWN0aW9uKHtcbiAgICAgICAgICAgIHN0YXJ0OiAxLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhlbFRvb2x0aXAsICdzaG93Jyk7XG4gICAgICAgICAgICAgICAgZWxUb29sdGlwLnN0eWxlLmNzc1RleHQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gYWxpZ25cbiAgICAgKi9cbiAgICBzZXRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmFsaWduID0gYWxpZ247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHBvc2l0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW92aW5nIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHR1aS51dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdG9vbHRpcCBhbGlnbiBvcHRpb24uXG4gICAgICovXG4gICAgcmVzZXRBbGlnbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbGlnbiA9IHRoaXMub3JnUG9zaXRpb25PcHRpb25zLmFsaWduO1xuICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBhbGlnbjtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsLnVwZGF0ZU9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0b29sdGlwIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHJlc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLm9yZ1Bvc2l0aW9uT3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFRvb2x0aXBCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwQmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlcyBvZiB0b29sdGlwLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxudmFyIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKTtcblxudmFyIHRhZ3MgPSB7XG4gICAgSFRNTF9ERUZBVUxUX1RFTVBMQVRFOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1kZWZhdWx0LXRvb2x0aXBcIj4nICtcbiAgICAgICAgJzxkaXY+e3sgY2F0ZWdvcnkgfX08L2Rpdj4nICtcbiAgICAgICAgJzxkaXY+JyArXG4gICAgICAgICAgICAnPHNwYW4+e3sgbGVnZW5kIH19PC9zcGFuPjonICtcbiAgICAgICAgICAgICcmbmJzcDs8c3Bhbj57eyB2YWx1ZSB9fTwvc3Bhbj4nICtcbiAgICAgICAgICAgICc8c3Bhbj57eyBzdWZmaXggfX08L3NwYW4+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAnPC9kaXY+JyxcbiAgICBIVE1MX0dST1VQOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1kZWZhdWx0LXRvb2x0aXAgdHVpLWNoYXJ0LWdyb3VwLXRvb2x0aXBcIj4nICtcbiAgICAgICAgJzxkaXY+e3sgY2F0ZWdvcnkgfX08L2Rpdj4nICtcbiAgICAgICAgJ3t7IGl0ZW1zIH19JyArXG4gICAgJzwvZGl2PicsXG4gICAgSFRNTF9HUk9VUF9JVEVNOiAnPGRpdj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLXJlY3Qge3sgY2hhcnRUeXBlIH19XCIgc3R5bGU9XCJ7eyBjc3NUZXh0IH19XCI+PC9kaXY+Jm5ic3A7PHNwYW4+e3sgbGVnZW5kIH19PC9zcGFuPjonICtcbiAgICAgICAgJyZuYnNwOzxzcGFuPnt7IHZhbHVlIH19PC9zcGFuPicgK1xuICAgICAgICAnPHNwYW4+e3sgc3VmZml4IH19PC9zcGFuPicgK1xuICAgICc8L2Rpdj4nLFxuICAgIEdST1VQX0NTU19URVhUOiAnYmFja2dyb3VuZC1jb2xvcjp7eyBjb2xvciB9fSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbERlZmF1bHQ6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUodGFncy5IVE1MX0RFRkFVTFRfVEVNUExBVEUpLFxuICAgIHRwbEdyb3VwOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKHRhZ3MuSFRNTF9HUk9VUCksXG4gICAgdHBsR3JvdXBJdGVtOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKHRhZ3MuSFRNTF9HUk9VUF9JVEVNKSxcbiAgICB0cGxHcm91cENzc1RleHQ6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUodGFncy5HUk9VUF9DU1NfVEVYVClcbn07XG4iXX0=
